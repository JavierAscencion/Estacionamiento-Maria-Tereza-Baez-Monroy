CCS PCH C Compiler, Version 5.080, 13314               12-sep.-19 10:07

               Filename:   E:\Google Drive\01 ESTACIONAMIENTOS\MARIA TERESA BAEZ MONROY(matanzo)\ENTRADA_CLIENTE\ENTRADA_CLIENTE.lst

               ROM used:   30354 bytes (46%)
                           Largest free fragment is 35180
               RAM used:   2302 (69%) at main() level
                           2488 (75%) worst case
               Stack used: 10 locations (9 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   6B28
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0106
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   01AA
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   01C6
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   01FA
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... //2019/01/23 Se cambio la razon social 
.................... //2018/06/21 //Version 1.2- serie MATE11.2 Se disminuyo tiempo de rebotes de auto 
.................... //2018/06/21 //Version 1.1- serie MATE11.1 Se modifico boleto, se agrego tolerancia y cambio hora de apertura 
.................... //2018/06/19 //Version 1- serie MATE11, 3 primeras letras de estacion, numero de entrada/cambios realizados 
.................... // Basado en: Programa de ejemplo 10 para comunicarme con el módulo ENC28J60. 
.................... // Cliente TCP. 
.................... // Incluimos las definiciones necesarias de la placa utilizada. 
.................... #include "Plantilla_Inicio.c" 
.................... // Controlador ETHERNET 
.................... // Fecha: 2018/02/19. 
.................... // Versión del compilador: v5.070 
.................... // Versión del programa: v0.1 
.................... // Revisión del programa: 0.00 
.................... // Definimos el microcontrolador utilizado. 
.................... #include <18F4680.h> // Definición de registros internos del PIC18F4520. 
.................... //////////// Standard Header file for the PIC18F4680 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4680 
000D2:  CLRF   FF7
000D4:  ADDLW  E2
000D6:  MOVWF  FF6
000D8:  MOVLW  00
000DA:  ADDWFC FF7,F
000DC:  TBLRD*+
000DE:  MOVF   FF5,W
000E0:  RETURN 0
000E2:  DATA 28,0C
000E4:  DATA 01,06
000E6:  CLRF   FF7
000E8:  ADDLW  F6
000EA:  MOVWF  FF6
000EC:  MOVLW  00
000EE:  ADDWFC FF7,F
000F0:  TBLRD*+
000F2:  MOVF   FF5,W
000F4:  RETURN 0
000F6:  DATA 42,4F
000F8:  DATA 4C,45
000FA:  DATA 54,45
000FC:  DATA 52,41
000FE:  DATA 5F,50
00100:  DATA 41,47
00102:  DATA 41,44
00104:  DATA 4F,00
*
0012A:  DATA 53,6F
0012C:  DATA 6C,69
0012E:  DATA 63,69
00130:  DATA 74,75
00132:  DATA 64,20
00134:  DATA 41,52
00136:  DATA 50,2E
00138:  DATA 20,20
0013A:  DATA 20,20
0013C:  DATA 20,20
0013E:  DATA 00,00
00140:  DATA 43,4F
00142:  DATA 4E,45
00144:  DATA 43,54
00146:  DATA 41,4E
00148:  DATA 44,4F
0014A:  DATA 2E,2E
0014C:  DATA 2E,20
0014E:  DATA 20,20
00150:  DATA 20,20
00152:  DATA 20,20
00154:  DATA 00,00
00156:  DATA 45,72
00158:  DATA 72,6F
0015A:  DATA 72,20
0015C:  DATA 65,6E
0015E:  DATA 20,65
00160:  DATA 6C,20
00162:  DATA 73,6F
00164:  DATA 63,6B
00166:  DATA 65,74
00168:  DATA 2E,20
0016A:  DATA 00,00
0016C:  DATA 43,4F
0016E:  DATA 4E,45
00170:  DATA 43,54
00172:  DATA 41,44
00174:  DATA 4F,20
00176:  DATA 20,20
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 20,20
00180:  DATA 00,00
00182:  DATA 44,45
00184:  DATA 53,43
00186:  DATA 4F,4E
00188:  DATA 45,43
0018A:  DATA 54,41
0018C:  DATA 44,4F
0018E:  DATA 20,20
00190:  DATA 20,20
00192:  DATA 20,20
00194:  DATA 20,00
00196:  DATA 44,45
00198:  DATA 53,43
0019A:  DATA 4F,4E
0019C:  DATA 45,43
0019E:  DATA 54,41
001A0:  DATA 44,4F
001A2:  DATA 20,20
001A4:  DATA 20,20
001A6:  DATA 20,20
001A8:  DATA 20,00
*
0022C:  DATA 0C,49
0022E:  DATA 4E,49
00230:  DATA 43,49
00232:  DATA 41,4E
00234:  DATA 44,4F
00236:  DATA 00,00
00238:  DATA 44,69
0023A:  DATA 61,73
0023C:  DATA 3A,25
0023E:  DATA 75,20
00240:  DATA 50,41
00242:  DATA 47,4F
00244:  DATA 3A,25
00246:  DATA 64,00
00248:  DATA 52,65
0024A:  DATA 73,74
0024C:  DATA 61,6E
0024E:  DATA 3A,25
00250:  DATA 75,20
00252:  DATA 00,00
00254:  DATA 54,49
00256:  DATA 45,4D
00258:  DATA 50,4F
0025A:  DATA 20,44
0025C:  DATA 45,20
0025E:  DATA 50,52
00260:  DATA 55,45
00262:  DATA 42,41
00264:  DATA 00,00
00266:  DATA 20,20
00268:  DATA 48,41
0026A:  DATA 20,45
0026C:  DATA 58,50
0026E:  DATA 49,52
00270:  DATA 41,44
00272:  DATA 4F,20
00274:  DATA 20,20
00276:  DATA 00,00
00278:  DATA 0C,0A
0027A:  DATA 20,20
0027C:  DATA 20,54
0027E:  DATA 4F,4D
00280:  DATA 45,20
00282:  DATA 53,55
00284:  DATA 20,42
00286:  DATA 4F,4C
00288:  DATA 45,54
0028A:  DATA 4F,0A
0028C:  DATA 20,59
0028E:  DATA 20,41
00290:  DATA 56,41
00292:  DATA 4E,43
00294:  DATA 45,20
00296:  DATA 50,4F
00298:  DATA 52,20
0029A:  DATA 46,41
0029C:  DATA 56,4F
0029E:  DATA 52,00
002A0:  DATA 0C,00
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 20,20
002B2:  DATA 20,20
002B4:  DATA 20,20
002B6:  DATA 00,00
002B8:  DATA 20,20
002BA:  DATA 20,25
002BC:  DATA 30,32
002BE:  DATA 64,20
002C0:  DATA 25,30
002C2:  DATA 32,64
002C4:  DATA 20,25
002C6:  DATA 30,32
002C8:  DATA 64,2F
002CA:  DATA 25,30
002CC:  DATA 32,64
002CE:  DATA 2F,25
002D0:  DATA 30,32
002D2:  DATA 64,20
002D4:  DATA 20,20
002D6:  DATA 20,00
002D8:  DATA 20,20
002DA:  DATA 20,25
002DC:  DATA 30,32
002DE:  DATA 64,3A
002E0:  DATA 25,30
002E2:  DATA 32,64
002E4:  DATA 20,25
002E6:  DATA 30,32
002E8:  DATA 64,2F
002EA:  DATA 25,30
002EC:  DATA 32,64
002EE:  DATA 2F,25
002F0:  DATA 30,32
002F2:  DATA 64,20
002F4:  DATA 20,20
002F6:  DATA 20,00
002F8:  DATA 20,20
002FA:  DATA 20,57
002FC:  DATA 57,57
002FE:  DATA 2E,41
00300:  DATA 43,43
00302:  DATA 45,53
00304:  DATA 41,2E
00306:  DATA 4D,45
00308:  DATA 20,20
0030A:  DATA 20,20
0030C:  DATA 00,00
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,41
00316:  DATA 43,43
00318:  DATA 45,53
0031A:  DATA 41,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 20,20
0032A:  DATA 20,20
0032C:  DATA 20,20
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 00,00
0033A:  DATA 20,20
0033C:  DATA 48,6F
0033E:  DATA 72,61
00340:  DATA 20,41
00342:  DATA 63,74
00344:  DATA 75,61
00346:  DATA 6C,69
00348:  DATA 7A,61
0034A:  DATA 64,61
0034C:  DATA 20,20
0034E:  DATA 00,00
00350:  DATA 45,4E
00352:  DATA 31,2D
00354:  DATA 25,30
00356:  DATA 38,4C
00358:  DATA 58,00
0035A:  DATA 0C,0A
0035C:  DATA 20,20
0035E:  DATA 20,20
00360:  DATA 20,42
00362:  DATA 49,45
00364:  DATA 4E,56
00366:  DATA 45,4E
00368:  DATA 49,44
0036A:  DATA 4F,00
0036C:  DATA 42,4F
0036E:  DATA 54,4F
00370:  DATA 4E,5F
00372:  DATA 42,4F
00374:  DATA 4C,45
00376:  DATA 54,4F
00378:  DATA 00,00
0037A:  DATA 46,6F
0037C:  DATA 6C,69
0037E:  DATA 6F,3A
00380:  DATA 25,73
00382:  DATA 00,00
00384:  DATA 50,4C
00386:  DATA 41,5A
00388:  DATA 41,20
0038A:  DATA 43,4F
0038C:  DATA 4D,45
0038E:  DATA 52,43
00390:  DATA 49,41
00392:  DATA 4C,20
00394:  DATA 34,20
00396:  DATA 79,20
00398:  DATA 31,33
0039A:  DATA 00,00
0039C:  DATA 52,46
0039E:  DATA 43,3A
003A0:  DATA 42,41
003A2:  DATA 4D,54
003A4:  DATA 39,37
003A6:  DATA 30,35
003A8:  DATA 32,38
003AA:  DATA 38,34
003AC:  DATA 41,0A
003AE:  DATA 00,00
003B0:  DATA 34,20
003B2:  DATA 70,6F
003B4:  DATA 6E,69
003B6:  DATA 65,6E
003B8:  DATA 74,65
003BA:  DATA 20,31
003BC:  DATA 33,30
003BE:  DATA 32,2C
003C0:  DATA 20,63
003C2:  DATA 6F,6C
003C4:  DATA 6F,6E
003C6:  DATA 69,61
003C8:  DATA 20,43
003CA:  DATA 65,6E
003CC:  DATA 74,72
003CE:  DATA 6F,20
003D0:  DATA 20,43
003D2:  DATA 50,20
003D4:  DATA 37,32
003D6:  DATA 30,30
003D8:  DATA 30,0A
003DA:  DATA 50,75
003DC:  DATA 65,62
003DE:  DATA 6C,61
003E0:  DATA 2C,20
003E2:  DATA 50,75
003E4:  DATA 65,62
003E6:  DATA 6C,61
003E8:  DATA 0A,00
003EA:  DATA 25,30
003EC:  DATA 32,64
003EE:  DATA 2F,25
003F0:  DATA 30,32
003F2:  DATA 64,2F
003F4:  DATA 32,30
003F6:  DATA 25,30
003F8:  DATA 32,64
003FA:  DATA 20,25
003FC:  DATA 30,32
003FE:  DATA 64,3A
00400:  DATA 25,30
00402:  DATA 32,64
00404:  DATA 3A,25
00406:  DATA 30,32
00408:  DATA 64,00
0040A:  DATA 54,41
0040C:  DATA 52,49
0040E:  DATA 46,41
00410:  DATA 3A,24
00412:  DATA 31,37
00414:  DATA 20,48
00416:  DATA 6F,72
00418:  DATA 61,20
0041A:  DATA 6F,20
0041C:  DATA 46,72
0041E:  DATA 61,63
00420:  DATA 63,69
00422:  DATA 6F,6E
00424:  DATA 20,20
00426:  DATA 20,20
00428:  DATA 20,20
0042A:  DATA 20,20
0042C:  DATA 20,20
0042E:  DATA 20,20
00430:  DATA 20,20
00432:  DATA 20,20
00434:  DATA 20,20
00436:  DATA 20,20
00438:  DATA 20,0A
0043A:  DATA 00,00
0043C:  DATA 54,4F
0043E:  DATA 4C,45
00440:  DATA 52,41
00442:  DATA 4E,43
00444:  DATA 49,41
00446:  DATA 3A,35
00448:  DATA 20,6D
0044A:  DATA 69,6E
0044C:  DATA 2E,20
0044E:  DATA 6C,61
00450:  DATA 20,70
00452:  DATA 72,69
00454:  DATA 6D,65
00456:  DATA 72,61
00458:  DATA 20,68
0045A:  DATA 6F,72
0045C:  DATA 61,20
0045E:  DATA 20,20
00460:  DATA 20,20
00462:  DATA 20,20
00464:  DATA 20,20
00466:  DATA 20,20
00468:  DATA 20,20
0046A:  DATA 20,0A
0046C:  DATA 00,00
0046E:  DATA 48,6F
00470:  DATA 72,61
00472:  DATA 72,69
00474:  DATA 6F,73
00476:  DATA 3A,64
00478:  DATA 65,20
0047A:  DATA 37,3A
0047C:  DATA 30,30
0047E:  DATA 20,61
00480:  DATA 20,32
00482:  DATA 31,3A
00484:  DATA 30,30
00486:  DATA 68,72
00488:  DATA 73,2E
0048A:  DATA 20,64
0048C:  DATA 65,20
0048E:  DATA 6C,75
00490:  DATA 6E,65
00492:  DATA 73,20
00494:  DATA 61,20
00496:  DATA 76,69
00498:  DATA 65,72
0049A:  DATA 6E,65
0049C:  DATA 73,0A
0049E:  DATA 00,00
004A0:  DATA 53,61
004A2:  DATA 62,61
004A4:  DATA 64,6F
004A6:  DATA 20,20
004A8:  DATA 20,64
004AA:  DATA 65,20
004AC:  DATA 38,3A
004AE:  DATA 30,30
004B0:  DATA 20,61
004B2:  DATA 20,32
004B4:  DATA 30,3A
004B6:  DATA 30,30
004B8:  DATA 68,72
004BA:  DATA 73,2E
004BC:  DATA 20,20
004BE:  DATA 20,20
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 20,20
004CA:  DATA 20,20
004CC:  DATA 20,20
004CE:  DATA 20,0A
004D0:  DATA 00,00
004D2:  DATA 44,6F
004D4:  DATA 6D,69
004D6:  DATA 6E,67
004D8:  DATA 6F,20
004DA:  DATA 20,64
004DC:  DATA 65,20
004DE:  DATA 38,3A
004E0:  DATA 30,30
004E2:  DATA 20,61
004E4:  DATA 20,31
004E6:  DATA 39,3A
004E8:  DATA 30,30
004EA:  DATA 68,72
004EC:  DATA 73,2E
004EE:  DATA 20,20
004F0:  DATA 20,20
004F2:  DATA 20,20
004F4:  DATA 20,20
004F6:  DATA 20,20
004F8:  DATA 20,20
004FA:  DATA 20,20
004FC:  DATA 20,20
004FE:  DATA 20,20
00500:  DATA 20,0A
00502:  DATA 00,00
00504:  DATA 22,41
00506:  DATA 43,43
00508:  DATA 45,53
0050A:  DATA 41,22
0050C:  DATA 20,61
0050E:  DATA 75,74
00510:  DATA 6F,6D
00512:  DATA 61,74
00514:  DATA 69,7A
00516:  DATA 61,63
00518:  DATA 69,6F
0051A:  DATA 6E,20
0051C:  DATA 00,00
0051E:  DATA 77,77
00520:  DATA 77,2E
00522:  DATA 61,63
00524:  DATA 63,65
00526:  DATA 73,61
00528:  DATA 2E,6D
0052A:  DATA 65,20
0052C:  DATA 20,61
0052E:  DATA 75,74
00530:  DATA 6F,6D
00532:  DATA 61,74
00534:  DATA 69,7A
00536:  DATA 61,63
00538:  DATA 69,6F
0053A:  DATA 6E,40
0053C:  DATA 61,63
0053E:  DATA 63,65
00540:  DATA 73,61
00542:  DATA 2E,6D
00544:  DATA 65,00
00546:  DATA 1D,68
00548:  DATA 8C,00
0054A:  DATA 1D,77
0054C:  DATA 01,00
0054E:  DATA 1D,68
00550:  DATA 8C,00
00552:  DATA 1D,77
00554:  DATA 01,00
*
006C2:  TBLRD*+
006C4:  MOVF   FF5,F
006C6:  BZ    06E0
006C8:  MOVFF  FF6,8FC
006CC:  MOVFF  FF7,8FD
006D0:  MOVFF  FF5,8FF
006D4:  RCALL  065E
006D6:  MOVFF  8FC,FF6
006DA:  MOVFF  8FD,FF7
006DE:  BRA    06C2
006E0:  RETURN 0
*
00A34:  ADDWF  FE8,W
00A36:  CLRF   FF7
00A38:  RLCF   FF7,F
00A3A:  ADDLW  4F
00A3C:  MOVWF  FF6
00A3E:  MOVLW  0A
00A40:  ADDWFC FF7,F
00A42:  TBLRD*-
00A44:  MOVF   FF5,W
00A46:  MOVWF  FFA
00A48:  TBLRD*
00A4A:  MOVF   FF5,W
00A4C:  MOVWF  FF9
00A4E:  DATA 86,07
00A50:  DATA A4,07
00A52:  DATA C2,07
00A54:  DATA E0,07
00A56:  DATA FE,07
00A58:  DATA 1C,08
00A5A:  DATA 3A,08
00A5C:  DATA 58,08
00A5E:  DATA 76,08
00A60:  DATA 94,08
00A62:  DATA B2,08
00A64:  DATA D0,08
00A66:  DATA EE,08
00A68:  DATA 0C,09
*
00FE8:  MOVLB  9
00FEA:  MOVF   x4A,W
00FEC:  MULWF  x4C
00FEE:  MOVFF  FF3,01
00FF2:  MOVFF  FF4,00
00FF6:  MULWF  x4D
00FF8:  MOVF   FF3,W
00FFA:  ADDWF  00,F
00FFC:  MOVF   x4B,W
00FFE:  MULWF  x4C
01000:  MOVF   FF3,W
01002:  ADDWFC 00,W
01004:  MOVWF  02
01006:  MOVLB  0
01008:  RETURN 0
*
0101E:  MOVLB  9
01020:  CLRF   x04
01022:  CLRF   x05
01024:  MOVLW  01
01026:  MOVWF  x06
01028:  CLRF   FDA
0102A:  CLRF   FD9
0102C:  MOVLW  08
0102E:  MOVWF  x09
01030:  MOVLW  FC
01032:  MOVWF  x08
01034:  MOVLW  09
01036:  MOVWF  FEA
01038:  CLRF   FE9
0103A:  MOVFF  909,FE2
0103E:  MOVFF  908,FE1
01042:  MOVFF  906,907
01046:  BCF    FD8.0
01048:  MOVF   FE5,W
0104A:  MULWF  FEE
0104C:  MOVF   FF3,W
0104E:  ADDWFC x04,F
01050:  MOVF   FF4,W
01052:  ADDWFC x05,F
01054:  DECFSZ x07,F
01056:  BRA    1046
01058:  MOVFF  904,FDE
0105C:  MOVFF  905,904
01060:  CLRF   x05
01062:  BTFSC  FD8.0
01064:  INCF   x05,F
01066:  INCF   x08,F
01068:  BTFSC  FD8.2
0106A:  INCF   x09,F
0106C:  INCF   x06,F
0106E:  MOVF   x06,W
01070:  SUBLW  05
01072:  BNZ   1034
01074:  MOVLB  0
01076:  GOTO   10E6 (RETURN)
0107A:  CLRF   01
0107C:  CLRF   02
0107E:  CLRF   00
01080:  CLRF   03
01082:  MOVLB  9
01084:  MOVF   x0E,W
01086:  BNZ   108C
01088:  MOVF   x0D,W
0108A:  BZ    10BC
0108C:  MOVLW  10
0108E:  MOVWF  x0F
01090:  BCF    FD8.0
01092:  RLCF   x0B,F
01094:  RLCF   x0C,F
01096:  RLCF   00,F
01098:  RLCF   03,F
0109A:  MOVF   x0E,W
0109C:  SUBWF  03,W
0109E:  BNZ   10A4
010A0:  MOVF   x0D,W
010A2:  SUBWF  00,W
010A4:  BNC   10B4
010A6:  MOVF   x0D,W
010A8:  SUBWF  00,F
010AA:  BTFSS  FD8.0
010AC:  DECF   03,F
010AE:  MOVF   x0E,W
010B0:  SUBWF  03,F
010B2:  BSF    FD8.0
010B4:  RLCF   01,F
010B6:  RLCF   02,F
010B8:  DECFSZ x0F,F
010BA:  BRA    1090
010BC:  MOVLB  0
010BE:  RETURN 0
*
01536:  TBLRD*+
01538:  MOVFF  FF6,8FB
0153C:  MOVFF  FF7,8FC
01540:  MOVFF  FF5,8FF
01544:  CALL   065E
01548:  MOVFF  8FB,FF6
0154C:  MOVFF  8FC,FF7
01550:  MOVLB  8
01552:  DECFSZ xFA,F
01554:  BRA    1558
01556:  BRA    155C
01558:  MOVLB  0
0155A:  BRA    1536
0155C:  MOVLB  0
0155E:  RETURN 0
01560:  MOVLB  9
01562:  MOVF   x14,W
01564:  CLRF   01
01566:  SUBWF  x13,W
01568:  BC    1570
0156A:  MOVFF  913,00
0156E:  BRA    1588
01570:  CLRF   00
01572:  MOVLW  08
01574:  MOVWF  x15
01576:  RLCF   x13,F
01578:  RLCF   00,F
0157A:  MOVF   x14,W
0157C:  SUBWF  00,W
0157E:  BTFSC  FD8.0
01580:  MOVWF  00
01582:  RLCF   01,F
01584:  DECFSZ x15,F
01586:  BRA    1576
01588:  MOVLB  0
0158A:  RETURN 0
0158C:  MOVF   01,W
0158E:  MOVFF  8FA,913
01592:  MOVLW  64
01594:  MOVLB  9
01596:  MOVWF  x14
01598:  MOVLB  0
0159A:  RCALL  1560
0159C:  MOVFF  00,8FA
015A0:  MOVF   01,W
015A2:  MOVLW  30
015A4:  BNZ   15B6
015A6:  MOVLB  8
015A8:  BTFSS  xFB.1
015AA:  BRA    15CA
015AC:  BTFSC  xFB.3
015AE:  BRA    15CA
015B0:  BTFSC  xFB.4
015B2:  MOVLW  20
015B4:  BRA    15BE
015B6:  MOVLB  8
015B8:  BCF    xFB.3
015BA:  BCF    xFB.4
015BC:  BSF    xFB.0
015BE:  ADDWF  01,F
015C0:  MOVFF  01,8FF
015C4:  MOVLB  0
015C6:  CALL   065E
015CA:  MOVFF  8FA,913
015CE:  MOVLW  0A
015D0:  MOVLB  9
015D2:  MOVWF  x14
015D4:  MOVLB  0
015D6:  RCALL  1560
015D8:  MOVFF  00,8FA
015DC:  MOVF   01,W
015DE:  MOVLW  30
015E0:  BNZ   15F2
015E2:  MOVLB  8
015E4:  BTFSC  xFB.3
015E6:  BRA    15FE
015E8:  BTFSS  xFB.0
015EA:  BRA    15FE
015EC:  BTFSC  xFB.4
015EE:  MOVLW  20
015F0:  MOVLB  0
015F2:  ADDWF  01,F
015F4:  MOVFF  01,8FF
015F8:  CALL   065E
015FC:  MOVLB  8
015FE:  MOVLW  30
01600:  ADDWF  xFA,F
01602:  MOVFF  8FA,8FF
01606:  MOVLB  0
01608:  CALL   065E
0160C:  RETURN 0
0160E:  MOVLW  20
01610:  MOVLB  8
01612:  BTFSS  xFA.4
01614:  MOVLW  30
01616:  MOVWF  xFB
01618:  MOVFF  8F9,00
0161C:  BTFSS  00.7
0161E:  BRA    1630
01620:  COMF   00,F
01622:  INCF   00,F
01624:  MOVFF  00,8F9
01628:  MOVLW  2D
0162A:  MOVWF  xFB
0162C:  BSF    xFA.7
0162E:  BSF    xFA.0
01630:  MOVF   01,W
01632:  MOVFF  8F9,913
01636:  MOVLW  64
01638:  MOVLB  9
0163A:  MOVWF  x14
0163C:  MOVLB  0
0163E:  RCALL  1560
01640:  MOVFF  00,8F9
01644:  MOVLW  30
01646:  ADDWF  01,W
01648:  MOVLB  8
0164A:  MOVWF  xFC
0164C:  MOVFF  8F9,913
01650:  MOVLW  0A
01652:  MOVLB  9
01654:  MOVWF  x14
01656:  MOVLB  0
01658:  RCALL  1560
0165A:  MOVLW  30
0165C:  ADDWF  00,W
0165E:  MOVLB  8
01660:  MOVWF  xFE
01662:  MOVLW  30
01664:  ADDWF  01,W
01666:  MOVWF  xFD
01668:  MOVFF  8FB,00
0166C:  MOVLW  30
0166E:  SUBWF  xFC,W
01670:  BZ    167A
01672:  BSF    xFA.1
01674:  BTFSC  xFA.7
01676:  BSF    xFA.2
01678:  BRA    169E
0167A:  MOVFF  8FB,8FC
0167E:  MOVLW  20
01680:  MOVWF  xFB
01682:  MOVLW  30
01684:  SUBWF  xFD,W
01686:  BZ    1690
01688:  BSF    xFA.0
0168A:  BTFSC  xFA.7
0168C:  BSF    xFA.1
0168E:  BRA    169E
01690:  BTFSS  FD8.2
01692:  BSF    xFA.0
01694:  BNZ   169E
01696:  MOVFF  8FC,8FD
0169A:  MOVLW  20
0169C:  MOVWF  xFC
0169E:  BTFSC  xFA.2
016A0:  BRA    16AC
016A2:  BTFSC  xFA.1
016A4:  BRA    16B6
016A6:  BTFSC  xFA.0
016A8:  BRA    16C0
016AA:  BRA    16CA
016AC:  MOVFF  8FB,8FF
016B0:  MOVLB  0
016B2:  CALL   065E
016B6:  MOVFF  8FC,8FF
016BA:  MOVLB  0
016BC:  CALL   065E
016C0:  MOVFF  8FD,8FF
016C4:  MOVLB  0
016C6:  CALL   065E
016CA:  MOVFF  8FE,8FF
016CE:  MOVLB  0
016D0:  CALL   065E
016D4:  GOTO   6DEE (RETURN)
*
0447C:  ADDWF  FE8,W
0447E:  CLRF   FF7
04480:  RLCF   FF7,F
04482:  ADDLW  97
04484:  MOVWF  FF6
04486:  MOVLW  44
04488:  ADDWFC FF7,F
0448A:  TBLRD*-
0448C:  MOVF   FF5,W
0448E:  MOVWF  FFA
04490:  TBLRD*
04492:  MOVF   FF5,W
04494:  MOVWF  FF9
04496:  DATA 14,42
04498:  DATA 1C,42
0449A:  DATA 64,42
0449C:  DATA 04,43
0449E:  DATA 30,43
044A0:  DATA 30,43
044A2:  DATA 40,43
044A4:  DATA 50,43
044A6:  DATA 64,43
*
0466A:  ADDWF  FE8,W
0466C:  CLRF   FF7
0466E:  RLCF   FF7,F
04670:  ADDLW  85
04672:  MOVWF  FF6
04674:  MOVLW  46
04676:  ADDWFC FF7,F
04678:  TBLRD*-
0467A:  MOVF   FF5,W
0467C:  MOVWF  FFA
0467E:  TBLRD*
04680:  MOVF   FF5,W
04682:  MOVWF  FF9
04684:  DATA BE,44
04686:  DATA BE,44
04688:  DATA 1A,45
0468A:  DATA B0,45
0468C:  DATA 14,46
0468E:  DATA 08,45
04690:  DATA 7E,45
*
05626:  ADDWF  FE8,W
05628:  CLRF   FF7
0562A:  RLCF   FF7,F
0562C:  ADDLW  41
0562E:  MOVWF  FF6
05630:  MOVLW  56
05632:  ADDWFC FF7,F
05634:  TBLRD*-
05636:  MOVF   FF5,W
05638:  MOVWF  FFA
0563A:  TBLRD*
0563C:  MOVF   FF5,W
0563E:  MOVWF  FF9
05640:  DATA 02,53
05642:  DATA 3E,53
05644:  DATA 72,53
05646:  DATA 18,54
05648:  DATA 7E,54
0564A:  DATA 1C,55
0564C:  DATA 4C,55
0564E:  DATA E6,55
*
05698:  MOVFF  8F7,FEA
0569C:  MOVFF  8F6,FE9
056A0:  MOVLB  8
056A2:  MOVFF  8FC,FEF
056A6:  INCF   FE9,F
056A8:  BTFSC  FD8.2
056AA:  INCF   FEA,F
056AC:  CLRF   FEF
056AE:  INCF   xF6,F
056B0:  BTFSC  FD8.2
056B2:  INCF   xF7,F
056B4:  MOVLB  0
056B6:  RETURN 0
056B8:  MOVLB  8
056BA:  BTFSC  xFA.7
056BC:  BRA    56E0
056BE:  MOVLW  0F
056C0:  MOVWF  00
056C2:  SWAPF  xF9,W
056C4:  ANDWF  00,F
056C6:  MOVLW  0A
056C8:  SUBWF  00,W
056CA:  BC    56D2
056CC:  MOVLW  30
056CE:  ADDWF  00,F
056D0:  BRA    56D6
056D2:  MOVF   xFA,W
056D4:  ADDWF  00,F
056D6:  MOVFF  00,8FC
056DA:  MOVLB  0
056DC:  RCALL  5698
056DE:  MOVLB  8
056E0:  MOVLW  0F
056E2:  ANDWF  xF9,F
056E4:  MOVLW  0A
056E6:  SUBWF  xF9,W
056E8:  BC    56EE
056EA:  MOVLW  30
056EC:  BRA    56F2
056EE:  BCF    xFA.7
056F0:  MOVF   xFA,W
056F2:  ADDWF  xF9,F
056F4:  MOVFF  8F9,8FC
056F8:  MOVLB  0
056FA:  RCALL  5698
056FC:  RETURN 0
056FE:  TBLRD*+
05700:  MOVFF  FF6,8FA
05704:  MOVFF  FF7,8FB
05708:  MOVFF  FF5,8FC
0570C:  RCALL  5698
0570E:  MOVFF  8FA,FF6
05712:  MOVFF  8FB,FF7
05716:  MOVLB  8
05718:  DECFSZ xF9,F
0571A:  BRA    571E
0571C:  BRA    5722
0571E:  MOVLB  0
05720:  BRA    56FE
05722:  MOVLB  0
05724:  GOTO   5806 (RETURN)
05728:  TSTFSZ 01
0572A:  BRA    5732
0572C:  TSTFSZ 02
0572E:  BRA    5734
05730:  BRA    5740
05732:  INCF   02,F
05734:  MOVFF  00,FEE
05738:  DECFSZ 01,F
0573A:  BRA    5734
0573C:  DECFSZ 02,F
0573E:  BRA    5734
05740:  RETURN 0
*
058C6:  TBLRD*+
058C8:  MOVF   FF5,F
058CA:  BZ    58E4
058CC:  MOVFF  FF6,8F9
058D0:  MOVFF  FF7,8FA
058D4:  MOVFF  FF5,8FC
058D8:  RCALL  5698
058DA:  MOVFF  8F9,FF6
058DE:  MOVFF  8FA,FF7
058E2:  BRA    58C6
058E4:  GOTO   5998 (RETURN)
*
05B8E:  TBLRD*+
05B90:  MOVFF  FF6,90E
05B94:  MOVFF  FF7,90F
05B98:  MOVFF  FF5,913
05B9C:  RCALL  5B7E
05B9E:  MOVFF  90E,FF6
05BA2:  MOVFF  90F,FF7
05BA6:  MOVLB  9
05BA8:  DECFSZ x0D,F
05BAA:  BRA    5BAE
05BAC:  BRA    5BB2
05BAE:  MOVLB  0
05BB0:  BRA    5B8E
05BB2:  MOVLB  0
05BB4:  RETURN 0
05BB6:  MOVF   FEF,F
05BB8:  BZ    5BD8
05BBA:  MOVFF  FEA,90F
05BBE:  MOVFF  FE9,90E
05BC2:  MOVFF  FEF,913
05BC6:  RCALL  5B7E
05BC8:  MOVFF  90F,FEA
05BCC:  MOVFF  90E,FE9
05BD0:  INCF   FE9,F
05BD2:  BTFSC  FD8.2
05BD4:  INCF   FEA,F
05BD6:  BRA    5BB6
05BD8:  RETURN 0
*
05BE6:  TBLRD*+
05BE8:  MOVF   FF5,F
05BEA:  BZ    5C04
05BEC:  MOVFF  FF6,90E
05BF0:  MOVFF  FF7,90F
05BF4:  MOVFF  FF5,913
05BF8:  RCALL  5B7E
05BFA:  MOVFF  90E,FF6
05BFE:  MOVFF  90F,FF7
05C02:  BRA    5BE6
05C04:  RETURN 0
05C06:  MOVLW  20
05C08:  MOVLB  9
05C0A:  BTFSS  x0E.4
05C0C:  MOVLW  30
05C0E:  MOVWF  x0F
05C10:  MOVFF  90D,00
05C14:  BTFSS  00.7
05C16:  BRA    5C28
05C18:  COMF   00,F
05C1A:  INCF   00,F
05C1C:  MOVFF  00,90D
05C20:  MOVLW  2D
05C22:  MOVWF  x0F
05C24:  BSF    x0E.7
05C26:  BSF    x0E.0
05C28:  MOVF   01,W
05C2A:  MOVFF  90D,913
05C2E:  MOVLW  64
05C30:  MOVWF  x14
05C32:  MOVLB  0
05C34:  CALL   1560
05C38:  MOVFF  00,90D
05C3C:  MOVLW  30
05C3E:  ADDWF  01,W
05C40:  MOVLB  9
05C42:  MOVWF  x10
05C44:  MOVFF  90D,913
05C48:  MOVLW  0A
05C4A:  MOVWF  x14
05C4C:  MOVLB  0
05C4E:  CALL   1560
05C52:  MOVLW  30
05C54:  ADDWF  00,W
05C56:  MOVLB  9
05C58:  MOVWF  x12
05C5A:  MOVLW  30
05C5C:  ADDWF  01,W
05C5E:  MOVWF  x11
05C60:  MOVFF  90F,00
05C64:  MOVLW  30
05C66:  SUBWF  x10,W
05C68:  BZ    5C72
05C6A:  BSF    x0E.1
05C6C:  BTFSC  x0E.7
05C6E:  BSF    x0E.2
05C70:  BRA    5C96
05C72:  BTFSC  x0E.2
05C74:  BRA    5C96
05C76:  MOVFF  90F,910
05C7A:  BTFSC  x0E.1
05C7C:  BRA    5C86
05C7E:  MOVLW  30
05C80:  SUBWF  x11,W
05C82:  BZ    5C8C
05C84:  BSF    x0E.0
05C86:  BTFSC  x0E.7
05C88:  BSF    x0E.1
05C8A:  BRA    5C96
05C8C:  BTFSS  FD8.2
05C8E:  BSF    x0E.0
05C90:  BTFSC  FD8.2
05C92:  MOVFF  910,911
05C96:  BTFSC  x0E.2
05C98:  BRA    5CA4
05C9A:  BTFSC  x0E.1
05C9C:  BRA    5CAC
05C9E:  BTFSC  x0E.0
05CA0:  BRA    5CB4
05CA2:  BRA    5CBC
05CA4:  MOVFF  90F,913
05CA8:  MOVLB  0
05CAA:  RCALL  5B7E
05CAC:  MOVFF  910,913
05CB0:  MOVLB  0
05CB2:  RCALL  5B7E
05CB4:  MOVFF  911,913
05CB8:  MOVLB  0
05CBA:  RCALL  5B7E
05CBC:  MOVFF  912,913
05CC0:  MOVLB  0
05CC2:  RCALL  5B7E
05CC4:  RETURN 0
*
06A3C:  MOVLW  20
06A3E:  MOVLB  8
06A40:  BTFSS  xFA.4
06A42:  MOVLW  30
06A44:  MOVWF  xFB
06A46:  MOVFF  8F9,00
06A4A:  BTFSS  00.7
06A4C:  BRA    6A5E
06A4E:  COMF   00,F
06A50:  INCF   00,F
06A52:  MOVFF  00,8F9
06A56:  MOVLW  2D
06A58:  MOVWF  xFB
06A5A:  BSF    xFA.7
06A5C:  BSF    xFA.0
06A5E:  MOVF   01,W
06A60:  MOVFF  8F9,913
06A64:  MOVLW  64
06A66:  MOVLB  9
06A68:  MOVWF  x14
06A6A:  MOVLB  0
06A6C:  CALL   1560
06A70:  MOVFF  00,8F9
06A74:  MOVLW  30
06A76:  ADDWF  01,W
06A78:  MOVLB  8
06A7A:  MOVWF  xFC
06A7C:  MOVFF  8F9,913
06A80:  MOVLW  0A
06A82:  MOVLB  9
06A84:  MOVWF  x14
06A86:  MOVLB  0
06A88:  CALL   1560
06A8C:  MOVLW  30
06A8E:  ADDWF  00,W
06A90:  MOVLB  8
06A92:  MOVWF  xFE
06A94:  MOVLW  30
06A96:  ADDWF  01,W
06A98:  MOVWF  xFD
06A9A:  MOVFF  8FB,00
06A9E:  MOVLW  30
06AA0:  SUBWF  xFC,W
06AA2:  BZ    6AAC
06AA4:  BSF    xFA.1
06AA6:  BTFSC  xFA.7
06AA8:  BSF    xFA.2
06AAA:  BRA    6AD0
06AAC:  BTFSC  xFA.2
06AAE:  BRA    6AD0
06AB0:  MOVFF  8FB,8FC
06AB4:  BTFSC  xFA.1
06AB6:  BRA    6AC0
06AB8:  MOVLW  30
06ABA:  SUBWF  xFD,W
06ABC:  BZ    6AC6
06ABE:  BSF    xFA.0
06AC0:  BTFSC  xFA.7
06AC2:  BSF    xFA.1
06AC4:  BRA    6AD0
06AC6:  BTFSS  FD8.2
06AC8:  BSF    xFA.0
06ACA:  BTFSC  FD8.2
06ACC:  MOVFF  8FC,8FD
06AD0:  BTFSC  xFA.2
06AD2:  BRA    6ADE
06AD4:  BTFSC  xFA.1
06AD6:  BRA    6AE8
06AD8:  BTFSC  xFA.0
06ADA:  BRA    6AF2
06ADC:  BRA    6AFC
06ADE:  MOVFF  8FB,8FF
06AE2:  MOVLB  0
06AE4:  CALL   065E
06AE8:  MOVFF  8FC,8FF
06AEC:  MOVLB  0
06AEE:  CALL   065E
06AF2:  MOVFF  8FD,8FF
06AF6:  MOVLB  0
06AF8:  CALL   065E
06AFC:  MOVFF  8FE,8FF
06B00:  MOVLB  0
06B02:  CALL   065E
06B06:  RETURN 0
....................  
.................... #list 
....................  
.................... // Conversor de 10 bits con justificación a la derecha. 
.................... //#device ADC=10 
.................... // Configuramos velocidad de operación. 
.................... #use delay(clock=40000000) // Trabajamos a 20.00Mhz.  
*
005E4:  MOVLW  09
005E6:  MOVWF  FEA
005E8:  CLRF   FE9
005EA:  MOVF   FEF,W
005EC:  BZ    060A
005EE:  MOVLW  0C
005F0:  MOVWF  01
005F2:  CLRF   00
005F4:  DECFSZ 00,F
005F6:  BRA    05F4
005F8:  DECFSZ 01,F
005FA:  BRA    05F2
005FC:  MOVLW  F7
005FE:  MOVWF  00
00600:  DECFSZ 00,F
00602:  BRA    0600
00604:  BRA    0606
00606:  DECFSZ FEF,F
00608:  BRA    05EE
0060A:  RETURN 0
.................... // Configuramos fusibles de programación. 
.................... //#FUSES NOWDT                    // No utilizamos el perro guardían. 
.................... #FUSES WDT4096 
.................... #FUSES H4                       // Oscilador de alta velocidad 40Mhz. 
.................... #FUSES FCMEN                    // Monitor de reloj activado. 
.................... #FUSES PUT                      // Temporizador de encendido. 
.................... #FUSES NOBROWNOUT               // No activamos el reset por bajo voltaje. 
.................... #FUSES NOPBADEN                 // Deshabilitamos el módulo conversor ADC del puerto B. 
.................... #FUSES NOLPT1OSC                // Timer 1 configurado para una alta potencia de operación. 
.................... //#FUSES NOMCLR                   // Pin Master Clear deshabilitado. 
.................... #FUSES MCLR                     // Pin Master Clear habilitado. 
.................... #FUSES STVREN                   // Si se rebalsa o llena el stack el microcontrolador se resetea. 
.................... #FUSES NOLVP                    // No utilizamos bajo voltaje para programación. 
.................... #FUSES NOXINST                  // Set de instruccciones ampliado, desactivado. 
.................... #FUSES NODEBUG                  // No utilizamos código para debug. 
.................... #FUSES PROTECT                  // Código protejido contra lecturas. 
.................... #FUSES NOCPB                    // Sector de booteo no protejido. 
.................... #FUSES NOCPD                    // Sin protección de código en la EEPROM. 
.................... #FUSES NOWRT                    // Memoria de programa no protejida contra escrituras. 
.................... #FUSES NOWRTC                   // Registros de configuración no protegido contra escritura. 
.................... #FUSES NOWRTB                   // Bloque de booteo no protejido contra escritura. 
.................... #FUSES NOWRTD                   // Memoria EEPROM no protejida contra escritura. 
.................... #FUSES NOEBTR                   // Memoria no protejida contra lectuas de tablas de memoria. 
.................... #FUSES NOEBTRB                  // Bloque de booteo no protejido contra lectura de tablas de memoria. 
....................  
.................... // Configuramos los puertos RS232 utilizados. 
.................... #use RS232(uart1, baud=38400,RESTART_WDT,stream=U1PRINTER,TIMEOUT=40,DISABLE_INTS) 
*
05B7E:  CLRWDT
05B80:  BTFSS  F9E.4
05B82:  BRA    5B7E
05B84:  MOVLB  9
05B86:  MOVFF  913,FAD
05B8A:  MOVLB  0
05B8C:  RETURN 0
....................  
.................... const int data_set=14;//CANTIDAD DE INSTRUCCIONES GRABADAS 
.................... const int port_size=90; 
.................... const int tag_size = 8; 
.................... const int word_size_reg =12;//TAMAÑO DE REGISTRO 
.................... const int16 lim_reg=300; 
.................... const int16 data_numbers_ext=2000;//maximo de tags en eeprom 
.................... const int instruccion_size = 10; 
....................  
.................... int envia_pc,a,b2,relay1,tcp_recibe,time_relay1,falla_grabar,f_graba; 
.................... char memory[30]; 
.................... int16 i,n,b,c_envia; 
.................... int size_tx_tcp,con_activas; 
.................... unsigned int16 m,dir; 
....................  
.................... int edo_str, reintento_envio,inicializado,socket2; 
.................... char XX[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RECIBIDOS DE TCP) 
.................... char YY[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RESPALDO EN RAM) 
.................... char txtcp[port_size];//ARREGLO DE TRANSMICION 
.................... char rxtcp[port_size];//1536->112 tags,se direcciona mal la ram con valores mas grandes 
.................... //500-alcanza para 54 tags, mas no alcanza la ram, 700au cabe 
.................... char lcd_men[port_size-10]; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size=26;//34;// 
.................... int deteccion_nulo,pre_cuenta; 
.................... int wieg,wigmal,tecla; 
.................... int sub_indice=0; 
.................... int wieg_full=0; 
.................... int wiegand_cuenta; 
.................... unsigned int32 deci; 
.................... char data[wieg_size]; 
.................... char con_barra[30],barra_codi[30]; 
.................... int32 folio; 
.................... const int idbar=1; 
.................... const int data_numbers=14; 
.................... //RELOJ/CALENDARIO 
.................... int day,month,yr,hrs,min,sec,dow,puntos,cambio_msj; 
.................... int dias_prueba,dia_temp,pago,cuenta,espera,hrs2; 
.................... int16 mes2,dia; 
.................... const int dia_limite=90; 
.................... //variables de entradas 
.................... int en1,en2,en3,en4,en5,flag_pluma; 
.................... //boleto 
.................... int time_boleto,re_bol,cta_lcd; 
.................... // Definimos macros hardware: 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00556:  MOVLB  9
00558:  BTFSC  x07.0
0055A:  BRA    0560
0055C:  BCF    F89.4
0055E:  BRA    0562
00560:  BSF    F89.4
00562:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00564:  BTFSC  x07.1
00566:  BRA    056C
00568:  BCF    F89.2
0056A:  BRA    056E
0056C:  BSF    F89.2
0056E:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
00570:  BTFSC  x07.2
00572:  BRA    0578
00574:  BCF    F89.1
00576:  BRA    057A
00578:  BSF    F89.1
0057A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0057C:  BTFSC  x07.3
0057E:  BRA    0584
00580:  BCF    F89.0
00582:  BRA    0586
00584:  BSF    F89.0
00586:  BCF    F92.0
....................  
....................  delay_cycles(1);  
00588:  NOP   
....................  output_high(LCD_E);  
0058A:  BCF    F92.3
0058C:  BSF    F89.3
....................  delay_us(2);  
0058E:  MOVLW  06
00590:  MOVWF  00
00592:  DECFSZ 00,F
00594:  BRA    0592
00596:  NOP   
....................  output_low(LCD_E);  
00598:  BCF    F92.3
0059A:  BCF    F89.3
0059C:  MOVLB  0
0059E:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
005A0:  BCF    F96.2
005A2:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
005A4:  MOVLW  C7
005A6:  MOVWF  00
005A8:  DECFSZ 00,F
005AA:  BRA    05A8
005AC:  BRA    05AE
.................... #endif  
....................  
.................... if(address)  
005AE:  MOVLB  9
005B0:  MOVF   x04,F
005B2:  BZ    05BA
....................    output_high(LCD_RS);  
005B4:  BCF    F96.2
005B6:  BSF    F8D.2
005B8:  BRA    05BE
.................... else  
....................    output_low(LCD_RS);  
005BA:  BCF    F96.2
005BC:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
005BE:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
005C0:  BCF    F92.3
005C2:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
005C4:  SWAPF  x05,W
005C6:  MOVWF  x06
005C8:  MOVLW  0F
005CA:  ANDWF  x06,F
005CC:  MOVFF  906,907
005D0:  MOVLB  0
005D2:  RCALL  0556
.................... lcd_send_nibble(n & 0xf);  
005D4:  MOVLB  9
005D6:  MOVF   x05,W
005D8:  ANDLW  0F
005DA:  MOVWF  x06
005DC:  MOVWF  x07
005DE:  MOVLB  0
005E0:  RCALL  0556
005E2:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
*
006EA:  MOVLW  01
006EC:  MOVLB  2
006EE:  MOVWF  x8C
....................  
....................    output_low(LCD_RS);  
006F0:  BCF    F96.2
006F2:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
006F4:  BCF    F92.3
006F6:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
006F8:  MOVLW  23
006FA:  MOVLB  9
006FC:  MOVWF  x00
006FE:  MOVLB  0
00700:  RCALL  05E4
....................  
....................    for(i=0 ;i < 3; i++)  
00702:  MOVLB  8
00704:  CLRF   xF9
00706:  MOVF   xF9,W
00708:  SUBLW  02
0070A:  BNC   0726
....................    {  
....................       lcd_send_nibble(0x03);  
0070C:  MOVLW  03
0070E:  MOVLB  9
00710:  MOVWF  x07
00712:  MOVLB  0
00714:  RCALL  0556
....................       delay_ms(5);  
00716:  MOVLW  05
00718:  MOVLB  9
0071A:  MOVWF  x00
0071C:  MOVLB  0
0071E:  RCALL  05E4
00720:  MOVLB  8
00722:  INCF   xF9,F
00724:  BRA    0706
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
00726:  MOVLW  02
00728:  MOVLB  9
0072A:  MOVWF  x07
0072C:  MOVLB  0
0072E:  RCALL  0556
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00730:  MOVLB  8
00732:  CLRF   xF9
00734:  MOVF   xF9,W
00736:  SUBLW  03
00738:  BNC   0760
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
0073A:  CLRF   03
0073C:  MOVF   xF9,W
0073E:  MOVLB  0
00740:  RCALL  00D2
00742:  MOVLB  8
00744:  MOVWF  xFA
00746:  MOVLB  9
00748:  CLRF   x04
0074A:  MOVWF  x05
0074C:  MOVLB  0
0074E:  RCALL  05A0
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
00750:  MOVLW  05
00752:  MOVLB  9
00754:  MOVWF  x00
00756:  MOVLB  0
00758:  RCALL  05E4
....................       #endif  
0075A:  MOVLB  8
0075C:  INCF   xF9,F
0075E:  BRA    0734
....................    }  
00760:  MOVLB  0
00762:  GOTO   6CCA (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
0060C:  MOVLB  9
0060E:  MOVF   x01,W
00610:  XORLW  01
00612:  MOVLB  0
00614:  BZ    0624
00616:  XORLW  03
00618:  BZ    062A
0061A:  XORLW  01
0061C:  BZ    0632
0061E:  XORLW  07
00620:  BZ    063A
00622:  BRA    0644
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
00624:  MOVLB  9
00626:  CLRF   x02
....................      break;  
00628:  BRA    0648
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
0062A:  MOVLW  40
0062C:  MOVLB  9
0062E:  MOVWF  x02
....................      break;  
00630:  BRA    0648
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
00632:  MOVLW  14
00634:  MOVLB  9
00636:  MOVWF  x02
....................      break;  
00638:  BRA    0648
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0063A:  MOVLW  54
0063C:  MOVLB  9
0063E:  MOVWF  x02
....................      break;  
00640:  BRA    0648
00642:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
00644:  MOVLB  9
00646:  CLRF   x02
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
00648:  MOVLW  01
0064A:  SUBWF  x00,W
0064C:  ADDWF  x02,F
.................... lcd_send_byte(0, 0x80 | address);  
0064E:  MOVF   x02,W
00650:  IORLW  80
00652:  MOVWF  x03
00654:  CLRF   x04
00656:  MOVWF  x05
00658:  MOVLB  0
0065A:  RCALL  05A0
0065C:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0065E:  MOVLB  8
00660:  MOVF   xFF,W
00662:  XORLW  0C
00664:  MOVLB  0
00666:  BZ    0672
00668:  XORLW  06
0066A:  BZ    0690
0066C:  XORLW  02
0066E:  BZ    06A4
00670:  BRA    06B2
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
00672:  MOVLB  9
00674:  CLRF   x04
00676:  MOVLW  01
00678:  MOVWF  x05
0067A:  MOVLB  0
0067C:  RCALL  05A0
....................       lcd_line = 1;  
0067E:  MOVLW  01
00680:  MOVLB  2
00682:  MOVWF  x8C
....................       delay_ms(2);  
00684:  MOVLW  02
00686:  MOVLB  9
00688:  MOVWF  x00
0068A:  MOVLB  0
0068C:  RCALL  05E4
....................       break;  
0068E:  BRA    06C0
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
00690:  MOVLB  2
00692:  INCF   x8C,F
00694:  MOVLW  01
00696:  MOVLB  9
00698:  MOVWF  x00
0069A:  MOVFF  28C,901
0069E:  MOVLB  0
006A0:  RCALL  060C
....................        break;  
006A2:  BRA    06C0
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
006A4:  MOVLB  9
006A6:  CLRF   x04
006A8:  MOVLW  10
006AA:  MOVWF  x05
006AC:  MOVLB  0
006AE:  RCALL  05A0
....................        break;  
006B0:  BRA    06C0
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
006B2:  MOVLW  01
006B4:  MOVLB  9
006B6:  MOVWF  x04
006B8:  MOVFF  8FF,905
006BC:  MOVLB  0
006BE:  RCALL  05A0
....................        break;  
....................    }  
006C0:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_SEGUINT.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B5//PIN_B7 
.................... #define EEPROM_SCL  PIN_B4//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
012A6:  MOVLW  08
012A8:  MOVWF  01
012AA:  MOVLW  0E
012AC:  MOVWF  00
012AE:  DECFSZ 00,F
012B0:  BRA    12AE
012B2:  BCF    F8A.4
012B4:  BCF    F93.4
012B6:  MOVLW  0E
012B8:  MOVWF  00
012BA:  DECFSZ 00,F
012BC:  BRA    12BA
012BE:  MOVLB  9
012C0:  RLCF   x0F,F
012C2:  BCF    F8A.5
012C4:  BTFSC  FD8.0
012C6:  BSF    F93.5
012C8:  BTFSS  FD8.0
012CA:  BCF    F93.5
012CC:  BSF    F93.4
012CE:  BTFSS  F81.4
012D0:  BRA    12CE
012D2:  DECFSZ 01,F
012D4:  BRA    12D8
012D6:  BRA    12DC
012D8:  MOVLB  0
012DA:  BRA    12AA
012DC:  MOVLW  0E
012DE:  MOVWF  00
012E0:  DECFSZ 00,F
012E2:  BRA    12E0
012E4:  BCF    F8A.4
012E6:  BCF    F93.4
012E8:  NOP   
012EA:  BSF    F93.5
012EC:  MOVLW  0E
012EE:  MOVWF  00
012F0:  DECFSZ 00,F
012F2:  BRA    12F0
012F4:  MOVLW  0E
012F6:  MOVWF  00
012F8:  DECFSZ 00,F
012FA:  BRA    12F8
012FC:  BSF    F93.4
012FE:  BTFSS  F81.4
01300:  BRA    12FE
01302:  CLRF   01
01304:  MOVLW  0E
01306:  MOVWF  00
01308:  DECFSZ 00,F
0130A:  BRA    1308
0130C:  BTFSC  F81.5
0130E:  BSF    01.0
01310:  BCF    F8A.4
01312:  BCF    F93.4
01314:  BCF    F8A.5
01316:  BCF    F93.5
01318:  MOVLB  0
0131A:  RETURN 0
0131C:  MOVLW  08
0131E:  MOVLB  9
01320:  MOVWF  x0D
01322:  MOVFF  00,90E
01326:  BSF    F93.5
01328:  MOVLW  0E
0132A:  MOVWF  00
0132C:  DECFSZ 00,F
0132E:  BRA    132C
01330:  BSF    F93.4
01332:  BTFSS  F81.4
01334:  BRA    1332
01336:  BTFSC  F81.5
01338:  BSF    FD8.0
0133A:  BTFSS  F81.5
0133C:  BCF    FD8.0
0133E:  RLCF   01,F
01340:  MOVLW  0E
01342:  MOVWF  00
01344:  DECFSZ 00,F
01346:  BRA    1344
01348:  BCF    F93.4
0134A:  BCF    F8A.4
0134C:  DECFSZ x0D,F
0134E:  BRA    1326
01350:  BSF    F93.5
01352:  MOVLW  0E
01354:  MOVWF  00
01356:  DECFSZ 00,F
01358:  BRA    1356
0135A:  BCF    F8A.5
0135C:  MOVF   x0E,W
0135E:  BTFSS  FD8.2
01360:  BCF    F93.5
01362:  NOP   
01364:  BSF    F93.4
01366:  BTFSS  F81.4
01368:  BRA    1366
0136A:  MOVLW  0E
0136C:  MOVWF  00
0136E:  DECFSZ 00,F
01370:  BRA    136E
01372:  BCF    F8A.4
01374:  BCF    F93.4
01376:  MOVLW  0E
01378:  MOVWF  00
0137A:  DECFSZ 00,F
0137C:  BRA    137A
0137E:  BCF    F8A.5
01380:  BCF    F93.5
01382:  MOVLB  0
01384:  GOTO   1402 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
006E2:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
006E4:  BSF    F93.5
006E6:  GOTO   6CC6 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data){ 
....................    short int status; 
....................    i2c_start(); 
*
01430:  BSF    F93.5
01432:  MOVLW  0E
01434:  MOVWF  00
01436:  DECFSZ 00,F
01438:  BRA    1436
0143A:  BSF    F93.4
0143C:  MOVLW  0E
0143E:  MOVWF  00
01440:  DECFSZ 00,F
01442:  BRA    1440
01444:  BCF    F8A.5
01446:  BCF    F93.5
01448:  MOVLW  0E
0144A:  MOVWF  00
0144C:  DECFSZ 00,F
0144E:  BRA    144C
01450:  BCF    F8A.4
01452:  BCF    F93.4
....................    i2c_write(0xa0); 
01454:  MOVLW  A0
01456:  MOVLB  9
01458:  MOVWF  x0F
0145A:  MOVLB  0
0145C:  RCALL  12A6
....................    i2c_write(address>>8); 
0145E:  MOVFF  90A,90D
01462:  MOVLB  9
01464:  CLRF   x0E
01466:  MOVFF  90A,90F
0146A:  MOVLB  0
0146C:  RCALL  12A6
....................    i2c_write(address); 
0146E:  MOVFF  909,90F
01472:  RCALL  12A6
....................    i2c_write(data); 
01474:  MOVFF  90B,90F
01478:  RCALL  12A6
....................    i2c_stop(); 
0147A:  BCF    F93.5
0147C:  NOP   
0147E:  BSF    F93.4
01480:  BTFSS  F81.4
01482:  BRA    1480
01484:  MOVLW  0E
01486:  MOVWF  00
01488:  DECFSZ 00,F
0148A:  BRA    1488
0148C:  BRA    148E
0148E:  NOP   
01490:  BSF    F93.5
01492:  MOVLW  0E
01494:  MOVWF  00
01496:  DECFSZ 00,F
01498:  BRA    1496
....................    i2c_start(); 
0149A:  BSF    F93.5
0149C:  MOVLW  0E
0149E:  MOVWF  00
014A0:  DECFSZ 00,F
014A2:  BRA    14A0
014A4:  BSF    F93.4
014A6:  MOVLW  0E
014A8:  MOVWF  00
014AA:  DECFSZ 00,F
014AC:  BRA    14AA
014AE:  BCF    F8A.5
014B0:  BCF    F93.5
014B2:  MOVLW  0E
014B4:  MOVWF  00
014B6:  DECFSZ 00,F
014B8:  BRA    14B6
014BA:  BCF    F8A.4
014BC:  BCF    F93.4
....................    status=i2c_write(0xa0); 
014BE:  MOVLW  A0
014C0:  MOVLB  9
014C2:  MOVWF  x0F
014C4:  MOVLB  0
014C6:  RCALL  12A6
014C8:  MOVF   01,W
014CA:  MOVLB  9
014CC:  BCF    x0C.0
014CE:  BTFSC  01.0
014D0:  BSF    x0C.0
....................    while(status==1) 
014D2:  BTFSS  x0C.0
014D4:  BRA    1512
....................    { 
....................    i2c_start(); 
014D6:  BSF    F93.5
014D8:  MOVLW  0E
014DA:  MOVWF  00
014DC:  DECFSZ 00,F
014DE:  BRA    14DC
014E0:  BSF    F93.4
014E2:  MOVLW  0E
014E4:  MOVWF  00
014E6:  DECFSZ 00,F
014E8:  BRA    14E6
014EA:  BTFSS  F81.4
014EC:  BRA    14EA
014EE:  BCF    F8A.5
014F0:  BCF    F93.5
014F2:  MOVLW  0E
014F4:  MOVWF  00
014F6:  DECFSZ 00,F
014F8:  BRA    14F6
014FA:  BCF    F8A.4
014FC:  BCF    F93.4
....................    status=i2c_write(0xa0); 
014FE:  MOVLW  A0
01500:  MOVWF  x0F
01502:  MOVLB  0
01504:  RCALL  12A6
01506:  MOVF   01,W
01508:  MOVLB  9
0150A:  BCF    x0C.0
0150C:  BTFSC  01.0
0150E:  BSF    x0C.0
01510:  BRA    14D2
....................    } 
....................    i2c_stop(); 
01512:  BCF    F93.5
01514:  NOP   
01516:  BSF    F93.4
01518:  BTFSS  F81.4
0151A:  BRA    1518
0151C:  MOVLW  0E
0151E:  MOVWF  00
01520:  DECFSZ 00,F
01522:  BRA    1520
01524:  BRA    1526
01526:  NOP   
01528:  BSF    F93.5
0152A:  MOVLW  0E
0152C:  MOVWF  00
0152E:  DECFSZ 00,F
01530:  BRA    152E
01532:  MOVLB  0
01534:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
01388:  BSF    F93.5
0138A:  MOVLW  0E
0138C:  MOVWF  00
0138E:  DECFSZ 00,F
01390:  BRA    138E
01392:  BSF    F93.4
01394:  MOVLW  0E
01396:  MOVWF  00
01398:  DECFSZ 00,F
0139A:  BRA    1398
0139C:  BCF    F8A.5
0139E:  BCF    F93.5
013A0:  MOVLW  0E
013A2:  MOVWF  00
013A4:  DECFSZ 00,F
013A6:  BRA    13A4
013A8:  BCF    F8A.4
013AA:  BCF    F93.4
....................    i2c_write(0xa0); 
013AC:  MOVLW  A0
013AE:  MOVLB  9
013B0:  MOVWF  x0F
013B2:  MOVLB  0
013B4:  RCALL  12A6
....................    i2c_write(address>>8); 
013B6:  MOVFF  90A,90C
013BA:  MOVLB  9
013BC:  CLRF   x0D
013BE:  MOVFF  90A,90F
013C2:  MOVLB  0
013C4:  RCALL  12A6
....................    i2c_write(address); 
013C6:  MOVFF  909,90F
013CA:  RCALL  12A6
....................    i2c_start(); 
013CC:  BSF    F93.5
013CE:  MOVLW  0E
013D0:  MOVWF  00
013D2:  DECFSZ 00,F
013D4:  BRA    13D2
013D6:  BSF    F93.4
013D8:  MOVLW  0E
013DA:  MOVWF  00
013DC:  DECFSZ 00,F
013DE:  BRA    13DC
013E0:  BTFSS  F81.4
013E2:  BRA    13E0
013E4:  BCF    F8A.5
013E6:  BCF    F93.5
013E8:  MOVLW  0E
013EA:  MOVWF  00
013EC:  DECFSZ 00,F
013EE:  BRA    13EC
013F0:  BCF    F8A.4
013F2:  BCF    F93.4
....................    i2c_write(0xa1); 
013F4:  MOVLW  A1
013F6:  MOVLB  9
013F8:  MOVWF  x0F
013FA:  MOVLB  0
013FC:  RCALL  12A6
....................    data=i2c_read(0); 
013FE:  CLRF   00
01400:  BRA    131C
01402:  MOVFF  01,90B
....................    i2c_stop(); 
01406:  BCF    F93.5
01408:  NOP   
0140A:  BSF    F93.4
0140C:  BTFSS  F81.4
0140E:  BRA    140C
01410:  MOVLW  0E
01412:  MOVWF  00
01414:  DECFSZ 00,F
01416:  BRA    1414
01418:  BRA    141A
0141A:  NOP   
0141C:  BSF    F93.5
0141E:  MOVLW  0E
01420:  MOVWF  00
01422:  DECFSZ 00,F
01424:  BRA    1422
....................    return(data); 
01426:  MOVLB  9
01428:  MOVFF  90B,01
0142C:  MOVLB  0
0142E:  RETURN 0
.................... } 
....................  
.................... #include "ds1307_3.c" //reloj 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_D6 
.................... #define RTC_SCL  PIN_E1 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
05A74:  MOVLW  08
05A76:  MOVWF  01
05A78:  MOVLW  0E
05A7A:  MOVWF  00
05A7C:  DECFSZ 00,F
05A7E:  BRA    5A7C
05A80:  BCF    F8D.1
05A82:  BCF    F96.1
05A84:  MOVLW  0E
05A86:  MOVWF  00
05A88:  DECFSZ 00,F
05A8A:  BRA    5A88
05A8C:  MOVLB  9
05A8E:  RLCF   x15,F
05A90:  BCF    F8C.6
05A92:  BTFSC  FD8.0
05A94:  BSF    F95.6
05A96:  BTFSS  FD8.0
05A98:  BCF    F95.6
05A9A:  BSF    F96.1
05A9C:  BTFSS  F84.1
05A9E:  BRA    5A9C
05AA0:  DECFSZ 01,F
05AA2:  BRA    5AA6
05AA4:  BRA    5AAA
05AA6:  MOVLB  0
05AA8:  BRA    5A78
05AAA:  MOVLW  0E
05AAC:  MOVWF  00
05AAE:  DECFSZ 00,F
05AB0:  BRA    5AAE
05AB2:  BCF    F8D.1
05AB4:  BCF    F96.1
05AB6:  NOP   
05AB8:  BSF    F95.6
05ABA:  MOVLW  0E
05ABC:  MOVWF  00
05ABE:  DECFSZ 00,F
05AC0:  BRA    5ABE
05AC2:  MOVLW  0E
05AC4:  MOVWF  00
05AC6:  DECFSZ 00,F
05AC8:  BRA    5AC6
05ACA:  BSF    F96.1
05ACC:  BTFSS  F84.1
05ACE:  BRA    5ACC
05AD0:  CLRF   01
05AD2:  MOVLW  0E
05AD4:  MOVWF  00
05AD6:  DECFSZ 00,F
05AD8:  BRA    5AD6
05ADA:  BTFSC  F83.6
05ADC:  BSF    01.0
05ADE:  BCF    F8D.1
05AE0:  BCF    F96.1
05AE2:  BCF    F8C.6
05AE4:  BCF    F95.6
05AE6:  MOVLB  0
05AE8:  RETURN 0
05AEA:  MOVLW  08
05AEC:  MOVLB  9
05AEE:  MOVWF  x16
05AF0:  MOVFF  00,917
05AF4:  BSF    F95.6
05AF6:  MOVLW  0E
05AF8:  MOVWF  00
05AFA:  DECFSZ 00,F
05AFC:  BRA    5AFA
05AFE:  BSF    F96.1
05B00:  BTFSS  F84.1
05B02:  BRA    5B00
05B04:  BTFSC  F83.6
05B06:  BSF    FD8.0
05B08:  BTFSS  F83.6
05B0A:  BCF    FD8.0
05B0C:  RLCF   01,F
05B0E:  MOVLW  0E
05B10:  MOVWF  00
05B12:  DECFSZ 00,F
05B14:  BRA    5B12
05B16:  BCF    F96.1
05B18:  BCF    F8D.1
05B1A:  DECFSZ x16,F
05B1C:  BRA    5AF4
05B1E:  BSF    F95.6
05B20:  MOVLW  0E
05B22:  MOVWF  00
05B24:  DECFSZ 00,F
05B26:  BRA    5B24
05B28:  BCF    F8C.6
05B2A:  MOVF   x17,W
05B2C:  BTFSS  FD8.2
05B2E:  BCF    F95.6
05B30:  NOP   
05B32:  BSF    F96.1
05B34:  BTFSS  F84.1
05B36:  BRA    5B34
05B38:  MOVLW  0E
05B3A:  MOVWF  00
05B3C:  DECFSZ 00,F
05B3E:  BRA    5B3C
05B40:  BCF    F8D.1
05B42:  BCF    F96.1
05B44:  MOVLW  0E
05B46:  MOVWF  00
05B48:  DECFSZ 00,F
05B4A:  BRA    5B48
05B4C:  BCF    F8C.6
05B4E:  BCF    F95.6
05B50:  MOVLB  0
05B52:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
....................    #endif 
....................    BYTE seconds = 0; 
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
.................... }  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... { 
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
063F6:  BCF    FF2.6
063F8:  BCF    FF2.7
063FA:  BTFSC  FF2.7
063FC:  BRA    63F8
....................   #endif 
....................   sec &= 0x7F; 
063FE:  MOVLB  9
06400:  BCF    x0F.7
....................   hr &= 0x3F;  
06402:  MOVLW  3F
06404:  ANDWF  x0D,F
....................  
....................   i2c_start();  
06406:  BSF    F95.6
06408:  MOVLW  0E
0640A:  MOVWF  00
0640C:  DECFSZ 00,F
0640E:  BRA    640C
06410:  BSF    F96.1
06412:  MOVLW  0E
06414:  MOVWF  00
06416:  DECFSZ 00,F
06418:  BRA    6416
0641A:  BCF    F8C.6
0641C:  BCF    F95.6
0641E:  MOVLW  0E
06420:  MOVWF  00
06422:  DECFSZ 00,F
06424:  BRA    6422
06426:  BCF    F8D.1
06428:  BCF    F96.1
....................   i2c_write(0xD0);            // I2C write address  
0642A:  MOVLW  D0
0642C:  MOVWF  x15
0642E:  MOVLB  0
06430:  CALL   5A74
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
06434:  MOVLB  9
06436:  CLRF   x15
06438:  MOVLB  0
0643A:  CALL   5A74
....................   i2c_write(bin2bcd(sec));      // REG 0  
0643E:  MOVFF  90F,910
06442:  RCALL  63CE
06444:  MOVFF  01,910
06448:  MOVFF  01,915
0644C:  CALL   5A74
....................   i2c_write(bin2bcd(min));      // REG 1  
06450:  MOVFF  90E,910
06454:  RCALL  63CE
06456:  MOVFF  01,910
0645A:  MOVFF  01,915
0645E:  CALL   5A74
....................   i2c_write(bin2bcd(hr));      // REG 2  
06462:  MOVFF  90D,910
06466:  RCALL  63CE
06468:  MOVFF  01,910
0646C:  MOVFF  01,915
06470:  CALL   5A74
....................   i2c_write(bin2bcd(dow));      // REG 3  
06474:  MOVFF  90C,910
06478:  RCALL  63CE
0647A:  MOVFF  01,910
0647E:  MOVFF  01,915
06482:  CALL   5A74
....................   i2c_write(bin2bcd(day));      // REG 4  
06486:  MOVFF  909,910
0648A:  RCALL  63CE
0648C:  MOVFF  01,910
06490:  MOVFF  01,915
06494:  CALL   5A74
....................   i2c_write(bin2bcd(mth));      // REG 5  
06498:  MOVFF  90A,910
0649C:  RCALL  63CE
0649E:  MOVFF  01,910
064A2:  MOVFF  01,915
064A6:  CALL   5A74
....................   i2c_write(bin2bcd(year));      // REG 6  
064AA:  MOVFF  90B,910
064AE:  RCALL  63CE
064B0:  MOVFF  01,910
064B4:  MOVFF  01,915
064B8:  CALL   5A74
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
064BC:  MOVLW  80
064BE:  MOVLB  9
064C0:  MOVWF  x15
064C2:  MOVLB  0
064C4:  CALL   5A74
....................   i2c_stop();  
064C8:  BCF    F95.6
064CA:  NOP   
064CC:  BSF    F96.1
064CE:  BTFSS  F84.1
064D0:  BRA    64CE
064D2:  MOVLW  0E
064D4:  MOVWF  00
064D6:  DECFSZ 00,F
064D8:  BRA    64D6
064DA:  BRA    64DC
064DC:  NOP   
064DE:  BSF    F95.6
064E0:  MOVLW  0E
064E2:  MOVWF  00
064E4:  DECFSZ 00,F
064E6:  BRA    64E4
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
064E8:  MOVLW  C0
064EA:  IORWF  FF2,F
.................... #endif 
064EC:  RETURN 0
.................... } 
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
05E08:  BCF    FF2.6
05E0A:  BCF    FF2.7
05E0C:  BTFSC  FF2.7
05E0E:  BRA    5E0A
*
0676E:  BCF    FF2.6
06770:  BCF    FF2.7
06772:  BTFSC  FF2.7
06774:  BRA    6770
*
07306:  BCF    FF2.6
07308:  BCF    FF2.7
0730A:  BTFSC  FF2.7
0730C:  BRA    7308
....................   #endif 
....................    
....................   i2c_start(); 
*
05E10:  BSF    F95.6
05E12:  MOVLW  0E
05E14:  MOVWF  00
05E16:  DECFSZ 00,F
05E18:  BRA    5E16
05E1A:  BSF    F96.1
05E1C:  MOVLW  0E
05E1E:  MOVWF  00
05E20:  DECFSZ 00,F
05E22:  BRA    5E20
05E24:  BCF    F8C.6
05E26:  BCF    F95.6
05E28:  MOVLW  0E
05E2A:  MOVWF  00
05E2C:  DECFSZ 00,F
05E2E:  BRA    5E2C
05E30:  BCF    F8D.1
05E32:  BCF    F96.1
*
06776:  BSF    F95.6
06778:  MOVLW  0E
0677A:  MOVWF  00
0677C:  DECFSZ 00,F
0677E:  BRA    677C
06780:  BSF    F96.1
06782:  MOVLW  0E
06784:  MOVWF  00
06786:  DECFSZ 00,F
06788:  BRA    6786
0678A:  BCF    F8C.6
0678C:  BCF    F95.6
0678E:  MOVLW  0E
06790:  MOVWF  00
06792:  DECFSZ 00,F
06794:  BRA    6792
06796:  BCF    F8D.1
06798:  BCF    F96.1
*
0730E:  BSF    F95.6
07310:  MOVLW  0E
07312:  MOVWF  00
07314:  DECFSZ 00,F
07316:  BRA    7314
07318:  BSF    F96.1
0731A:  MOVLW  0E
0731C:  MOVWF  00
0731E:  DECFSZ 00,F
07320:  BRA    731E
07322:  BCF    F8C.6
07324:  BCF    F95.6
07326:  MOVLW  0E
07328:  MOVWF  00
0732A:  DECFSZ 00,F
0732C:  BRA    732A
0732E:  BCF    F8D.1
07330:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05E34:  MOVLW  D0
05E36:  MOVLB  9
05E38:  MOVWF  x15
05E3A:  MOVLB  0
05E3C:  RCALL  5A74
*
0679A:  MOVLW  D0
0679C:  MOVWF  x15
0679E:  MOVLB  0
067A0:  CALL   5A74
*
07332:  MOVLW  D0
07334:  MOVLB  9
07336:  MOVWF  x15
07338:  MOVLB  0
0733A:  CALL   5A74
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
*
05E3E:  MOVLW  03
05E40:  MOVLB  9
05E42:  MOVWF  x15
05E44:  MOVLB  0
05E46:  RCALL  5A74
*
067A4:  MOVLW  03
067A6:  MOVLB  9
067A8:  MOVWF  x15
067AA:  MOVLB  0
067AC:  CALL   5A74
*
0733E:  MOVLW  03
07340:  MOVLB  9
07342:  MOVWF  x15
07344:  MOVLB  0
07346:  CALL   5A74
....................   i2c_start();  
*
05E48:  BSF    F95.6
05E4A:  MOVLW  0E
05E4C:  MOVWF  00
05E4E:  DECFSZ 00,F
05E50:  BRA    5E4E
05E52:  BSF    F96.1
05E54:  MOVLW  0E
05E56:  MOVWF  00
05E58:  DECFSZ 00,F
05E5A:  BRA    5E58
05E5C:  BTFSS  F84.1
05E5E:  BRA    5E5C
05E60:  BCF    F8C.6
05E62:  BCF    F95.6
05E64:  MOVLW  0E
05E66:  MOVWF  00
05E68:  DECFSZ 00,F
05E6A:  BRA    5E68
05E6C:  BCF    F8D.1
05E6E:  BCF    F96.1
*
067B0:  BSF    F95.6
067B2:  MOVLW  0E
067B4:  MOVWF  00
067B6:  DECFSZ 00,F
067B8:  BRA    67B6
067BA:  BSF    F96.1
067BC:  MOVLW  0E
067BE:  MOVWF  00
067C0:  DECFSZ 00,F
067C2:  BRA    67C0
067C4:  BTFSS  F84.1
067C6:  BRA    67C4
067C8:  BCF    F8C.6
067CA:  BCF    F95.6
067CC:  MOVLW  0E
067CE:  MOVWF  00
067D0:  DECFSZ 00,F
067D2:  BRA    67D0
067D4:  BCF    F8D.1
067D6:  BCF    F96.1
*
0734A:  BSF    F95.6
0734C:  MOVLW  0E
0734E:  MOVWF  00
07350:  DECFSZ 00,F
07352:  BRA    7350
07354:  BSF    F96.1
07356:  MOVLW  0E
07358:  MOVWF  00
0735A:  DECFSZ 00,F
0735C:  BRA    735A
0735E:  BTFSS  F84.1
07360:  BRA    735E
07362:  BCF    F8C.6
07364:  BCF    F95.6
07366:  MOVLW  0E
07368:  MOVWF  00
0736A:  DECFSZ 00,F
0736C:  BRA    736A
0736E:  BCF    F8D.1
07370:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05E70:  MOVLW  D1
05E72:  MOVLB  9
05E74:  MOVWF  x15
05E76:  MOVLB  0
05E78:  RCALL  5A74
*
067D8:  MOVLW  D1
067DA:  MOVLB  9
067DC:  MOVWF  x15
067DE:  MOVLB  0
067E0:  CALL   5A74
*
07372:  MOVLW  D1
07374:  MOVLB  9
07376:  MOVWF  x15
07378:  MOVLB  0
0737A:  CALL   5A74
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
*
05E7A:  MOVLW  01
05E7C:  MOVWF  00
05E7E:  RCALL  5AEA
05E80:  MOVF   01,W
05E82:  ANDLW  7F
05E84:  MOVLB  9
05E86:  MOVWF  x0D
05E88:  MOVWF  x16
05E8A:  MOVLB  0
05E8C:  RCALL  5B54
05E8E:  MOVFF  01,276
*
067E4:  MOVLW  01
067E6:  MOVWF  00
067E8:  CALL   5AEA
067EC:  MOVF   01,W
067EE:  ANDLW  7F
067F0:  MOVLB  9
067F2:  MOVWF  x0D
067F4:  MOVWF  x16
067F6:  MOVLB  0
067F8:  CALL   5B54
067FC:  MOVFF  01,276
*
0737E:  MOVLW  01
07380:  MOVWF  00
07382:  CALL   5AEA
07386:  MOVF   01,W
07388:  ANDLW  7F
0738A:  MOVLB  9
0738C:  MOVWF  x0D
0738E:  MOVWF  x16
07390:  MOVLB  0
07392:  CALL   5B54
07396:  MOVFF  01,276
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
*
05E92:  MOVLW  01
05E94:  MOVWF  00
05E96:  RCALL  5AEA
05E98:  MOVF   01,W
05E9A:  ANDLW  3F
05E9C:  MOVLB  9
05E9E:  MOVWF  x0D
05EA0:  MOVWF  x16
05EA2:  MOVLB  0
05EA4:  RCALL  5B54
05EA6:  MOVFF  01,270
*
06800:  MOVLW  01
06802:  MOVWF  00
06804:  CALL   5AEA
06808:  MOVF   01,W
0680A:  ANDLW  3F
0680C:  MOVLB  9
0680E:  MOVWF  x0D
06810:  MOVWF  x16
06812:  MOVLB  0
06814:  CALL   5B54
06818:  MOVFF  01,270
*
0739A:  MOVLW  01
0739C:  MOVWF  00
0739E:  CALL   5AEA
073A2:  MOVF   01,W
073A4:  ANDLW  3F
073A6:  MOVLB  9
073A8:  MOVWF  x0D
073AA:  MOVWF  x16
073AC:  MOVLB  0
073AE:  CALL   5B54
073B2:  MOVFF  01,270
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
*
05EAA:  MOVLW  01
05EAC:  MOVWF  00
05EAE:  RCALL  5AEA
05EB0:  MOVF   01,W
05EB2:  ANDLW  1F
05EB4:  MOVLB  9
05EB6:  MOVWF  x0D
05EB8:  MOVWF  x16
05EBA:  MOVLB  0
05EBC:  RCALL  5B54
05EBE:  MOVFF  01,271
*
0681C:  MOVLW  01
0681E:  MOVWF  00
06820:  CALL   5AEA
06824:  MOVF   01,W
06826:  ANDLW  1F
06828:  MOVLB  9
0682A:  MOVWF  x0D
0682C:  MOVWF  x16
0682E:  MOVLB  0
06830:  CALL   5B54
06834:  MOVFF  01,271
*
073B6:  MOVLW  01
073B8:  MOVWF  00
073BA:  CALL   5AEA
073BE:  MOVF   01,W
073C0:  ANDLW  1F
073C2:  MOVLB  9
073C4:  MOVWF  x0D
073C6:  MOVWF  x16
073C8:  MOVLB  0
073CA:  CALL   5B54
073CE:  MOVFF  01,271
....................   year = bcd2bin(i2c_read(0));            // REG 6  
*
05EC2:  CLRF   00
05EC4:  RCALL  5AEA
05EC6:  MOVFF  01,90D
05ECA:  MOVFF  01,916
05ECE:  RCALL  5B54
05ED0:  MOVFF  01,272
*
06838:  CLRF   00
0683A:  CALL   5AEA
0683E:  MOVFF  01,90D
06842:  MOVFF  01,916
06846:  CALL   5B54
0684A:  MOVFF  01,272
*
073D2:  CLRF   00
073D4:  CALL   5AEA
073D8:  MOVFF  01,90D
073DC:  MOVFF  01,916
073E0:  CALL   5B54
073E4:  MOVFF  01,272
....................   i2c_stop();  
*
05ED4:  BCF    F95.6
05ED6:  NOP   
05ED8:  BSF    F96.1
05EDA:  BTFSS  F84.1
05EDC:  BRA    5EDA
05EDE:  MOVLW  0E
05EE0:  MOVWF  00
05EE2:  DECFSZ 00,F
05EE4:  BRA    5EE2
05EE6:  BRA    5EE8
05EE8:  NOP   
05EEA:  BSF    F95.6
05EEC:  MOVLW  0E
05EEE:  MOVWF  00
05EF0:  DECFSZ 00,F
05EF2:  BRA    5EF0
*
0684E:  BCF    F95.6
06850:  NOP   
06852:  BSF    F96.1
06854:  BTFSS  F84.1
06856:  BRA    6854
06858:  MOVLW  0E
0685A:  MOVWF  00
0685C:  DECFSZ 00,F
0685E:  BRA    685C
06860:  BRA    6862
06862:  NOP   
06864:  BSF    F95.6
06866:  MOVLW  0E
06868:  MOVWF  00
0686A:  DECFSZ 00,F
0686C:  BRA    686A
*
073E8:  BCF    F95.6
073EA:  NOP   
073EC:  BSF    F96.1
073EE:  BTFSS  F84.1
073F0:  BRA    73EE
073F2:  MOVLW  0E
073F4:  MOVWF  00
073F6:  DECFSZ 00,F
073F8:  BRA    73F6
073FA:  BRA    73FC
073FC:  NOP   
073FE:  BSF    F95.6
07400:  MOVLW  0E
07402:  MOVWF  00
07404:  DECFSZ 00,F
07406:  BRA    7404
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
05EF4:  MOVLW  C0
05EF6:  IORWF  FF2,F
*
0686E:  MOVLW  C0
06870:  IORWF  FF2,F
*
07408:  MOVLW  C0
0740A:  IORWF  FF2,F
.................... #endif 
.................... } 
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
05EF8:  BCF    FF2.6
05EFA:  BCF    FF2.7
05EFC:  BTFSC  FF2.7
05EFE:  BRA    5EFA
*
06872:  BCF    FF2.6
06874:  BCF    FF2.7
06876:  BTFSC  FF2.7
06878:  BRA    6874
*
0721A:  BCF    FF2.6
0721C:  BCF    FF2.7
0721E:  BTFSC  FF2.7
07220:  BRA    721C
....................   #endif 
....................   i2c_start(); 
*
05F00:  BSF    F95.6
05F02:  MOVLW  0E
05F04:  MOVWF  00
05F06:  DECFSZ 00,F
05F08:  BRA    5F06
05F0A:  BSF    F96.1
05F0C:  MOVLW  0E
05F0E:  MOVWF  00
05F10:  DECFSZ 00,F
05F12:  BRA    5F10
05F14:  BCF    F8C.6
05F16:  BCF    F95.6
05F18:  MOVLW  0E
05F1A:  MOVWF  00
05F1C:  DECFSZ 00,F
05F1E:  BRA    5F1C
05F20:  BCF    F8D.1
05F22:  BCF    F96.1
*
0687A:  BSF    F95.6
0687C:  MOVLW  0E
0687E:  MOVWF  00
06880:  DECFSZ 00,F
06882:  BRA    6880
06884:  BSF    F96.1
06886:  MOVLW  0E
06888:  MOVWF  00
0688A:  DECFSZ 00,F
0688C:  BRA    688A
0688E:  BCF    F8C.6
06890:  BCF    F95.6
06892:  MOVLW  0E
06894:  MOVWF  00
06896:  DECFSZ 00,F
06898:  BRA    6896
0689A:  BCF    F8D.1
0689C:  BCF    F96.1
*
07222:  BSF    F95.6
07224:  MOVLW  0E
07226:  MOVWF  00
07228:  DECFSZ 00,F
0722A:  BRA    7228
0722C:  BSF    F96.1
0722E:  MOVLW  0E
07230:  MOVWF  00
07232:  DECFSZ 00,F
07234:  BRA    7232
07236:  BCF    F8C.6
07238:  BCF    F95.6
0723A:  MOVLW  0E
0723C:  MOVWF  00
0723E:  DECFSZ 00,F
07240:  BRA    723E
07242:  BCF    F8D.1
07244:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05F24:  MOVLW  D0
05F26:  MOVLB  9
05F28:  MOVWF  x15
05F2A:  MOVLB  0
05F2C:  RCALL  5A74
*
0689E:  MOVLW  D0
068A0:  MOVLB  9
068A2:  MOVWF  x15
068A4:  MOVLB  0
068A6:  CALL   5A74
*
07246:  MOVLW  D0
07248:  MOVLB  9
0724A:  MOVWF  x15
0724C:  MOVLB  0
0724E:  CALL   5A74
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
*
05F2E:  MOVLB  9
05F30:  CLRF   x15
05F32:  MOVLB  0
05F34:  RCALL  5A74
*
068AA:  MOVLB  9
068AC:  CLRF   x15
068AE:  MOVLB  0
068B0:  CALL   5A74
*
07252:  MOVLB  9
07254:  CLRF   x15
07256:  MOVLB  0
07258:  CALL   5A74
....................   i2c_start();  
*
05F36:  BSF    F95.6
05F38:  MOVLW  0E
05F3A:  MOVWF  00
05F3C:  DECFSZ 00,F
05F3E:  BRA    5F3C
05F40:  BSF    F96.1
05F42:  MOVLW  0E
05F44:  MOVWF  00
05F46:  DECFSZ 00,F
05F48:  BRA    5F46
05F4A:  BTFSS  F84.1
05F4C:  BRA    5F4A
05F4E:  BCF    F8C.6
05F50:  BCF    F95.6
05F52:  MOVLW  0E
05F54:  MOVWF  00
05F56:  DECFSZ 00,F
05F58:  BRA    5F56
05F5A:  BCF    F8D.1
05F5C:  BCF    F96.1
*
068B4:  BSF    F95.6
068B6:  MOVLW  0E
068B8:  MOVWF  00
068BA:  DECFSZ 00,F
068BC:  BRA    68BA
068BE:  BSF    F96.1
068C0:  MOVLW  0E
068C2:  MOVWF  00
068C4:  DECFSZ 00,F
068C6:  BRA    68C4
068C8:  BTFSS  F84.1
068CA:  BRA    68C8
068CC:  BCF    F8C.6
068CE:  BCF    F95.6
068D0:  MOVLW  0E
068D2:  MOVWF  00
068D4:  DECFSZ 00,F
068D6:  BRA    68D4
068D8:  BCF    F8D.1
068DA:  BCF    F96.1
*
0725C:  BSF    F95.6
0725E:  MOVLW  0E
07260:  MOVWF  00
07262:  DECFSZ 00,F
07264:  BRA    7262
07266:  BSF    F96.1
07268:  MOVLW  0E
0726A:  MOVWF  00
0726C:  DECFSZ 00,F
0726E:  BRA    726C
07270:  BTFSS  F84.1
07272:  BRA    7270
07274:  BCF    F8C.6
07276:  BCF    F95.6
07278:  MOVLW  0E
0727A:  MOVWF  00
0727C:  DECFSZ 00,F
0727E:  BRA    727C
07280:  BCF    F8D.1
07282:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05F5E:  MOVLW  D1
05F60:  MOVLB  9
05F62:  MOVWF  x15
05F64:  MOVLB  0
05F66:  RCALL  5A74
*
068DC:  MOVLW  D1
068DE:  MOVLB  9
068E0:  MOVWF  x15
068E2:  MOVLB  0
068E4:  CALL   5A74
*
07284:  MOVLW  D1
07286:  MOVLB  9
07288:  MOVWF  x15
0728A:  MOVLB  0
0728C:  CALL   5A74
....................   sec = bcd2bin(i2c_read() & 0x7f);  
*
05F68:  MOVLW  01
05F6A:  MOVWF  00
05F6C:  RCALL  5AEA
05F6E:  MOVF   01,W
05F70:  ANDLW  7F
05F72:  MOVLB  9
05F74:  MOVWF  x0D
05F76:  MOVWF  x16
05F78:  MOVLB  0
05F7A:  RCALL  5B54
05F7C:  MOVFF  01,275
*
068E8:  MOVLW  01
068EA:  MOVWF  00
068EC:  CALL   5AEA
068F0:  MOVF   01,W
068F2:  ANDLW  7F
068F4:  MOVLB  9
068F6:  MOVWF  x0D
068F8:  MOVWF  x16
068FA:  MOVLB  0
068FC:  CALL   5B54
06900:  MOVFF  01,275
*
07290:  MOVLW  01
07292:  MOVWF  00
07294:  CALL   5AEA
07298:  MOVF   01,W
0729A:  ANDLW  7F
0729C:  MOVLB  9
0729E:  MOVWF  x0D
072A0:  MOVWF  x16
072A2:  MOVLB  0
072A4:  CALL   5B54
072A8:  MOVFF  01,275
....................   min = bcd2bin(i2c_read() & 0x7f);  
*
05F80:  MOVLW  01
05F82:  MOVWF  00
05F84:  RCALL  5AEA
05F86:  MOVF   01,W
05F88:  ANDLW  7F
05F8A:  MOVLB  9
05F8C:  MOVWF  x0D
05F8E:  MOVWF  x16
05F90:  MOVLB  0
05F92:  RCALL  5B54
05F94:  MOVFF  01,274
*
06904:  MOVLW  01
06906:  MOVWF  00
06908:  CALL   5AEA
0690C:  MOVF   01,W
0690E:  ANDLW  7F
06910:  MOVLB  9
06912:  MOVWF  x0D
06914:  MOVWF  x16
06916:  MOVLB  0
06918:  CALL   5B54
0691C:  MOVFF  01,274
*
072AC:  MOVLW  01
072AE:  MOVWF  00
072B0:  CALL   5AEA
072B4:  MOVF   01,W
072B6:  ANDLW  7F
072B8:  MOVLB  9
072BA:  MOVWF  x0D
072BC:  MOVWF  x16
072BE:  MOVLB  0
072C0:  CALL   5B54
072C4:  MOVFF  01,274
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
*
05F98:  CLRF   00
05F9A:  RCALL  5AEA
05F9C:  MOVF   01,W
05F9E:  ANDLW  3F
05FA0:  MOVLB  9
05FA2:  MOVWF  x0D
05FA4:  MOVWF  x16
05FA6:  MOVLB  0
05FA8:  RCALL  5B54
05FAA:  MOVFF  01,273
*
06920:  CLRF   00
06922:  CALL   5AEA
06926:  MOVF   01,W
06928:  ANDLW  3F
0692A:  MOVLB  9
0692C:  MOVWF  x0D
0692E:  MOVWF  x16
06930:  MOVLB  0
06932:  CALL   5B54
06936:  MOVFF  01,273
*
072C8:  CLRF   00
072CA:  CALL   5AEA
072CE:  MOVF   01,W
072D0:  ANDLW  3F
072D2:  MOVLB  9
072D4:  MOVWF  x0D
072D6:  MOVWF  x16
072D8:  MOVLB  0
072DA:  CALL   5B54
072DE:  MOVFF  01,273
....................   i2c_stop();  
*
05FAE:  BCF    F95.6
05FB0:  NOP   
05FB2:  BSF    F96.1
05FB4:  BTFSS  F84.1
05FB6:  BRA    5FB4
05FB8:  MOVLW  0E
05FBA:  MOVWF  00
05FBC:  DECFSZ 00,F
05FBE:  BRA    5FBC
05FC0:  BRA    5FC2
05FC2:  NOP   
05FC4:  BSF    F95.6
05FC6:  MOVLW  0E
05FC8:  MOVWF  00
05FCA:  DECFSZ 00,F
05FCC:  BRA    5FCA
*
0693A:  BCF    F95.6
0693C:  NOP   
0693E:  BSF    F96.1
06940:  BTFSS  F84.1
06942:  BRA    6940
06944:  MOVLW  0E
06946:  MOVWF  00
06948:  DECFSZ 00,F
0694A:  BRA    6948
0694C:  BRA    694E
0694E:  NOP   
06950:  BSF    F95.6
06952:  MOVLW  0E
06954:  MOVWF  00
06956:  DECFSZ 00,F
06958:  BRA    6956
*
072E2:  BCF    F95.6
072E4:  NOP   
072E6:  BSF    F96.1
072E8:  BTFSS  F84.1
072EA:  BRA    72E8
072EC:  MOVLW  0E
072EE:  MOVWF  00
072F0:  DECFSZ 00,F
072F2:  BRA    72F0
072F4:  BRA    72F6
072F6:  NOP   
072F8:  BSF    F95.6
072FA:  MOVLW  0E
072FC:  MOVWF  00
072FE:  DECFSZ 00,F
07300:  BRA    72FE
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
05FCE:  MOVLW  C0
05FD0:  IORWF  FF2,F
*
0695A:  MOVLW  C0
0695C:  IORWF  FF2,F
*
07302:  MOVLW  C0
07304:  IORWF  FF2,F
.................... #endif 
.................... } 
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................  
....................   BYTE temp; 
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
063CE:  MOVFF  910,911
....................   retval = 0;  
063D2:  MOVLB  9
063D4:  CLRF   x12
....................  
....................   while(TRUE)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
063D6:  MOVF   x11,W
063D8:  SUBLW  09
063DA:  BC    63E6
....................     {  
....................       temp -= 10;  
063DC:  MOVLW  0A
063DE:  SUBWF  x11,F
....................       retval += 0x10;  
063E0:  MOVLW  10
063E2:  ADDWF  x12,F
....................     }  
063E4:  BRA    63EC
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
063E6:  MOVF   x11,W
063E8:  ADDWF  x12,F
....................       break;  
063EA:  BRA    63EE
....................     }  
063EC:  BRA    63D6
....................   }  
....................  
....................   return(retval); 
063EE:  MOVFF  912,01
063F2:  MOVLB  0
063F4:  RETURN 0
.................... }  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp; 
....................  
....................   temp = bcd_value;  
*
05B54:  MOVFF  916,917
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
05B58:  BCF    FD8.0
05B5A:  MOVLB  9
05B5C:  RRCF   x17,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
05B5E:  MOVLW  78
05B60:  ANDWF  x17,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
05B62:  RRCF   x17,W
05B64:  MOVWF  00
05B66:  RRCF   00,F
05B68:  MOVLW  3F
05B6A:  ANDWF  00,F
05B6C:  MOVF   00,W
05B6E:  ADDWF  x17,W
05B70:  MOVWF  x18
05B72:  MOVF   x16,W
05B74:  ANDLW  0F
05B76:  ADDWF  x18,W
05B78:  MOVWF  01
05B7A:  MOVLB  0
05B7C:  RETURN 0
.................... } 
....................  
.................... // Entradas. 
.................... #define entrada01 PIN_D4// 
.................... #define entrada02 PIN_B0//DATA1  
.................... #define entrada03 PIN_B1//DATA0 
.................... #define entrada04 PIN_D0// 
.................... #define entrada05 PIN_D1//SENSOR BARRERA 
....................  
.................... // Salidas. 
.................... #define salida01 PIN_A5//abre entrada 
.................... #define salida02 PIN_E0//abre entrada 
.................... #define salida03 PIN_D2//abre salida 
.................... #define salida04 PIN_D3//indicador de cupo lleno 
.................... #define salida05 PIN_D7// 
.................... #define salida06 PIN_C2//indicador de conexion 
.................... // Macros de entrada: 
.................... char texto1[12]= "BOLETO_FOL";// 
.................... char texto2[12]= "BORRARTODO";// 
.................... char texto3[12]= "BORRAR_TAG";// 
.................... char texto4[12]= "ABRIR_ENTR";// 
.................... char texto5[12]= "CUPO_LLENO";//CANCELA BOLETOS 
.................... char texto6[12]= "CUPO_DISPO";//ACTIVA BOLETOS 
.................... char texto7[12]= "MENSAJEEN1";// 
.................... char texto8[12]= "          ";// 
.................... char texto9[12]= "CONSULTA01";// 
.................... char texto10[12]="CONFIGDATE";// 
.................... char texto11[12]="CONFIGURAB";// 
.................... char texto12[12]="BORRA_CON1";// 
.................... char texto13[12]="FOLIORESET";//REINICIAR FOLIOS 
.................... char texto14[12]="PAGADO0000";// 
.................... char boleto[]= "BOLETO"; // 
.................... char barrera[] ="BARRERAABIERTAE1"; 
.................... int fmensaje; 
.................... int16 time_lcd; 
.................... //int en5,flag_pluma; 
....................  
....................  
.................... int flag_time; 
.................... int16 time_bot; 
....................  
.................... // Define el stack usado: ENC28J60. 
.................... #define STACK_USE_CCS_PICENS   1 
.................... // Utilizamos el stack para el protocolo ICPM. 
.................... #define STACK_USE_ICMP  1 
.................... // Utilizamos el stack para el protocolo ARP. 
.................... #define STACK_USE_ARP 1 
.................... // Utilizamos el stack para el protocolo TCP. 
.................... #define STACK_USE_TCP 1 
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... // Definimos los pines utilizados. 
.................... #define  PIN_ENC_MAC_SO    PIN_C4 
.................... #define  PIN_ENC_MAC_SI    PIN_C5 
.................... #define  PIN_ENC_MAC_CLK   PIN_C3 
....................  
.................... #define  PIN_ENC_MAC_CS    PIN_C1 
.................... #define  PIN_ENC_MAC_RST   PIN_C0 
.................... #define  PIN_ENC_MAC_INT   PIN_D2 
.................... #define  PIN_ENC_MAC_WOL   PIN_D3 
....................  
.................... // Incluimos las definiciones necesarias para utilizar el stack TCP/IP. 
.................... #include "tcpip/stacktsk.c"  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_C0 
....................       #define PIN_ENC_MAC_RST PIN_C1 
....................       #define PIN_ENC_MAC_INT PIN_C6 
....................       #define PIN_ENC_MAC_WOL PIN_C7 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................       
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_MCPENC 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
.................... */ 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     35 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05650:  MOVFF  90F,911
05654:  MOVFF  90E,910
05658:  MOVFF  911,03
0565C:  MOVLB  9
0565E:  MOVFF  910,FE9
05662:  MOVFF  03,FEA
05666:  MOVF   FEF,F
05668:  BZ    5676
0566A:  INCF   x10,F
0566C:  BTFSC  FD8.2
0566E:  INCF   x11,F
05670:  MOVLB  0
05672:  BRA    5658
05674:  MOVLB  9
....................    return(sc - s); 
05676:  MOVF   x0E,W
05678:  SUBWF  x10,W
0567A:  MOVWF  00
0567C:  MOVF   x0F,W
0567E:  SUBWFB x11,W
05680:  MOVWF  03
05682:  MOVFF  00,01
05686:  MOVWF  02
05688:  MOVLB  0
0568A:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
010C0:  MOVFF  389,8FF
010C4:  MOVFF  388,8FE
010C8:  MOVFF  387,8FD
010CC:  MOVFF  386,8FC
010D0:  MOVLW  41
010D2:  MOVLB  9
010D4:  MOVWF  x03
010D6:  MOVLW  C6
010D8:  MOVWF  x02
010DA:  MOVLW  4E
010DC:  MOVWF  x01
010DE:  MOVLW  6D
010E0:  MOVWF  x00
010E2:  MOVLB  0
010E4:  BRA    101E
010E6:  MOVLW  39
010E8:  MOVLB  8
010EA:  ADDWF  00,W
010EC:  MOVLB  3
010EE:  MOVWF  x86
010F0:  MOVLW  30
010F2:  MOVLB  8
010F4:  ADDWFC 01,W
010F6:  MOVLB  3
010F8:  MOVWF  x87
010FA:  MOVLW  00
010FC:  MOVLB  8
010FE:  ADDWFC 02,W
01100:  MOVLB  3
01102:  MOVWF  x88
01104:  MOVLW  00
01106:  MOVLB  8
01108:  ADDWFC 03,W
0110A:  MOVLB  3
0110C:  MOVWF  x89
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
0110E:  MOVFF  388,00
01112:  MOVFF  389,01
01116:  CLRF   02
01118:  CLRF   03
0111A:  MOVFF  01,8FE
0111E:  MOVFF  00,8FD
01122:  MOVFF  01,90C
01126:  MOVFF  00,90B
0112A:  MOVLW  7F
0112C:  MOVLB  9
0112E:  MOVWF  x0E
01130:  SETF   x0D
01132:  MOVLB  0
01134:  RCALL  107A
01136:  MOVFF  00,01
0113A:  MOVFF  03,02
0113E:  GOTO   125C (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
0100A:  MOVFF  8FF,389
0100E:  MOVFF  8FE,388
01012:  MOVFF  8FD,387
01016:  MOVFF  8FC,386
0101A:  GOTO   125A (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
017DC:  MOVFF  9A6,9A7
....................     new.v[1]=v.v[0]; 
017E0:  MOVFF  9A5,9A8
....................  
....................     return(new.Val); 
017E4:  MOVLB  9
017E6:  MOVFF  9A7,01
017EA:  MOVFF  9A8,02
017EE:  MOVLB  0
017F0:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
02730:  MOVFF  991,992
....................     new.v[1]=v.v[2]; 
02734:  MOVFF  990,993
....................     new.v[2]=v.v[1]; 
02738:  MOVFF  98F,994
....................     new.v[3]=v.v[0]; 
0273C:  MOVFF  98E,995
....................  
....................     return(new.Val); 
02740:  MOVFF  992,00
02744:  MOVFF  993,01
02748:  MOVFF  994,02
0274C:  MOVFF  995,03
02750:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
0248E:  MOVLB  9
02490:  CLRF   x97
02492:  CLRF   x96
02494:  CLRF   x95
02496:  CLRF   x94
....................  
....................    i = count >> 1; 
02498:  BCF    FD8.0
0249A:  RRCF   x8B,W
0249C:  MOVWF  x8D
0249E:  RRCF   x8A,W
024A0:  MOVWF  x8C
....................    val = (WORD *)buffer; 
024A2:  MOVFF  989,98F
024A6:  MOVFF  988,98E
....................  
....................    while( i-- ) 
024AA:  MOVFF  98D,03
024AE:  MOVF   x8C,W
024B0:  BTFSC  FD8.2
024B2:  DECF   x8D,F
024B4:  DECF   x8C,F
024B6:  IORWF  03,W
024B8:  BZ    24E8
....................       sum.Val += *val++; 
024BA:  MOVFF  98F,03
024BE:  MOVFF  98E,00
024C2:  MOVLW  02
024C4:  ADDWF  x8E,F
024C6:  BTFSC  FD8.0
024C8:  INCF   x8F,F
024CA:  MOVFF  00,FE9
024CE:  MOVFF  03,FEA
024D2:  MOVFF  FEC,03
024D6:  MOVF   FED,F
024D8:  MOVF   FEF,W
024DA:  ADDWF  x94,F
024DC:  MOVF   03,W
024DE:  ADDWFC x95,F
024E0:  MOVLW  00
024E2:  ADDWFC x96,F
024E4:  ADDWFC x97,F
024E6:  BRA    24AA
....................  
....................    if ( count & 1 ) 
024E8:  MOVF   x8A,W
024EA:  ANDLW  01
024EC:  MOVWF  00
024EE:  CLRF   03
024F0:  MOVF   00,W
024F2:  IORWF  03,W
024F4:  BZ    250E
....................       sum.Val += *(BYTE *)val; 
024F6:  MOVFF  98F,03
024FA:  MOVFF  98E,FE9
024FE:  MOVFF  03,FEA
02502:  MOVF   FEF,W
02504:  ADDWF  x94,F
02506:  MOVLW  00
02508:  ADDWFC x95,F
0250A:  ADDWFC x96,F
0250C:  ADDWFC x97,F
....................  
....................    tempSum.Val = sum.Val; 
0250E:  MOVFF  997,993
02512:  MOVFF  996,992
02516:  MOVFF  995,991
0251A:  MOVFF  994,990
....................    i = tempSum.words.MSB.Val; 
0251E:  MOVFF  993,98D
02522:  MOVFF  992,98C
....................  
....................    while( i != 0u ) 
02526:  MOVF   x8C,F
02528:  BNZ   252E
0252A:  MOVF   x8D,F
0252C:  BZ    257C
....................    { 
....................       sum.words.MSB.Val = 0; 
0252E:  CLRF   x97
02530:  CLRF   x96
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
02532:  CLRF   x9B
02534:  CLRF   x9A
02536:  MOVFF  995,999
0253A:  MOVFF  994,998
0253E:  MOVFF  98C,00
02542:  MOVFF  98D,01
02546:  CLRF   02
02548:  CLRF   03
0254A:  MOVF   00,W
0254C:  ADDWF  x94,W
0254E:  MOVWF  x94
02550:  MOVF   01,W
02552:  ADDWFC x95,W
02554:  MOVWF  x95
02556:  MOVF   02,W
02558:  ADDWFC x9A,W
0255A:  MOVWF  x96
0255C:  MOVF   03,W
0255E:  ADDWFC x9B,W
02560:  MOVWF  x97
....................       tempSum.Val = sum.Val; 
02562:  MOVFF  997,993
02566:  MOVFF  996,992
0256A:  MOVFF  995,991
0256E:  MOVFF  994,990
....................       i = tempSum.words.MSB.Val; 
02572:  MOVFF  993,98D
02576:  MOVFF  992,98C
0257A:  BRA    2526
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
0257C:  MOVFF  995,03
02580:  COMF   03,F
02582:  MOVF   x94,W
02584:  XORLW  FF
02586:  MOVWF  01
02588:  MOVFF  03,02
0258C:  MOVLB  0
0258E:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
00ACC:  MOVLW  83
00ACE:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
00AD0:  MOVLW  34
00AD2:  MOVWF  FD7
00AD4:  MOVLW  8C
00AD6:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
00AD8:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
00ADA:  MOVLW  C0
00ADC:  IORWF  FF2,F
00ADE:  GOTO   129C (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
02B2E:  BCF    FF2.5
....................     ret=TickCount; 
02B30:  MOVFF  38C,94D
02B34:  MOVFF  38B,94C
....................     enable_interrupts(INT_TIMER0); 
02B38:  BSF    FF2.5
....................     return ret; 
02B3A:  MOVLB  9
02B3C:  MOVFF  94C,01
02B40:  MOVFF  94D,02
02B44:  MOVLB  0
02B46:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00106:  MOVLB  3
00108:  INCF   x8B,F
0010A:  BTFSC  FD8.2
0010C:  INCF   x8C,F
....................  
....................         second_counter_intermediate++; 
0010E:  INCF   x8E,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00110:  MOVF   x8E,W
00112:  SUBLW  0B
00114:  BC    011A
....................             second_counter++; //increment this ever 1s 
00116:  INCF   x8D,F
....................             second_counter_intermediate=0; 
00118:  CLRF   x8E
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
0011A:  MOVLW  34
0011C:  MOVWF  FD7
0011E:  MOVLW  8C
00120:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
.................... /* 
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
.................... */  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
00122:  BCF    FF2.2
00124:  MOVLB  0
00126:  GOTO   0084
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
00AE2:  BCF    F94.3
00AE4:  BCF    F8B.3
....................    output_float(PIN_ENC_MAC_SO); 
00AE6:  BSF    F94.4
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
00AE8:  BCF    F94.1
00AEA:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00AEC:  BCF    F94.0
00AEE:  BSF    F8B.0
00AF0:  GOTO   0DF0 (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
00AF4:  MOVLB  9
00AF6:  CLRF   xB1
00AF8:  MOVF   xB1,W
00AFA:  SUBLW  07
00AFC:  BNC   0B26
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
00AFE:  BCF    FD8.0
00B00:  RLCF   xB0,F
00B02:  BC    0B08
00B04:  BCF    F8B.5
00B06:  BRA    0B0A
00B08:  BSF    F8B.5
00B0A:  BCF    F94.5
....................       output_high(PIN_ENC_MAC_CLK); 
00B0C:  BCF    F94.3
00B0E:  BSF    F8B.3
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
00B10:  BSF    F94.4
00B12:  BTFSC  F82.4
00B14:  BRA    0B1A
00B16:  BCF    FD8.0
00B18:  BRA    0B1C
00B1A:  BSF    FD8.0
00B1C:  RLCF   xB2,F
....................       output_low(PIN_ENC_MAC_CLK); 
00B1E:  BCF    F94.3
00B20:  BCF    F8B.3
00B22:  INCF   xB1,F
00B24:  BRA    0AF8
....................    } 
....................    return(in); 
00B26:  MOVFF  9B2,01
....................  #endif 
00B2A:  MOVLB  0
00B2C:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
00DEE:  BRA    0AE2
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
00DF0:  MOVLW  1D
00DF2:  MOVLB  9
00DF4:  MOVWF  xA5
00DF6:  MOVLB  0
00DF8:  RCALL  0B2E
00DFA:  MOVFF  01,8F9
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00DFE:  MOVLB  8
00E00:  BTFSS  xF9.3
00E02:  BRA    0E08
00E04:  MOVLB  0
00E06:  BRA    0DF0
00E08:  MOVF   xF9,W
00E0A:  XORLW  FF
00E0C:  ANDLW  01
00E0E:  BTFSC  FD8.2
00E10:  BRA    0E16
00E12:  MOVLB  0
00E14:  BRA    0DF0
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
00E16:  MOVLB  0
00E18:  BRA    0B58
....................     delay_ms(1); 
00E1A:  MOVLW  01
00E1C:  MOVLB  9
00E1E:  MOVWF  x00
00E20:  MOVLB  0
00E22:  CALL   05E4
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
00E26:  MOVLB  3
00E28:  CLRF   x8A
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
00E2A:  BSF    x93.0
....................    NextPacketLocation.Val = RXSTART; 
00E2C:  CLRF   x90
00E2E:  CLRF   x8F
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
00E30:  MOVLW  08
00E32:  MOVLB  9
00E34:  MOVWF  xAB
00E36:  CLRF   xAC
00E38:  MOVLB  0
00E3A:  RCALL  0B6C
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
00E3C:  MOVLW  09
00E3E:  MOVLB  9
00E40:  MOVWF  xAB
00E42:  CLRF   xAC
00E44:  MOVLB  0
00E46:  RCALL  0B6C
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
00E48:  MOVLW  0C
00E4A:  MOVLB  9
00E4C:  MOVWF  xAB
00E4E:  MOVLW  F7
00E50:  MOVWF  xAC
00E52:  MOVLB  0
00E54:  RCALL  0B6C
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00E56:  MOVLW  0D
00E58:  MOVLB  9
00E5A:  MOVWF  xAB
00E5C:  MOVLW  1B
00E5E:  MOVWF  xAC
00E60:  MOVLB  0
00E62:  RCALL  0B6C
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
00E64:  MOVLW  0A
00E66:  MOVLB  9
00E68:  MOVWF  xAB
00E6A:  MOVLW  F7
00E6C:  MOVWF  xAC
00E6E:  MOVLB  0
00E70:  RCALL  0B6C
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
00E72:  MOVLW  0B
00E74:  MOVLB  9
00E76:  MOVWF  xAB
00E78:  MOVLW  1B
00E7A:  MOVWF  xAC
00E7C:  MOVLB  0
00E7E:  RCALL  0B6C
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
00E80:  MOVLW  04
00E82:  MOVLB  9
00E84:  MOVWF  xAB
00E86:  MOVLW  F8
00E88:  MOVWF  xAC
00E8A:  MOVLB  0
00E8C:  RCALL  0B6C
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
00E8E:  MOVLW  05
00E90:  MOVLB  9
00E92:  MOVWF  xAB
00E94:  MOVLW  1B
00E96:  MOVWF  xAC
00E98:  MOVLB  0
00E9A:  RCALL  0B6C
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
00E9C:  MOVLW  02
00E9E:  MOVLB  9
00EA0:  MOVWF  xA9
00EA2:  CLRF   xA8
00EA4:  MOVLB  0
00EA6:  RCALL  0BC6
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00EA8:  MOVLB  9
00EAA:  CLRF   xAB
00EAC:  MOVLW  0D
00EAE:  MOVWF  xAC
00EB0:  MOVLB  0
00EB2:  RCALL  0B6C
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00EB4:  MOVLW  02
00EB6:  MOVLB  9
00EB8:  MOVWF  xAB
00EBA:  MOVLW  32
00EBC:  MOVWF  xAC
00EBE:  MOVLB  0
00EC0:  RCALL  0B6C
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00EC2:  MOVLW  03
00EC4:  MOVLB  9
00EC6:  MOVWF  xAB
00EC8:  MOVLW  40
00ECA:  MOVWF  xAC
00ECC:  MOVLB  0
00ECE:  RCALL  0B6C
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00ED0:  MOVLW  09
00ED2:  MOVLB  9
00ED4:  MOVWF  xAB
00ED6:  MOVLW  3F
00ED8:  MOVWF  xAC
00EDA:  MOVLB  0
00EDC:  RCALL  0B6C
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
00EDE:  MOVLW  06
00EE0:  MOVLB  9
00EE2:  MOVWF  xAB
00EE4:  MOVLW  12
00EE6:  MOVWF  xAC
00EE8:  MOVLB  0
00EEA:  RCALL  0B6C
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
00EEC:  MOVLW  07
00EEE:  MOVLB  9
00EF0:  MOVWF  xAB
00EF2:  MOVLW  0C
00EF4:  MOVWF  xAC
00EF6:  MOVLB  0
00EF8:  RCALL  0B6C
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
00EFA:  MOVLW  0A
00EFC:  MOVLB  9
00EFE:  MOVWF  xAB
00F00:  MOVLW  EE
00F02:  MOVWF  xAC
00F04:  MOVLB  0
00F06:  RCALL  0B6C
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
00F08:  MOVLW  0B
00F0A:  MOVLB  9
00F0C:  MOVWF  xAB
00F0E:  MOVLW  05
00F10:  MOVWF  xAC
00F12:  MOVLB  0
00F14:  RCALL  0B6C
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
00F16:  MOVLW  03
00F18:  MOVLB  9
00F1A:  MOVWF  xA9
00F1C:  MOVLW  04
00F1E:  MOVWF  xA8
00F20:  MOVLB  0
00F22:  RCALL  0BC6
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00F24:  MOVLW  04
00F26:  MOVLB  9
00F28:  MOVWF  xAB
00F2A:  MOVFF  357,9AC
00F2E:  MOVLB  0
00F30:  RCALL  0B6C
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00F32:  MOVLW  05
00F34:  MOVLB  9
00F36:  MOVWF  xAB
00F38:  MOVFF  358,9AC
00F3C:  MOVLB  0
00F3E:  RCALL  0B6C
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00F40:  MOVLW  02
00F42:  MOVLB  9
00F44:  MOVWF  xAB
00F46:  MOVFF  359,9AC
00F4A:  MOVLB  0
00F4C:  RCALL  0B6C
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00F4E:  MOVLW  03
00F50:  MOVLB  9
00F52:  MOVWF  xAB
00F54:  MOVFF  35A,9AC
00F58:  MOVLB  0
00F5A:  RCALL  0B6C
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00F5C:  MOVLB  9
00F5E:  CLRF   xAB
00F60:  MOVFF  35B,9AC
00F64:  MOVLB  0
00F66:  RCALL  0B6C
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00F68:  MOVLW  01
00F6A:  MOVLB  9
00F6C:  MOVWF  xAB
00F6E:  MOVFF  35C,9AC
00F72:  MOVLB  0
00F74:  RCALL  0B6C
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00F76:  MOVLW  12
00F78:  MOVLB  9
00F7A:  MOVWF  xA5
00F7C:  MOVLB  0
00F7E:  RCALL  0B2E
00F80:  MOVFF  01,394
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00F84:  MOVLW  10
00F86:  MOVLB  8
00F88:  MOVWF  xFE
00F8A:  MOVLW  01
00F8C:  MOVLB  9
00F8E:  MOVWF  x00
00F90:  MOVLB  8
00F92:  CLRF   xFF
00F94:  MOVLB  0
00F96:  RCALL  0C2A
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
00F98:  MOVLW  14
00F9A:  MOVLB  8
00F9C:  MOVWF  xFE
00F9E:  MOVLW  04
00FA0:  MOVLB  9
00FA2:  MOVWF  x00
00FA4:  MOVLW  72
00FA6:  MOVLB  8
00FA8:  MOVWF  xFF
00FAA:  MOVLB  0
00FAC:  RCALL  0C2A
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
00FAE:  MOVLB  8
00FB0:  CLRF   xFA
00FB2:  MOVLB  0
00FB4:  BRA    0D4C
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
00FB6:  MOVLW  1F
00FB8:  MOVLB  9
00FBA:  MOVWF  xAD
00FBC:  MOVLW  04
00FBE:  MOVWF  xAE
00FC0:  MOVLB  0
00FC2:  RCALL  0BA8
00FC4:  GOTO   129E (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
06B08:  MOVLW  01
06B0A:  MOVLB  8
06B0C:  MOVWF  xFE
06B0E:  MOVLB  0
06B10:  CALL   0CB2
06B14:  MOVFF  01,8F9
06B18:  MOVLW  00
06B1A:  MOVLB  8
06B1C:  BTFSC  01.2
06B1E:  MOVLW  01
06B20:  MOVWF  01
06B22:  MOVLB  0
06B24:  GOTO   766A (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
02C46:  MOVLW  1F
02C48:  MOVLB  9
02C4A:  MOVWF  xA5
02C4C:  MOVLB  0
02C4E:  CALL   0B2E
02C52:  MOVFF  01,987
02C56:  MOVLW  00
02C58:  MOVLB  9
02C5A:  BTFSC  01.3
02C5C:  MOVLW  01
02C5E:  XORLW  00
02C60:  BZ    2C66
02C62:  MOVLW  00
02C64:  BRA    2C68
02C66:  MOVLW  01
02C68:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
02C6A:  MOVLB  0
02C6C:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
01AF8:  MOVLW  1F
01AFA:  MOVLB  9
01AFC:  MOVWF  xA5
01AFE:  MOVLB  0
01B00:  CALL   0B2E
01B04:  MOVFF  01,987
01B08:  MOVLW  00
01B0A:  MOVLB  9
01B0C:  BTFSC  01.3
01B0E:  MOVLW  01
01B10:  XORLW  00
01B12:  BNZ   1B18
01B14:  MOVLW  00
01B16:  BRA    1B1A
01B18:  MOVLW  FF
01B1A:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
01B1C:  MOVLB  0
01B1E:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
01706:  MOVLB  3
01708:  BTFSS  x93.0
0170A:  BRA    170E
....................       return; 
0170C:  BRA    1778
....................    WasDiscarded = TRUE; 
0170E:  BSF    x93.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
01710:  MOVLW  01
01712:  SUBWF  x8F,W
01714:  MOVLB  9
01716:  MOVWF  x4C
01718:  MOVLW  00
0171A:  MOVLB  3
0171C:  SUBWFB x90,W
0171E:  MOVLB  9
01720:  MOVWF  x4D
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
01722:  MOVF   x4D,W
01724:  SUBLW  1A
01726:  BC    173A
01728:  XORLW  FF
0172A:  BNZ   1732
0172C:  MOVF   x4C,W
0172E:  SUBLW  F7
01730:  BC    173A
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
01732:  MOVLW  1B
01734:  MOVWF  x4D
01736:  MOVLW  F7
01738:  MOVWF  x4C
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
0173A:  MOVLW  1E
0173C:  MOVWF  xAD
0173E:  MOVLW  40
01740:  MOVWF  xAE
01742:  MOVLB  0
01744:  CALL   0BA8
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
01748:  MOVLB  9
0174A:  CLRF   xA9
0174C:  MOVLW  0C
0174E:  MOVWF  xA8
01750:  MOVLB  0
01752:  CALL   0BC6
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
01756:  MOVLW  0C
01758:  MOVLB  9
0175A:  MOVWF  xAB
0175C:  MOVFF  94C,9AC
01760:  MOVLB  0
01762:  CALL   0B6C
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
01766:  MOVLW  0D
01768:  MOVLB  9
0176A:  MOVWF  xAB
0176C:  MOVFF  94D,9AC
01770:  MOVLB  0
01772:  CALL   0B6C
01776:  MOVLB  3
01778:  MOVLB  0
0177A:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
02C6E:  MOVLW  01
02C70:  MOVLB  9
02C72:  MOVWF  xA9
02C74:  MOVLW  19
02C76:  MOVWF  xA8
02C78:  MOVLB  0
02C7A:  CALL   0BC6
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
02C7E:  MOVLW  19
02C80:  MOVLB  9
02C82:  MOVWF  xA5
02C84:  MOVLB  0
02C86:  CALL   0B2E
02C8A:  MOVFF  01,986
....................  
....................       BankSel(ERXWRPTL); 
02C8E:  MOVLB  9
02C90:  CLRF   xA9
02C92:  MOVLW  0E
02C94:  MOVWF  xA8
02C96:  MOVLB  0
02C98:  CALL   0BC6
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
02C9C:  MOVLW  0E
02C9E:  MOVLB  9
02CA0:  MOVWF  xA5
02CA2:  MOVLB  0
02CA4:  CALL   0B2E
02CA8:  MOVFF  01,988
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
02CAC:  MOVLW  0F
02CAE:  MOVLB  9
02CB0:  MOVWF  xA5
02CB2:  MOVLB  0
02CB4:  CALL   0B2E
02CB8:  MOVFF  01,989
....................  
....................       BankSel(EPKTCNT); 
02CBC:  MOVLW  01
02CBE:  MOVLB  9
02CC0:  MOVWF  xA9
02CC2:  MOVLW  19
02CC4:  MOVWF  xA8
02CC6:  MOVLB  0
02CC8:  CALL   0BC6
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
02CCC:  MOVLW  19
02CCE:  MOVLB  9
02CD0:  MOVWF  xA5
02CD2:  MOVLB  0
02CD4:  CALL   0B2E
02CD8:  MOVFF  01,98A
02CDC:  MOVLB  9
02CDE:  MOVF   x86,W
02CE0:  SUBWF  01,W
02CE2:  BTFSC  FD8.2
02CE4:  BRA    2CEA
02CE6:  MOVLB  0
02CE8:  BRA    2C7E
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
02CEA:  CLRF   xA9
02CEC:  MOVLW  0C
02CEE:  MOVWF  xA8
02CF0:  MOVLB  0
02CF2:  CALL   0BC6
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
02CF6:  MOVLW  0C
02CF8:  MOVLB  9
02CFA:  MOVWF  xA5
02CFC:  MOVLB  0
02CFE:  CALL   0B2E
02D02:  MOVFF  01,986
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
02D06:  MOVLW  0D
02D08:  MOVLB  9
02D0A:  MOVWF  xA5
02D0C:  MOVLB  0
02D0E:  CALL   0B2E
02D12:  MOVFF  01,987
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
02D16:  MOVLB  9
02D18:  MOVF   x87,W
02D1A:  SUBWF  x89,W
02D1C:  BNC   2D4A
02D1E:  BNZ   2D26
02D20:  MOVF   x88,W
02D22:  SUBWF  x86,W
02D24:  BC    2D4A
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
02D26:  MOVF   x86,W
02D28:  SUBWF  x88,W
02D2A:  MOVWF  00
02D2C:  MOVF   x87,W
02D2E:  SUBWFB x89,W
02D30:  MOVWF  03
02D32:  MOVF   00,W
02D34:  XORLW  FF
02D36:  ADDLW  F8
02D38:  MOVWF  00
02D3A:  MOVLW  1B
02D3C:  SUBFWB 03,F
02D3E:  MOVFF  00,01
02D42:  MOVFF  03,02
02D46:  BRA    2D80
....................    } 
02D48:  BRA    2D80
....................    else if ( WritePT.Val == ReadPT.Val ) 
02D4A:  MOVF   x86,W
02D4C:  SUBWF  x88,W
02D4E:  BNZ   2D62
02D50:  MOVF   x87,W
02D52:  SUBWF  x89,W
02D54:  BNZ   2D62
....................    { 
....................       return RXSIZE - 1; 
02D56:  MOVLW  F7
02D58:  MOVWF  01
02D5A:  MOVLW  1B
02D5C:  MOVWF  02
02D5E:  BRA    2D80
....................    } 
02D60:  BRA    2D80
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
02D62:  MOVF   x88,W
02D64:  SUBWF  x86,W
02D66:  MOVWF  x8A
02D68:  MOVF   x89,W
02D6A:  SUBWFB x87,W
02D6C:  MOVWF  x8B
02D6E:  MOVLW  01
02D70:  SUBWF  x8A,W
02D72:  MOVWF  00
02D74:  MOVLW  00
02D76:  SUBWFB x8B,W
02D78:  MOVWF  03
02D7A:  MOVFF  00,01
02D7E:  MOVWF  02
....................    } 
02D80:  MOVLB  0
02D82:  GOTO   3004 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
017F2:  MOVLW  01
017F4:  MOVLB  9
017F6:  MOVWF  xA9
017F8:  MOVLW  19
017FA:  MOVWF  xA8
017FC:  MOVLB  0
017FE:  CALL   0BC6
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
01802:  MOVLW  19
01804:  MOVLB  9
01806:  MOVWF  xA5
01808:  MOVLB  0
0180A:  CALL   0B2E
0180E:  MOVFF  01,917
01812:  MOVLB  9
01814:  MOVF   x17,F
01816:  BNZ   181E
....................       return FALSE; 
01818:  MOVLW  00
0181A:  MOVWF  01
0181C:  BRA    193E
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
0181E:  MOVLB  3
01820:  BTFSC  x93.0
01822:  BRA    1832
....................    { 
....................       MACDiscardRx(); 
01824:  MOVLB  0
01826:  RCALL  1706
....................       return FALSE; 
01828:  MOVLW  00
0182A:  MOVWF  01
0182C:  MOVLB  9
0182E:  BRA    193E
01830:  MOVLB  3
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
01832:  MOVFF  390,392
01836:  MOVFF  38F,391
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
0183A:  MOVLB  9
0183C:  CLRF   xA9
0183E:  CLRF   xA8
01840:  MOVLB  0
01842:  CALL   0BC6
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
01846:  MOVLB  9
01848:  CLRF   xAB
0184A:  MOVFF  38F,9AC
0184E:  MOVLB  0
01850:  CALL   0B6C
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
01854:  MOVLW  01
01856:  MOVLB  9
01858:  MOVWF  xAB
0185A:  MOVFF  390,9AC
0185E:  MOVLB  0
01860:  CALL   0B6C
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
01864:  MOVLW  09
01866:  MOVLB  9
01868:  MOVWF  x18
0186A:  MOVLW  03
0186C:  MOVWF  x17
0186E:  MOVFF  918,995
01872:  MOVWF  x94
01874:  CLRF   x97
01876:  MOVLW  14
01878:  MOVWF  x96
0187A:  MOVLB  0
0187C:  RCALL  177C
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
0187E:  MOVFF  916,9A6
01882:  MOVFF  915,9A5
01886:  RCALL  17DC
01888:  MOVFF  02,916
0188C:  MOVFF  01,915
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
01890:  MOVLB  9
01892:  MOVF   x04,W
01894:  SUBLW  1A
01896:  BC    18A2
01898:  XORLW  FF
0189A:  BNZ   18CE
0189C:  MOVF   x03,W
0189E:  SUBLW  F7
018A0:  BNC   18CE
018A2:  MOVLW  09
018A4:  MOVWF  x18
018A6:  MOVLW  03
018A8:  MOVWF  FE9
018AA:  MOVFF  918,FEA
018AE:  BTFSC  FEF.0
018B0:  BRA    18CE
018B2:  BTFSC  x08.7
018B4:  BRA    18CE
018B6:  BTFSC  x07.4
018B8:  BRA    18CE
018BA:  MOVF   x06,W
018BC:  SUBLW  04
018BE:  BC    18CA
018C0:  XORLW  FF
018C2:  BNZ   18CE
018C4:  MOVF   x05,W
018C6:  SUBLW  EE
018C8:  BNC   18CE
018CA:  BTFSC  x07.7
018CC:  BRA    18D0
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
018CE:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
018D0:  MOVFF  904,390
018D4:  MOVFF  903,38F
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
018D8:  MOVFF  8FF,01
018DC:  MOVLB  9
018DE:  MOVFF  900,03
018E2:  MOVFF  01,917
018E6:  MOVFF  03,918
018EA:  MOVFF  03,FEA
018EE:  MOVFF  01,FE9
018F2:  MOVLW  09
018F4:  MOVWF  FE2
018F6:  MOVLW  0F
018F8:  MOVWF  FE1
018FA:  MOVLW  06
018FC:  MOVWF  01
018FE:  MOVFF  FE6,FEE
01902:  DECFSZ 01,F
01904:  BRA    18FE
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
01906:  MOVFF  902,03
0190A:  MOVFF  901,FE9
0190E:  MOVFF  03,FEA
01912:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
01914:  MOVF   x16,W
01916:  SUBLW  08
01918:  BNZ   1934
0191A:  MOVF   x15,F
0191C:  BZ    1924
0191E:  MOVF   x15,W
01920:  SUBLW  06
01922:  BNZ   1934
....................     { 
....................        *type = header.Type.v[0]; 
01924:  MOVFF  902,03
01928:  MOVFF  901,FE9
0192C:  MOVFF  03,FEA
01930:  MOVFF  915,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
01934:  MOVLB  3
01936:  BCF    x93.0
....................    return TRUE; 
01938:  MOVLW  01
0193A:  MOVWF  01
0193C:  MOVLB  9
0193E:  MOVLB  0
01940:  GOTO   44DA (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
01C26:  MOVLB  9
01C28:  CLRF   xA9
01C2A:  MOVLW  02
01C2C:  MOVWF  xA8
01C2E:  MOVLB  0
01C30:  CALL   0BC6
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
01C34:  MOVLW  02
01C36:  MOVLB  9
01C38:  MOVWF  xAB
01C3A:  MOVLW  F8
01C3C:  MOVWF  xAC
01C3E:  MOVLB  0
01C40:  CALL   0B6C
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
01C44:  MOVLW  03
01C46:  MOVLB  9
01C48:  MOVWF  xAB
01C4A:  MOVLW  1B
01C4C:  MOVWF  xAC
01C4E:  MOVLB  0
01C50:  CALL   0B6C
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C54:  MOVLW  06
01C56:  MOVLB  9
01C58:  ADDWF  xA6,F
01C5A:  MOVLW  1C
01C5C:  ADDWFC xA7,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C5E:  MOVLW  09
01C60:  MOVWF  xA9
01C62:  MOVLW  A6
01C64:  MOVWF  xA8
01C66:  MOVWF  FE9
01C68:  MOVFF  9A9,FEA
01C6C:  MOVFF  FEF,9AC
01C70:  MOVLW  06
01C72:  MOVWF  xAB
01C74:  MOVLB  0
01C76:  CALL   0B6C
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01C7A:  MOVLW  09
01C7C:  MOVLB  9
01C7E:  MOVWF  xA9
01C80:  MOVLW  A6
01C82:  MOVWF  xA8
01C84:  MOVLW  01
01C86:  ADDWF  xA8,W
01C88:  MOVWF  FE9
01C8A:  MOVLW  00
01C8C:  ADDWFC xA9,W
01C8E:  MOVWF  FEA
01C90:  MOVFF  FEF,9AC
01C94:  MOVLW  07
01C96:  MOVWF  xAB
01C98:  MOVLB  0
01C9A:  CALL   0B6C
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
01C9E:  MOVLB  9
01CA0:  CLRF   xAA
01CA2:  MOVLB  0
01CA4:  RCALL  1BBE
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01CA6:  MOVFF  9A4,9AB
01CAA:  MOVFF  9A3,9AA
01CAE:  MOVLB  9
01CB0:  CLRF   xAD
01CB2:  MOVLW  06
01CB4:  MOVWF  xAC
01CB6:  MOVLB  0
01CB8:  RCALL  1BDC
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01CBA:  MOVLW  03
01CBC:  MOVLB  9
01CBE:  MOVWF  xA9
01CC0:  MOVLW  57
01CC2:  MOVWF  xA8
01CC4:  MOVFF  9A9,9AB
01CC8:  MOVWF  xAA
01CCA:  CLRF   xAD
01CCC:  MOVLW  06
01CCE:  MOVWF  xAC
01CD0:  MOVLB  0
01CD2:  RCALL  1BDC
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01CD4:  MOVLW  08
01CD6:  MOVLB  9
01CD8:  MOVWF  xAA
01CDA:  MOVLB  0
01CDC:  RCALL  1BBE
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01CDE:  MOVLB  9
01CE0:  MOVF   xA5,F
01CE2:  BNZ   1CEA
01CE4:  CLRF   03
01CE6:  MOVLW  00
01CE8:  BRA    1CEE
01CEA:  CLRF   03
01CEC:  MOVLW  06
01CEE:  MOVWF  xA8
01CF0:  MOVFF  03,9A9
01CF4:  MOVWF  xAA
01CF6:  MOVLB  0
01CF8:  RCALL  1BBE
01CFA:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
01CFC:  MOVLW  1C
01CFE:  MOVLB  9
01D00:  MOVWF  xA5
01D02:  MOVLB  0
01D04:  CALL   0B2E
01D08:  MOVFF  01,992
01D0C:  MOVLW  00
01D0E:  MOVLB  9
01D10:  BTFSC  01.1
01D12:  MOVLW  01
01D14:  XORLW  00
01D16:  BZ    1D38
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
01D18:  MOVLW  1F
01D1A:  MOVWF  xAD
01D1C:  MOVLW  80
01D1E:  MOVWF  xAE
01D20:  MOVLB  0
01D22:  CALL   0BA8
....................       BFCReg(ECON1, ECON1_TXRST); 
01D26:  MOVLW  1F
01D28:  MOVLB  9
01D2A:  MOVWF  xAA
01D2C:  MOVLW  80
01D2E:  MOVWF  xAB
01D30:  MOVLB  0
01D32:  CALL   0B8A
01D36:  MOVLB  9
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01D38:  MOVLW  1C
01D3A:  MOVWF  xAA
01D3C:  MOVLW  0A
01D3E:  MOVWF  xAB
01D40:  MOVLB  0
01D42:  CALL   0B8A
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
01D46:  MOVLW  1F
01D48:  MOVLB  9
01D4A:  MOVWF  xAD
01D4C:  MOVLW  08
01D4E:  MOVWF  xAE
01D50:  MOVLB  0
01D52:  CALL   0BA8
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
01D56:  MOVLB  3
01D58:  MOVF   x94,W
01D5A:  SUBLW  05
01D5C:  BTFSS  FD8.2
01D5E:  BRA    1F28
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01D60:  MOVLW  1C
01D62:  MOVLB  9
01D64:  MOVWF  xA5
01D66:  MOVLB  0
01D68:  CALL   0B2E
01D6C:  MOVFF  01,992
01D70:  MOVLB  9
01D72:  MOVF   01,W
01D74:  ANDLW  0A
01D76:  BTFSS  FD8.2
01D78:  BRA    1D7E
01D7A:  MOVLB  3
01D7C:  BRA    1D60
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
01D7E:  MOVLW  1C
01D80:  MOVWF  xA5
01D82:  MOVLB  0
01D84:  CALL   0B2E
01D88:  MOVFF  01,992
01D8C:  MOVLW  00
01D8E:  MOVLB  9
01D90:  BTFSC  01.1
01D92:  MOVLW  01
01D94:  XORLW  00
01D96:  BTFSC  FD8.2
01D98:  BRA    1F26
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
01D9A:  MOVLW  1F
01D9C:  MOVWF  xAA
01D9E:  MOVLW  08
01DA0:  MOVWF  xAB
01DA2:  MOVLB  0
01DA4:  CALL   0B8A
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
01DA8:  MOVLB  9
01DAA:  CLRF   xA9
01DAC:  CLRF   xA8
01DAE:  MOVLB  0
01DB0:  CALL   0BC6
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01DB4:  MOVLB  9
01DB6:  CLRF   xA5
01DB8:  MOVLB  0
01DBA:  CALL   0B2E
01DBE:  MOVFF  01,986
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01DC2:  MOVLW  01
01DC4:  MOVLB  9
01DC6:  MOVWF  xA5
01DC8:  MOVLB  0
01DCA:  CALL   0B2E
01DCE:  MOVFF  01,987
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01DD2:  MOVLW  06
01DD4:  MOVLB  9
01DD6:  MOVWF  xA5
01DD8:  MOVLB  0
01DDA:  CALL   0B2E
01DDE:  MOVFF  01,988
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01DE2:  MOVLW  07
01DE4:  MOVLB  9
01DE6:  MOVWF  xA5
01DE8:  MOVLB  0
01DEA:  CALL   0B2E
01DEE:  MOVFF  01,989
....................          TXEnd.Val++; 
01DF2:  MOVLB  9
01DF4:  INCF   x88,F
01DF6:  BTFSC  FD8.2
01DF8:  INCF   x89,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
01DFA:  CLRF   xAB
01DFC:  MOVFF  988,9AC
01E00:  MOVLB  0
01E02:  CALL   0B6C
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
01E06:  MOVLW  01
01E08:  MOVLB  9
01E0A:  MOVWF  xAB
01E0C:  MOVFF  989,9AC
01E10:  MOVLB  0
01E12:  CALL   0B6C
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01E16:  MOVLW  09
01E18:  MOVLB  9
01E1A:  MOVWF  x93
01E1C:  MOVLW  8A
01E1E:  MOVWF  x92
01E20:  MOVFF  993,995
01E24:  MOVWF  x94
01E26:  CLRF   x97
01E28:  MOVLW  07
01E2A:  MOVWF  x96
01E2C:  MOVLB  0
01E2E:  RCALL  177C
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
01E30:  MOVLB  9
01E32:  CLRF   x91
01E34:  MOVF   x91,W
01E36:  SUBLW  0F
01E38:  BNC   1F08
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01E3A:  MOVLW  1C
01E3C:  MOVWF  xA5
01E3E:  MOVLB  0
01E40:  CALL   0B2E
01E44:  MOVFF  01,992
01E48:  MOVLW  00
01E4A:  MOVLB  9
01E4C:  BTFSC  01.1
01E4E:  MOVLW  01
01E50:  XORLW  00
01E52:  BZ    1EFE
01E54:  BTFSS  x8D.5
01E56:  BRA    1EFE
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
01E58:  MOVLW  1F
01E5A:  MOVWF  xAD
01E5C:  MOVLW  80
01E5E:  MOVWF  xAE
01E60:  MOVLB  0
01E62:  CALL   0BA8
....................                BFCReg(ECON1, ECON1_TXRST); 
01E66:  MOVLW  1F
01E68:  MOVLB  9
01E6A:  MOVWF  xAA
01E6C:  MOVLW  80
01E6E:  MOVWF  xAB
01E70:  MOVLB  0
01E72:  CALL   0B8A
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01E76:  MOVLW  1C
01E78:  MOVLB  9
01E7A:  MOVWF  xAA
01E7C:  MOVLW  0A
01E7E:  MOVWF  xAB
01E80:  MOVLB  0
01E82:  CALL   0B8A
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
01E86:  MOVLW  1F
01E88:  MOVLB  9
01E8A:  MOVWF  xAD
01E8C:  MOVLW  08
01E8E:  MOVWF  xAE
01E90:  MOVLB  0
01E92:  CALL   0BA8
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01E96:  MOVLW  1C
01E98:  MOVLB  9
01E9A:  MOVWF  xA5
01E9C:  MOVLB  0
01E9E:  CALL   0B2E
01EA2:  MOVFF  01,992
01EA6:  MOVLB  9
01EA8:  MOVF   01,W
01EAA:  ANDLW  0A
01EAC:  BTFSS  FD8.2
01EAE:  BRA    1EB4
01EB0:  MOVLB  0
01EB2:  BRA    1E96
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
01EB4:  MOVLW  1F
01EB6:  MOVWF  xAA
01EB8:  MOVLW  08
01EBA:  MOVWF  xAB
01EBC:  MOVLB  0
01EBE:  CALL   0B8A
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
01EC2:  MOVLB  9
01EC4:  CLRF   xAB
01EC6:  MOVFF  988,9AC
01ECA:  MOVLB  0
01ECC:  CALL   0B6C
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
01ED0:  MOVLW  01
01ED2:  MOVLB  9
01ED4:  MOVWF  xAB
01ED6:  MOVFF  989,9AC
01EDA:  MOVLB  0
01EDC:  CALL   0B6C
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01EE0:  MOVLW  09
01EE2:  MOVLB  9
01EE4:  MOVWF  x93
01EE6:  MOVLW  8A
01EE8:  MOVWF  x92
01EEA:  MOVFF  993,995
01EEE:  MOVWF  x94
01EF0:  CLRF   x97
01EF2:  MOVLW  07
01EF4:  MOVWF  x96
01EF6:  MOVLB  0
01EF8:  RCALL  177C
....................             } 
01EFA:  BRA    1F02
01EFC:  MOVLB  9
....................             else 
....................             { 
....................                break; 
01EFE:  BRA    1F08
01F00:  MOVLB  0
....................             } 
01F02:  MOVLB  9
01F04:  INCF   x91,F
01F06:  BRA    1E34
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01F08:  CLRF   xAB
01F0A:  MOVFF  986,9AC
01F0E:  MOVLB  0
01F10:  CALL   0B6C
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01F14:  MOVLW  01
01F16:  MOVLB  9
01F18:  MOVWF  xAB
01F1A:  MOVFF  987,9AC
01F1E:  MOVLB  0
01F20:  CALL   0B6C
01F24:  MOVLB  9
01F26:  MOVLB  3
....................       } 
....................    } 
01F28:  MOVLB  0
01F2A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02254:  MOVLW  14
02256:  MOVLB  3
02258:  ADDWF  x91,W
0225A:  MOVLB  9
0225C:  MOVWF  x35
0225E:  MOVLW  00
02260:  MOVLB  3
02262:  ADDWFC x92,W
02264:  MOVLB  9
02266:  MOVWF  x36
02268:  MOVF   x31,W
0226A:  ADDWF  x35,W
0226C:  MOVWF  x33
0226E:  MOVF   x32,W
02270:  ADDWFC x36,W
02272:  MOVWF  x34
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
02274:  MOVF   x34,W
02276:  SUBLW  1A
02278:  BC    228C
0227A:  XORLW  FF
0227C:  BNZ   2284
0227E:  MOVF   x33,W
02280:  SUBLW  F7
02282:  BC    228C
....................       ReadPT.Val -= RXSIZE; 
02284:  MOVLW  F8
02286:  SUBWF  x33,F
02288:  MOVLW  1B
0228A:  SUBWFB x34,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
0228C:  CLRF   xA9
0228E:  CLRF   xA8
02290:  MOVLB  0
02292:  CALL   0BC6
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
02296:  MOVLB  9
02298:  CLRF   xAB
0229A:  MOVFF  933,9AC
0229E:  MOVLB  0
022A0:  CALL   0B6C
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
022A4:  MOVLW  01
022A6:  MOVLB  9
022A8:  MOVWF  xAB
022AA:  MOVFF  934,9AC
022AE:  MOVLB  0
022B0:  CALL   0B6C
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
022B4:  MOVLW  02
022B6:  MOVLB  9
022B8:  MOVWF  xAB
022BA:  MOVFF  933,9AC
022BE:  MOVLB  0
022C0:  CALL   0B6C
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
022C4:  MOVLW  03
022C6:  MOVLB  9
022C8:  MOVWF  xAB
022CA:  MOVFF  934,9AC
022CE:  MOVLB  0
022D0:  CALL   0B6C
022D4:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01B20:  MOVFF  99F,38A
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
01B24:  MOVLW  07
01B26:  MOVLB  9
01B28:  ADDWF  xA0,F
01B2A:  MOVLW  1C
01B2C:  ADDWFC xA1,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
01B2E:  CLRF   xA9
01B30:  MOVLW  02
01B32:  MOVWF  xA8
01B34:  MOVLB  0
01B36:  CALL   0BC6
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01B3A:  MOVLW  09
01B3C:  MOVLB  9
01B3E:  MOVWF  xA3
01B40:  MOVLW  A0
01B42:  MOVWF  xA2
01B44:  MOVWF  FE9
01B46:  MOVFF  9A3,FEA
01B4A:  MOVFF  FEF,9AC
01B4E:  CLRF   xAB
01B50:  MOVLB  0
01B52:  CALL   0B6C
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
01B56:  MOVLW  09
01B58:  MOVLB  9
01B5A:  MOVWF  xA3
01B5C:  MOVLW  A0
01B5E:  MOVWF  xA2
01B60:  MOVLW  01
01B62:  ADDWF  xA2,W
01B64:  MOVWF  FE9
01B66:  MOVLW  00
01B68:  ADDWFC xA3,W
01B6A:  MOVWF  FEA
01B6C:  MOVFF  FEF,9AC
01B70:  MOVLW  01
01B72:  MOVWF  xAB
01B74:  MOVLB  0
01B76:  CALL   0B6C
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01B7A:  MOVLW  09
01B7C:  MOVLB  9
01B7E:  MOVWF  xA3
01B80:  MOVLW  A0
01B82:  MOVWF  xA2
01B84:  MOVWF  FE9
01B86:  MOVFF  9A3,FEA
01B8A:  MOVFF  FEF,9AC
01B8E:  MOVLW  02
01B90:  MOVWF  xAB
01B92:  MOVLB  0
01B94:  CALL   0B6C
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
01B98:  MOVLW  09
01B9A:  MOVLB  9
01B9C:  MOVWF  xA3
01B9E:  MOVLW  A0
01BA0:  MOVWF  xA2
01BA2:  MOVLW  01
01BA4:  ADDWF  xA2,W
01BA6:  MOVWF  FE9
01BA8:  MOVLW  00
01BAA:  ADDWFC xA3,W
01BAC:  MOVWF  FEA
01BAE:  MOVFF  FEF,9AC
01BB2:  MOVLW  03
01BB4:  MOVWF  xAB
01BB6:  MOVLB  0
01BB8:  CALL   0B6C
01BBC:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02146:  MOVLW  14
02148:  MOVLB  3
0214A:  ADDWF  x91,W
0214C:  MOVLB  9
0214E:  MOVWF  x5E
02150:  MOVLW  00
02152:  MOVLB  3
02154:  ADDWFC x92,W
02156:  MOVLB  9
02158:  MOVWF  x5F
0215A:  MOVF   x58,W
0215C:  ADDWF  x5E,W
0215E:  MOVWF  x5C
02160:  MOVF   x59,W
02162:  ADDWFC x5F,W
02164:  MOVWF  x5D
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
02166:  MOVF   x5D,W
02168:  SUBLW  1A
0216A:  BC    217E
0216C:  XORLW  FF
0216E:  BNZ   2176
02170:  MOVF   x5C,W
02172:  SUBLW  F7
02174:  BC    217E
....................    { 
....................       temp.Val -= RXSIZE; 
02176:  MOVLW  F8
02178:  SUBWF  x5C,F
0217A:  MOVLW  1B
0217C:  SUBWFB x5D,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
0217E:  CLRF   xA9
02180:  MOVLW  10
02182:  MOVWF  xA8
02184:  MOVLB  0
02186:  CALL   0BC6
....................    WriteReg(EDMASTL, temp.v[0]); 
0218A:  MOVLW  10
0218C:  MOVLB  9
0218E:  MOVWF  xAB
02190:  MOVFF  95C,9AC
02194:  MOVLB  0
02196:  CALL   0B6C
....................    WriteReg(EDMASTH, temp.v[1]); 
0219A:  MOVLW  11
0219C:  MOVLB  9
0219E:  MOVWF  xAB
021A0:  MOVFF  95D,9AC
021A4:  MOVLB  0
021A6:  CALL   0B6C
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
021AA:  MOVLW  01
021AC:  MOVLB  9
021AE:  SUBWF  x5A,W
021B0:  MOVWF  00
021B2:  MOVLW  00
021B4:  SUBWFB x5B,W
021B6:  MOVWF  03
021B8:  MOVF   00,W
021BA:  ADDWF  x5C,F
021BC:  MOVF   03,W
021BE:  ADDWFC x5D,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
021C0:  MOVF   x5D,W
021C2:  SUBLW  1A
021C4:  BC    21D8
021C6:  XORLW  FF
021C8:  BNZ   21D0
021CA:  MOVF   x5C,W
021CC:  SUBLW  F7
021CE:  BC    21D8
....................    { 
....................       temp.Val -= RXSIZE; 
021D0:  MOVLW  F8
021D2:  SUBWF  x5C,F
021D4:  MOVLW  1B
021D6:  SUBWFB x5D,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
021D8:  MOVLW  12
021DA:  MOVWF  xAB
021DC:  MOVFF  95C,9AC
021E0:  MOVLB  0
021E2:  CALL   0B6C
....................    WriteReg(EDMANDH, temp.v[1]); 
021E6:  MOVLW  13
021E8:  MOVLB  9
021EA:  MOVWF  xAB
021EC:  MOVFF  95D,9AC
021F0:  MOVLB  0
021F2:  CALL   0B6C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
021F6:  MOVLW  1F
021F8:  MOVLB  9
021FA:  MOVWF  xAD
021FC:  MOVLW  30
021FE:  MOVWF  xAE
02200:  MOVLB  0
02202:  CALL   0BA8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02206:  MOVLW  1F
02208:  MOVLB  9
0220A:  MOVWF  xA5
0220C:  MOVLB  0
0220E:  CALL   0B2E
02212:  MOVFF  01,95E
02216:  MOVLW  00
02218:  MOVLB  9
0221A:  BTFSC  01.5
0221C:  MOVLW  01
0221E:  XORLW  00
02220:  BTFSC  FD8.2
02222:  BRA    2228
02224:  MOVLB  0
02226:  BRA    2206
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02228:  MOVLW  16
0222A:  MOVWF  xA5
0222C:  MOVLB  0
0222E:  CALL   0B2E
02232:  MOVFF  01,95D
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02236:  MOVLW  17
02238:  MOVLB  9
0223A:  MOVWF  xA5
0223C:  MOVLB  0
0223E:  CALL   0B2E
02242:  MOVFF  01,95C
....................    return temp.Val; 
02246:  MOVLB  9
02248:  MOVFF  95C,01
0224C:  MOVFF  95D,02
02250:  MOVLB  0
02252:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
02D86:  MOVLW  06
02D88:  MOVLB  9
02D8A:  ADDWF  x9F,W
02D8C:  MOVWF  xA5
02D8E:  MOVLW  1C
02D90:  ADDWFC xA0,W
02D92:  MOVWF  xA6
02D94:  MOVLW  01
02D96:  ADDWF  xA5,W
02D98:  MOVWF  xA3
02D9A:  MOVLW  00
02D9C:  ADDWFC xA6,W
02D9E:  MOVWF  xA4
.................... #endif 
....................    BankSel(EDMASTL); 
02DA0:  CLRF   xA9
02DA2:  MOVLW  10
02DA4:  MOVWF  xA8
02DA6:  MOVLB  0
02DA8:  CALL   0BC6
....................    WriteReg(EDMASTL, temp.v[0]); 
02DAC:  MOVLW  10
02DAE:  MOVLB  9
02DB0:  MOVWF  xAB
02DB2:  MOVFF  9A3,9AC
02DB6:  MOVLB  0
02DB8:  CALL   0B6C
....................    WriteReg(EDMASTH, temp.v[1]); 
02DBC:  MOVLW  11
02DBE:  MOVLB  9
02DC0:  MOVWF  xAB
02DC2:  MOVFF  9A4,9AC
02DC6:  MOVLB  0
02DC8:  CALL   0B6C
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
02DCC:  MOVLW  01
02DCE:  MOVLB  9
02DD0:  SUBWF  xA1,W
02DD2:  MOVWF  00
02DD4:  MOVLW  00
02DD6:  SUBWFB xA2,W
02DD8:  MOVWF  03
02DDA:  MOVF   00,W
02DDC:  ADDWF  xA3,F
02DDE:  MOVF   03,W
02DE0:  ADDWFC xA4,F
....................    WriteReg(EDMANDL, temp.v[0]); 
02DE2:  MOVLW  12
02DE4:  MOVWF  xAB
02DE6:  MOVFF  9A3,9AC
02DEA:  MOVLB  0
02DEC:  CALL   0B6C
....................    WriteReg(EDMANDH, temp.v[1]); 
02DF0:  MOVLW  13
02DF2:  MOVLB  9
02DF4:  MOVWF  xAB
02DF6:  MOVFF  9A4,9AC
02DFA:  MOVLB  0
02DFC:  CALL   0B6C
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02E00:  MOVLW  1F
02E02:  MOVLB  9
02E04:  MOVWF  xAD
02E06:  MOVLW  30
02E08:  MOVWF  xAE
02E0A:  MOVLB  0
02E0C:  CALL   0BA8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02E10:  MOVLW  1F
02E12:  MOVLB  9
02E14:  MOVWF  xA5
02E16:  MOVLB  0
02E18:  CALL   0B2E
02E1C:  MOVFF  01,9A5
02E20:  MOVLW  00
02E22:  MOVLB  9
02E24:  BTFSC  01.5
02E26:  MOVLW  01
02E28:  XORLW  00
02E2A:  BTFSC  FD8.2
02E2C:  BRA    2E32
02E2E:  MOVLB  0
02E30:  BRA    2E10
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02E32:  MOVLW  16
02E34:  MOVWF  xA5
02E36:  MOVLB  0
02E38:  CALL   0B2E
02E3C:  MOVFF  01,9A4
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02E40:  MOVLW  17
02E42:  MOVLB  9
02E44:  MOVWF  xA5
02E46:  MOVLB  0
02E48:  CALL   0B2E
02E4C:  MOVFF  01,9A3
....................    return temp.Val; 
02E50:  MOVLB  9
02E52:  MOVFF  9A3,01
02E56:  MOVFF  9A4,02
02E5A:  MOVLB  0
02E5C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
025BC:  MOVLB  9
025BE:  MOVF   x86,F
025C0:  BNZ   25D0
025C2:  MOVF   x87,F
025C4:  BNZ   25D0
....................    { 
....................       return 0xFFFF; 
025C6:  MOVLW  FF
025C8:  MOVWF  01
025CA:  MOVWF  02
025CC:  BRA    2710
....................    } 
025CE:  BRA    25FE
....................    else if(len == 1u) 
025D0:  DECFSZ x86,W
025D2:  BRA    25FE
025D4:  MOVF   x87,F
025D6:  BNZ   25FE
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
025D8:  MOVLB  0
025DA:  RCALL  2590
025DC:  MOVLB  9
025DE:  CLRF   x8B
025E0:  MOVFF  01,98A
025E4:  MOVFF  01,03
025E8:  MOVLW  00
025EA:  CLRF   00
025EC:  DECF   00,F
025EE:  XORWF  00,F
025F0:  MOVLW  FF
025F2:  XORWF  03,F
025F4:  MOVFF  00,01
025F8:  MOVFF  03,02
025FC:  BRA    2710
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
025FE:  CLRF   xA9
02600:  CLRF   xA8
02602:  MOVLB  0
02604:  CALL   0BC6
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
02608:  MOVLB  9
0260A:  CLRF   xA5
0260C:  MOVLB  0
0260E:  CALL   0B2E
02612:  MOVFF  01,988
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
02616:  MOVLW  01
02618:  MOVLB  9
0261A:  MOVWF  xA5
0261C:  MOVLB  0
0261E:  CALL   0B2E
02622:  MOVFF  01,989
....................    WriteReg(EDMASTL, temp.v[0]); 
02626:  MOVLW  10
02628:  MOVLB  9
0262A:  MOVWF  xAB
0262C:  MOVFF  988,9AC
02630:  MOVLB  0
02632:  CALL   0B6C
....................    WriteReg(EDMASTH, temp.v[1]); 
02636:  MOVLW  11
02638:  MOVLB  9
0263A:  MOVWF  xAB
0263C:  MOVFF  989,9AC
02640:  MOVLB  0
02642:  CALL   0B6C
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
02646:  MOVLB  9
02648:  MOVF   x89,W
0264A:  SUBLW  1B
0264C:  BNC   2684
0264E:  BNZ   2656
02650:  MOVF   x88,W
02652:  SUBLW  F7
02654:  BNC   2684
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
02656:  MOVLW  01
02658:  SUBWF  x86,W
0265A:  MOVWF  00
0265C:  MOVLW  00
0265E:  SUBWFB x87,W
02660:  MOVWF  03
02662:  MOVF   00,W
02664:  ADDWF  x88,F
02666:  MOVF   03,W
02668:  ADDWFC x89,F
....................       if(temp.Val > RXSTOP) 
0266A:  MOVF   x89,W
0266C:  SUBLW  1A
0266E:  BC    2682
02670:  XORLW  FF
02672:  BNZ   267A
02674:  MOVF   x88,W
02676:  SUBLW  F7
02678:  BC    2682
....................       { 
....................          temp.Val -= RXSIZE; 
0267A:  MOVLW  F8
0267C:  SUBWF  x88,F
0267E:  MOVLW  1B
02680:  SUBWFB x89,F
....................       } 
....................    } 
02682:  BRA    2698
....................    else 
....................    { 
....................       temp.Val += len-1; 
02684:  MOVLW  01
02686:  SUBWF  x86,W
02688:  MOVWF  00
0268A:  MOVLW  00
0268C:  SUBWFB x87,W
0268E:  MOVWF  03
02690:  MOVF   00,W
02692:  ADDWF  x88,F
02694:  MOVF   03,W
02696:  ADDWFC x89,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
02698:  MOVLW  12
0269A:  MOVWF  xAB
0269C:  MOVFF  988,9AC
026A0:  MOVLB  0
026A2:  CALL   0B6C
....................    WriteReg(EDMANDH, temp.v[1]); 
026A6:  MOVLW  13
026A8:  MOVLB  9
026AA:  MOVWF  xAB
026AC:  MOVFF  989,9AC
026B0:  MOVLB  0
026B2:  CALL   0B6C
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
026B6:  MOVLW  1F
026B8:  MOVLB  9
026BA:  MOVWF  xAD
026BC:  MOVLW  30
026BE:  MOVWF  xAE
026C0:  MOVLB  0
026C2:  CALL   0BA8
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
026C6:  MOVLW  1F
026C8:  MOVLB  9
026CA:  MOVWF  xA5
026CC:  MOVLB  0
026CE:  CALL   0B2E
026D2:  MOVFF  01,98A
026D6:  MOVLW  00
026D8:  MOVLB  9
026DA:  BTFSC  01.5
026DC:  MOVLW  01
026DE:  XORLW  00
026E0:  BTFSC  FD8.2
026E2:  BRA    26E8
026E4:  MOVLB  0
026E6:  BRA    26C6
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
026E8:  MOVLW  16
026EA:  MOVWF  xA5
026EC:  MOVLB  0
026EE:  CALL   0B2E
026F2:  MOVFF  01,988
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
026F6:  MOVLW  17
026F8:  MOVLB  9
026FA:  MOVWF  xA5
026FC:  MOVLB  0
026FE:  CALL   0B2E
02702:  MOVFF  01,989
....................    return temp.Val; 
02706:  MOVLB  9
02708:  MOVFF  988,01
0270C:  MOVFF  989,02
02710:  MOVLB  0
02712:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
02590:  BCF    F94.1
02592:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
02594:  MOVLW  3A
02596:  MOVLB  9
02598:  MOVWF  xB0
0259A:  MOVLB  0
0259C:  CALL   0AF4
....................    c=ENCSPIXfer(0); 
025A0:  MOVLB  9
025A2:  CLRF   xB0
025A4:  MOVLB  0
025A6:  CALL   0AF4
025AA:  MOVFF  01,98A
....................    SPIUnselectEthernet(); 
025AE:  BCF    F94.1
025B0:  BSF    F8B.1
....................    return(c); 
025B2:  MOVLB  9
025B4:  MOVFF  98A,01
025B8:  MOVLB  0
025BA:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
0177C:  MOVLB  9
0177E:  CLRF   x99
01780:  CLRF   x98
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
01782:  BCF    F94.1
01784:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
01786:  MOVLW  3A
01788:  MOVWF  xB0
0178A:  MOVLB  0
0178C:  CALL   0AF4
....................    while(i<len) 
01790:  MOVLB  9
01792:  MOVF   x99,W
01794:  SUBWF  x97,W
01796:  BNC   17CC
01798:  BNZ   17A0
0179A:  MOVF   x96,W
0179C:  SUBWF  x98,W
0179E:  BC    17CC
....................    { 
....................       *val=ENCSPIXfer(0); 
017A0:  MOVFF  995,99B
017A4:  MOVFF  994,99A
017A8:  CLRF   xB0
017AA:  MOVLB  0
017AC:  CALL   0AF4
017B0:  MOVFF  99B,FEA
017B4:  MOVFF  99A,FE9
017B8:  MOVFF  01,FEF
....................       val++; 
017BC:  MOVLB  9
017BE:  INCF   x94,F
017C0:  BTFSC  FD8.2
017C2:  INCF   x95,F
....................       i++; 
017C4:  INCF   x98,F
017C6:  BTFSC  FD8.2
017C8:  INCF   x99,F
017CA:  BRA    1792
....................    } 
....................    SPIUnselectEthernet(); 
017CC:  BCF    F94.1
017CE:  BSF    F8B.1
....................  
....................    return(i); 
017D0:  MOVFF  998,01
017D4:  MOVFF  999,02
017D8:  MOVLB  0
017DA:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01BBE:  BCF    F94.1
01BC0:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BC2:  MOVLW  7A
01BC4:  MOVLB  9
01BC6:  MOVWF  xB0
01BC8:  MOVLB  0
01BCA:  CALL   0AF4
....................    ENCSPIXfer(val); 
01BCE:  MOVFF  9AA,9B0
01BD2:  CALL   0AF4
....................    SPIUnselectEthernet(); 
01BD6:  BCF    F94.1
01BD8:  BSF    F8B.1
01BDA:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01BDC:  BCF    F94.1
01BDE:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BE0:  MOVLW  7A
01BE2:  MOVLB  9
01BE4:  MOVWF  xB0
01BE6:  MOVLB  0
01BE8:  CALL   0AF4
....................    while(len--) 
01BEC:  MOVLB  9
01BEE:  MOVFF  9AD,03
01BF2:  MOVF   xAC,W
01BF4:  BTFSC  FD8.2
01BF6:  DECF   xAD,F
01BF8:  DECF   xAC,F
01BFA:  IORWF  03,W
01BFC:  BZ    1C1E
....................    { 
....................       ENCSPIXfer(*val); 
01BFE:  MOVFF  9AB,03
01C02:  MOVFF  9AA,FE9
01C06:  MOVFF  03,FEA
01C0A:  MOVFF  FEF,9B0
01C0E:  MOVLB  0
01C10:  CALL   0AF4
....................       val++; 
01C14:  MOVLB  9
01C16:  INCF   xAA,F
01C18:  BTFSC  FD8.2
01C1A:  INCF   xAB,F
01C1C:  BRA    1BEE
....................    } 
....................    SPIUnselectEthernet(); 
01C1E:  BCF    F94.1
01C20:  BSF    F8B.1
01C22:  MOVLB  0
01C24:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B58:  BCF    F94.1
00B5A:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
00B5C:  MOVLB  9
00B5E:  SETF   xB0
00B60:  MOVLB  0
00B62:  RCALL  0AF4
....................    SPIUnselectEthernet(); 
00B64:  BCF    F94.1
00B66:  BSF    F8B.1
00B68:  GOTO   0E1A (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
00B2E:  BCF    F94.1
00B30:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
00B32:  MOVFF  9A5,9A7
00B36:  MOVFF  9A5,9B0
00B3A:  MOVLB  0
00B3C:  RCALL  0AF4
....................    c=ENCSPIXfer(0); 
00B3E:  MOVLB  9
00B40:  CLRF   xB0
00B42:  MOVLB  0
00B44:  RCALL  0AF4
00B46:  MOVFF  01,9A6
....................    SPIUnselectEthernet(); 
00B4A:  BCF    F94.1
00B4C:  BSF    F8B.1
....................    return(c); 
00B4E:  MOVLB  9
00B50:  MOVFF  9A6,01
00B54:  MOVLB  0
00B56:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
00BF8:  BCF    F94.1
00BFA:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
00BFC:  MOVFF  903,905
00C00:  MOVFF  903,9B0
00C04:  MOVLB  0
00C06:  RCALL  0AF4
....................    ENCSPIXfer(0); 
00C08:  MOVLB  9
00C0A:  CLRF   xB0
00C0C:  MOVLB  0
00C0E:  RCALL  0AF4
....................    c=ENCSPIXfer(0); 
00C10:  MOVLB  9
00C12:  CLRF   xB0
00C14:  MOVLB  0
00C16:  RCALL  0AF4
00C18:  MOVFF  01,904
....................  
....................    SPIUnselectEthernet(); 
00C1C:  BCF    F94.1
00C1E:  BSF    F8B.1
....................  
....................    return(c); 
00C20:  MOVLB  9
00C22:  MOVFF  904,01
00C26:  MOVLB  0
00C28:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
00CB2:  MOVLW  02
00CB4:  MOVLB  9
00CB6:  MOVWF  xA9
00CB8:  MOVLW  14
00CBA:  MOVWF  xA8
00CBC:  MOVLB  0
00CBE:  RCALL  0BC6
....................    WriteReg(MIREGADR, Register); 
00CC0:  MOVLW  14
00CC2:  MOVLB  9
00CC4:  MOVWF  xAB
00CC6:  MOVFF  8FE,9AC
00CCA:  MOVLB  0
00CCC:  RCALL  0B6C
....................    WriteReg(MICMD, MICMD_MIIRD); 
00CCE:  MOVLW  12
00CD0:  MOVLB  9
00CD2:  MOVWF  xAB
00CD4:  MOVLW  01
00CD6:  MOVWF  xAC
00CD8:  MOVLB  0
00CDA:  RCALL  0B6C
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
00CDC:  MOVLW  03
00CDE:  MOVLB  9
00CE0:  MOVWF  xA9
00CE2:  MOVLW  0A
00CE4:  MOVWF  xA8
00CE6:  MOVLB  0
00CE8:  RCALL  0BC6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00CEA:  MOVLW  0A
00CEC:  MOVLB  9
00CEE:  MOVWF  x03
00CF0:  MOVLB  0
00CF2:  RCALL  0BF8
00CF4:  MOVFF  01,901
00CF8:  MOVLW  00
00CFA:  MOVLB  9
00CFC:  BTFSC  01.0
00CFE:  MOVLW  01
00D00:  XORLW  00
00D02:  BTFSC  FD8.2
00D04:  BRA    0D0A
00D06:  MOVLB  0
00D08:  BRA    0CEA
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
00D0A:  MOVLW  02
00D0C:  MOVWF  xA9
00D0E:  MOVLW  14
00D10:  MOVWF  xA8
00D12:  MOVLB  0
00D14:  RCALL  0BC6
....................    WriteReg(MICMD, 0x00); 
00D16:  MOVLW  12
00D18:  MOVLB  9
00D1A:  MOVWF  xAB
00D1C:  CLRF   xAC
00D1E:  MOVLB  0
00D20:  RCALL  0B6C
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
00D22:  MOVLW  18
00D24:  MOVLB  9
00D26:  MOVWF  x03
00D28:  MOVLB  0
00D2A:  RCALL  0BF8
00D2C:  MOVFF  01,8FF
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
00D30:  MOVLW  19
00D32:  MOVLB  9
00D34:  MOVWF  x03
00D36:  MOVLB  0
00D38:  RCALL  0BF8
00D3A:  MOVFF  01,900
....................    return Result; 
00D3E:  MOVFF  8FF,01
00D42:  MOVLB  9
00D44:  MOVFF  900,02
00D48:  MOVLB  0
00D4A:  RETURN 0
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B6C:  BCF    F94.1
00B6E:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
00B70:  MOVLB  9
00B72:  MOVF   xAB,W
00B74:  IORLW  40
00B76:  MOVWF  xAD
00B78:  MOVWF  xB0
00B7A:  MOVLB  0
00B7C:  RCALL  0AF4
....................    ENCSPIXfer(Data); 
00B7E:  MOVFF  9AC,9B0
00B82:  RCALL  0AF4
....................    SPIUnselectEthernet(); 
00B84:  BCF    F94.1
00B86:  BSF    F8B.1
00B88:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00B8A:  BCF    F94.1
00B8C:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
00B8E:  MOVLB  9
00B90:  MOVF   xAA,W
00B92:  IORLW  A0
00B94:  MOVWF  xAC
00B96:  MOVWF  xB0
00B98:  MOVLB  0
00B9A:  RCALL  0AF4
....................    ENCSPIXfer(Data); 
00B9C:  MOVFF  9AB,9B0
00BA0:  RCALL  0AF4
....................    SPIUnselectEthernet(); 
00BA2:  BCF    F94.1
00BA4:  BSF    F8B.1
00BA6:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00BA8:  BCF    F94.1
00BAA:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
00BAC:  MOVLB  9
00BAE:  MOVF   xAD,W
00BB0:  IORLW  80
00BB2:  MOVWF  xAF
00BB4:  MOVWF  xB0
00BB6:  MOVLB  0
00BB8:  RCALL  0AF4
....................    ENCSPIXfer(Data); 
00BBA:  MOVFF  9AE,9B0
00BBE:  RCALL  0AF4
....................    SPIUnselectEthernet(); 
00BC0:  BCF    F94.1
00BC2:  BSF    F8B.1
00BC4:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
00C2A:  MOVLW  02
00C2C:  MOVLB  9
00C2E:  MOVWF  xA9
00C30:  MOVLW  14
00C32:  MOVWF  xA8
00C34:  MOVLB  0
00C36:  RCALL  0BC6
....................    WriteReg(MIREGADR, Register); 
00C38:  MOVLW  14
00C3A:  MOVLB  9
00C3C:  MOVWF  xAB
00C3E:  MOVFF  8FE,9AC
00C42:  MOVLB  0
00C44:  RCALL  0B6C
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00C46:  MOVLW  08
00C48:  MOVLB  9
00C4A:  MOVWF  x02
00C4C:  SETF   x01
00C4E:  MOVFF  901,FE9
00C52:  MOVWF  FEA
00C54:  MOVFF  FEF,9AC
00C58:  MOVLW  16
00C5A:  MOVWF  xAB
00C5C:  MOVLB  0
00C5E:  RCALL  0B6C
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00C60:  MOVLW  08
00C62:  MOVLB  9
00C64:  MOVWF  x02
00C66:  SETF   x01
00C68:  MOVLW  01
00C6A:  ADDWF  x01,W
00C6C:  MOVWF  FE9
00C6E:  MOVLW  00
00C70:  ADDWFC x02,W
00C72:  MOVWF  FEA
00C74:  MOVFF  FEF,9AC
00C78:  MOVLW  17
00C7A:  MOVWF  xAB
00C7C:  MOVLB  0
00C7E:  RCALL  0B6C
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
00C80:  MOVLW  03
00C82:  MOVLB  9
00C84:  MOVWF  xA9
00C86:  MOVLW  0A
00C88:  MOVWF  xA8
00C8A:  MOVLB  0
00C8C:  RCALL  0BC6
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00C8E:  MOVLW  0A
00C90:  MOVLB  9
00C92:  MOVWF  x03
00C94:  MOVLB  0
00C96:  RCALL  0BF8
00C98:  MOVFF  01,901
00C9C:  MOVLW  00
00C9E:  MOVLB  9
00CA0:  BTFSC  01.0
00CA2:  MOVLW  01
00CA4:  XORLW  00
00CA6:  BTFSC  FD8.2
00CA8:  BRA    0CAE
00CAA:  MOVLB  0
00CAC:  BRA    0C8E
00CAE:  MOVLB  0
00CB0:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
00BC6:  MOVLW  1F
00BC8:  MOVLB  9
00BCA:  MOVWF  xAA
00BCC:  MOVLW  03
00BCE:  MOVWF  xAB
00BD0:  MOVLB  0
00BD2:  RCALL  0B8A
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00BD4:  MOVLW  09
00BD6:  MOVLB  9
00BD8:  MOVWF  xAB
00BDA:  MOVLW  A8
00BDC:  MOVWF  xAA
00BDE:  MOVLW  01
00BE0:  ADDWF  xAA,W
00BE2:  MOVWF  FE9
00BE4:  MOVLW  00
00BE6:  ADDWFC xAB,W
00BE8:  MOVWF  FEA
00BEA:  MOVFF  FEF,9AE
00BEE:  MOVLW  1F
00BF0:  MOVWF  xAD
00BF2:  MOVLB  0
00BF4:  RCALL  0BA8
00BF6:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
00D4C:  MOVLW  1F
00D4E:  MOVLB  9
00D50:  MOVWF  xAA
00D52:  MOVLW  0C
00D54:  MOVWF  xAB
00D56:  MOVLB  0
00D58:  RCALL  0B8A
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
00D5A:  MOVLB  8
00D5C:  CLRF   xFE
00D5E:  MOVLB  0
00D60:  RCALL  0CB2
00D62:  MOVFF  02,8FD
00D66:  MOVFF  01,8FC
....................    if(DuplexState == USE_PHY) 
00D6A:  MOVLB  8
00D6C:  MOVF   xFA,W
00D6E:  SUBLW  02
00D70:  BNZ   0D7A
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
00D72:  CLRF   xFA
00D74:  BTFSC  xFD.0
00D76:  INCF   xFA,F
....................    } 
00D78:  BRA    0D90
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
00D7A:  BCF    xFD.0
00D7C:  BTFSC  xFA.0
00D7E:  BSF    xFD.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
00D80:  CLRF   xFE
00D82:  MOVFF  8FD,900
00D86:  MOVFF  8FC,8FF
00D8A:  MOVLB  0
00D8C:  RCALL  0C2A
00D8E:  MOVLB  8
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
00D90:  MOVLW  02
00D92:  MOVLB  9
00D94:  MOVWF  xA9
00D96:  MOVWF  xA8
00D98:  MOVLB  0
00D9A:  RCALL  0BC6
....................    Register = ReadMACReg(MACON3); 
00D9C:  MOVLW  02
00D9E:  MOVLB  9
00DA0:  MOVWF  x03
00DA2:  MOVLB  0
00DA4:  RCALL  0BF8
00DA6:  MOVFF  01,8FB
....................    Register.MACON3bits.FULDPX = DuplexState; 
00DAA:  MOVLB  8
00DAC:  BCF    xFB.0
00DAE:  BTFSC  xFA.0
00DB0:  BSF    xFB.0
....................    WriteReg(MACON3, Register.Val); 
00DB2:  MOVLW  02
00DB4:  MOVLB  9
00DB6:  MOVWF  xAB
00DB8:  MOVFF  8FB,9AC
00DBC:  MOVLB  0
00DBE:  RCALL  0B6C
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
00DC0:  MOVLB  8
00DC2:  MOVF   xFA,F
00DC4:  BZ    0DCA
00DC6:  MOVLW  15
00DC8:  BRA    0DCC
00DCA:  MOVLW  12
00DCC:  MOVWF  xFE
00DCE:  MOVLW  04
00DD0:  MOVLB  9
00DD2:  MOVWF  xAB
00DD4:  MOVFF  8FE,9AC
00DD8:  MOVLB  0
00DDA:  RCALL  0B6C
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
00DDC:  MOVLW  1F
00DDE:  MOVLB  9
00DE0:  MOVWF  xAD
00DE2:  MOVLW  04
00DE4:  MOVWF  xAE
00DE6:  MOVLB  0
00DE8:  RCALL  0BA8
00DEA:  GOTO   0FB6 (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
0239E:  MOVLW  09
023A0:  MOVLB  9
023A2:  MOVWF  x1E
023A4:  MOVWF  x1D
023A6:  MOVWF  x95
023A8:  MOVWF  x94
023AA:  CLRF   x97
023AC:  MOVLW  14
023AE:  MOVWF  x96
023B0:  MOVLB  0
023B2:  CALL   177C
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
023B6:  MOVLB  9
023B8:  MOVF   x09,W
023BA:  ANDLW  F0
023BC:  SUBLW  40
023BE:  BZ    23C6
....................     	return FALSE; 
023C0:  MOVLW  00
023C2:  MOVWF  01
023C4:  BRA    2488
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
023C6:  MOVF   x09,W
023C8:  ANDLW  0F
023CA:  MOVWF  00
023CC:  RLCF   00,W
023CE:  MOVLB  3
023D0:  MOVWF  x97
023D2:  RLCF   x97,F
023D4:  MOVLW  FC
023D6:  ANDWF  x97,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
023D8:  MOVLB  9
023DA:  CLRF   x59
023DC:  CLRF   x58
023DE:  CLRF   x5B
023E0:  MOVFF  397,95A
023E4:  MOVLB  0
023E6:  RCALL  2146
023E8:  MOVFF  02,908
023EC:  MOVFF  01,907
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
023F0:  MOVLB  9
023F2:  CLRF   x32
023F4:  MOVFF  397,931
023F8:  MOVLB  0
023FA:  RCALL  2254
....................  
....................     if(CalcChecksum.Val) 
023FC:  MOVLB  9
023FE:  MOVF   x07,W
02400:  IORWF  x08,W
02402:  BZ    240A
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
02404:  MOVLW  00
02406:  MOVWF  01
02408:  BRA    2488
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
0240A:  MOVLW  09
0240C:  MOVWF  xA0
0240E:  MOVWF  x9F
02410:  MOVLB  0
02412:  RCALL  22D6
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
02414:  MOVLB  8
02416:  MOVF   xFF,W
02418:  MOVLB  9
0241A:  IORWF  x00,W
0241C:  BZ    2438
....................         localIP->Val    = header.DestAddress.Val; 
0241E:  MOVFF  8FF,FE9
02422:  MOVLB  9
02424:  MOVFF  900,FEA
02428:  MOVFF  919,FEF
0242C:  MOVFF  91A,FEC
02430:  MOVFF  91B,FEC
02434:  MOVFF  91C,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
02438:  MOVLW  06
0243A:  ADDWF  x01,W
0243C:  MOVWF  FE9
0243E:  MOVLW  00
02440:  ADDWFC x02,W
02442:  MOVWF  FEA
02444:  MOVFF  915,FEF
02448:  MOVFF  916,FEC
0244C:  MOVFF  917,FEC
02450:  MOVFF  918,FEC
....................     *protocol           = header.Protocol; 
02454:  MOVFF  904,03
02458:  MOVFF  903,FE9
0245C:  MOVFF  03,FEA
02460:  MOVFF  912,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
02464:  MOVFF  906,03
02468:  MOVFF  905,FE9
0246C:  MOVFF  03,FEA
02470:  MOVLB  3
02472:  MOVF   x97,W
02474:  MOVLB  9
02476:  SUBWF  x0B,W
02478:  MOVWF  00
0247A:  MOVLW  00
0247C:  SUBWFB x0C,W
0247E:  MOVFF  00,FEF
02482:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
02484:  MOVLW  01
02486:  MOVWF  01
02488:  MOVLB  0
0248A:  GOTO   4546 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02E5E:  MOVLW  14
02E60:  MOVLB  3
02E62:  MOVWF  x97
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
02E64:  MOVLW  45
02E66:  MOVLB  9
02E68:  MOVWF  x8B
....................     header.TypeOfService    = IP_SERVICE; 
02E6A:  CLRF   x8C
....................     header.TotalLength      = sizeof(header) + len; 
02E6C:  MOVLW  14
02E6E:  ADDWF  x89,W
02E70:  MOVWF  x8D
02E72:  MOVLW  00
02E74:  ADDWFC x8A,W
02E76:  MOVWF  x8E
....................     header.Identification   = ++_Identifier; 
02E78:  MOVLB  3
02E7A:  INCF   x95,F
02E7C:  BTFSC  FD8.2
02E7E:  INCF   x96,F
02E80:  MOVFF  396,990
02E84:  MOVFF  395,98F
....................     header.FragmentInfo     = 0; 
02E88:  MOVLB  9
02E8A:  CLRF   x92
02E8C:  CLRF   x91
....................     header.TimeToLive       = MY_IP_TTL; 
02E8E:  MOVLW  64
02E90:  MOVWF  x93
....................     header.Protocol         = protocol; 
02E92:  MOVFF  988,994
....................     header.HeaderChecksum   = 0; 
02E96:  CLRF   x96
02E98:  CLRF   x95
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
02E9A:  MOVFF  356,99A
02E9E:  MOVFF  355,999
02EA2:  MOVFF  354,998
02EA6:  MOVFF  353,997
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02EAA:  MOVLW  06
02EAC:  ADDWF  x86,W
02EAE:  MOVWF  FE9
02EB0:  MOVLW  00
02EB2:  ADDWFC x87,W
02EB4:  MOVWF  FEA
02EB6:  MOVFF  FEF,99B
02EBA:  MOVFF  FEC,99C
02EBE:  MOVFF  FEC,99D
02EC2:  MOVFF  FEC,99E
....................  
....................     SwapIPHeader(&header); 
02EC6:  MOVLW  09
02EC8:  MOVWF  xA0
02ECA:  MOVLW  8B
02ECC:  MOVWF  x9F
02ECE:  MOVLB  0
02ED0:  CALL   22D6
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
02ED4:  MOVLB  9
02ED6:  MOVFF  986,01
02EDA:  MOVFF  987,03
02EDE:  MOVFF  01,99F
02EE2:  MOVFF  03,9A0
02EE6:  MOVLW  14
02EE8:  ADDWF  x89,W
02EEA:  MOVWF  xA1
02EEC:  MOVLW  00
02EEE:  ADDWFC x8A,W
02EF0:  MOVWF  xA2
02EF2:  MOVFF  03,9A4
02EF6:  MOVFF  01,9A3
02EFA:  CLRF   xA5
02EFC:  MOVWF  xA7
02EFE:  MOVFF  9A1,9A6
02F02:  MOVLB  0
02F04:  CALL   1C26
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
02F08:  MOVLW  09
02F0A:  MOVLB  9
02F0C:  MOVWF  xA0
02F0E:  MOVLW  8B
02F10:  MOVWF  x9F
02F12:  MOVFF  9A0,9AB
02F16:  MOVWF  xAA
02F18:  CLRF   xAD
02F1A:  MOVLW  14
02F1C:  MOVWF  xAC
02F1E:  MOVLB  0
02F20:  CALL   1BDC
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
02F24:  MOVLB  9
02F26:  CLRF   xA0
02F28:  CLRF   x9F
02F2A:  CLRF   xA2
02F2C:  MOVLW  14
02F2E:  MOVWF  xA1
02F30:  MOVLB  0
02F32:  RCALL  2D86
02F34:  MOVFF  02,996
02F38:  MOVFF  01,995
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
02F3C:  MOVFF  38A,99F
02F40:  MOVLB  9
02F42:  CLRF   xA1
02F44:  MOVLW  0A
02F46:  MOVWF  xA0
02F48:  MOVLB  0
02F4A:  CALL   1B20
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02F4E:  MOVLW  09
02F50:  MOVLB  9
02F52:  MOVWF  xA0
02F54:  MOVLW  95
02F56:  MOVWF  x9F
02F58:  MOVFF  9A0,9AB
02F5C:  MOVWF  xAA
02F5E:  CLRF   xAD
02F60:  MOVLW  02
02F62:  MOVWF  xAC
02F64:  MOVLB  0
02F66:  CALL   1BDC
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
02F6A:  MOVFF  38A,99F
02F6E:  MOVLB  9
02F70:  CLRF   xA1
02F72:  MOVLW  14
02F74:  MOVWF  xA0
02F76:  MOVLB  0
02F78:  CALL   1B20
.................... #endif 
....................  
....................     return 0x0; 
02F7C:  MOVLW  00
02F7E:  MOVWF  01
02F80:  MOVWF  02
02F82:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
02714:  MOVLB  3
02716:  MOVF   x97,W
02718:  MOVLB  9
0271A:  ADDWF  x2D,W
0271C:  MOVWF  x2F
0271E:  MOVLW  00
02720:  ADDWFC x2E,W
02722:  MOVWF  x30
02724:  MOVWF  x32
02726:  MOVFF  92F,931
0272A:  MOVLB  0
0272C:  RCALL  2254
0272E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
022D6:  MOVLW  02
022D8:  MOVLB  9
022DA:  ADDWF  x9F,W
022DC:  MOVWF  01
022DE:  MOVLW  00
022E0:  ADDWFC xA0,W
022E2:  MOVWF  03
022E4:  MOVFF  01,9A1
022E8:  MOVWF  xA2
022EA:  MOVLW  02
022EC:  ADDWF  x9F,W
022EE:  MOVWF  FE9
022F0:  MOVLW  00
022F2:  ADDWFC xA0,W
022F4:  MOVWF  FEA
022F6:  MOVFF  FEC,9A6
022FA:  MOVF   FED,F
022FC:  MOVFF  FEF,9A5
02300:  MOVLB  0
02302:  CALL   17DC
02306:  MOVFF  9A2,FEA
0230A:  MOVFF  9A1,FE9
0230E:  MOVFF  02,FEC
02312:  MOVF   FED,F
02314:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
02318:  MOVLW  04
0231A:  MOVLB  9
0231C:  ADDWF  x9F,W
0231E:  MOVWF  01
02320:  MOVLW  00
02322:  ADDWFC xA0,W
02324:  MOVWF  03
02326:  MOVFF  01,9A1
0232A:  MOVWF  xA2
0232C:  MOVLW  04
0232E:  ADDWF  x9F,W
02330:  MOVWF  FE9
02332:  MOVLW  00
02334:  ADDWFC xA0,W
02336:  MOVWF  FEA
02338:  MOVFF  FEC,9A6
0233C:  MOVF   FED,F
0233E:  MOVFF  FEF,9A5
02342:  MOVLB  0
02344:  CALL   17DC
02348:  MOVFF  9A2,FEA
0234C:  MOVFF  9A1,FE9
02350:  MOVFF  02,FEC
02354:  MOVF   FED,F
02356:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
0235A:  MOVLW  0A
0235C:  MOVLB  9
0235E:  ADDWF  x9F,W
02360:  MOVWF  01
02362:  MOVLW  00
02364:  ADDWFC xA0,W
02366:  MOVWF  03
02368:  MOVFF  01,9A1
0236C:  MOVWF  xA2
0236E:  MOVLW  0A
02370:  ADDWF  x9F,W
02372:  MOVWF  FE9
02374:  MOVLW  00
02376:  ADDWFC xA0,W
02378:  MOVWF  FEA
0237A:  MOVFF  FEC,9A6
0237E:  MOVF   FED,F
02380:  MOVFF  FEF,9A5
02384:  MOVLB  0
02386:  CALL   17DC
0238A:  MOVFF  9A2,FEA
0238E:  MOVFF  9A1,FE9
02392:  MOVFF  02,FEC
02396:  MOVF   FED,F
02398:  MOVFF  01,FEF
0239C:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
01142:  MOVLB  8
01144:  CLRF   xF9
01146:  MOVF   xF9,W
01148:  SUBLW  22
0114A:  BNC   122A
....................     { 
....................         ps = &TCB[s]; 
0114C:  MOVLB  9
0114E:  CLRF   x4B
01150:  MOVFF  8F9,94A
01154:  CLRF   x4D
01156:  MOVLW  24
01158:  MOVWF  x4C
0115A:  MOVLB  0
0115C:  RCALL  0FE8
0115E:  MOVFF  02,03
01162:  MOVF   01,W
01164:  ADDLW  9A
01166:  MOVWF  01
01168:  MOVLW  03
0116A:  ADDWFC 03,F
0116C:  MOVFF  01,8FA
01170:  MOVLB  8
01172:  MOVFF  03,8FB
....................  
....................         ps->smState             = TCP_CLOSED; 
01176:  MOVFF  8FA,FE9
0117A:  MOVFF  8FB,FEA
0117E:  MOVLW  0A
01180:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
01182:  MOVLW  23
01184:  ADDWF  xFA,W
01186:  MOVWF  FE9
01188:  MOVLW  00
0118A:  ADDWFC xFB,W
0118C:  MOVWF  FEA
0118E:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
01190:  MOVLW  23
01192:  ADDWF  xFA,W
01194:  MOVWF  FE9
01196:  MOVLW  00
01198:  ADDWFC xFB,W
0119A:  MOVWF  FEA
0119C:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
0119E:  MOVLW  23
011A0:  ADDWF  xFA,W
011A2:  MOVWF  FE9
011A4:  MOVLW  00
011A6:  ADDWFC xFB,W
011A8:  MOVWF  FEA
011AA:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
011AC:  MOVLW  23
011AE:  ADDWF  xFA,W
011B0:  MOVWF  FE9
011B2:  MOVLW  00
011B4:  ADDWFC xFB,W
011B6:  MOVWF  FEA
011B8:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
011BA:  MOVLW  23
011BC:  ADDWF  xFA,W
011BE:  MOVWF  FE9
011C0:  MOVLW  00
011C2:  ADDWFC xFB,W
011C4:  MOVWF  FEA
011C6:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
011C8:  MOVLW  0F
011CA:  ADDWF  xFA,W
011CC:  MOVWF  FE9
011CE:  MOVLW  00
011D0:  ADDWFC xFB,W
011D2:  MOVWF  FEA
011D4:  INCFSZ FEF,W
011D6:  BRA    11DA
011D8:  BRA    1200
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
011DA:  MOVLW  0F
011DC:  ADDWF  xFA,W
011DE:  MOVWF  FE9
011E0:  MOVLW  00
011E2:  ADDWFC xFB,W
011E4:  MOVWF  FEA
011E6:  MOVFF  FEF,94D
011EA:  MOVLB  0
011EC:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
011F0:  MOVLW  0F
011F2:  MOVLB  8
011F4:  ADDWF  xFA,W
011F6:  MOVWF  FE9
011F8:  MOVLW  00
011FA:  ADDWFC xFB,W
011FC:  MOVWF  FEA
011FE:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
01200:  MOVLW  21
01202:  ADDWF  xFA,W
01204:  MOVWF  FE9
01206:  MOVLW  00
01208:  ADDWFC xFB,W
0120A:  MOVWF  FEA
0120C:  CLRF   FEC
0120E:  MOVF   FED,F
01210:  MOVLW  24
01212:  MOVWF  FEF
....................       ps->TxCount            = 0; 
01214:  MOVLW  10
01216:  ADDWF  xFA,W
01218:  MOVWF  FE9
0121A:  MOVLW  00
0121C:  ADDWFC xFB,W
0121E:  MOVWF  FEA
01220:  CLRF   FEC
01222:  MOVF   FED,F
01224:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
01226:  INCF   xF9,F
01228:  BRA    1146
....................     TCPInit_RandSeed+=get_timer0(); 
0122A:  MOVF   FD6,W
0122C:  ADDWF  x86,F
0122E:  MOVF   FD7,W
01230:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
01232:  MOVF   FCE,W
01234:  ADDWF  x86,F
01236:  MOVF   FCF,W
01238:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0123A:  MOVF   FCC,W
0123C:  ADDWF  x86,F
0123E:  MOVLW  00
01240:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
01242:  MOVF   FB2,W
01244:  ADDWF  x86,F
01246:  MOVF   FB3,W
01248:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
0124A:  CLRF   xFF
0124C:  CLRF   xFE
0124E:  MOVFF  887,8FD
01252:  MOVFF  886,8FC
01256:  MOVLB  0
01258:  BRA    100A
....................     _NextPort=rand(); 
0125A:  BRA    10C0
0125C:  MOVFF  02,399
01260:  MOVFF  01,398
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
01264:  MOVLW  04
01266:  MOVLB  3
01268:  ADDWF  x99,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
0126A:  MOVF   x99,W
0126C:  SUBLW  12
0126E:  BC    1284
01270:  XORLW  FF
01272:  BNZ   127A
01274:  MOVF   x98,W
01276:  SUBLW  87
01278:  BC    1284
0127A:  MOVLW  88
0127C:  SUBWF  x98,F
0127E:  MOVLW  13
01280:  SUBWFB x99,F
01282:  BRA    126A
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
01284:  MOVF   x99,W
01286:  SUBLW  03
01288:  BNC   128E
0128A:  MOVLW  04
0128C:  ADDWF  x99,F
0128E:  MOVLB  0
01290:  GOTO   12A2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
04752:  MOVLB  9
04754:  BCF    x03.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
04756:  CLRF   x00
04758:  MOVF   x00,W
0475A:  SUBLW  22
0475C:  BNC   479E
....................    { 
....................       ps = &TCB[s]; 
0475E:  CLRF   x4B
04760:  MOVFF  900,94A
04764:  CLRF   x4D
04766:  MOVLW  24
04768:  MOVWF  x4C
0476A:  MOVLB  0
0476C:  CALL   0FE8
04770:  MOVFF  02,03
04774:  MOVF   01,W
04776:  ADDLW  9A
04778:  MOVWF  01
0477A:  MOVLW  03
0477C:  ADDWFC 03,F
0477E:  MOVFF  01,901
04782:  MOVLB  9
04784:  MOVFF  03,902
....................       if(ps->smState == TCP_CLOSED) 
04788:  MOVFF  901,FE9
0478C:  MOVFF  902,FEA
04790:  MOVF   FEF,W
04792:  SUBLW  0A
04794:  BNZ   479A
....................       { 
....................          lbFound = TRUE; 
04796:  BSF    x03.0
....................          break; 
04798:  BRA    479E
....................       } 
0479A:  INCF   x00,F
0479C:  BRA    4758
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
0479E:  BTFSC  x03.0
047A0:  BRA    47A8
....................       return INVALID_SOCKET; 
047A2:  MOVLW  FE
047A4:  MOVWF  01
047A6:  BRA    4948
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
047A8:  MOVLW  0B
047AA:  ADDWF  x01,W
047AC:  MOVWF  FE9
047AE:  MOVLW  00
047B0:  ADDWFC x02,W
047B2:  MOVWF  FEA
047B4:  MOVLB  3
047B6:  INCF   x98,F
047B8:  BTFSC  FD8.2
047BA:  INCF   x99,F
047BC:  MOVFF  399,FEC
047C0:  MOVF   FED,F
047C2:  MOVFF  398,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
047C6:  MOVF   x99,W
047C8:  SUBLW  12
047CA:  BC    47DC
047CC:  XORLW  FF
047CE:  BNZ   47D6
047D0:  MOVF   x98,W
047D2:  SUBLW  87
047D4:  BC    47DC
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
047D6:  MOVLW  03
047D8:  MOVWF  x99
047DA:  SETF   x98
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
047DC:  MOVLW  23
047DE:  MOVLB  9
047E0:  ADDWF  x01,W
047E2:  MOVWF  FE9
047E4:  MOVLW  00
047E6:  ADDWFC x02,W
047E8:  MOVWF  FEA
047EA:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
047EC:  MOVLW  0D
047EE:  ADDWF  x01,W
047F0:  MOVWF  FE9
047F2:  MOVLW  00
047F4:  ADDWFC x02,W
047F6:  MOVWF  FEA
047F8:  MOVFF  8FF,FEC
047FC:  MOVF   FED,F
047FE:  MOVFF  8FE,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
04802:  MOVLW  16
04804:  ADDWF  x01,W
04806:  MOVWF  FE9
04808:  MOVLW  00
0480A:  ADDWFC x02,W
0480C:  MOVWF  FEA
0480E:  MOVLW  01
04810:  ADDWF  FEE,F
04812:  MOVLW  00
04814:  ADDWFC FEE,F
04816:  ADDWFC FEE,F
04818:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
0481A:  MOVLW  1A
0481C:  ADDWF  x01,W
0481E:  MOVWF  FE9
04820:  MOVLW  00
04822:  ADDWFC x02,W
04824:  MOVWF  FEA
04826:  MOVF   FEE,F
04828:  MOVF   FEE,F
0482A:  CLRF   FEC
0482C:  MOVF   FED,F
0482E:  CLRF   FEF
04830:  MOVF   FED,F
04832:  CLRF   FEF
04834:  MOVF   FED,F
04836:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
04838:  MOVLW  01
0483A:  ADDWF  x01,W
0483C:  MOVWF  01
0483E:  MOVLW  00
04840:  ADDWFC x02,W
04842:  MOVWF  03
04844:  MOVFF  01,904
04848:  MOVWF  x05
0484A:  MOVWF  FEA
0484C:  MOVFF  01,FE9
04850:  MOVFF  8FD,FE2
04854:  MOVFF  8FC,FE1
04858:  MOVLW  0A
0485A:  MOVWF  01
0485C:  MOVFF  FE6,FEE
04860:  DECFSZ 01,F
04862:  BRA    485C
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
04864:  MOVLW  01
04866:  ADDWF  x01,W
04868:  MOVWF  01
0486A:  MOVLW  00
0486C:  ADDWFC x02,W
0486E:  MOVWF  03
04870:  MOVFF  01,904
04874:  MOVWF  x05
04876:  MOVLW  0B
04878:  ADDWF  x01,W
0487A:  MOVWF  FE9
0487C:  MOVLW  00
0487E:  ADDWFC x02,W
04880:  MOVWF  FEA
04882:  MOVFF  FEC,951
04886:  MOVF   FED,F
04888:  MOVFF  FEF,950
0488C:  MOVLW  0D
0488E:  ADDWF  x01,W
04890:  MOVWF  FE9
04892:  MOVLW  00
04894:  ADDWFC x02,W
04896:  MOVWF  FEA
04898:  MOVFF  FEC,953
0489C:  MOVF   FED,F
0489E:  MOVFF  FEF,952
048A2:  MOVLW  16
048A4:  ADDWF  x01,W
048A6:  MOVWF  FE9
048A8:  MOVLW  00
048AA:  ADDWFC x02,W
048AC:  MOVWF  FEA
048AE:  MOVFF  FEF,954
048B2:  MOVFF  FEC,955
048B6:  MOVFF  FEC,956
048BA:  MOVFF  FEC,957
048BE:  MOVLW  1A
048C0:  ADDWF  x01,W
048C2:  MOVWF  FE9
048C4:  MOVLW  00
048C6:  ADDWFC x02,W
048C8:  MOVWF  FEA
048CA:  MOVFF  FEF,958
048CE:  MOVFF  FEC,959
048D2:  MOVFF  FEC,95A
048D6:  MOVFF  FEC,95B
048DA:  MOVFF  03,94F
048DE:  MOVFF  01,94E
048E2:  MOVLW  02
048E4:  MOVWF  x5C
048E6:  SETF   x5D
048E8:  CLRF   x5F
048EA:  CLRF   x5E
048EC:  MOVLB  0
048EE:  CALL   2F84
....................  
....................    ps->smState = TCP_SYN_SENT; 
048F2:  MOVLB  9
048F4:  MOVFF  901,FE9
048F8:  MOVFF  902,FEA
048FC:  MOVLW  01
048FE:  MOVWF  FEF
....................    ps->SND_SEQ++; 
04900:  MOVLW  16
04902:  ADDWF  x01,W
04904:  MOVWF  FE9
04906:  MOVLW  00
04908:  ADDWFC x02,W
0490A:  MOVWF  FEA
0490C:  MOVLW  01
0490E:  ADDWF  FEE,F
04910:  MOVLW  00
04912:  ADDWFC FEE,F
04914:  ADDWFC FEE,F
04916:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
04918:  MOVLW  1F
0491A:  ADDWF  x01,W
0491C:  MOVWF  01
0491E:  MOVLW  00
04920:  ADDWFC x02,W
04922:  MOVWF  03
04924:  MOVFF  01,904
04928:  MOVWF  x05
0492A:  MOVLB  0
0492C:  CALL   2B2E
04930:  MOVFF  905,FEA
04934:  MOVFF  904,FE9
04938:  MOVFF  02,FEC
0493C:  MOVF   FED,F
0493E:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
04942:  MOVLB  9
04944:  MOVFF  900,01
04948:  MOVLB  0
0494A:  GOTO   5430 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
0494E:  MOVLB  9
04950:  CLRF   x4B
04952:  MOVFF  8FC,94A
04956:  CLRF   x4D
04958:  MOVLW  24
0495A:  MOVWF  x4C
0495C:  MOVLB  0
0495E:  CALL   0FE8
04962:  MOVFF  02,8FE
04966:  MOVFF  01,8FD
0496A:  MOVLW  9A
0496C:  MOVLB  8
0496E:  ADDWF  01,W
04970:  MOVWF  FE9
04972:  MOVLW  03
04974:  ADDWFC 02,W
04976:  MOVWF  FEA
04978:  MOVF   FEF,W
0497A:  SUBLW  03
0497C:  BZ    4982
0497E:  MOVLW  00
04980:  BRA    4984
04982:  MOVLW  01
04984:  MOVWF  01
04986:  MOVLB  0
04988:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
05096:  MOVLB  9
05098:  CLRF   x4B
0509A:  MOVFF  8FE,94A
0509E:  CLRF   x4D
050A0:  MOVLW  24
050A2:  MOVWF  x4C
050A4:  MOVLB  0
050A6:  CALL   0FE8
050AA:  MOVFF  02,03
050AE:  MOVF   01,W
050B0:  ADDLW  9A
050B2:  MOVWF  01
050B4:  MOVLW  03
050B6:  ADDWFC 03,F
050B8:  MOVFF  01,8FF
050BC:  MOVLB  8
050BE:  MOVFF  03,900
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
050C2:  MOVFF  8FF,FE9
050C6:  MOVLB  9
050C8:  MOVFF  900,FEA
050CC:  MOVF   FEF,W
050CE:  SUBLW  03
050D0:  BZ    50F4
050D2:  MOVFF  8FF,FE9
050D6:  MOVLB  9
050D8:  MOVFF  900,FEA
050DC:  MOVF   FEF,W
050DE:  SUBLW  02
050E0:  BZ    50F4
....................    { 
....................       CloseSocket(ps); 
050E2:  MOVFF  900,94B
050E6:  MOVFF  8FF,94A
050EA:  MOVLB  0
050EC:  CALL   2B48
....................       return; 
050F0:  BRA    51CA
050F2:  MOVLB  9
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
050F4:  MOVFF  8FE,903
050F8:  MOVLB  0
050FA:  BRA    5034
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
050FC:  MOVLW  01
050FE:  MOVLB  8
05100:  ADDWF  xFF,W
05102:  MOVWF  01
05104:  MOVLW  00
05106:  MOVLB  9
05108:  ADDWFC x00,W
0510A:  MOVWF  03
0510C:  MOVFF  01,901
05110:  MOVWF  x02
05112:  MOVLW  0B
05114:  MOVLB  8
05116:  ADDWF  xFF,W
05118:  MOVWF  FE9
0511A:  MOVLW  00
0511C:  MOVLB  9
0511E:  ADDWFC x00,W
05120:  MOVWF  FEA
05122:  MOVFF  FEC,951
05126:  MOVF   FED,F
05128:  MOVFF  FEF,950
0512C:  MOVLW  0D
0512E:  MOVLB  8
05130:  ADDWF  xFF,W
05132:  MOVWF  FE9
05134:  MOVLW  00
05136:  MOVLB  9
05138:  ADDWFC x00,W
0513A:  MOVWF  FEA
0513C:  MOVFF  FEC,953
05140:  MOVF   FED,F
05142:  MOVFF  FEF,952
05146:  MOVLW  16
05148:  MOVLB  8
0514A:  ADDWF  xFF,W
0514C:  MOVWF  FE9
0514E:  MOVLW  00
05150:  MOVLB  9
05152:  ADDWFC x00,W
05154:  MOVWF  FEA
05156:  MOVFF  FEF,954
0515A:  MOVFF  FEC,955
0515E:  MOVFF  FEC,956
05162:  MOVFF  FEC,957
05166:  MOVLW  1A
05168:  MOVLB  8
0516A:  ADDWF  xFF,W
0516C:  MOVWF  FE9
0516E:  MOVLW  00
05170:  MOVLB  9
05172:  ADDWFC x00,W
05174:  MOVWF  FEA
05176:  MOVFF  FEF,958
0517A:  MOVFF  FEC,959
0517E:  MOVFF  FEC,95A
05182:  MOVFF  FEC,95B
05186:  MOVFF  03,94F
0518A:  MOVFF  01,94E
0518E:  MOVLW  11
05190:  MOVWF  x5C
05192:  SETF   x5D
05194:  CLRF   x5F
05196:  CLRF   x5E
05198:  MOVLB  0
0519A:  CALL   2F84
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
0519E:  MOVLW  16
051A0:  MOVLB  8
051A2:  ADDWF  xFF,W
051A4:  MOVWF  FE9
051A6:  MOVLW  00
051A8:  MOVLB  9
051AA:  ADDWFC x00,W
051AC:  MOVWF  FEA
051AE:  MOVLW  01
051B0:  ADDWF  FEE,F
051B2:  MOVLW  00
051B4:  ADDWFC FEE,F
051B6:  ADDWFC FEE,F
051B8:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
051BA:  MOVFF  8FF,FE9
051BE:  MOVLB  9
051C0:  MOVFF  900,FEA
051C4:  MOVLW  04
051C6:  MOVWF  FEF
051C8:  MOVLB  0
....................  
....................    return; 
051CA:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
04CC0:  MOVLB  9
04CC2:  CLRF   x4B
04CC4:  MOVFF  909,94A
04CC8:  CLRF   x4D
04CCA:  MOVLW  24
04CCC:  MOVWF  x4C
04CCE:  MOVLB  0
04CD0:  CALL   0FE8
04CD4:  MOVFF  02,03
04CD8:  MOVF   01,W
04CDA:  ADDLW  9A
04CDC:  MOVWF  01
04CDE:  MOVLW  03
04CE0:  ADDWFC 03,F
04CE2:  MOVFF  01,90A
04CE6:  MOVLB  9
04CE8:  MOVFF  03,90B
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
04CEC:  MOVLW  0F
04CEE:  ADDWF  x0A,W
04CF0:  MOVWF  FE9
04CF2:  MOVLW  00
04CF4:  ADDWFC x0B,W
04CF6:  MOVWF  FEA
04CF8:  INCFSZ FEF,W
04CFA:  BRA    4D02
....................       return FALSE; 
04CFC:  MOVLW  00
04CFE:  MOVWF  01
04D00:  BRA    4E5C
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
04D02:  MOVLW  23
04D04:  ADDWF  x0A,W
04D06:  MOVWF  01
04D08:  MOVLW  00
04D0A:  ADDWFC x0B,W
04D0C:  MOVWF  03
04D0E:  MOVFF  01,FE9
04D12:  MOVWF  FEA
04D14:  BTFSC  FEF.1
04D16:  BRA    4D1E
....................       return FALSE; 
04D18:  MOVLW  00
04D1A:  MOVWF  01
04D1C:  BRA    4E5C
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
04D1E:  MOVLW  01
04D20:  ADDWF  x0A,W
04D22:  MOVWF  01
04D24:  MOVLW  00
04D26:  ADDWFC x0B,W
04D28:  MOVWF  03
04D2A:  MOVFF  01,90C
04D2E:  MOVWF  x0D
04D30:  MOVLW  0B
04D32:  ADDWF  x0A,W
04D34:  MOVWF  FE9
04D36:  MOVLW  00
04D38:  ADDWFC x0B,W
04D3A:  MOVWF  FEA
04D3C:  MOVFF  FEC,951
04D40:  MOVF   FED,F
04D42:  MOVFF  FEF,950
04D46:  MOVLW  0D
04D48:  ADDWF  x0A,W
04D4A:  MOVWF  FE9
04D4C:  MOVLW  00
04D4E:  ADDWFC x0B,W
04D50:  MOVWF  FEA
04D52:  MOVFF  FEC,953
04D56:  MOVF   FED,F
04D58:  MOVFF  FEF,952
04D5C:  MOVLW  16
04D5E:  ADDWF  x0A,W
04D60:  MOVWF  FE9
04D62:  MOVLW  00
04D64:  ADDWFC x0B,W
04D66:  MOVWF  FEA
04D68:  MOVFF  FEF,954
04D6C:  MOVFF  FEC,955
04D70:  MOVFF  FEC,956
04D74:  MOVFF  FEC,957
04D78:  MOVLW  1A
04D7A:  ADDWF  x0A,W
04D7C:  MOVWF  FE9
04D7E:  MOVLW  00
04D80:  ADDWFC x0B,W
04D82:  MOVWF  FEA
04D84:  MOVFF  FEF,958
04D88:  MOVFF  FEC,959
04D8C:  MOVFF  FEC,95A
04D90:  MOVFF  FEC,95B
04D94:  MOVLW  0F
04D96:  ADDWF  x0A,W
04D98:  MOVWF  FE9
04D9A:  MOVLW  00
04D9C:  ADDWFC x0B,W
04D9E:  MOVWF  FEA
04DA0:  MOVFF  FEF,95D
04DA4:  MOVLW  10
04DA6:  ADDWF  x0A,W
04DA8:  MOVWF  FE9
04DAA:  MOVLW  00
04DAC:  ADDWFC x0B,W
04DAE:  MOVWF  FEA
04DB0:  MOVFF  FEC,95F
04DB4:  MOVF   FED,F
04DB6:  MOVFF  FEF,95E
04DBA:  MOVFF  03,94F
04DBE:  MOVFF  01,94E
04DC2:  MOVLW  18
04DC4:  MOVWF  x5C
04DC6:  MOVLB  0
04DC8:  CALL   2F84
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
04DCC:  MOVLW  16
04DCE:  MOVLB  9
04DD0:  ADDWF  x0A,W
04DD2:  MOVWF  01
04DD4:  MOVLW  00
04DD6:  ADDWFC x0B,W
04DD8:  MOVWF  03
04DDA:  MOVFF  01,90C
04DDE:  MOVWF  x0D
04DE0:  MOVWF  FEA
04DE2:  MOVFF  01,FE9
04DE6:  MOVFF  FEF,90E
04DEA:  MOVFF  FEC,90F
04DEE:  MOVFF  FEC,910
04DF2:  MOVFF  FEC,911
04DF6:  MOVLW  10
04DF8:  ADDWF  x0A,W
04DFA:  MOVWF  FE9
04DFC:  MOVLW  00
04DFE:  ADDWFC x0B,W
04E00:  MOVWF  FEA
04E02:  MOVFF  FEC,03
04E06:  MOVF   FED,F
04E08:  MOVFF  FEF,00
04E0C:  MOVFF  03,01
04E10:  CLRF   02
04E12:  CLRF   03
04E14:  MOVF   x0E,W
04E16:  ADDWF  00,F
04E18:  MOVF   x0F,W
04E1A:  ADDWFC 01,F
04E1C:  MOVF   x10,W
04E1E:  ADDWFC 02,F
04E20:  MOVF   x11,W
04E22:  ADDWFC 03,F
04E24:  MOVFF  90D,FEA
04E28:  MOVFF  90C,FE9
04E2C:  MOVFF  00,FEF
04E30:  MOVFF  01,FEC
04E34:  MOVFF  02,FEC
04E38:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
04E3C:  MOVLW  23
04E3E:  ADDWF  x0A,W
04E40:  MOVWF  FE9
04E42:  MOVLW  00
04E44:  ADDWFC x0B,W
04E46:  MOVWF  FEA
04E48:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
04E4A:  MOVLW  23
04E4C:  ADDWF  x0A,W
04E4E:  MOVWF  FE9
04E50:  MOVLW  00
04E52:  ADDWFC x0B,W
04E54:  MOVWF  FEA
04E56:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
04E58:  MOVLW  01
04E5A:  MOVWF  01
04E5C:  MOVLB  0
04E5E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
04AB4:  MOVLB  9
04AB6:  CLRF   x4B
04AB8:  MOVFF  90E,94A
04ABC:  CLRF   x4D
04ABE:  MOVLW  24
04AC0:  MOVWF  x4C
04AC2:  MOVLB  0
04AC4:  CALL   0FE8
04AC8:  MOVFF  01,90F
04ACC:  MOVLW  14
04ACE:  MOVLB  9
04AD0:  ADDWF  01,W
04AD2:  MOVWF  01
04AD4:  MOVLW  00
04AD6:  ADDWFC 02,W
04AD8:  MOVWF  03
04ADA:  MOVF   01,W
04ADC:  ADDLW  9A
04ADE:  MOVWF  FE9
04AE0:  MOVLW  03
04AE2:  ADDWFC 03,W
04AE4:  MOVWF  FEA
04AE6:  MOVFF  FEC,910
04AEA:  MOVF   FED,F
04AEC:  MOVFF  FEF,90F
04AF0:  MOVF   x0F,F
04AF2:  BNZ   4AFE
04AF4:  MOVF   x10,F
04AF6:  BNZ   4AFE
....................       return FALSE; 
04AF8:  MOVLW  00
04AFA:  MOVWF  01
04AFC:  BRA    4B7E
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04AFE:  CLRF   x4B
04B00:  MOVFF  90E,94A
04B04:  CLRF   x4D
04B06:  MOVLW  24
04B08:  MOVWF  x4C
04B0A:  MOVLB  0
04B0C:  CALL   0FE8
04B10:  MOVFF  02,910
04B14:  MOVFF  01,90F
04B18:  MOVLW  0F
04B1A:  MOVLB  9
04B1C:  ADDWF  01,W
04B1E:  MOVWF  01
04B20:  MOVLW  00
04B22:  ADDWFC 02,W
04B24:  MOVWF  03
04B26:  MOVF   01,W
04B28:  ADDLW  9A
04B2A:  MOVWF  FE9
04B2C:  MOVLW  03
04B2E:  ADDWFC 03,W
04B30:  MOVWF  FEA
04B32:  INCFSZ FEF,W
04B34:  BRA    4B46
....................       return IPIsTxReady(FALSE); 
04B36:  CLRF   x86
04B38:  MOVLB  0
04B3A:  CALL   2C46
04B3E:  MOVF   01,W
04B40:  MOVLB  9
04B42:  BRA    4B7E
04B44:  BRA    4B7E
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
04B46:  CLRF   x4B
04B48:  MOVFF  90E,94A
04B4C:  CLRF   x4D
04B4E:  MOVLW  24
04B50:  MOVWF  x4C
04B52:  MOVLB  0
04B54:  CALL   0FE8
04B58:  MOVFF  02,910
04B5C:  MOVFF  01,90F
04B60:  MOVLW  23
04B62:  MOVLB  9
04B64:  ADDWF  x0F,F
04B66:  MOVLW  00
04B68:  ADDWFC x10,F
04B6A:  MOVLW  9A
04B6C:  ADDWF  x0F,W
04B6E:  MOVWF  FE9
04B70:  MOVLW  03
04B72:  ADDWFC x10,W
04B74:  MOVWF  FEA
04B76:  MOVLW  00
04B78:  BTFSC  FEF.1
04B7A:  MOVLW  01
04B7C:  MOVWF  01
04B7E:  MOVLB  0
04B80:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
04B82:  MOVFF  909,90E
04B86:  RCALL  4AB4
04B88:  MOVF   01,F
04B8A:  BNZ   4B94
....................       return(0); 
04B8C:  MOVLW  00
04B8E:  MOVWF  01
04B90:  MOVWF  02
04B92:  BRA    4CBA
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04B94:  MOVLB  9
04B96:  CLRF   x4B
04B98:  MOVFF  909,94A
04B9C:  CLRF   x4D
04B9E:  MOVLW  24
04BA0:  MOVWF  x4C
04BA2:  MOVLB  0
04BA4:  CALL   0FE8
04BA8:  MOVFF  02,90F
04BAC:  MOVFF  01,90E
04BB0:  MOVLW  0F
04BB2:  MOVLB  9
04BB4:  ADDWF  01,W
04BB6:  MOVWF  01
04BB8:  MOVLW  00
04BBA:  ADDWFC 02,W
04BBC:  MOVWF  03
04BBE:  MOVF   01,W
04BC0:  ADDLW  9A
04BC2:  MOVWF  FE9
04BC4:  MOVLW  03
04BC6:  ADDWFC 03,W
04BC8:  MOVWF  FEA
04BCA:  INCFSZ FEF,W
04BCC:  BRA    4BD4
....................       txCount = 0; 
04BCE:  CLRF   x0B
04BD0:  CLRF   x0A
04BD2:  BRA    4C0E
....................    else 
....................       txCount = TCB[s].TxCount; 
04BD4:  CLRF   x4B
04BD6:  MOVFF  909,94A
04BDA:  CLRF   x4D
04BDC:  MOVLW  24
04BDE:  MOVWF  x4C
04BE0:  MOVLB  0
04BE2:  CALL   0FE8
04BE6:  MOVFF  01,90E
04BEA:  MOVLW  10
04BEC:  MOVLB  9
04BEE:  ADDWF  01,W
04BF0:  MOVWF  01
04BF2:  MOVLW  00
04BF4:  ADDWFC 02,W
04BF6:  MOVWF  03
04BF8:  MOVF   01,W
04BFA:  ADDLW  9A
04BFC:  MOVWF  FE9
04BFE:  MOVLW  03
04C00:  ADDWFC 03,W
04C02:  MOVWF  FEA
04C04:  MOVFF  FEC,90B
04C08:  MOVF   FED,F
04C0A:  MOVFF  FEF,90A
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
04C0E:  MOVLW  CA
04C10:  BSF    FD8.0
04C12:  SUBFWB x0A,W
04C14:  MOVWF  x0C
04C16:  MOVLW  03
04C18:  SUBFWB x0B,W
04C1A:  MOVWF  x0D
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
04C1C:  CLRF   x4B
04C1E:  MOVFF  909,94A
04C22:  CLRF   x4D
04C24:  MOVLW  24
04C26:  MOVWF  x4C
04C28:  MOVLB  0
04C2A:  CALL   0FE8
04C2E:  MOVFF  02,90F
04C32:  MOVFF  01,90E
04C36:  MOVLW  14
04C38:  MOVLB  9
04C3A:  ADDWF  01,W
04C3C:  MOVWF  01
04C3E:  MOVLW  00
04C40:  ADDWFC 02,W
04C42:  MOVWF  03
04C44:  MOVF   01,W
04C46:  ADDLW  9A
04C48:  MOVWF  FE9
04C4A:  MOVLW  03
04C4C:  ADDWFC 03,W
04C4E:  MOVWF  FEA
04C50:  MOVFF  FEC,03
04C54:  MOVF   FED,F
04C56:  MOVFF  FEF,01
04C5A:  MOVF   03,W
04C5C:  SUBWF  x0D,W
04C5E:  BNC   4CA6
04C60:  BNZ   4C68
04C62:  MOVF   x0C,W
04C64:  SUBWF  01,W
04C66:  BC    4CA6
04C68:  CLRF   x4B
04C6A:  MOVFF  909,94A
04C6E:  CLRF   x4D
04C70:  MOVLW  24
04C72:  MOVWF  x4C
04C74:  MOVLB  0
04C76:  CALL   0FE8
04C7A:  MOVFF  02,90F
04C7E:  MOVFF  01,90E
04C82:  MOVLW  14
04C84:  MOVLB  9
04C86:  ADDWF  01,W
04C88:  MOVWF  01
04C8A:  MOVLW  00
04C8C:  ADDWFC 02,W
04C8E:  MOVWF  03
04C90:  MOVF   01,W
04C92:  ADDLW  9A
04C94:  MOVWF  FE9
04C96:  MOVLW  03
04C98:  ADDWFC 03,W
04C9A:  MOVWF  FEA
04C9C:  MOVFF  FEC,03
04CA0:  MOVF   FED,F
04CA2:  MOVF   FEF,W
04CA4:  BRA    4CAC
04CA6:  MOVFF  90D,03
04CAA:  MOVF   x0C,W
04CAC:  MOVWF  x0C
04CAE:  MOVFF  03,90D
....................  
....................    return(txAvail); 
04CB2:  MOVFF  90C,01
04CB6:  MOVFF  90D,02
04CBA:  MOVLB  0
04CBC:  GOTO   4F3A (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
04E60:  MOVLB  9
04E62:  CLRF   x4B
04E64:  MOVFF  8FE,94A
04E68:  CLRF   x4D
04E6A:  MOVLW  24
04E6C:  MOVWF  x4C
04E6E:  MOVLB  0
04E70:  CALL   0FE8
04E74:  MOVFF  02,03
04E78:  MOVF   01,W
04E7A:  ADDLW  9A
04E7C:  MOVWF  01
04E7E:  MOVLW  03
04E80:  ADDWFC 03,F
04E82:  MOVFF  01,903
04E86:  MOVLB  9
04E88:  MOVFF  03,904
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
04E8C:  MOVLW  14
04E8E:  ADDWF  x03,W
04E90:  MOVWF  FE9
04E92:  MOVLW  00
04E94:  ADDWFC x04,W
04E96:  MOVWF  FEA
04E98:  MOVFF  FEC,908
04E9C:  MOVF   FED,F
04E9E:  MOVFF  FEF,907
04EA2:  MOVF   x07,F
04EA4:  BNZ   4EB2
04EA6:  MOVF   x08,F
04EA8:  BNZ   4EB2
....................       return 0; 
04EAA:  MOVLW  00
04EAC:  MOVWF  01
04EAE:  MOVWF  02
04EB0:  BRA    502E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
04EB2:  MOVLW  0F
04EB4:  ADDWF  x03,W
04EB6:  MOVWF  FE9
04EB8:  MOVLW  00
04EBA:  ADDWFC x04,W
04EBC:  MOVWF  FEA
04EBE:  INCFSZ FEF,W
04EC0:  BRA    4F32
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
04EC2:  MOVLW  0F
04EC4:  ADDWF  x03,W
04EC6:  MOVWF  01
04EC8:  MOVLW  00
04ECA:  ADDWFC x04,W
04ECC:  MOVWF  03
04ECE:  MOVFF  01,907
04ED2:  MOVWF  x08
04ED4:  CLRF   x86
04ED6:  MOVLB  0
04ED8:  CALL   1AF8
04EDC:  MOVFF  908,FEA
04EE0:  MOVFF  907,FE9
04EE4:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
04EE8:  MOVLW  0F
04EEA:  MOVLB  9
04EEC:  ADDWF  x03,W
04EEE:  MOVWF  FE9
04EF0:  MOVLW  00
04EF2:  ADDWFC x04,W
04EF4:  MOVWF  FEA
04EF6:  INCFSZ FEF,W
04EF8:  BRA    4F02
....................          return 0; 
04EFA:  MOVLW  00
04EFC:  MOVWF  01
04EFE:  MOVWF  02
04F00:  BRA    502E
....................  
....................       ps->TxCount = 0; 
04F02:  MOVLW  10
04F04:  ADDWF  x03,W
04F06:  MOVWF  FE9
04F08:  MOVLW  00
04F0A:  ADDWFC x04,W
04F0C:  MOVWF  FEA
04F0E:  CLRF   FEC
04F10:  MOVF   FED,F
04F12:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
04F14:  MOVLW  0F
04F16:  ADDWF  x03,W
04F18:  MOVWF  FE9
04F1A:  MOVLW  00
04F1C:  ADDWFC x04,W
04F1E:  MOVWF  FEA
04F20:  MOVFF  FEF,99F
04F24:  CLRF   xA1
04F26:  MOVLW  28
04F28:  MOVWF  xA0
04F2A:  MOVLB  0
04F2C:  CALL   1B20
04F30:  MOVLB  9
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
04F32:  MOVFF  8FE,909
04F36:  MOVLB  0
04F38:  BRA    4B82
04F3A:  MOVFF  02,906
04F3E:  MOVFF  01,905
....................     
....................    len = n < len ? n : len; 
04F42:  MOVLB  9
04F44:  MOVF   x06,W
04F46:  SUBWF  x02,W
04F48:  BNC   4F5A
04F4A:  BNZ   4F52
04F4C:  MOVF   x01,W
04F4E:  SUBWF  x05,W
04F50:  BC    4F5A
04F52:  MOVFF  906,03
04F56:  MOVF   x05,W
04F58:  BRA    4F60
04F5A:  MOVFF  902,03
04F5E:  MOVF   x01,W
04F60:  MOVWF  x01
04F62:  MOVFF  03,902
....................    n = len; 
04F66:  MOVFF  902,906
04F6A:  MOVFF  901,905
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
04F6E:  MOVLW  23
04F70:  ADDWF  x03,W
04F72:  MOVWF  FE9
04F74:  MOVLW  00
04F76:  ADDWFC x04,W
04F78:  MOVWF  FEA
04F7A:  BSF    FEF.4
....................  
....................    while (n--) 
04F7C:  MOVFF  906,03
04F80:  MOVF   x05,W
04F82:  BTFSC  FD8.2
04F84:  DECF   x06,F
04F86:  DECF   x05,F
04F88:  IORWF  03,W
04F8A:  BZ    4FF6
....................    { 
....................       MACPut(*ptr++); 
04F8C:  MOVFF  900,03
04F90:  MOVLB  8
04F92:  MOVF   xFF,W
04F94:  INCF   xFF,F
04F96:  BTFSS  FD8.2
04F98:  BRA    4FA0
04F9A:  MOVLB  9
04F9C:  INCF   x00,F
04F9E:  MOVLB  8
04FA0:  MOVWF  FE9
04FA2:  MOVFF  03,FEA
04FA6:  MOVFF  FEF,9AA
04FAA:  MOVLB  0
04FAC:  CALL   1BBE
....................       ps->RemoteWindow -= 1; 
04FB0:  MOVLW  14
04FB2:  MOVLB  9
04FB4:  ADDWF  x03,W
04FB6:  MOVWF  FE9
04FB8:  MOVLW  00
04FBA:  ADDWFC x04,W
04FBC:  MOVWF  FEA
04FBE:  MOVLW  01
04FC0:  SUBWF  FEF,W
04FC2:  MOVWF  00
04FC4:  MOVLW  00
04FC6:  SUBWFB FEC,W
04FC8:  MOVWF  03
04FCA:  MOVF   00,W
04FCC:  MOVF   FED,F
04FCE:  MOVWF  FEF
04FD0:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
04FD4:  MOVLW  10
04FD6:  ADDWF  x03,W
04FD8:  MOVWF  FE9
04FDA:  MOVLW  00
04FDC:  ADDWFC x04,W
04FDE:  MOVWF  FEA
04FE0:  MOVLW  01
04FE2:  ADDWF  FEF,W
04FE4:  MOVWF  01
04FE6:  MOVLW  00
04FE8:  ADDWFC FEC,W
04FEA:  MOVWF  03
04FEC:  MOVF   FED,F
04FEE:  MOVFF  01,FEF
04FF2:  MOVWF  FEC
04FF4:  BRA    4F7C
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
04FF6:  MOVLW  10
04FF8:  ADDWF  x03,W
04FFA:  MOVWF  FE9
04FFC:  MOVLW  00
04FFE:  ADDWFC x04,W
05000:  MOVWF  FEA
05002:  MOVFF  FEC,908
05006:  MOVF   FED,F
05008:  MOVFF  FEF,907
0500C:  MOVF   x08,W
0500E:  SUBLW  02
05010:  BC    5026
05012:  XORLW  FF
05014:  BNZ   501C
05016:  MOVF   x07,W
05018:  SUBLW  C9
0501A:  BC    5026
....................       TCPFlush(s); 
0501C:  MOVFF  8FE,909
05020:  MOVLB  0
05022:  RCALL  4CC0
05024:  MOVLB  9
....................  
....................    return(len); 
05026:  MOVFF  901,01
0502A:  MOVFF  902,02
0502E:  MOVLB  0
05030:  GOTO   529A (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
05034:  MOVLB  9
05036:  CLRF   x4B
05038:  MOVFF  903,94A
0503C:  CLRF   x4D
0503E:  MOVLW  24
05040:  MOVWF  x4C
05042:  MOVLB  0
05044:  CALL   0FE8
05048:  MOVFF  02,03
0504C:  MOVF   01,W
0504E:  ADDLW  9A
05050:  MOVWF  01
05052:  MOVLW  03
05054:  ADDWFC 03,F
05056:  MOVFF  01,904
0505A:  MOVLB  9
0505C:  MOVFF  03,905
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
05060:  MOVLW  23
05062:  ADDWF  x04,W
05064:  MOVWF  FE9
05066:  MOVLW  00
05068:  ADDWFC x05,W
0506A:  MOVWF  FEA
0506C:  BTFSC  FEF.3
0506E:  BRA    5076
....................         return FALSE; 
05070:  MOVLW  00
05072:  MOVWF  01
05074:  BRA    5090
....................  
....................     MACDiscardRx(); 
05076:  MOVLB  0
05078:  CALL   1706
....................     ps->Flags.bIsGetReady = FALSE; 
0507C:  MOVLW  23
0507E:  MOVLB  9
05080:  ADDWF  x04,W
05082:  MOVWF  FE9
05084:  MOVLW  00
05086:  ADDWFC x05,W
05088:  MOVWF  FEA
0508A:  BCF    FEF.3
....................  
....................     return TRUE; 
0508C:  MOVLW  01
0508E:  MOVWF  01
05090:  MOVLB  0
05092:  GOTO   50FC (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
049D0:  MOVLB  9
049D2:  CLRF   x4B
049D4:  MOVFF  8FE,94A
049D8:  CLRF   x4D
049DA:  MOVLW  24
049DC:  MOVWF  x4C
049DE:  MOVLB  0
049E0:  CALL   0FE8
049E4:  MOVFF  02,03
049E8:  MOVF   01,W
049EA:  ADDLW  9A
049EC:  MOVWF  01
049EE:  MOVLW  03
049F0:  ADDWFC 03,F
049F2:  MOVFF  01,901
049F6:  MOVLB  9
049F8:  MOVFF  03,902
....................  
....................     if ( ps->Flags.bIsGetReady ) 
049FC:  MOVLW  23
049FE:  ADDWF  x01,W
04A00:  MOVWF  FE9
04A02:  MOVLW  00
04A04:  ADDWFC x02,W
04A06:  MOVWF  FEA
04A08:  BTFSS  FEF.3
04A0A:  BRA    4AAA
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
04A0C:  MOVLW  23
04A0E:  ADDWF  x01,W
04A10:  MOVWF  FE9
04A12:  MOVLW  00
04A14:  ADDWFC x02,W
04A16:  MOVWF  FEA
04A18:  BTFSS  FEF.2
04A1A:  BRA    4A38
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
04A1C:  CLRF   x2E
04A1E:  MOVLW  14
04A20:  MOVWF  x2D
04A22:  MOVLB  0
04A24:  CALL   2714
....................  
....................             ps->Flags.bFirstRead = FALSE; 
04A28:  MOVLW  23
04A2A:  MOVLB  9
04A2C:  ADDWF  x01,W
04A2E:  MOVWF  FE9
04A30:  MOVLW  00
04A32:  ADDWFC x02,W
04A34:  MOVWF  FEA
04A36:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
04A38:  MOVLW  12
04A3A:  ADDWF  x01,W
04A3C:  MOVWF  FE9
04A3E:  MOVLW  00
04A40:  ADDWFC x02,W
04A42:  MOVWF  FEA
04A44:  MOVFF  FEC,904
04A48:  MOVF   FED,F
04A4A:  MOVFF  FEF,903
04A4E:  MOVF   x03,F
04A50:  BNZ   4A72
04A52:  MOVF   x04,F
04A54:  BNZ   4A72
....................         { 
....................             MACDiscardRx(); 
04A56:  MOVLB  0
04A58:  CALL   1706
....................             ps->Flags.bIsGetReady = FALSE; 
04A5C:  MOVLW  23
04A5E:  MOVLB  9
04A60:  ADDWF  x01,W
04A62:  MOVWF  FE9
04A64:  MOVLW  00
04A66:  ADDWFC x02,W
04A68:  MOVWF  FEA
04A6A:  BCF    FEF.3
....................             return FALSE; 
04A6C:  MOVLW  00
04A6E:  MOVWF  01
04A70:  BRA    4AAE
....................         } 
....................  
....................          ps->RxCount--; 
04A72:  MOVLW  12
04A74:  ADDWF  x01,W
04A76:  MOVWF  FE9
04A78:  MOVLW  00
04A7A:  ADDWFC x02,W
04A7C:  MOVWF  FEA
04A7E:  MOVLW  FF
04A80:  ADDWF  FEF,F
04A82:  BC    4A88
04A84:  MOVF   FEE,F
04A86:  DECF   FED,F
....................          *data = MACGet(); 
04A88:  MOVFF  900,904
04A8C:  MOVFF  8FF,903
04A90:  MOVLB  0
04A92:  CALL   2590
04A96:  MOVFF  904,FEA
04A9A:  MOVFF  903,FE9
04A9E:  MOVFF  01,FEF
....................         return TRUE; 
04AA2:  MOVLW  01
04AA4:  MOVWF  01
04AA6:  MOVLB  9
04AA8:  BRA    4AAE
....................     } 
....................     return FALSE; 
04AAA:  MOVLW  00
04AAC:  MOVWF  01
04AAE:  MOVLB  0
04AB0:  GOTO   51F6 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
0498A:  MOVLB  9
0498C:  CLRF   x4B
0498E:  MOVFF  8FE,94A
04992:  CLRF   x4D
04994:  MOVLW  24
04996:  MOVWF  x4C
04998:  MOVLB  0
0499A:  CALL   0FE8
0499E:  MOVFF  02,900
049A2:  MOVFF  01,8FF
049A6:  MOVLW  23
049A8:  MOVLB  8
049AA:  ADDWF  xFF,F
049AC:  MOVLW  00
049AE:  MOVLB  9
049B0:  ADDWFC x00,F
049B2:  MOVLW  9A
049B4:  MOVLB  8
049B6:  ADDWF  xFF,W
049B8:  MOVWF  FE9
049BA:  MOVLW  03
049BC:  MOVLB  9
049BE:  ADDWFC x00,W
049C0:  MOVWF  FEA
049C2:  MOVLW  00
049C4:  BTFSC  FEF.3
049C6:  MOVLW  01
049C8:  MOVWF  01
049CA:  MOVLB  0
049CC:  GOTO   51D4 (RETURN)
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
04016:  MOVLB  9
04018:  CLRF   x0A
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0401A:  MOVLB  8
0401C:  CLRF   xFF
0401E:  MOVF   xFF,W
04020:  SUBLW  22
04022:  BTFSS  FD8.0
04024:  BRA    4476
....................    { 
....................       ps = &TCB[s]; 
04026:  MOVLB  9
04028:  CLRF   x4B
0402A:  MOVFF  8FF,94A
0402E:  CLRF   x4D
04030:  MOVLW  24
04032:  MOVWF  x4C
04034:  MOVLB  0
04036:  CALL   0FE8
0403A:  MOVFF  02,03
0403E:  MOVF   01,W
04040:  ADDLW  9A
04042:  MOVWF  01
04044:  MOVLW  03
04046:  ADDWFC 03,F
04048:  MOVFF  01,904
0404C:  MOVLB  9
0404E:  MOVFF  03,905
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
04052:  MOVLW  23
04054:  ADDWF  x04,W
04056:  MOVWF  FE9
04058:  MOVLW  00
0405A:  ADDWFC x05,W
0405C:  MOVWF  FEA
0405E:  BTFSC  FEF.3
04060:  BRA    4072
04062:  MOVLW  23
04064:  ADDWF  x04,W
04066:  MOVWF  FE9
04068:  MOVLW  00
0406A:  ADDWFC x05,W
0406C:  MOVWF  FEA
0406E:  BTFSS  FEF.4
04070:  BRA    4074
....................          continue; 
04072:  BRA    4470
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
04074:  MOVFF  904,FE9
04078:  MOVFF  905,FEA
0407C:  MOVF   FEF,W
0407E:  SUBLW  0A
04080:  BZ    40A4
04082:  MOVFF  904,FE9
04086:  MOVFF  905,FEA
0408A:  MOVF   FEF,F
0408C:  BNZ   40A6
0408E:  MOVLW  23
04090:  ADDWF  x04,W
04092:  MOVWF  01
04094:  MOVLW  00
04096:  ADDWFC x05,W
04098:  MOVWF  03
0409A:  MOVFF  01,FE9
0409E:  MOVWF  FEA
040A0:  BTFSS  FEF.0
040A2:  BRA    40A6
....................          continue; 
040A4:  BRA    4470
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
040A6:  MOVFF  904,FE9
040AA:  MOVFF  905,FEA
040AE:  MOVF   FEF,W
040B0:  SUBLW  03
040B2:  BNZ   40CC
040B4:  MOVLW  23
040B6:  ADDWF  x04,W
040B8:  MOVWF  01
040BA:  MOVLW  00
040BC:  ADDWFC x05,W
040BE:  MOVWF  03
040C0:  MOVFF  01,FE9
040C4:  MOVWF  FEA
040C6:  BTFSS  FEF.0
040C8:  BRA    40CC
....................          continue; 
040CA:  BRA    4470
....................  
....................  
....................       tick = TickGet(); 
040CC:  MOVLB  0
040CE:  CALL   2B2E
040D2:  MOVFF  02,903
040D6:  MOVFF  01,902
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
040DA:  MOVLW  1F
040DC:  MOVLB  9
040DE:  ADDWF  x04,W
040E0:  MOVWF  FE9
040E2:  MOVLW  00
040E4:  ADDWFC x05,W
040E6:  MOVWF  FEA
040E8:  MOVFF  FEC,03
040EC:  MOVF   FED,F
040EE:  MOVFF  FEF,01
040F2:  MOVF   x03,W
040F4:  SUBWF  03,W
040F6:  BNC   4100
040F8:  BNZ   4104
040FA:  MOVF   01,W
040FC:  SUBWF  x02,W
040FE:  BNC   4104
04100:  MOVLW  00
04102:  BRA    4106
04104:  MOVLW  01
04106:  CLRF   03
04108:  IORWF  03,W
0410A:  BZ    4142
0410C:  MOVLW  1F
0410E:  ADDWF  x04,W
04110:  MOVWF  FE9
04112:  MOVLW  00
04114:  ADDWFC x05,W
04116:  MOVWF  FEA
04118:  MOVFF  FEC,03
0411C:  MOVF   FED,F
0411E:  MOVF   FEF,W
04120:  SUBLW  FF
04122:  MOVWF  x0B
04124:  MOVLW  FF
04126:  SUBFWB 03,W
04128:  MOVWF  x0C
0412A:  MOVF   x02,W
0412C:  ADDWF  x0B,F
0412E:  MOVF   x03,W
04130:  ADDWFC x0C,F
04132:  MOVLW  01
04134:  ADDWF  x0B,W
04136:  MOVWF  01
04138:  MOVLW  00
0413A:  ADDWFC x0C,W
0413C:  MOVWF  03
0413E:  MOVF   01,W
04140:  BRA    4162
04142:  MOVLW  1F
04144:  ADDWF  x04,W
04146:  MOVWF  FE9
04148:  MOVLW  00
0414A:  ADDWFC x05,W
0414C:  MOVWF  FEA
0414E:  MOVFF  FEC,03
04152:  MOVF   FED,F
04154:  MOVF   FEF,W
04156:  SUBWF  x02,W
04158:  MOVWF  00
0415A:  MOVF   03,W
0415C:  SUBWFB x03,W
0415E:  MOVWF  03
04160:  MOVF   00,W
04162:  MOVWF  x00
04164:  MOVFF  03,901
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
04168:  MOVLW  21
0416A:  ADDWF  x04,W
0416C:  MOVWF  FE9
0416E:  MOVLW  00
04170:  ADDWFC x05,W
04172:  MOVWF  FEA
04174:  MOVFF  FEC,03
04178:  MOVF   FED,F
0417A:  MOVFF  FEF,01
0417E:  MOVF   x01,W
04180:  SUBWF  03,W
04182:  BNC   418E
04184:  BNZ   418C
04186:  MOVF   x00,W
04188:  SUBWF  01,W
0418A:  BNC   418E
....................          continue; 
0418C:  BRA    4470
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
0418E:  MOVLW  01
04190:  MOVWF  x86
04192:  MOVLB  0
04194:  CALL   2C46
04198:  MOVF   01,F
0419A:  BNZ   419E
....................          return; 
0419C:  BRA    4476
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
0419E:  MOVLW  1F
041A0:  MOVLB  9
041A2:  ADDWF  x04,W
041A4:  MOVWF  01
041A6:  MOVLW  00
041A8:  ADDWFC x05,W
041AA:  MOVWF  03
041AC:  MOVFF  01,90B
041B0:  MOVWF  x0C
041B2:  MOVLB  0
041B4:  CALL   2B2E
041B8:  MOVFF  90C,FEA
041BC:  MOVFF  90B,FE9
041C0:  MOVFF  02,FEC
041C4:  MOVF   FED,F
041C6:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
041CA:  MOVLW  21
041CC:  MOVLB  9
041CE:  ADDWF  x04,W
041D0:  MOVWF  FE9
041D2:  MOVLW  00
041D4:  ADDWFC x05,W
041D6:  MOVWF  FEA
041D8:  BCF    FD8.0
041DA:  RLCF   FEF,W
041DC:  MOVWF  02
041DE:  RLCF   FEC,W
041E0:  MOVWF  03
041E2:  MOVF   02,W
041E4:  MOVF   FED,F
041E6:  MOVWF  FEF
041E8:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
041EC:  MOVLW  1E
041EE:  ADDWF  x04,W
041F0:  MOVWF  FE9
041F2:  MOVLW  00
041F4:  ADDWFC x05,W
041F6:  MOVWF  FEA
041F8:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
041FA:  MOVFF  904,FE9
041FE:  MOVFF  905,FEA
04202:  MOVLW  01
04204:  SUBWF  FEF,W
04206:  ADDLW  F7
04208:  BTFSC  FD8.0
0420A:  BRA    4392
0420C:  ADDLW  09
0420E:  MOVLB  0
04210:  GOTO   447C
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
04214:  MOVLW  02
04216:  MOVLB  9
04218:  MOVWF  x0A
....................          break; 
0421A:  BRA    4392
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0421C:  MOVLW  1E
0421E:  MOVLB  9
04220:  ADDWF  x04,W
04222:  MOVWF  FE9
04224:  MOVLW  00
04226:  ADDWFC x05,W
04228:  MOVWF  FEA
0422A:  MOVF   FEF,W
0422C:  SUBLW  03
0422E:  BNC   4236
....................          { 
....................             flags = SYN | ACK; 
04230:  MOVLW  12
04232:  MOVWF  x0A
....................          } 
04234:  BRA    4262
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
04236:  MOVLW  23
04238:  ADDWF  x04,W
0423A:  MOVWF  FE9
0423C:  MOVLW  00
0423E:  ADDWFC x05,W
04240:  MOVWF  FEA
04242:  BTFSS  FEF.0
04244:  BRA    4252
....................             { 
....................                ps->smState = TCP_LISTEN; 
04246:  MOVFF  904,FE9
0424A:  MOVFF  905,FEA
0424E:  CLRF   FEF
....................             } 
04250:  BRA    4262
....................             else 
....................             { 
....................                flags = SYN; 
04252:  MOVLW  02
04254:  MOVWF  x0A
....................                ps->smState = TCP_SYN_SENT; 
04256:  MOVFF  904,FE9
0425A:  MOVFF  905,FEA
0425E:  MOVLW  01
04260:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
04262:  BRA    4392
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04264:  MOVLW  1E
04266:  MOVLB  9
04268:  ADDWF  x04,W
0426A:  MOVWF  FE9
0426C:  MOVLW  00
0426E:  ADDWFC x05,W
04270:  MOVWF  FEA
04272:  MOVF   FEF,W
04274:  SUBLW  03
04276:  BNC   42B6
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04278:  MOVLW  0F
0427A:  ADDWF  x04,W
0427C:  MOVWF  FE9
0427E:  MOVLW  00
04280:  ADDWFC x05,W
04282:  MOVWF  FEA
04284:  INCFSZ FEF,W
04286:  BRA    428A
04288:  BRA    42AC
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
0428A:  MOVLW  0F
0428C:  ADDWF  x04,W
0428E:  MOVWF  FE9
04290:  MOVLW  00
04292:  ADDWFC x05,W
04294:  MOVWF  FEA
04296:  MOVFF  FEF,99F
0429A:  CLRF   xA1
0429C:  CLRF   xA0
0429E:  MOVLB  0
042A0:  CALL   1B20
....................                MACFlush(); 
042A4:  CALL   1CFC
....................             } 
042A8:  BRA    42B2
042AA:  MOVLB  9
....................             else 
....................                flags = ACK; 
042AC:  MOVLW  10
042AE:  MOVWF  x0A
042B0:  MOVLB  0
....................          } 
042B2:  BRA    4300
042B4:  MOVLB  9
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
042B6:  MOVLW  0F
042B8:  ADDWF  x04,W
042BA:  MOVWF  FE9
042BC:  MOVLW  00
042BE:  ADDWFC x05,W
042C0:  MOVWF  FEA
042C2:  INCFSZ FEF,W
042C4:  BRA    42C8
042C6:  BRA    42EE
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
042C8:  MOVLW  0F
042CA:  ADDWF  x04,W
042CC:  MOVWF  FE9
042CE:  MOVLW  00
042D0:  ADDWFC x05,W
042D2:  MOVWF  FEA
042D4:  MOVFF  FEF,94D
042D8:  MOVLB  0
042DA:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
042DE:  MOVLW  0F
042E0:  MOVLB  9
042E2:  ADDWF  x04,W
042E4:  MOVWF  FE9
042E6:  MOVLW  00
042E8:  ADDWFC x05,W
042EA:  MOVWF  FEA
042EC:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
042EE:  MOVLW  11
042F0:  MOVWF  x0A
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
042F2:  MOVFF  904,FE9
042F6:  MOVFF  905,FEA
042FA:  MOVLW  04
042FC:  MOVWF  FEF
042FE:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
04300:  MOVLB  9
04302:  BRA    4392
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04304:  MOVLW  1E
04306:  MOVLB  9
04308:  ADDWF  x04,W
0430A:  MOVWF  FE9
0430C:  MOVLW  00
0430E:  ADDWFC x05,W
04310:  MOVWF  FEA
04312:  MOVF   FEF,W
04314:  SUBLW  03
04316:  BNC   431E
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
04318:  MOVLW  01
0431A:  MOVWF  x0A
....................          } 
0431C:  BRA    432E
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
0431E:  MOVFF  905,94B
04322:  MOVFF  904,94A
04326:  MOVLB  0
04328:  CALL   2B48
0432C:  MOVLB  9
....................          } 
....................          break; 
0432E:  BRA    4392
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
04330:  MOVFF  905,94B
04334:  MOVFF  904,94A
04338:  CALL   2B48
....................          break; 
0433C:  MOVLB  9
0433E:  BRA    4392
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
04340:  MOVFF  905,94B
04344:  MOVFF  904,94A
04348:  CALL   2B48
....................          break; 
0434C:  MOVLB  9
0434E:  BRA    4392
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
04350:  MOVLW  01
04352:  MOVLB  9
04354:  MOVWF  x0A
....................          ps->smState = TCP_LAST_ACK; 
04356:  MOVFF  904,FE9
0435A:  MOVFF  905,FEA
0435E:  MOVLW  09
04360:  MOVWF  FEF
....................          break; 
04362:  BRA    4392
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04364:  MOVLW  1E
04366:  MOVLB  9
04368:  ADDWF  x04,W
0436A:  MOVWF  FE9
0436C:  MOVLW  00
0436E:  ADDWFC x05,W
04370:  MOVWF  FEA
04372:  MOVF   FEF,W
04374:  SUBLW  03
04376:  BNC   437E
....................             flags = FIN; 
04378:  MOVLW  01
0437A:  MOVWF  x0A
0437C:  BRA    438E
....................          else 
....................             CloseSocket(ps); 
0437E:  MOVFF  905,94B
04382:  MOVFF  904,94A
04386:  MOVLB  0
04388:  CALL   2B48
0438C:  MOVLB  9
....................          break; 
0438E:  BRA    4392
04390:  MOVLB  9
....................       } 
....................  
....................  
....................       if(flags) 
04392:  MOVF   x0A,F
04394:  BZ    4470
....................       { 
....................          if(flags & ACK) 
04396:  BTFSS  x0A.4
04398:  BRA    43B8
....................             seq = ps->SND_SEQ; 
0439A:  MOVLW  16
0439C:  ADDWF  x04,W
0439E:  MOVWF  FE9
043A0:  MOVLW  00
043A2:  ADDWFC x05,W
043A4:  MOVWF  FEA
043A6:  MOVFF  FEF,906
043AA:  MOVFF  FEC,907
043AE:  MOVFF  FEC,908
043B2:  MOVFF  FEC,909
043B6:  BRA    43EC
....................          else 
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
043B8:  MOVLW  16
043BA:  ADDWF  x04,W
043BC:  MOVWF  FE9
043BE:  MOVLW  00
043C0:  ADDWFC x05,W
043C2:  MOVWF  FEA
043C4:  MOVFF  FEF,906
043C8:  MOVFF  FEC,907
043CC:  MOVFF  FEC,908
043D0:  MOVFF  FEC,909
....................             ps->SND_SEQ++; 
043D4:  MOVLW  16
043D6:  ADDWF  x04,W
043D8:  MOVWF  FE9
043DA:  MOVLW  00
043DC:  ADDWFC x05,W
043DE:  MOVWF  FEA
043E0:  MOVLW  01
043E2:  ADDWF  FEE,F
043E4:  MOVLW  00
043E6:  ADDWFC FEE,F
043E8:  ADDWFC FEE,F
043EA:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
043EC:  MOVLW  01
043EE:  ADDWF  x04,W
043F0:  MOVWF  01
043F2:  MOVLW  00
043F4:  ADDWFC x05,W
043F6:  MOVWF  03
043F8:  MOVFF  01,90B
043FC:  MOVWF  x0C
043FE:  MOVLW  0B
04400:  ADDWF  x04,W
04402:  MOVWF  FE9
04404:  MOVLW  00
04406:  ADDWFC x05,W
04408:  MOVWF  FEA
0440A:  MOVFF  FEC,951
0440E:  MOVF   FED,F
04410:  MOVFF  FEF,950
04414:  MOVLW  0D
04416:  ADDWF  x04,W
04418:  MOVWF  FE9
0441A:  MOVLW  00
0441C:  ADDWFC x05,W
0441E:  MOVWF  FEA
04420:  MOVFF  FEC,953
04424:  MOVF   FED,F
04426:  MOVFF  FEF,952
0442A:  MOVLW  1A
0442C:  ADDWF  x04,W
0442E:  MOVWF  FE9
04430:  MOVLW  00
04432:  ADDWFC x05,W
04434:  MOVWF  FEA
04436:  MOVFF  FEF,958
0443A:  MOVFF  FEC,959
0443E:  MOVFF  FEC,95A
04442:  MOVFF  FEC,95B
04446:  MOVFF  03,94F
0444A:  MOVFF  01,94E
0444E:  MOVFF  909,957
04452:  MOVFF  908,956
04456:  MOVFF  907,955
0445A:  MOVFF  906,954
0445E:  MOVFF  90A,95C
04462:  SETF   x5D
04464:  CLRF   x5F
04466:  CLRF   x5E
04468:  MOVLB  0
0446A:  CALL   2F84
0446E:  MOVLB  9
....................       } 
04470:  MOVLB  8
04472:  INCF   xFF,F
04474:  BRA    401E
04476:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
04478:  GOTO   4668 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
03BC0:  MOVLW  06
03BC2:  MOVLB  8
03BC4:  ADDWF  xFF,W
03BC6:  MOVWF  FE9
03BC8:  MOVLW  00
03BCA:  MOVLB  9
03BCC:  ADDWFC x00,W
03BCE:  MOVWF  FEA
03BD0:  MOVFF  FEF,919
03BD4:  MOVFF  FEC,91A
03BD8:  MOVFF  FEC,91B
03BDC:  MOVFF  FEC,91C
....................    pseudoHeader.DestAddress        = *localIP; 
03BE0:  MOVFF  902,03
03BE4:  MOVFF  901,FE9
03BE8:  MOVFF  03,FEA
03BEC:  MOVFF  FEF,91D
03BF0:  MOVFF  FEC,91E
03BF4:  MOVFF  FEC,91F
03BF8:  MOVFF  FEC,920
....................    pseudoHeader.Zero               = 0x0; 
03BFC:  CLRF   x21
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
03BFE:  MOVLW  06
03C00:  MOVWF  x22
....................    pseudoHeader.TCPLength          = len; 
03C02:  MOVFF  904,924
03C06:  MOVFF  903,923
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03C0A:  MOVFF  924,9A6
03C0E:  MOVFF  923,9A5
03C12:  MOVLB  0
03C14:  CALL   17DC
03C18:  MOVFF  02,924
03C1C:  MOVFF  01,923
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03C20:  MOVLW  09
03C22:  MOVLB  9
03C24:  MOVWF  x2C
03C26:  MOVLW  19
03C28:  MOVWF  x2B
03C2A:  MOVFF  92C,989
03C2E:  MOVWF  x88
03C30:  CLRF   x8B
03C32:  MOVLW  0C
03C34:  MOVWF  x8A
03C36:  MOVLB  0
03C38:  CALL   248E
03C3C:  MOVFF  01,926
03C40:  MOVLB  9
03C42:  COMF   x26,F
03C44:  MOVFF  02,927
03C48:  COMF   x27,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
03C4A:  MOVFF  904,987
03C4E:  MOVFF  903,986
03C52:  MOVLB  0
03C54:  CALL   25BC
03C58:  MOVFF  02,929
03C5C:  MOVFF  01,928
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
03C60:  MOVLB  9
03C62:  MOVF   x29,W
03C64:  SUBWF  x26,W
03C66:  BNZ   3C6E
03C68:  MOVF   x28,W
03C6A:  SUBWF  x27,W
03C6C:  BZ    3C7C
....................    { 
....................       MACDiscardRx(); 
03C6E:  MOVLB  0
03C70:  CALL   1706
....................       return TRUE; 
03C74:  MOVLW  01
03C76:  MOVWF  01
03C78:  BRA    3D58
03C7A:  MOVLB  9
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
03C7C:  CLRF   x2E
03C7E:  CLRF   x2D
03C80:  MOVLB  0
03C82:  CALL   2714
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
03C86:  MOVLW  09
03C88:  MOVLB  9
03C8A:  MOVWF  x2C
03C8C:  MOVLW  05
03C8E:  MOVWF  x2B
03C90:  MOVFF  92C,995
03C94:  MOVWF  x94
03C96:  CLRF   x97
03C98:  MOVLW  14
03C9A:  MOVWF  x96
03C9C:  MOVLB  0
03C9E:  CALL   177C
....................    SwapTCPHeader(&TCPHeader); 
03CA2:  MOVLW  09
03CA4:  MOVLB  9
03CA6:  MOVWF  x87
03CA8:  MOVLW  05
03CAA:  MOVWF  x86
03CAC:  MOVLB  0
03CAE:  CALL   2752
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
03CB2:  MOVLB  9
03CB4:  MOVFF  911,00
03CB8:  SWAPF  00,W
03CBA:  ANDLW  0F
03CBC:  MOVWF  00
03CBE:  RLCF   00,F
03CC0:  RLCF   00,F
03CC2:  MOVLW  FC
03CC4:  ANDWF  00,F
03CC6:  MOVF   00,W
03CC8:  ADDLW  EC
03CCA:  MOVWF  x2A
....................    len = len - optionsSize - sizeof(TCPHeader); 
03CCC:  MOVF   x2A,W
03CCE:  SUBWF  x03,W
03CD0:  MOVWF  x2B
03CD2:  MOVLW  00
03CD4:  SUBWFB x04,W
03CD6:  MOVWF  x2C
03CD8:  MOVLW  14
03CDA:  SUBWF  x2B,W
03CDC:  MOVWF  x03
03CDE:  MOVLW  00
03CE0:  SUBWFB x2C,W
03CE2:  MOVWF  x04
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
03CE4:  MOVFF  911,00
03CE8:  SWAPF  00,W
03CEA:  ANDLW  0F
03CEC:  MOVWF  00
03CEE:  RLCF   00,W
03CF0:  MOVWF  x2B
03CF2:  RLCF   x2B,F
03CF4:  MOVLW  FC
03CF6:  ANDWF  x2B,F
03CF8:  CLRF   x2E
03CFA:  MOVFF  92B,92D
03CFE:  MOVLB  0
03D00:  CALL   2714
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
03D04:  MOVLW  09
03D06:  MOVLB  9
03D08:  MOVWF  x2D
03D0A:  MOVLW  05
03D0C:  MOVWF  x2C
03D0E:  MOVFF  900,92F
03D12:  MOVFF  8FF,92E
03D16:  MOVLB  0
03D18:  GOTO   292C
03D1C:  MOVFF  01,925
....................    if(socket != INVALID_SOCKET) 
03D20:  MOVLB  9
03D22:  MOVF   x25,W
03D24:  SUBLW  FE
03D26:  BZ    3D4E
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
03D28:  MOVFF  925,92C
03D2C:  MOVFF  900,92E
03D30:  MOVFF  8FF,92D
03D34:  MOVLW  09
03D36:  MOVWF  x30
03D38:  MOVLW  05
03D3A:  MOVWF  x2F
03D3C:  MOVFF  904,932
03D40:  MOVFF  903,931
03D44:  MOVLB  0
03D46:  GOTO   31A8
....................    } 
03D4A:  BRA    3D54
03D4C:  MOVLB  9
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
03D4E:  MOVLB  0
03D50:  CALL   1706
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
03D54:  MOVLW  01
03D56:  MOVWF  01
03D58:  GOTO   45A2 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
02F84:  MOVLW  01
02F86:  MOVLB  9
02F88:  MOVWF  x86
02F8A:  MOVLB  0
02F8C:  RCALL  2C46
02F8E:  MOVF   01,F
02F90:  BZ    2F84
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
02F92:  MOVLB  9
02F94:  INCFSZ x5D,W
02F96:  BRA    2FA8
....................       buff = MACGetTxBuffer(TRUE); 
02F98:  MOVLW  01
02F9A:  MOVWF  x86
02F9C:  MOVLB  0
02F9E:  CALL   1AF8
02FA2:  MOVFF  01,95D
02FA6:  MOVLB  9
....................  
....................    if(buff == INVALID_BUFFER) 
02FA8:  INCFSZ x5D,W
02FAA:  BRA    2FAE
....................       return; 
02FAC:  BRA    31A4
....................  
....................    IPSetTxBuffer(buff, 0); 
02FAE:  MOVFF  95D,99F
02FB2:  CLRF   xA1
02FB4:  MOVLW  14
02FB6:  MOVWF  xA0
02FB8:  MOVLB  0
02FBA:  CALL   1B20
....................  
....................    header.SourcePort           = localPort; 
02FBE:  MOVFF  951,963
02FC2:  MOVFF  950,962
....................    header.DestPort             = remotePort; 
02FC6:  MOVFF  953,965
02FCA:  MOVFF  952,964
....................    header.SeqNumber            = tseq; 
02FCE:  MOVFF  957,969
02FD2:  MOVFF  956,968
02FD6:  MOVFF  955,967
02FDA:  MOVFF  954,966
....................    header.AckNumber            = tack; 
02FDE:  MOVFF  95B,96D
02FE2:  MOVFF  95A,96C
02FE6:  MOVFF  959,96B
02FEA:  MOVFF  958,96A
....................    header.Flags.bits.Reserved2 = 0; 
02FEE:  MOVLW  3F
02FF0:  MOVLB  9
02FF2:  ANDWF  x6F,W
02FF4:  MOVWF  x6F
....................    header.DataOffset.Reserved3 = 0; 
02FF6:  MOVLW  F0
02FF8:  ANDWF  x6E,W
02FFA:  MOVWF  x6E
....................    header.Flags.b              = flags; 
02FFC:  MOVFF  95C,96F
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
03000:  MOVLB  0
03002:  BRA    2C6E
03004:  MOVFF  02,971
03008:  MOVFF  01,970
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
0300C:  MOVLB  9
0300E:  MOVF   x71,F
03010:  BNZ   3018
03012:  MOVF   x70,W
03014:  SUBLW  28
03016:  BC    3022
....................    { 
....................       header.Window -= 40; 
03018:  MOVLW  28
0301A:  SUBWF  x70,F
0301C:  MOVLW  00
0301E:  SUBWFB x71,F
....................    } 
03020:  BRA    3026
....................    else 
....................       header.Window = 0; 
03022:  CLRF   x71
03024:  CLRF   x70
.................... #endif 
....................  
....................    header.Checksum             = 0; 
03026:  CLRF   x73
03028:  CLRF   x72
....................    header.UrgentPointer        = 0; 
0302A:  CLRF   x75
0302C:  CLRF   x74
....................  
....................    SwapTCPHeader(&header); 
0302E:  MOVLW  09
03030:  MOVWF  x87
03032:  MOVLW  62
03034:  MOVWF  x86
03036:  MOVLB  0
03038:  CALL   2752
....................  
....................    len += sizeof(header); 
0303C:  MOVLW  14
0303E:  MOVLB  9
03040:  ADDWF  x5E,F
03042:  MOVLW  00
03044:  ADDWFC x5F,F
....................  
....................    if ( flags & SYN ) 
03046:  BTFSS  x5C.1
03048:  BRA    3068
....................    { 
....................       len += sizeof(options); 
0304A:  MOVLW  04
0304C:  ADDWF  x5E,F
0304E:  MOVLW  00
03050:  ADDWFC x5F,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03052:  MOVLW  02
03054:  MOVWF  x76
....................       options.Length = 0x04; 
03056:  MOVLW  04
03058:  MOVWF  x77
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
0305A:  MOVWF  x78
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
0305C:  CLRF   x79
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
0305E:  MOVLW  0F
03060:  ANDWF  x6E,W
03062:  IORLW  60
03064:  MOVWF  x6E
....................    } 
03066:  BRA    3070
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
03068:  MOVLW  0F
0306A:  ANDWF  x6E,W
0306C:  IORLW  50
0306E:  MOVWF  x6E
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03070:  MOVFF  356,97D
03074:  MOVFF  355,97C
03078:  MOVFF  354,97B
0307C:  MOVFF  353,97A
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
03080:  MOVLW  06
03082:  ADDWF  x4E,W
03084:  MOVWF  FE9
03086:  MOVLW  00
03088:  ADDWFC x4F,W
0308A:  MOVWF  FEA
0308C:  MOVFF  FEF,97E
03090:  MOVFF  FEC,97F
03094:  MOVFF  FEC,980
03098:  MOVFF  FEC,981
....................    pseudoHeader.Zero           = 0x0; 
0309C:  CLRF   x82
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
0309E:  MOVLW  06
030A0:  MOVWF  x83
....................    pseudoHeader.TCPLength      = len; 
030A2:  MOVFF  95F,985
030A6:  MOVFF  95E,984
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
030AA:  MOVFF  985,9A6
030AE:  MOVFF  984,9A5
030B2:  MOVLB  0
030B4:  CALL   17DC
030B8:  MOVFF  02,985
030BC:  MOVFF  01,984
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
030C0:  MOVLW  09
030C2:  MOVLB  9
030C4:  MOVWF  x87
030C6:  MOVLW  7A
030C8:  MOVWF  x86
030CA:  MOVFF  987,989
030CE:  MOVWF  x88
030D0:  CLRF   x8B
030D2:  MOVLW  0C
030D4:  MOVWF  x8A
030D6:  MOVLB  0
030D8:  CALL   248E
030DC:  MOVFF  01,972
030E0:  MOVLB  9
030E2:  COMF   x72,F
030E4:  MOVFF  02,973
030E8:  COMF   x73,F
....................    checkSum.Val = header.Checksum; 
030EA:  MOVFF  973,961
030EE:  MOVFF  972,960
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
030F2:  MOVFF  94F,987
030F6:  MOVFF  94E,986
030FA:  MOVLW  06
030FC:  MOVWF  x88
030FE:  MOVFF  95F,98A
03102:  MOVFF  95E,989
03106:  MOVLB  0
03108:  RCALL  2E5E
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
0310A:  MOVLW  09
0310C:  MOVLB  9
0310E:  MOVWF  x87
03110:  MOVLW  62
03112:  MOVWF  x86
03114:  MOVFF  987,9AB
03118:  MOVWF  xAA
0311A:  CLRF   xAD
0311C:  MOVLW  14
0311E:  MOVWF  xAC
03120:  MOVLB  0
03122:  CALL   1BDC
....................  
....................    if ( flags & SYN ) 
03126:  MOVLB  9
03128:  BTFSS  x5C.1
0312A:  BRA    3148
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
0312C:  MOVLW  09
0312E:  MOVWF  x87
03130:  MOVLW  76
03132:  MOVWF  x86
03134:  MOVFF  987,9AB
03138:  MOVWF  xAA
0313A:  CLRF   xAD
0313C:  MOVLW  04
0313E:  MOVWF  xAC
03140:  MOVLB  0
03142:  CALL   1BDC
03146:  MOVLB  9
....................  
....................    IPSetTxBuffer(buff, 0); 
03148:  MOVFF  95D,99F
0314C:  CLRF   xA1
0314E:  MOVLW  14
03150:  MOVWF  xA0
03152:  MOVLB  0
03154:  CALL   1B20
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
03158:  MOVFF  95F,987
0315C:  MOVFF  95E,986
03160:  CALL   25BC
03164:  MOVFF  02,961
03168:  MOVFF  01,960
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
0316C:  MOVFF  95D,99F
03170:  MOVLB  9
03172:  CLRF   xA1
03174:  MOVLW  24
03176:  MOVWF  xA0
03178:  MOVLB  0
0317A:  CALL   1B20
....................    MACPut(checkSum.v[1]); 
0317E:  MOVFF  961,9AA
03182:  CALL   1BBE
....................    MACPut(checkSum.v[0]); 
03186:  MOVFF  960,9AA
0318A:  CALL   1BBE
....................    MACSetTxBuffer(buff, 0); 
0318E:  MOVFF  95D,99F
03192:  MOVLB  9
03194:  CLRF   xA1
03196:  CLRF   xA0
03198:  MOVLB  0
0319A:  CALL   1B20
....................  
....................    MACFlush(); 
0319E:  CALL   1CFC
031A2:  MOVLB  9
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
031A4:  MOVLB  0
031A6:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
0292C:  MOVLW  FE
0292E:  MOVLB  9
02930:  MOVWF  x33
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
02932:  CLRF   x32
02934:  MOVF   x32,W
02936:  SUBLW  22
02938:  BTFSS  FD8.0
0293A:  BRA    2A42
....................    { 
....................       ps = &TCB[s]; 
0293C:  CLRF   x4B
0293E:  MOVFF  932,94A
02942:  CLRF   x4D
02944:  MOVLW  24
02946:  MOVWF  x4C
02948:  MOVLB  0
0294A:  CALL   0FE8
0294E:  MOVFF  02,03
02952:  MOVF   01,W
02954:  ADDLW  9A
02956:  MOVWF  01
02958:  MOVLW  03
0295A:  ADDWFC 03,F
0295C:  MOVFF  01,930
02960:  MOVLB  9
02962:  MOVFF  03,931
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
02966:  MOVFF  930,FE9
0296A:  MOVFF  931,FEA
0296E:  MOVF   FEF,W
02970:  SUBLW  0A
02972:  BZ    2A3E
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
02974:  MOVLW  0B
02976:  ADDWF  x30,W
02978:  MOVWF  FE9
0297A:  MOVLW  00
0297C:  ADDWFC x31,W
0297E:  MOVWF  FEA
02980:  MOVFF  FEC,935
02984:  MOVF   FED,F
02986:  MOVFF  FEF,934
0298A:  MOVLW  02
0298C:  ADDWF  x2C,W
0298E:  MOVWF  FE9
02990:  MOVLW  00
02992:  ADDWFC x2D,W
02994:  MOVWF  FEA
02996:  MOVFF  FEC,03
0299A:  MOVF   FED,F
0299C:  MOVF   FEF,W
0299E:  SUBWF  x34,W
029A0:  BNZ   2A3E
029A2:  MOVF   03,W
029A4:  SUBWF  x35,W
029A6:  BNZ   2A3E
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
029A8:  MOVFF  930,FE9
029AC:  MOVFF  931,FEA
029B0:  MOVF   FEF,F
029B2:  BNZ   29B8
....................                partialMatch = s; 
029B4:  MOVFF  932,933
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
029B8:  MOVLW  0D
029BA:  ADDWF  x30,W
029BC:  MOVWF  FE9
029BE:  MOVLW  00
029C0:  ADDWFC x31,W
029C2:  MOVWF  FEA
029C4:  MOVFF  FEC,935
029C8:  MOVF   FED,F
029CA:  MOVFF  FEF,934
029CE:  MOVFF  92C,FE9
029D2:  MOVFF  92D,FEA
029D6:  MOVFF  FEC,03
029DA:  MOVF   FED,F
029DC:  MOVF   FEF,W
029DE:  SUBWF  x34,W
029E0:  BNZ   2A3E
029E2:  MOVF   03,W
029E4:  SUBWF  x35,W
029E6:  BNZ   2A3E
029E8:  MOVLW  07
029EA:  ADDWF  x30,W
029EC:  MOVWF  FE9
029EE:  MOVLW  00
029F0:  ADDWFC x31,W
029F2:  MOVWF  FEA
029F4:  MOVFF  FEF,934
029F8:  MOVFF  FEC,935
029FC:  MOVFF  FEC,936
02A00:  MOVFF  FEC,937
02A04:  MOVLW  06
02A06:  ADDWF  x2E,W
02A08:  MOVWF  FE9
02A0A:  MOVLW  00
02A0C:  ADDWFC x2F,W
02A0E:  MOVWF  FEA
02A10:  MOVFF  FEF,00
02A14:  MOVFF  FEC,01
02A18:  MOVFF  FEC,02
02A1C:  MOVFF  FEC,03
02A20:  MOVF   00,W
02A22:  SUBWF  x34,W
02A24:  BNZ   2A3E
02A26:  MOVF   01,W
02A28:  SUBWF  x35,W
02A2A:  BNZ   2A3E
02A2C:  MOVF   02,W
02A2E:  SUBWF  x36,W
02A30:  BNZ   2A3E
02A32:  MOVF   03,W
02A34:  SUBWF  x37,W
02A36:  BNZ   2A3E
....................             { 
....................                return s; 
02A38:  MOVFF  932,01
02A3C:  BRA    2B28
....................             } 
....................          } 
....................       } 
02A3E:  INCF   x32,F
02A40:  BRA    2934
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
02A42:  MOVF   x33,W
02A44:  SUBLW  FE
02A46:  BNZ   2A4E
....................       return INVALID_SOCKET; 
02A48:  MOVLW  FE
02A4A:  MOVWF  01
02A4C:  BRA    2B28
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
02A4E:  CLRF   x4B
02A50:  MOVFF  933,94A
02A54:  CLRF   x4D
02A56:  MOVLW  24
02A58:  MOVWF  x4C
02A5A:  MOVLB  0
02A5C:  CALL   0FE8
02A60:  MOVFF  02,03
02A64:  MOVF   01,W
02A66:  ADDLW  9A
02A68:  MOVWF  01
02A6A:  MOVLW  03
02A6C:  ADDWFC 03,F
02A6E:  MOVFF  01,930
02A72:  MOVLB  9
02A74:  MOVFF  03,931
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
02A78:  MOVLW  01
02A7A:  ADDWF  x30,W
02A7C:  MOVWF  01
02A7E:  MOVLW  00
02A80:  ADDWFC x31,W
02A82:  MOVWF  03
02A84:  MOVFF  01,934
02A88:  MOVWF  x35
02A8A:  MOVWF  FEA
02A8C:  MOVFF  01,FE9
02A90:  MOVFF  92F,FE2
02A94:  MOVFF  92E,FE1
02A98:  MOVLW  0A
02A9A:  MOVWF  01
02A9C:  MOVFF  FE6,FEE
02AA0:  DECFSZ 01,F
02AA2:  BRA    2A9C
....................    ps->remotePort          = h->SourcePort; 
02AA4:  MOVLW  0D
02AA6:  ADDWF  x30,W
02AA8:  MOVWF  01
02AAA:  MOVLW  00
02AAC:  ADDWFC x31,W
02AAE:  MOVFF  92C,FE9
02AB2:  MOVFF  92D,FEA
02AB6:  MOVFF  FEC,03
02ABA:  MOVF   FED,F
02ABC:  MOVFF  FEF,936
02AC0:  MOVWF  FEA
02AC2:  MOVFF  01,FE9
02AC6:  MOVFF  03,FEC
02ACA:  MOVF   FED,F
02ACC:  MOVFF  936,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
02AD0:  MOVLW  23
02AD2:  ADDWF  x30,W
02AD4:  MOVWF  FE9
02AD6:  MOVLW  00
02AD8:  ADDWFC x31,W
02ADA:  MOVWF  FEA
02ADC:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
02ADE:  MOVLW  0F
02AE0:  ADDWF  x30,W
02AE2:  MOVWF  FE9
02AE4:  MOVLW  00
02AE6:  ADDWFC x31,W
02AE8:  MOVWF  FEA
02AEA:  INCFSZ FEF,W
02AEC:  BRA    2AF0
02AEE:  BRA    2B16
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
02AF0:  MOVLW  0F
02AF2:  ADDWF  x30,W
02AF4:  MOVWF  FE9
02AF6:  MOVLW  00
02AF8:  ADDWFC x31,W
02AFA:  MOVWF  FEA
02AFC:  MOVFF  FEF,94D
02B00:  MOVLB  0
02B02:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
02B06:  MOVLW  0F
02B08:  MOVLB  9
02B0A:  ADDWF  x30,W
02B0C:  MOVWF  FE9
02B0E:  MOVLW  00
02B10:  ADDWFC x31,W
02B12:  MOVWF  FEA
02B14:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
02B16:  MOVLW  23
02B18:  ADDWF  x30,W
02B1A:  MOVWF  FE9
02B1C:  MOVLW  00
02B1E:  ADDWFC x31,W
02B20:  MOVWF  FEA
02B22:  BSF    FEF.1
....................  
....................    return partialMatch; 
02B24:  MOVFF  933,01
02B28:  MOVLB  0
02B2A:  GOTO   3D1C (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
02752:  MOVLB  9
02754:  MOVFF  986,01
02758:  MOVFF  987,989
0275C:  MOVFF  01,988
02760:  MOVFF  986,FE9
02764:  MOVFF  987,FEA
02768:  MOVFF  FEC,9A6
0276C:  MOVF   FED,F
0276E:  MOVFF  FEF,9A5
02772:  MOVLB  0
02774:  CALL   17DC
02778:  MOVFF  989,FEA
0277C:  MOVFF  988,FE9
02780:  MOVFF  02,FEC
02784:  MOVF   FED,F
02786:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
0278A:  MOVLW  02
0278C:  MOVLB  9
0278E:  ADDWF  x86,W
02790:  MOVWF  01
02792:  MOVLW  00
02794:  ADDWFC x87,W
02796:  MOVWF  03
02798:  MOVFF  01,988
0279C:  MOVWF  x89
0279E:  MOVLW  02
027A0:  ADDWF  x86,W
027A2:  MOVWF  FE9
027A4:  MOVLW  00
027A6:  ADDWFC x87,W
027A8:  MOVWF  FEA
027AA:  MOVFF  FEC,9A6
027AE:  MOVF   FED,F
027B0:  MOVFF  FEF,9A5
027B4:  MOVLB  0
027B6:  CALL   17DC
027BA:  MOVFF  989,FEA
027BE:  MOVFF  988,FE9
027C2:  MOVFF  02,FEC
027C6:  MOVF   FED,F
027C8:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
027CC:  MOVLW  04
027CE:  MOVLB  9
027D0:  ADDWF  x86,W
027D2:  MOVWF  01
027D4:  MOVLW  00
027D6:  ADDWFC x87,W
027D8:  MOVWF  03
027DA:  MOVFF  01,988
027DE:  MOVWF  x89
027E0:  MOVLW  04
027E2:  ADDWF  x86,W
027E4:  MOVWF  FE9
027E6:  MOVLW  00
027E8:  ADDWFC x87,W
027EA:  MOVWF  FEA
027EC:  MOVFF  FEF,98E
027F0:  MOVFF  FEC,98F
027F4:  MOVFF  FEC,990
027F8:  MOVFF  FEC,991
027FC:  MOVLB  0
027FE:  RCALL  2730
02800:  MOVFF  989,FEA
02804:  MOVFF  988,FE9
02808:  MOVFF  00,FEF
0280C:  MOVFF  01,FEC
02810:  MOVFF  02,FEC
02814:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
02818:  MOVLW  08
0281A:  MOVLB  9
0281C:  ADDWF  x86,W
0281E:  MOVWF  01
02820:  MOVLW  00
02822:  ADDWFC x87,W
02824:  MOVWF  03
02826:  MOVFF  01,988
0282A:  MOVWF  x89
0282C:  MOVLW  08
0282E:  ADDWF  x86,W
02830:  MOVWF  FE9
02832:  MOVLW  00
02834:  ADDWFC x87,W
02836:  MOVWF  FEA
02838:  MOVFF  FEF,98E
0283C:  MOVFF  FEC,98F
02840:  MOVFF  FEC,990
02844:  MOVFF  FEC,991
02848:  MOVLB  0
0284A:  RCALL  2730
0284C:  MOVFF  989,FEA
02850:  MOVFF  988,FE9
02854:  MOVFF  00,FEF
02858:  MOVFF  01,FEC
0285C:  MOVFF  02,FEC
02860:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
02864:  MOVLW  0E
02866:  MOVLB  9
02868:  ADDWF  x86,W
0286A:  MOVWF  01
0286C:  MOVLW  00
0286E:  ADDWFC x87,W
02870:  MOVWF  03
02872:  MOVFF  01,988
02876:  MOVWF  x89
02878:  MOVLW  0E
0287A:  ADDWF  x86,W
0287C:  MOVWF  FE9
0287E:  MOVLW  00
02880:  ADDWFC x87,W
02882:  MOVWF  FEA
02884:  MOVFF  FEC,9A6
02888:  MOVF   FED,F
0288A:  MOVFF  FEF,9A5
0288E:  MOVLB  0
02890:  CALL   17DC
02894:  MOVFF  989,FEA
02898:  MOVFF  988,FE9
0289C:  MOVFF  02,FEC
028A0:  MOVF   FED,F
028A2:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
028A6:  MOVLW  10
028A8:  MOVLB  9
028AA:  ADDWF  x86,W
028AC:  MOVWF  01
028AE:  MOVLW  00
028B0:  ADDWFC x87,W
028B2:  MOVWF  03
028B4:  MOVFF  01,988
028B8:  MOVWF  x89
028BA:  MOVLW  10
028BC:  ADDWF  x86,W
028BE:  MOVWF  FE9
028C0:  MOVLW  00
028C2:  ADDWFC x87,W
028C4:  MOVWF  FEA
028C6:  MOVFF  FEC,9A6
028CA:  MOVF   FED,F
028CC:  MOVFF  FEF,9A5
028D0:  MOVLB  0
028D2:  CALL   17DC
028D6:  MOVFF  989,FEA
028DA:  MOVFF  988,FE9
028DE:  MOVFF  02,FEC
028E2:  MOVF   FED,F
028E4:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
028E8:  MOVLW  12
028EA:  MOVLB  9
028EC:  ADDWF  x86,W
028EE:  MOVWF  01
028F0:  MOVLW  00
028F2:  ADDWFC x87,W
028F4:  MOVWF  03
028F6:  MOVFF  01,988
028FA:  MOVWF  x89
028FC:  MOVLW  12
028FE:  ADDWF  x86,W
02900:  MOVWF  FE9
02902:  MOVLW  00
02904:  ADDWFC x87,W
02906:  MOVWF  FEA
02908:  MOVFF  FEC,9A6
0290C:  MOVF   FED,F
0290E:  MOVFF  FEF,9A5
02912:  MOVLB  0
02914:  CALL   17DC
02918:  MOVFF  989,FEA
0291C:  MOVFF  988,FE9
02920:  MOVFF  02,FEC
02924:  MOVF   FED,F
02926:  MOVFF  01,FEF
0292A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
02B48:  MOVLW  0F
02B4A:  MOVLB  9
02B4C:  ADDWF  x4A,W
02B4E:  MOVWF  FE9
02B50:  MOVLW  00
02B52:  ADDWFC x4B,W
02B54:  MOVWF  FEA
02B56:  INCFSZ FEF,W
02B58:  BRA    2B5C
02B5A:  BRA    2B90
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
02B5C:  MOVLW  0F
02B5E:  ADDWF  x4A,W
02B60:  MOVWF  FE9
02B62:  MOVLW  00
02B64:  ADDWFC x4B,W
02B66:  MOVWF  FEA
02B68:  MOVFF  FEF,94D
02B6C:  MOVLB  0
02B6E:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
02B72:  MOVLW  0F
02B74:  MOVLB  9
02B76:  ADDWF  x4A,W
02B78:  MOVWF  FE9
02B7A:  MOVLW  00
02B7C:  ADDWFC x4B,W
02B7E:  MOVWF  FEA
02B80:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
02B82:  MOVLW  23
02B84:  ADDWF  x4A,W
02B86:  MOVWF  FE9
02B88:  MOVLW  00
02B8A:  ADDWFC x4B,W
02B8C:  MOVWF  FEA
02B8E:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
02B90:  MOVLW  07
02B92:  ADDWF  x4A,W
02B94:  MOVWF  FE9
02B96:  MOVLW  00
02B98:  ADDWFC x4B,W
02B9A:  MOVWF  FEA
02B9C:  MOVF   FEE,F
02B9E:  MOVF   FEE,F
02BA0:  CLRF   FEC
02BA2:  MOVF   FED,F
02BA4:  CLRF   FEF
02BA6:  MOVF   FED,F
02BA8:  CLRF   FEF
02BAA:  MOVF   FED,F
02BAC:  CLRF   FEF
....................     ps->remotePort = 0x00; 
02BAE:  MOVLW  0D
02BB0:  ADDWF  x4A,W
02BB2:  MOVWF  FE9
02BB4:  MOVLW  00
02BB6:  ADDWFC x4B,W
02BB8:  MOVWF  FEA
02BBA:  CLRF   FEC
02BBC:  MOVF   FED,F
02BBE:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
02BC0:  MOVLW  23
02BC2:  ADDWF  x4A,W
02BC4:  MOVWF  FE9
02BC6:  MOVLW  00
02BC8:  ADDWFC x4B,W
02BCA:  MOVWF  FEA
02BCC:  BTFSS  FEF.3
02BCE:  BRA    2BD8
....................     { 
....................         MACDiscardRx(); 
02BD0:  MOVLB  0
02BD2:  CALL   1706
02BD6:  MOVLB  9
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
02BD8:  MOVLW  23
02BDA:  ADDWF  x4A,W
02BDC:  MOVWF  FE9
02BDE:  MOVLW  00
02BE0:  ADDWFC x4B,W
02BE2:  MOVWF  FEA
02BE4:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
02BE6:  MOVLW  21
02BE8:  ADDWF  x4A,W
02BEA:  MOVWF  FE9
02BEC:  MOVLW  00
02BEE:  ADDWFC x4B,W
02BF0:  MOVWF  FEA
02BF2:  CLRF   FEC
02BF4:  MOVF   FED,F
02BF6:  MOVLW  24
02BF8:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
02BFA:  MOVLW  23
02BFC:  ADDWF  x4A,W
02BFE:  MOVWF  FE9
02C00:  MOVLW  00
02C02:  ADDWFC x4B,W
02C04:  MOVWF  FEA
02C06:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
02C08:  MOVLW  23
02C0A:  ADDWF  x4A,W
02C0C:  MOVWF  FE9
02C0E:  MOVLW  00
02C10:  ADDWFC x4B,W
02C12:  MOVWF  FEA
02C14:  BTFSS  FEF.0
02C16:  BRA    2C24
....................     { 
....................         ps->smState = TCP_LISTEN; 
02C18:  MOVFF  94A,FE9
02C1C:  MOVFF  94B,FEA
02C20:  CLRF   FEF
....................     } 
02C22:  BRA    2C30
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
02C24:  MOVFF  94A,FE9
02C28:  MOVFF  94B,FEA
02C2C:  MOVLW  0A
02C2E:  MOVWF  FEF
....................     } 
....................     //ps->smState = TCP_CLOSED; 
....................  
....................    ps->TxCount = 0; 
02C30:  MOVLW  10
02C32:  ADDWF  x4A,W
02C34:  MOVWF  FE9
02C36:  MOVLW  00
02C38:  ADDWFC x4B,W
02C3A:  MOVWF  FEA
02C3C:  CLRF   FEC
02C3E:  MOVF   FED,F
02C40:  CLRF   FEF
....................  
....................     return; 
02C42:  MOVLB  0
02C44:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
031A8:  MOVLB  9
031AA:  CLRF   x4B
031AC:  MOVFF  92C,94A
031B0:  CLRF   x4D
031B2:  MOVLW  24
031B4:  MOVWF  x4C
031B6:  MOVLB  0
031B8:  CALL   0FE8
031BC:  MOVFF  02,03
031C0:  MOVF   01,W
031C2:  ADDLW  9A
031C4:  MOVWF  01
031C6:  MOVLW  03
031C8:  ADDWFC 03,F
031CA:  MOVFF  01,943
031CE:  MOVLB  9
031D0:  MOVFF  03,944
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
031D4:  CLRF   x45
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
031D6:  MOVLW  1E
031D8:  ADDWF  x43,W
031DA:  MOVWF  FE9
031DC:  MOVLW  00
031DE:  ADDWFC x44,W
031E0:  MOVWF  FEA
031E2:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
031E4:  MOVLW  1F
031E6:  ADDWF  x43,W
031E8:  MOVWF  01
031EA:  MOVLW  00
031EC:  ADDWFC x44,W
031EE:  MOVWF  03
031F0:  MOVFF  01,94A
031F4:  MOVWF  x4B
031F6:  MOVLB  0
031F8:  RCALL  2B2E
031FA:  MOVFF  94B,FEA
031FE:  MOVFF  94A,FE9
03202:  MOVFF  02,FEC
03206:  MOVF   FED,F
03208:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
0320C:  MOVLW  21
0320E:  MOVLB  9
03210:  ADDWF  x43,W
03212:  MOVWF  FE9
03214:  MOVLW  00
03216:  ADDWFC x44,W
03218:  MOVWF  FEA
0321A:  CLRF   FEC
0321C:  MOVF   FED,F
0321E:  MOVLW  24
03220:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
03222:  MOVLW  0D
03224:  ADDWF  x2F,W
03226:  MOVWF  FE9
03228:  MOVLW  00
0322A:  ADDWFC x30,W
0322C:  MOVWF  FEA
0322E:  BTFSS  FEF.2
03230:  BRA    3266
....................    { 
....................       MACDiscardRx(); 
03232:  MOVLB  0
03234:  CALL   1706
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
03238:  MOVLB  9
0323A:  MOVFF  943,94A
0323E:  MOVFF  944,94B
03242:  MOVLW  23
03244:  ADDWF  x43,W
03246:  MOVWF  FE9
03248:  MOVLW  00
0324A:  ADDWFC x44,W
0324C:  MOVWF  FEA
0324E:  BTFSS  FEF.0
03250:  BRA    3256
03252:  MOVLW  00
03254:  BRA    3258
03256:  MOVLW  01
03258:  MOVFF  94B,FEA
0325C:  MOVFF  94A,FE9
03260:  MOVWF  FEF
....................       return; 
03262:  GOTO   3BBA
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
03266:  MOVLW  16
03268:  ADDWF  x43,W
0326A:  MOVWF  FE9
0326C:  MOVLW  00
0326E:  ADDWFC x44,W
03270:  MOVWF  FEA
03272:  MOVFF  FEF,937
03276:  MOVFF  FEC,938
0327A:  MOVFF  FEC,939
0327E:  MOVFF  FEC,93A
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
03282:  MOVLW  0E
03284:  ADDWF  x2F,W
03286:  MOVWF  FE9
03288:  MOVLW  00
0328A:  ADDWFC x30,W
0328C:  MOVWF  FEA
0328E:  MOVFF  FEC,94B
03292:  MOVF   FED,F
03294:  MOVFF  FEF,94A
03298:  CLRF   x4C
0329A:  CLRF   x4D
0329C:  MOVLW  08
0329E:  ADDWF  x2F,W
032A0:  MOVWF  FE9
032A2:  MOVLW  00
032A4:  ADDWFC x30,W
032A6:  MOVWF  FEA
032A8:  MOVFF  FEF,00
032AC:  MOVFF  FEC,01
032B0:  MOVFF  FEC,02
032B4:  MOVFF  FEC,03
032B8:  MOVF   00,W
032BA:  SUBWF  x37,W
032BC:  MOVWF  00
032BE:  MOVF   01,W
032C0:  SUBWFB x38,W
032C2:  MOVWF  01
032C4:  MOVF   02,W
032C6:  SUBWFB x39,W
032C8:  MOVWF  02
032CA:  MOVF   03,W
032CC:  SUBWFB x3A,W
032CE:  MOVWF  03
032D0:  MOVF   00,W
032D2:  SUBWF  x4A,F
032D4:  MOVF   01,W
032D6:  SUBWFB x4B,F
032D8:  MOVF   02,W
032DA:  SUBWFB x4C,F
032DC:  MOVF   03,W
032DE:  SUBWFB x4D,F
032E0:  MOVLW  10
032E2:  ADDWF  x43,W
032E4:  MOVWF  FE9
032E6:  MOVLW  00
032E8:  ADDWFC x44,W
032EA:  MOVWF  FEA
032EC:  MOVFF  FEC,03
032F0:  MOVF   FED,F
032F2:  MOVFF  FEF,00
032F6:  MOVFF  03,01
032FA:  CLRF   02
032FC:  CLRF   03
032FE:  MOVF   00,W
03300:  SUBWF  x4A,W
03302:  MOVWF  x46
03304:  MOVF   01,W
03306:  SUBWFB x4B,W
03308:  MOVWF  x47
0330A:  MOVF   02,W
0330C:  SUBWFB x4C,W
0330E:  MOVWF  x48
03310:  MOVF   03,W
03312:  SUBWFB x4D,W
03314:  MOVWF  x49
....................    if(temp < 0) 
03316:  BTFSS  x49.7
03318:  BRA    332E
....................    { 
....................       ps->RemoteWindow = 0; 
0331A:  MOVLW  14
0331C:  ADDWF  x43,W
0331E:  MOVWF  FE9
03320:  MOVLW  00
03322:  ADDWFC x44,W
03324:  MOVWF  FEA
03326:  CLRF   FEC
03328:  MOVF   FED,F
0332A:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
0332C:  BRA    3342
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
0332E:  MOVLW  14
03330:  ADDWF  x43,W
03332:  MOVWF  FE9
03334:  MOVLW  00
03336:  ADDWFC x44,W
03338:  MOVWF  FEA
0333A:  MOVFF  933,FEF
0333E:  MOVFF  934,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
03342:  MOVFF  943,FE9
03346:  MOVFF  944,FEA
0334A:  DECFSZ FEF,W
0334C:  BRA    34B8
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
0334E:  MOVLW  0D
03350:  ADDWF  x2F,W
03352:  MOVWF  FE9
03354:  MOVLW  00
03356:  ADDWFC x30,W
03358:  MOVWF  FEA
0335A:  BTFSC  FEF.1
0335C:  BRA    3382
....................       { 
....................          MACDiscardRx(); 
0335E:  MOVLB  0
03360:  CALL   1706
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
03364:  MOVLW  0D
03366:  MOVLB  9
03368:  ADDWF  x2F,W
0336A:  MOVWF  FE9
0336C:  MOVLW  00
0336E:  ADDWFC x30,W
03370:  MOVWF  FEA
03372:  BTFSS  FEF.4
03374:  BRA    337E
....................           { 
....................             flags = RST; 
03376:  MOVLW  04
03378:  MOVWF  x45
....................             goto SendTCPControlPacket; 
0337A:  GOTO   3B52
....................            } 
....................  
....................          return; 
0337E:  GOTO   3BBA
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
03382:  MOVLW  1A
03384:  ADDWF  x43,W
03386:  MOVWF  01
03388:  MOVLW  00
0338A:  ADDWFC x44,W
0338C:  MOVFF  01,94A
03390:  MOVWF  x4B
03392:  MOVLW  04
03394:  ADDWF  x2F,W
03396:  MOVWF  FE9
03398:  MOVLW  00
0339A:  ADDWFC x30,W
0339C:  MOVWF  FEA
0339E:  MOVFF  FEF,94C
033A2:  MOVFF  FEC,94D
033A6:  MOVFF  FEC,94E
033AA:  MOVFF  FEC,94F
033AE:  MOVF   x31,W
033B0:  ADDWF  x4C,F
033B2:  MOVF   x32,W
033B4:  ADDWFC x4D,F
033B6:  MOVLW  00
033B8:  ADDWFC x4E,F
033BA:  ADDWFC x4F,F
033BC:  MOVLW  01
033BE:  ADDWF  x4C,W
033C0:  MOVWF  00
033C2:  MOVLW  00
033C4:  ADDWFC x4D,W
033C6:  MOVWF  01
033C8:  MOVLW  00
033CA:  ADDWFC x4E,W
033CC:  MOVWF  02
033CE:  MOVLW  00
033D0:  ADDWFC x4F,W
033D2:  MOVFF  94B,FEA
033D6:  MOVFF  94A,FE9
033DA:  MOVFF  00,FEF
033DE:  MOVFF  01,FEC
033E2:  MOVFF  02,FEC
033E6:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
033E8:  MOVLW  1A
033EA:  ADDWF  x43,W
033EC:  MOVWF  FE9
033EE:  MOVLW  00
033F0:  ADDWFC x44,W
033F2:  MOVWF  FEA
033F4:  MOVFF  FEF,933
033F8:  MOVFF  FEC,934
033FC:  MOVFF  FEC,935
03400:  MOVFF  FEC,936
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
03404:  MOVLW  0D
03406:  ADDWF  x2F,W
03408:  MOVWF  FE9
0340A:  MOVLW  00
0340C:  ADDWFC x30,W
0340E:  MOVWF  FEA
03410:  BTFSC  FEF.4
03412:  BRA    342E
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
03414:  MOVFF  943,FE9
03418:  MOVFF  944,FEA
0341C:  MOVLW  02
0341E:  MOVWF  FEF
....................          MACDiscardRx(); 
03420:  MOVLB  0
03422:  CALL   1706
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
03426:  MOVLW  12
03428:  MOVLB  9
0342A:  MOVWF  x45
....................          goto SendTCPControlPacket; 
0342C:  BRA    3B52
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
0342E:  MOVFF  943,FE9
03432:  MOVFF  944,FEA
03436:  MOVLW  03
03438:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
0343A:  MOVLW  10
0343C:  MOVWF  x45
....................  
....................       ps->RemoteWindow = h->Window; 
0343E:  MOVLW  14
03440:  ADDWF  x43,W
03442:  MOVWF  01
03444:  MOVLW  00
03446:  ADDWFC x44,W
03448:  MOVWF  03
0344A:  MOVWF  x4B
0344C:  MOVLW  0E
0344E:  ADDWF  x2F,W
03450:  MOVWF  FE9
03452:  MOVLW  00
03454:  ADDWFC x30,W
03456:  MOVWF  FEA
03458:  MOVFF  FEC,03
0345C:  MOVF   FED,F
0345E:  MOVFF  FEF,94C
03462:  MOVFF  94B,FEA
03466:  MOVFF  01,FE9
0346A:  MOVFF  03,FEC
0346E:  MOVF   FED,F
03470:  MOVFF  94C,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
03474:  MOVF   x31,W
03476:  IORWF  x32,W
03478:  BZ    34AE
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
0347A:  MOVLW  23
0347C:  ADDWF  x43,W
0347E:  MOVWF  FE9
03480:  MOVLW  00
03482:  ADDWFC x44,W
03484:  MOVWF  FEA
03486:  BSF    FEF.3
....................          ps->RxCount             = len; 
03488:  MOVLW  12
0348A:  ADDWF  x43,W
0348C:  MOVWF  FE9
0348E:  MOVLW  00
03490:  ADDWFC x44,W
03492:  MOVWF  FEA
03494:  MOVFF  932,FEC
03498:  MOVF   FED,F
0349A:  MOVFF  931,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
0349E:  MOVLW  23
034A0:  ADDWF  x43,W
034A2:  MOVWF  FE9
034A4:  MOVLW  00
034A6:  ADDWFC x44,W
034A8:  MOVWF  FEA
034AA:  BSF    FEF.2
....................       } 
034AC:  BRA    34B6
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
034AE:  MOVLB  0
034B0:  CALL   1706
034B4:  MOVLB  9
....................       } 
....................       goto SendTCPControlPacket; 
034B6:  BRA    3B52
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
034B8:  MOVFF  943,FE9
034BC:  MOVFF  944,FEA
034C0:  MOVF   FEF,F
034C2:  BTFSS  FD8.2
034C4:  BRA    363A
....................    { 
....................       MACDiscardRx(); 
034C6:  MOVLB  0
034C8:  CALL   1706
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
034CC:  MOVLW  0D
034CE:  MOVLB  9
034D0:  ADDWF  x2F,W
034D2:  MOVWF  FE9
034D4:  MOVLW  00
034D6:  ADDWFC x30,W
034D8:  MOVWF  FEA
034DA:  BTFSC  FEF.1
034DC:  BRA    34E4
....................       { 
....................          flags = RST; 
034DE:  MOVLW  04
034E0:  MOVWF  x45
....................          goto SendTCPControlPacket; 
034E2:  BRA    3B52
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
034E4:  MOVLW  1A
034E6:  ADDWF  x43,W
034E8:  MOVWF  01
034EA:  MOVLW  00
034EC:  ADDWFC x44,W
034EE:  MOVFF  01,94A
034F2:  MOVWF  x4B
034F4:  MOVLW  04
034F6:  ADDWF  x2F,W
034F8:  MOVWF  FE9
034FA:  MOVLW  00
034FC:  ADDWFC x30,W
034FE:  MOVWF  FEA
03500:  MOVFF  FEF,94C
03504:  MOVFF  FEC,94D
03508:  MOVFF  FEC,94E
0350C:  MOVFF  FEC,94F
03510:  MOVF   x31,W
03512:  ADDWF  x4C,F
03514:  MOVF   x32,W
03516:  ADDWFC x4D,F
03518:  MOVLW  00
0351A:  ADDWFC x4E,F
0351C:  ADDWFC x4F,F
0351E:  MOVLW  01
03520:  ADDWF  x4C,W
03522:  MOVWF  00
03524:  MOVLW  00
03526:  ADDWFC x4D,W
03528:  MOVWF  01
0352A:  MOVLW  00
0352C:  ADDWFC x4E,W
0352E:  MOVWF  02
03530:  MOVLW  00
03532:  ADDWFC x4F,W
03534:  MOVFF  94B,FEA
03538:  MOVFF  94A,FE9
0353C:  MOVFF  00,FEF
03540:  MOVFF  01,FEC
03544:  MOVFF  02,FEC
03548:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
0354A:  MOVLW  14
0354C:  ADDWF  x43,W
0354E:  MOVWF  01
03550:  MOVLW  00
03552:  ADDWFC x44,W
03554:  MOVWF  03
03556:  MOVWF  x4B
03558:  MOVLW  0E
0355A:  ADDWF  x2F,W
0355C:  MOVWF  FE9
0355E:  MOVLW  00
03560:  ADDWFC x30,W
03562:  MOVWF  FEA
03564:  MOVFF  FEC,03
03568:  MOVF   FED,F
0356A:  MOVFF  FEF,94C
0356E:  MOVFF  94B,FEA
03572:  MOVFF  01,FE9
03576:  MOVFF  03,FEC
0357A:  MOVF   FED,F
0357C:  MOVFF  94C,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
03580:  MOVLW  01
03582:  ADDWF  x43,W
03584:  MOVWF  01
03586:  MOVLW  00
03588:  ADDWFC x44,W
0358A:  MOVWF  03
0358C:  MOVFF  01,94A
03590:  MOVWF  x4B
03592:  MOVWF  FEA
03594:  MOVFF  01,FE9
03598:  MOVFF  92E,FE2
0359C:  MOVFF  92D,FE1
035A0:  MOVLW  0A
035A2:  MOVWF  01
035A4:  MOVFF  FE6,FEE
035A8:  DECFSZ 01,F
035AA:  BRA    35A4
....................       ps->remotePort = h->SourcePort; 
035AC:  MOVLW  0D
035AE:  ADDWF  x43,W
035B0:  MOVWF  01
035B2:  MOVLW  00
035B4:  ADDWFC x44,W
035B6:  MOVFF  92F,FE9
035BA:  MOVFF  930,FEA
035BE:  MOVFF  FEC,03
035C2:  MOVF   FED,F
035C4:  MOVFF  FEF,94C
035C8:  MOVWF  FEA
035CA:  MOVFF  01,FE9
035CE:  MOVFF  03,FEC
035D2:  MOVF   FED,F
035D4:  MOVFF  94C,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
035D8:  MOVFF  943,FE9
035DC:  MOVFF  944,FEA
035E0:  MOVLW  02
035E2:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
035E4:  MOVLW  16
035E6:  ADDWF  x43,W
035E8:  MOVWF  FE9
035EA:  MOVLW  00
035EC:  ADDWFC x44,W
035EE:  MOVWF  FEA
035F0:  MOVFF  FEF,937
035F4:  MOVFF  FEC,938
035F8:  MOVFF  FEC,939
035FC:  MOVFF  FEC,93A
....................       ps->SND_SEQ++; 
03600:  MOVLW  16
03602:  ADDWF  x43,W
03604:  MOVWF  FE9
03606:  MOVLW  00
03608:  ADDWFC x44,W
0360A:  MOVWF  FEA
0360C:  MOVLW  01
0360E:  ADDWF  FEE,F
03610:  MOVLW  00
03612:  ADDWFC FEE,F
03614:  ADDWFC FEE,F
03616:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
03618:  MOVLW  1A
0361A:  ADDWF  x43,W
0361C:  MOVWF  FE9
0361E:  MOVLW  00
03620:  ADDWFC x44,W
03622:  MOVWF  FEA
03624:  MOVFF  FEF,933
03628:  MOVFF  FEC,934
0362C:  MOVFF  FEC,935
03630:  MOVFF  FEC,936
....................       flags = SYN | ACK; 
03634:  MOVLW  12
03636:  MOVWF  x45
....................       goto SendTCPControlPacket; 
03638:  BRA    3B52
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
0363A:  MOVLW  1A
0363C:  ADDWF  x43,W
0363E:  MOVWF  FE9
03640:  MOVLW  00
03642:  ADDWFC x44,W
03644:  MOVWF  FEA
03646:  MOVFF  FEF,93B
0364A:  MOVFF  FEC,93C
0364E:  MOVFF  FEC,93D
03652:  MOVFF  FEC,93E
....................    prevSeq = ps->SND_SEQ; 
03656:  MOVLW  16
03658:  ADDWF  x43,W
0365A:  MOVWF  FE9
0365C:  MOVLW  00
0365E:  ADDWFC x44,W
03660:  MOVWF  FEA
03662:  MOVFF  FEF,93F
03666:  MOVFF  FEC,940
0366A:  MOVFF  FEC,941
0366E:  MOVFF  FEC,942
....................  
....................    ack = h->SeqNumber; 
03672:  MOVLW  04
03674:  ADDWF  x2F,W
03676:  MOVWF  FE9
03678:  MOVLW  00
0367A:  ADDWFC x30,W
0367C:  MOVWF  FEA
0367E:  MOVFF  FEF,933
03682:  MOVFF  FEC,934
03686:  MOVFF  FEC,935
0368A:  MOVFF  FEC,936
....................    ack += (DWORD)len; 
0368E:  MOVFF  931,00
03692:  MOVFF  932,01
03696:  CLRF   02
03698:  CLRF   03
0369A:  MOVF   00,W
0369C:  ADDWF  x33,F
0369E:  MOVF   01,W
036A0:  ADDWFC x34,F
036A2:  MOVF   02,W
036A4:  ADDWFC x35,F
036A6:  MOVF   03,W
036A8:  ADDWFC x36,F
....................    seq = ps->SND_SEQ; 
036AA:  MOVLW  16
036AC:  ADDWF  x43,W
036AE:  MOVWF  FE9
036B0:  MOVLW  00
036B2:  ADDWFC x44,W
036B4:  MOVWF  FEA
036B6:  MOVFF  FEF,937
036BA:  MOVFF  FEC,938
036BE:  MOVFF  FEC,939
036C2:  MOVFF  FEC,93A
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
036C6:  MOVLW  04
036C8:  ADDWF  x2F,W
036CA:  MOVWF  FE9
036CC:  MOVLW  00
036CE:  ADDWFC x30,W
036D0:  MOVWF  FEA
036D2:  MOVFF  FEF,94A
036D6:  MOVFF  FEC,94B
036DA:  MOVFF  FEC,94C
036DE:  MOVFF  FEC,94D
036E2:  MOVF   x3B,W
036E4:  SUBWF  x4A,W
036E6:  BTFSS  FD8.2
036E8:  BRA    3B36
036EA:  MOVF   x3C,W
036EC:  SUBWF  x4B,W
036EE:  BTFSS  FD8.2
036F0:  BRA    3B36
036F2:  MOVF   x3D,W
036F4:  SUBWF  x4C,W
036F6:  BTFSS  FD8.2
036F8:  BRA    3B36
036FA:  MOVF   x3E,W
036FC:  SUBWF  x4D,W
036FE:  BTFSS  FD8.2
03700:  BRA    3B36
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
03702:  MOVFF  943,FE9
03706:  MOVFF  944,FEA
0370A:  MOVF   FEF,W
0370C:  SUBLW  02
0370E:  BNZ   3796
....................          { 
....................             if(h->Flags.bits.flagACK) 
03710:  MOVLW  0D
03712:  ADDWF  x2F,W
03714:  MOVWF  FE9
03716:  MOVLW  00
03718:  ADDWFC x30,W
0371A:  MOVWF  FEA
0371C:  BTFSS  FEF.4
0371E:  BRA    378C
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
03720:  MOVLW  1A
03722:  ADDWF  x43,W
03724:  MOVWF  FE9
03726:  MOVLW  00
03728:  ADDWFC x44,W
0372A:  MOVWF  FEA
0372C:  MOVFF  933,FEF
03730:  MOVFF  934,FEC
03734:  MOVFF  935,FEC
03738:  MOVFF  936,FEC
....................                ps->smState = TCP_ESTABLISHED; 
0373C:  MOVFF  943,FE9
03740:  MOVFF  944,FEA
03744:  MOVLW  03
03746:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
03748:  MOVF   x31,W
0374A:  IORWF  x32,W
0374C:  BZ    3782
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
0374E:  MOVLW  23
03750:  ADDWF  x43,W
03752:  MOVWF  FE9
03754:  MOVLW  00
03756:  ADDWFC x44,W
03758:  MOVWF  FEA
0375A:  BSF    FEF.3
....................                   ps->RxCount             = len; 
0375C:  MOVLW  12
0375E:  ADDWF  x43,W
03760:  MOVWF  FE9
03762:  MOVLW  00
03764:  ADDWFC x44,W
03766:  MOVWF  FEA
03768:  MOVFF  932,FEC
0376C:  MOVF   FED,F
0376E:  MOVFF  931,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
03772:  MOVLW  23
03774:  ADDWF  x43,W
03776:  MOVWF  FE9
03778:  MOVLW  00
0377A:  ADDWFC x44,W
0377C:  MOVWF  FEA
0377E:  BSF    FEF.2
....................                } 
03780:  BRA    378A
....................                else 
....................                   MACDiscardRx(); 
03782:  MOVLB  0
03784:  CALL   1706
03788:  MOVLB  9
....................             } 
0378A:  BRA    3794
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
0378C:  MOVLB  0
0378E:  CALL   1706
03792:  MOVLB  9
....................             } 
....................          } 
03794:  BRA    3B34
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
03796:  MOVLW  1A
03798:  ADDWF  x43,W
0379A:  MOVWF  FE9
0379C:  MOVLW  00
0379E:  ADDWFC x44,W
037A0:  MOVWF  FEA
037A2:  MOVFF  933,FEF
037A6:  MOVFF  934,FEC
037AA:  MOVFF  935,FEC
037AE:  MOVFF  936,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
037B2:  MOVFF  943,FE9
037B6:  MOVFF  944,FEA
037BA:  MOVF   FEF,W
037BC:  SUBLW  03
037BE:  BTFSS  FD8.2
037C0:  BRA    3966
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
037C2:  MOVLW  0D
037C4:  ADDWF  x2F,W
037C6:  MOVWF  FE9
037C8:  MOVLW  00
037CA:  ADDWFC x30,W
037CC:  MOVWF  FEA
037CE:  BTFSS  FEF.4
037D0:  BRA    3828
037D2:  MOVLW  23
037D4:  ADDWF  x43,W
037D6:  MOVWF  FE9
037D8:  MOVLW  00
037DA:  ADDWFC x44,W
037DC:  MOVWF  FEA
037DE:  BTFSC  FEF.1
037E0:  BRA    3828
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
037E2:  MOVLW  0F
037E4:  ADDWF  x43,W
037E6:  MOVWF  FE9
037E8:  MOVLW  00
037EA:  ADDWFC x44,W
037EC:  MOVWF  FEA
037EE:  INCFSZ FEF,W
037F0:  BRA    37F4
037F2:  BRA    3828
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
037F4:  MOVLW  0F
037F6:  ADDWF  x43,W
037F8:  MOVWF  FE9
037FA:  MOVLW  00
037FC:  ADDWFC x44,W
037FE:  MOVWF  FEA
03800:  MOVFF  FEF,94D
03804:  MOVLB  0
03806:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
0380A:  MOVLW  0F
0380C:  MOVLB  9
0380E:  ADDWF  x43,W
03810:  MOVWF  FE9
03812:  MOVLW  00
03814:  ADDWFC x44,W
03816:  MOVWF  FEA
03818:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
0381A:  MOVLW  23
0381C:  ADDWF  x43,W
0381E:  MOVWF  FE9
03820:  MOVLW  00
03822:  ADDWFC x44,W
03824:  MOVWF  FEA
03826:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
03828:  MOVLW  0D
0382A:  ADDWF  x2F,W
0382C:  MOVWF  FE9
0382E:  MOVLW  00
03830:  ADDWFC x30,W
03832:  MOVWF  FEA
03834:  BTFSS  FEF.0
03836:  BRA    38CE
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
03838:  MOVLW  11
0383A:  MOVWF  x45
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
0383C:  MOVLW  16
0383E:  ADDWF  x43,W
03840:  MOVWF  FE9
03842:  MOVLW  00
03844:  ADDWFC x44,W
03846:  MOVWF  FEA
03848:  MOVFF  FEF,937
0384C:  MOVFF  FEC,938
03850:  MOVFF  FEC,939
03854:  MOVFF  FEC,93A
....................                   ps->SND_SEQ++; 
03858:  MOVLW  16
0385A:  ADDWF  x43,W
0385C:  MOVWF  FE9
0385E:  MOVLW  00
03860:  ADDWFC x44,W
03862:  MOVWF  FEA
03864:  MOVLW  01
03866:  ADDWF  FEE,F
03868:  MOVLW  00
0386A:  ADDWFC FEE,F
0386C:  ADDWFC FEE,F
0386E:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03870:  MOVLW  1A
03872:  ADDWF  x43,W
03874:  MOVWF  FE9
03876:  MOVLW  00
03878:  ADDWFC x44,W
0387A:  MOVWF  FEA
0387C:  MOVLW  01
0387E:  ADDWF  FEF,W
03880:  MOVWF  00
03882:  MOVLW  00
03884:  ADDWFC FEC,W
03886:  MOVWF  01
03888:  MOVLW  00
0388A:  ADDWFC FEC,W
0388C:  MOVWF  02
0388E:  MOVLW  00
03890:  ADDWFC FEC,W
03892:  MOVF   FED,F
03894:  MOVF   FED,F
03896:  MOVF   FED,F
03898:  MOVFF  00,FEF
0389C:  MOVFF  01,FEC
038A0:  MOVFF  02,FEC
038A4:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
038A6:  MOVLW  1A
038A8:  ADDWF  x43,W
038AA:  MOVWF  FE9
038AC:  MOVLW  00
038AE:  ADDWFC x44,W
038B0:  MOVWF  FEA
038B2:  MOVFF  FEF,933
038B6:  MOVFF  FEC,934
038BA:  MOVFF  FEC,935
038BE:  MOVFF  FEC,936
....................                   ps->smState = TCP_LAST_ACK; 
038C2:  MOVFF  943,FE9
038C6:  MOVFF  944,FEA
038CA:  MOVLW  09
038CC:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
038CE:  MOVF   x31,W
038D0:  IORWF  x32,W
038D2:  BZ    395C
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
038D4:  MOVLW  23
038D6:  ADDWF  x43,W
038D8:  MOVWF  FE9
038DA:  MOVLW  00
038DC:  ADDWFC x44,W
038DE:  MOVWF  FEA
038E0:  BTFSC  FEF.3
038E2:  BRA    391A
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
038E4:  MOVLW  23
038E6:  ADDWF  x43,W
038E8:  MOVWF  FE9
038EA:  MOVLW  00
038EC:  ADDWFC x44,W
038EE:  MOVWF  FEA
038F0:  BSF    FEF.3
....................                      ps->RxCount             = len; 
038F2:  MOVLW  12
038F4:  ADDWF  x43,W
038F6:  MOVWF  FE9
038F8:  MOVLW  00
038FA:  ADDWFC x44,W
038FC:  MOVWF  FEA
038FE:  MOVFF  932,FEC
03902:  MOVF   FED,F
03904:  MOVFF  931,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
03908:  MOVLW  23
0390A:  ADDWF  x43,W
0390C:  MOVWF  FE9
0390E:  MOVLW  00
03910:  ADDWFC x44,W
03912:  MOVWF  FEA
03914:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
03916:  BSF    x45.4
....................                   } 
03918:  BRA    395A
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
0391A:  MOVLW  16
0391C:  ADDWF  x43,W
0391E:  MOVWF  FE9
03920:  MOVLW  00
03922:  ADDWFC x44,W
03924:  MOVWF  FEA
03926:  MOVFF  93F,FEF
0392A:  MOVFF  940,FEC
0392E:  MOVFF  941,FEC
03932:  MOVFF  942,FEC
....................                      ps->SND_ACK = prevAck; 
03936:  MOVLW  1A
03938:  ADDWF  x43,W
0393A:  MOVWF  FE9
0393C:  MOVLW  00
0393E:  ADDWFC x44,W
03940:  MOVWF  FEA
03942:  MOVFF  93B,FEF
03946:  MOVFF  93C,FEC
0394A:  MOVFF  93D,FEC
0394E:  MOVFF  93E,FEC
....................  
....................                      MACDiscardRx(); 
03952:  MOVLB  0
03954:  CALL   1706
03958:  MOVLB  9
....................                   } 
....................                } 
0395A:  BRA    3964
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
0395C:  MOVLB  0
0395E:  CALL   1706
03962:  MOVLB  9
....................                } 
....................             } 
03964:  BRA    3B34
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
03966:  MOVFF  943,FE9
0396A:  MOVFF  944,FEA
0396E:  MOVF   FEF,W
03970:  SUBLW  09
03972:  BNZ   399E
....................             { 
....................                MACDiscardRx(); 
03974:  MOVLB  0
03976:  CALL   1706
....................  
....................                if(h->Flags.bits.flagACK) 
0397A:  MOVLW  0D
0397C:  MOVLB  9
0397E:  ADDWF  x2F,W
03980:  MOVWF  FE9
03982:  MOVLW  00
03984:  ADDWFC x30,W
03986:  MOVWF  FEA
03988:  BTFSS  FEF.4
0398A:  BRA    399C
....................                { 
....................                   CloseSocket(ps); 
0398C:  MOVFF  944,94B
03990:  MOVFF  943,94A
03994:  MOVLB  0
03996:  CALL   2B48
0399A:  MOVLB  9
....................                } 
....................             } 
0399C:  BRA    3B34
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
0399E:  MOVFF  943,FE9
039A2:  MOVFF  944,FEA
039A6:  MOVF   FEF,W
039A8:  SUBLW  04
039AA:  BNZ   3A70
....................             { 
....................                MACDiscardRx(); 
039AC:  MOVLB  0
039AE:  CALL   1706
....................  
....................                if(h->Flags.bits.flagFIN) 
039B2:  MOVLW  0D
039B4:  MOVLB  9
039B6:  ADDWF  x2F,W
039B8:  MOVWF  FE9
039BA:  MOVLW  00
039BC:  ADDWFC x30,W
039BE:  MOVWF  FEA
039C0:  BTFSS  FEF.0
039C2:  BRA    3A4E
....................                { 
....................                   flags = ACK; 
039C4:  MOVLW  10
039C6:  MOVWF  x45
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
039C8:  MOVLW  1A
039CA:  ADDWF  x43,W
039CC:  MOVWF  FE9
039CE:  MOVLW  00
039D0:  ADDWFC x44,W
039D2:  MOVWF  FEA
039D4:  MOVLW  01
039D6:  ADDWF  FEF,W
039D8:  MOVWF  00
039DA:  MOVLW  00
039DC:  ADDWFC FEC,W
039DE:  MOVWF  01
039E0:  MOVLW  00
039E2:  ADDWFC FEC,W
039E4:  MOVWF  02
039E6:  MOVLW  00
039E8:  ADDWFC FEC,W
039EA:  MOVF   FED,F
039EC:  MOVF   FED,F
039EE:  MOVF   FED,F
039F0:  MOVFF  00,FEF
039F4:  MOVFF  01,FEC
039F8:  MOVFF  02,FEC
039FC:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
039FE:  MOVLW  1A
03A00:  ADDWF  x43,W
03A02:  MOVWF  FE9
03A04:  MOVLW  00
03A06:  ADDWFC x44,W
03A08:  MOVWF  FEA
03A0A:  MOVFF  FEF,933
03A0E:  MOVFF  FEC,934
03A12:  MOVFF  FEC,935
03A16:  MOVFF  FEC,936
....................                   if(h->Flags.bits.flagACK) 
03A1A:  MOVLW  0D
03A1C:  ADDWF  x2F,W
03A1E:  MOVWF  FE9
03A20:  MOVLW  00
03A22:  ADDWFC x30,W
03A24:  MOVWF  FEA
03A26:  BTFSS  FEF.4
03A28:  BRA    3A3C
....................                   { 
....................                      CloseSocket(ps); 
03A2A:  MOVFF  944,94B
03A2E:  MOVFF  943,94A
03A32:  MOVLB  0
03A34:  CALL   2B48
....................                   } 
03A38:  BRA    3A4A
03A3A:  MOVLB  9
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
03A3C:  MOVFF  943,FE9
03A40:  MOVFF  944,FEA
03A44:  MOVLW  06
03A46:  MOVWF  FEF
03A48:  MOVLB  0
....................                   } 
....................                } 
03A4A:  BRA    3A6C
03A4C:  MOVLB  9
....................                else if(h->Flags.bits.flagACK) 
03A4E:  MOVLW  0D
03A50:  ADDWF  x2F,W
03A52:  MOVWF  FE9
03A54:  MOVLW  00
03A56:  ADDWFC x30,W
03A58:  MOVWF  FEA
03A5A:  BTFSS  FEF.4
03A5C:  BRA    3A6A
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
03A5E:  MOVFF  943,FE9
03A62:  MOVFF  944,FEA
03A66:  MOVLW  05
03A68:  MOVWF  FEF
03A6A:  MOVLB  0
....................                } 
....................             } 
03A6C:  BRA    3B32
03A6E:  MOVLB  9
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
03A70:  MOVFF  943,FE9
03A74:  MOVFF  944,FEA
03A78:  MOVF   FEF,W
03A7A:  SUBLW  05
03A7C:  BNZ   3AFE
....................             { 
....................                MACDiscardRx(); 
03A7E:  MOVLB  0
03A80:  CALL   1706
....................  
....................                if(h->Flags.bits.flagFIN) 
03A84:  MOVLW  0D
03A86:  MOVLB  9
03A88:  ADDWF  x2F,W
03A8A:  MOVWF  FE9
03A8C:  MOVLW  00
03A8E:  ADDWFC x30,W
03A90:  MOVWF  FEA
03A92:  BTFSS  FEF.0
03A94:  BRA    3AFC
....................                { 
....................                   flags = ACK; 
03A96:  MOVLW  10
03A98:  MOVWF  x45
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03A9A:  MOVLW  1A
03A9C:  ADDWF  x43,W
03A9E:  MOVWF  FE9
03AA0:  MOVLW  00
03AA2:  ADDWFC x44,W
03AA4:  MOVWF  FEA
03AA6:  MOVLW  01
03AA8:  ADDWF  FEF,W
03AAA:  MOVWF  00
03AAC:  MOVLW  00
03AAE:  ADDWFC FEC,W
03AB0:  MOVWF  01
03AB2:  MOVLW  00
03AB4:  ADDWFC FEC,W
03AB6:  MOVWF  02
03AB8:  MOVLW  00
03ABA:  ADDWFC FEC,W
03ABC:  MOVF   FED,F
03ABE:  MOVF   FED,F
03AC0:  MOVF   FED,F
03AC2:  MOVFF  00,FEF
03AC6:  MOVFF  01,FEC
03ACA:  MOVFF  02,FEC
03ACE:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03AD0:  MOVLW  1A
03AD2:  ADDWF  x43,W
03AD4:  MOVWF  FE9
03AD6:  MOVLW  00
03AD8:  ADDWFC x44,W
03ADA:  MOVWF  FEA
03ADC:  MOVFF  FEF,933
03AE0:  MOVFF  FEC,934
03AE4:  MOVFF  FEC,935
03AE8:  MOVFF  FEC,936
....................                   CloseSocket(ps); 
03AEC:  MOVFF  944,94B
03AF0:  MOVFF  943,94A
03AF4:  MOVLB  0
03AF6:  CALL   2B48
03AFA:  MOVLB  9
....................                } 
....................             } 
03AFC:  BRA    3B34
....................             else if ( ps->smState == TCP_CLOSING ) 
03AFE:  MOVFF  943,FE9
03B02:  MOVFF  944,FEA
03B06:  MOVF   FEF,W
03B08:  SUBLW  06
03B0A:  BNZ   3B34
....................             { 
....................                MACDiscardRx(); 
03B0C:  MOVLB  0
03B0E:  CALL   1706
....................  
....................                if ( h->Flags.bits.flagACK ) 
03B12:  MOVLW  0D
03B14:  MOVLB  9
03B16:  ADDWF  x2F,W
03B18:  MOVWF  FE9
03B1A:  MOVLW  00
03B1C:  ADDWFC x30,W
03B1E:  MOVWF  FEA
03B20:  BTFSS  FEF.4
03B22:  BRA    3B34
....................                { 
....................                   CloseSocket(ps); 
03B24:  MOVFF  944,94B
03B28:  MOVFF  943,94A
03B2C:  MOVLB  0
03B2E:  CALL   2B48
03B32:  MOVLB  9
....................                } 
....................             } 
....................          } 
....................       } 
03B34:  BRA    3B52
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
03B36:  MOVLB  0
03B38:  CALL   1706
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
03B3C:  MOVLW  10
03B3E:  MOVLB  9
03B40:  MOVWF  x45
....................          ack = prevAck; 
03B42:  MOVFF  93E,936
03B46:  MOVFF  93D,935
03B4A:  MOVFF  93C,934
03B4E:  MOVFF  93B,933
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
03B52:  MOVLB  9
03B54:  MOVF   x45,F
03B56:  BZ    3BBA
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
03B58:  MOVLW  02
03B5A:  ADDWF  x2F,W
03B5C:  MOVWF  FE9
03B5E:  MOVLW  00
03B60:  ADDWFC x30,W
03B62:  MOVWF  FEA
03B64:  MOVFF  FEC,951
03B68:  MOVF   FED,F
03B6A:  MOVFF  FEF,950
03B6E:  MOVFF  92F,FE9
03B72:  MOVFF  930,FEA
03B76:  MOVFF  FEC,953
03B7A:  MOVF   FED,F
03B7C:  MOVFF  FEF,952
03B80:  MOVFF  92E,94F
03B84:  MOVFF  92D,94E
03B88:  MOVFF  93A,957
03B8C:  MOVFF  939,956
03B90:  MOVFF  938,955
03B94:  MOVFF  937,954
03B98:  MOVFF  936,95B
03B9C:  MOVFF  935,95A
03BA0:  MOVFF  934,959
03BA4:  MOVFF  933,958
03BA8:  MOVFF  945,95C
03BAC:  SETF   x5D
03BAE:  CLRF   x5F
03BB0:  CLRF   x5E
03BB2:  MOVLB  0
03BB4:  CALL   2F84
03BB8:  MOVLB  9
....................    } 
03BBA:  MOVLB  0
03BBC:  GOTO   3D4A (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
03E24:  MOVLW  09
03E26:  MOVLB  9
03E28:  MOVWF  x58
03E2A:  MOVLW  0B
03E2C:  MOVWF  x57
03E2E:  MOVFF  958,995
03E32:  MOVWF  x94
03E34:  CLRF   x97
03E36:  MOVLW  08
03E38:  MOVWF  x96
03E3A:  MOVLB  0
03E3C:  CALL   177C
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
03E40:  MOVLB  9
03E42:  CLRF   x56
03E44:  CLRF   x55
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
03E46:  MOVFF  906,03
03E4A:  MOVFF  905,FE9
03E4E:  MOVFF  03,FEA
03E52:  MOVFF  FEF,95A
03E56:  CLRF   x59
03E58:  MOVLW  14
03E5A:  MOVWF  x58
03E5C:  CLRF   x5B
03E5E:  MOVLB  0
03E60:  CALL   2146
03E64:  MOVFF  02,954
03E68:  MOVFF  01,953
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
03E6C:  MOVFF  906,03
03E70:  MOVLB  9
03E72:  MOVFF  905,FE9
03E76:  MOVFF  03,FEA
03E7A:  MOVLW  08
03E7C:  SUBWF  FEF,W
03E7E:  MOVWF  FEF
....................     MACGetArray(data, *len); 
03E80:  MOVFF  906,03
03E84:  MOVFF  905,FE9
03E88:  MOVFF  03,FEA
03E8C:  MOVFF  FEF,996
03E90:  MOVFF  904,995
03E94:  MOVFF  903,994
03E98:  CLRF   x97
03E9A:  MOVLB  0
03E9C:  CALL   177C
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
03EA0:  MOVLW  09
03EA2:  MOVLB  9
03EA4:  MOVWF  x58
03EA6:  MOVLW  0B
03EA8:  MOVWF  x57
03EAA:  MOVLB  0
03EAC:  RCALL  3D5C
....................  
....................     *code = packet.Type; 
03EAE:  MOVFF  902,03
03EB2:  MOVLB  9
03EB4:  MOVFF  901,FE9
03EB8:  MOVFF  03,FEA
03EBC:  MOVFF  90B,FEF
....................     *id = packet.Identifier; 
03EC0:  MOVFF  908,03
03EC4:  MOVFF  907,FE9
03EC8:  MOVFF  03,FEA
03ECC:  MOVFF  910,FEC
03ED0:  MOVF   FED,F
03ED2:  MOVFF  90F,FEF
....................     *seq = packet.SequenceNumber; 
03ED6:  MOVFF  90A,03
03EDA:  MOVFF  909,FE9
03EDE:  MOVFF  03,FEA
03EE2:  MOVFF  912,FEC
03EE6:  MOVF   FED,F
03EE8:  MOVFF  911,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
03EEC:  MOVF   x55,W
03EEE:  SUBWF  x53,W
03EF0:  BNZ   3EF8
03EF2:  MOVF   x56,W
03EF4:  SUBWF  x54,W
03EF6:  BZ    3EFC
03EF8:  MOVLW  00
03EFA:  BRA    3EFE
03EFC:  MOVLW  01
03EFE:  MOVWF  01
03F00:  MOVLB  0
03F02:  GOTO   45F8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
03F06:  MOVLW  01
03F08:  MOVLB  9
03F0A:  MOVWF  x86
03F0C:  MOVLB  0
03F0E:  CALL   1AF8
03F12:  MOVFF  01,953
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
03F16:  MOVLB  9
03F18:  INCFSZ x53,W
03F1A:  BRA    3F1E
....................       return; 
03F1C:  BRA    4010
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
03F1E:  MOVFF  953,99F
03F22:  CLRF   xA1
03F24:  MOVLW  14
03F26:  MOVWF  xA0
03F28:  MOVLB  0
03F2A:  CALL   1B20
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
03F2E:  CLRF   03
03F30:  MOVLB  9
03F32:  MOVF   x04,W
03F34:  ADDLW  08
03F36:  MOVWF  x51
03F38:  MOVLW  00
03F3A:  ADDWFC 03,W
03F3C:  MOVWF  x52
....................  
....................     packet.Code             = 0; 
03F3E:  CLRF   x0A
....................     packet.Type             = code; 
03F40:  MOVFF  901,909
....................     packet.Checksum         = 0; 
03F44:  CLRF   x0C
03F46:  CLRF   x0B
....................     packet.Identifier       = id; 
03F48:  MOVFF  906,90E
03F4C:  MOVFF  905,90D
....................     packet.SequenceNumber   = seq; 
03F50:  MOVFF  908,910
03F54:  MOVFF  907,90F
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
03F58:  MOVLW  09
03F5A:  MOVWF  FEA
03F5C:  MOVLW  11
03F5E:  MOVWF  FE9
03F60:  MOVFF  903,FE2
03F64:  MOVFF  902,FE1
03F68:  MOVF   x04,W
03F6A:  MOVWF  01
03F6C:  BZ    3F76
03F6E:  MOVFF  FE6,FEE
03F72:  DECFSZ 01,F
03F74:  BRA    3F6E
....................  
....................     SwapICMPPacket(&packet); 
03F76:  MOVLW  09
03F78:  MOVWF  x58
03F7A:  MOVWF  x57
03F7C:  MOVLB  0
03F7E:  RCALL  3D5C
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
03F80:  MOVLW  08
03F82:  MOVLB  9
03F84:  ADDWF  x04,W
03F86:  CLRF   x55
03F88:  MOVWF  x54
03F8A:  MOVFF  900,987
03F8E:  MOVFF  8FF,986
03F92:  MOVLW  01
03F94:  MOVWF  x88
03F96:  MOVFF  955,98A
03F9A:  MOVFF  954,989
03F9E:  MOVLB  0
03FA0:  CALL   2E5E
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
03FA4:  MOVLW  09
03FA6:  MOVLB  9
03FA8:  MOVWF  x55
03FAA:  MOVWF  x54
03FAC:  MOVWF  xAB
03FAE:  MOVWF  xAA
03FB0:  MOVFF  952,9AD
03FB4:  MOVFF  951,9AC
03FB8:  MOVLB  0
03FBA:  CALL   1BDC
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
03FBE:  MOVLB  9
03FC0:  CLRF   xA0
03FC2:  MOVLW  14
03FC4:  MOVWF  x9F
03FC6:  MOVFF  952,9A2
03FCA:  MOVFF  951,9A1
03FCE:  MOVLB  0
03FD0:  CALL   2D86
03FD4:  MOVFF  02,90C
03FD8:  MOVFF  01,90B
....................    IPSetTxBuffer(MyTxBuffer, 2); 
03FDC:  MOVFF  953,99F
03FE0:  MOVLB  9
03FE2:  CLRF   xA1
03FE4:  MOVLW  16
03FE6:  MOVWF  xA0
03FE8:  MOVLB  0
03FEA:  CALL   1B20
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
03FEE:  MOVLW  09
03FF0:  MOVLB  9
03FF2:  MOVWF  x55
03FF4:  MOVLW  0B
03FF6:  MOVWF  x54
03FF8:  MOVFF  955,9AB
03FFC:  MOVWF  xAA
03FFE:  CLRF   xAD
04000:  MOVLW  02
04002:  MOVWF  xAC
04004:  MOVLB  0
04006:  CALL   1BDC
.................... #endif 
....................  
....................  
....................     MACFlush(); 
0400A:  CALL   1CFC
0400E:  MOVLB  9
04010:  MOVLB  0
04012:  GOTO   4654 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
03D5C:  MOVLW  04
03D5E:  MOVLB  9
03D60:  ADDWF  x57,W
03D62:  MOVWF  01
03D64:  MOVLW  00
03D66:  ADDWFC x58,W
03D68:  MOVWF  03
03D6A:  MOVFF  01,959
03D6E:  MOVWF  x5A
03D70:  MOVLW  04
03D72:  ADDWF  x57,W
03D74:  MOVWF  FE9
03D76:  MOVLW  00
03D78:  ADDWFC x58,W
03D7A:  MOVWF  FEA
03D7C:  MOVFF  FEC,9A6
03D80:  MOVF   FED,F
03D82:  MOVFF  FEF,9A5
03D86:  MOVLB  0
03D88:  CALL   17DC
03D8C:  MOVFF  95A,FEA
03D90:  MOVFF  959,FE9
03D94:  MOVFF  02,FEC
03D98:  MOVF   FED,F
03D9A:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
03D9E:  MOVLW  06
03DA0:  MOVLB  9
03DA2:  ADDWF  x57,W
03DA4:  MOVWF  01
03DA6:  MOVLW  00
03DA8:  ADDWFC x58,W
03DAA:  MOVWF  03
03DAC:  MOVFF  01,959
03DB0:  MOVWF  x5A
03DB2:  MOVLW  06
03DB4:  ADDWF  x57,W
03DB6:  MOVWF  FE9
03DB8:  MOVLW  00
03DBA:  ADDWFC x58,W
03DBC:  MOVWF  FEA
03DBE:  MOVFF  FEC,9A6
03DC2:  MOVF   FED,F
03DC4:  MOVFF  FEF,9A5
03DC8:  MOVLB  0
03DCA:  CALL   17DC
03DCE:  MOVFF  95A,FEA
03DD2:  MOVFF  959,FE9
03DD6:  MOVFF  02,FEC
03DDA:  MOVF   FED,F
03DDC:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
03DE0:  MOVLW  02
03DE2:  MOVLB  9
03DE4:  ADDWF  x57,W
03DE6:  MOVWF  01
03DE8:  MOVLW  00
03DEA:  ADDWFC x58,W
03DEC:  MOVWF  03
03DEE:  MOVFF  01,959
03DF2:  MOVWF  x5A
03DF4:  MOVLW  02
03DF6:  ADDWF  x57,W
03DF8:  MOVWF  FE9
03DFA:  MOVLW  00
03DFC:  ADDWFC x58,W
03DFE:  MOVWF  FEA
03E00:  MOVFF  FEC,9A6
03E04:  MOVF   FED,F
03E06:  MOVFF  FEF,9A5
03E0A:  MOVLB  0
03E0C:  CALL   17DC
03E10:  MOVFF  95A,FEA
03E14:  MOVFF  959,FE9
03E18:  MOVFF  02,FEC
03E1C:  MOVF   FED,F
03E1E:  MOVFF  01,FEF
03E22:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
00FC8:  MOVLB  3
00FCA:  BCF    x93.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
00FCC:  MOVLB  8
00FCE:  SETF   x88
....................     Cache.MACAddr.v[1] = 0xff; 
00FD0:  SETF   x89
....................     Cache.MACAddr.v[2] = 0xff; 
00FD2:  SETF   x8A
....................     Cache.MACAddr.v[3] = 0xff; 
00FD4:  SETF   x8B
....................     Cache.MACAddr.v[4] = 0xff; 
00FD6:  SETF   x8C
....................     Cache.MACAddr.v[5] = 0xff; 
00FD8:  SETF   x8D
....................  
....................     Cache.IPAddr.Val = 0x0; 
00FDA:  CLRF   x91
00FDC:  CLRF   x90
00FDE:  CLRF   x8F
00FE0:  CLRF   x8E
00FE2:  MOVLB  0
00FE4:  GOTO   12A0 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
020B0:  MOVLW  00
020B2:  MOVLB  3
020B4:  BTFSC  x93.1
020B6:  MOVLW  01
020B8:  XORLW  00
020BA:  MOVLB  0
020BC:  BZ    20C0
020BE:  BRA    211A
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
020C0:  MOVLW  08
020C2:  MOVLB  9
020C4:  MOVWF  x0B
020C6:  SETF   x0A
020C8:  MOVLW  09
020CA:  MOVWF  x0D
020CC:  MOVWF  x0C
020CE:  MOVLB  0
020D0:  BRA    19FC
020D2:  MOVF   01,F
020D4:  BNZ   20D8
....................             break; 
020D6:  BRA    213E
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
020D8:  CALL   1706
....................  
....................         if ( opCode == ARP_REPLY ) 
020DC:  MOVLB  9
020DE:  MOVF   x09,F
020E0:  BNZ   2114
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
020E2:  MOVLW  08
020E4:  MOVWF  FEA
020E6:  MOVLW  88
020E8:  MOVWF  FE9
020EA:  MOVLW  08
020EC:  MOVWF  FE2
020EE:  SETF   FE1
020F0:  MOVLW  06
020F2:  MOVWF  01
020F4:  MOVFF  FE6,FEE
020F8:  DECFSZ 01,F
020FA:  BRA    20F4
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
020FC:  MOVFF  908,891
02100:  MOVFF  907,890
02104:  MOVFF  906,88F
02108:  MOVFF  905,88E
....................             break; 
0210C:  MOVLB  0
0210E:  BRA    213E
....................         } 
02110:  BRA    211A
02112:  MOVLB  9
....................         else 
....................             smARP = SM_ARP_REPLY; 
02114:  MOVLB  3
02116:  BSF    x93.1
02118:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
0211A:  MOVLW  08
0211C:  MOVLB  9
0211E:  MOVWF  x0B
02120:  SETF   x0A
02122:  CLRF   x0C
02124:  MOVLB  0
02126:  RCALL  1F2C
02128:  MOVF   01,F
0212A:  BZ    2134
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
0212C:  MOVLB  3
0212E:  BCF    x93.1
.................... 		} 
02130:  BRA    213C
02132:  MOVLB  0
....................         else 
....................             return FALSE; 
02134:  MOVLW  00
02136:  MOVWF  01
02138:  BRA    2142
0213A:  MOVLB  3
....................         break; 
0213C:  MOVLB  0
....................  
....................     } 
....................     return TRUE; 
0213E:  MOVLW  01
02140:  MOVWF  01
02142:  GOTO   450C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
04692:  MOVFF  8FD,03
04696:  MOVLB  8
04698:  MOVFF  8FC,FE9
0469C:  MOVFF  03,FEA
046A0:  MOVFF  FEF,904
046A4:  MOVFF  FEC,905
046A8:  MOVFF  FEC,906
046AC:  MOVFF  FEC,907
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
046B0:  MOVLW  08
046B2:  MOVLB  9
046B4:  MOVWF  x0B
046B6:  MOVLW  FE
046B8:  MOVWF  x0A
046BA:  MOVLW  01
046BC:  MOVWF  x0C
046BE:  MOVLB  0
046C0:  CALL   1F2C
046C4:  GOTO   535E (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
046C8:  MOVLB  8
046CA:  MOVFF  8FC,FE9
046CE:  MOVFF  8FD,FEA
046D2:  MOVFF  FEF,00
046D6:  MOVFF  FEC,01
046DA:  MOVFF  FEC,02
046DE:  MOVFF  FEC,03
046E2:  MOVF   00,W
046E4:  SUBWF  x8E,W
046E6:  BNZ   46FA
046E8:  MOVF   01,W
046EA:  SUBWF  x8F,W
046EC:  BNZ   46FA
046EE:  MOVF   02,W
046F0:  SUBWF  x90,W
046F2:  BNZ   46FA
046F4:  MOVF   03,W
046F6:  SUBWF  x91,W
046F8:  BZ    4722
046FA:  MOVLB  3
046FC:  MOVF   x61,W
046FE:  MOVLB  8
04700:  SUBWF  x8E,W
04702:  BNZ   4748
04704:  MOVLB  3
04706:  MOVF   x62,W
04708:  MOVLB  8
0470A:  SUBWF  x8F,W
0470C:  BNZ   4748
0470E:  MOVLB  3
04710:  MOVF   x63,W
04712:  MOVLB  8
04714:  SUBWF  x90,W
04716:  BNZ   4748
04718:  MOVLB  3
0471A:  MOVF   x64,W
0471C:  MOVLB  8
0471E:  SUBWF  x91,W
04720:  BNZ   4748
....................     { 
....................         *MACAddr = Cache.MACAddr; 
04722:  MOVFF  8FF,03
04726:  MOVFF  8FE,FE9
0472A:  MOVFF  03,FEA
0472E:  MOVLW  08
04730:  MOVWF  FE2
04732:  MOVLW  88
04734:  MOVWF  FE1
04736:  MOVLW  06
04738:  MOVWF  01
0473A:  MOVFF  FE6,FEE
0473E:  DECFSZ 01,F
04740:  BRA    473A
....................         return TRUE; 
04742:  MOVLW  01
04744:  MOVWF  01
04746:  BRA    474C
....................     } 
....................     return FALSE; 
04748:  MOVLW  00
0474A:  MOVWF  01
0474C:  MOVLB  0
0474E:  GOTO   538A (RETURN)
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
019FC:  MOVLW  09
019FE:  MOVLB  9
01A00:  MOVWF  x95
01A02:  MOVLW  0E
01A04:  MOVWF  x94
01A06:  CLRF   x97
01A08:  MOVLW  1C
01A0A:  MOVWF  x96
01A0C:  MOVLB  0
01A0E:  RCALL  177C
....................  
....................     MACDiscardRx(); 
01A10:  RCALL  1706
....................  
....................     SwapARPPacket(&packet); 
01A12:  MOVLW  09
01A14:  MOVLB  9
01A16:  MOVWF  x2B
01A18:  MOVLW  0E
01A1A:  MOVWF  x2A
01A1C:  MOVLB  0
01A1E:  RCALL  1944
....................  
....................    debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
01A20:  MOVLB  9
01A22:  DECFSZ x0E,W
01A24:  BRA    1A36
01A26:  MOVF   x0F,F
01A28:  BNZ   1A36
01A2A:  MOVF   x12,W
01A2C:  SUBLW  06
01A2E:  BNZ   1A36
01A30:  MOVF   x13,W
01A32:  SUBLW  04
01A34:  BZ    1A3C
....................          return FALSE; 
01A36:  MOVLW  00
01A38:  MOVWF  01
01A3A:  BRA    1AF2
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
01A3C:  MOVF   x14,W
01A3E:  SUBLW  02
01A40:  BNZ   1A56
01A42:  MOVF   x15,F
01A44:  BNZ   1A56
....................         *opCode = ARP_REPLY; 
01A46:  MOVFF  90D,03
01A4A:  MOVFF  90C,FE9
01A4E:  MOVFF  03,FEA
01A52:  CLRF   FEF
01A54:  BRA    1A86
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
01A56:  DECFSZ x14,W
01A58:  BRA    1A70
01A5A:  MOVF   x15,F
01A5C:  BNZ   1A70
....................         *opCode = ARP_REQUEST; 
01A5E:  MOVFF  90D,03
01A62:  MOVFF  90C,FE9
01A66:  MOVFF  03,FEA
01A6A:  MOVLW  01
01A6C:  MOVWF  FEF
01A6E:  BRA    1A86
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
01A70:  MOVFF  90D,03
01A74:  MOVFF  90C,FE9
01A78:  MOVFF  03,FEA
01A7C:  MOVLW  02
01A7E:  MOVWF  FEF
....................         return FALSE; 
01A80:  MOVLW  00
01A82:  MOVWF  01
01A84:  BRA    1AF2
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
01A86:  MOVLB  3
01A88:  MOVF   x53,W
01A8A:  MOVLB  9
01A8C:  SUBWF  x26,W
01A8E:  BNZ   1AEE
01A90:  MOVLB  3
01A92:  MOVF   x54,W
01A94:  MOVLB  9
01A96:  SUBWF  x27,W
01A98:  BNZ   1AEE
01A9A:  MOVLB  3
01A9C:  MOVF   x55,W
01A9E:  MOVLB  9
01AA0:  SUBWF  x28,W
01AA2:  BNZ   1AEE
01AA4:  MOVLB  3
01AA6:  MOVF   x56,W
01AA8:  MOVLB  9
01AAA:  SUBWF  x29,W
01AAC:  BNZ   1AEE
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
01AAE:  MOVFF  90A,FE9
01AB2:  MOVFF  90B,FEA
01AB6:  MOVLW  09
01AB8:  MOVWF  FE2
01ABA:  MOVLW  16
01ABC:  MOVWF  FE1
01ABE:  MOVLW  06
01AC0:  MOVWF  01
01AC2:  MOVFF  FE6,FEE
01AC6:  DECFSZ 01,F
01AC8:  BRA    1AC2
....................         remote->IPAddr      = packet.SenderIPAddr; 
01ACA:  MOVLW  06
01ACC:  ADDWF  x0A,W
01ACE:  MOVWF  FE9
01AD0:  MOVLW  00
01AD2:  ADDWFC x0B,W
01AD4:  MOVWF  FEA
01AD6:  MOVFF  91C,FEF
01ADA:  MOVFF  91D,FEC
01ADE:  MOVFF  91E,FEC
01AE2:  MOVFF  91F,FEC
....................         return TRUE; 
01AE6:  MOVLW  01
01AE8:  MOVWF  01
01AEA:  BRA    1AF2
....................     } 
01AEC:  BRA    1AF2
....................     else 
....................         return FALSE; 
01AEE:  MOVLW  00
01AF0:  MOVWF  01
01AF2:  MOVLB  0
01AF4:  GOTO   20D2 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
01F2C:  MOVLW  01
01F2E:  MOVLB  9
01F30:  MOVWF  x86
01F32:  MOVLB  0
01F34:  RCALL  1AF8
01F36:  MOVFF  01,929
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
01F3A:  MOVLB  9
01F3C:  INCFSZ x29,W
01F3E:  BRA    1F46
....................       return FALSE; 
01F40:  MOVLW  00
01F42:  MOVWF  01
01F44:  BRA    20AC
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
01F46:  MOVFF  929,99F
01F4A:  CLRF   xA1
01F4C:  CLRF   xA0
01F4E:  MOVLB  0
01F50:  RCALL  1B20
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
01F52:  MOVLB  9
01F54:  CLRF   x0E
01F56:  MOVLW  01
01F58:  MOVWF  x0D
....................     packet.Protocol                 = ARP_IP; 
01F5A:  MOVLW  08
01F5C:  MOVWF  x10
01F5E:  CLRF   x0F
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
01F60:  MOVLW  06
01F62:  MOVWF  x11
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
01F64:  MOVLW  04
01F66:  MOVWF  x12
....................  
....................     if ( opCode == ARP_REQUEST ) 
01F68:  DECFSZ x0C,W
01F6A:  BRA    1F80
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
01F6C:  CLRF   x14
01F6E:  MOVLW  01
01F70:  MOVWF  x13
....................         packet.TargetMACAddr.v[0]   = 0xff; 
01F72:  SETF   x1F
....................         packet.TargetMACAddr.v[1]   = 0xff; 
01F74:  SETF   x20
....................         packet.TargetMACAddr.v[2]   = 0xff; 
01F76:  SETF   x21
....................         packet.TargetMACAddr.v[3]   = 0xff; 
01F78:  SETF   x22
....................         packet.TargetMACAddr.v[4]   = 0xff; 
01F7A:  SETF   x23
....................         packet.TargetMACAddr.v[5]   = 0xff; 
01F7C:  SETF   x24
....................     } 
01F7E:  BRA    1FA2
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
01F80:  CLRF   x14
01F82:  MOVLW  02
01F84:  MOVWF  x13
....................         packet.TargetMACAddr        = remote->MACAddr; 
01F86:  MOVFF  90A,FE1
01F8A:  MOVFF  90B,FE2
01F8E:  MOVLW  09
01F90:  MOVWF  FEA
01F92:  MOVLW  1F
01F94:  MOVWF  FE9
01F96:  MOVLW  06
01F98:  MOVWF  01
01F9A:  MOVFF  FE6,FEE
01F9E:  DECFSZ 01,F
01FA0:  BRA    1F9A
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
01FA2:  MOVLW  09
01FA4:  MOVWF  FEA
01FA6:  MOVLW  15
01FA8:  MOVWF  FE9
01FAA:  MOVLW  03
01FAC:  MOVWF  FE2
01FAE:  MOVLW  57
01FB0:  MOVWF  FE1
01FB2:  MOVLW  06
01FB4:  MOVWF  01
01FB6:  MOVFF  FE6,FEE
01FBA:  DECFSZ 01,F
01FBC:  BRA    1FB6
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
01FBE:  MOVFF  356,91E
01FC2:  MOVFF  355,91D
01FC6:  MOVFF  354,91C
01FCA:  MOVFF  353,91B
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
01FCE:  MOVLW  06
01FD0:  ADDWF  x0A,W
01FD2:  MOVWF  FE9
01FD4:  MOVLW  00
01FD6:  ADDWFC x0B,W
01FD8:  MOVWF  FEA
01FDA:  MOVFF  FEF,00
01FDE:  MOVFF  FEC,01
01FE2:  MOVFF  FEC,02
01FE6:  MOVFF  FEC,03
01FEA:  MOVF   00,W
01FEC:  XORWF  x1B,W
01FEE:  MOVWF  x2A
01FF0:  MOVF   01,W
01FF2:  XORWF  x1C,W
01FF4:  MOVWF  x2B
01FF6:  MOVF   02,W
01FF8:  XORWF  x1D,W
01FFA:  MOVWF  x2C
01FFC:  MOVF   03,W
01FFE:  XORWF  x1E,W
02000:  MOVWF  x2D
02002:  MOVF   x2A,W
02004:  MOVLB  3
02006:  ANDWF  x5D,W
02008:  MOVWF  00
0200A:  MOVLB  9
0200C:  MOVF   x2B,W
0200E:  MOVLB  3
02010:  ANDWF  x5E,W
02012:  MOVWF  01
02014:  MOVLB  9
02016:  MOVF   x2C,W
02018:  MOVLB  3
0201A:  ANDWF  x5F,W
0201C:  MOVWF  02
0201E:  MOVLB  9
02020:  MOVF   x2D,W
02022:  MOVLB  3
02024:  ANDWF  x60,W
02026:  MOVWF  03
02028:  MOVF   00,F
0202A:  BNZ   2038
0202C:  MOVF   01,F
0202E:  BNZ   2038
02030:  MOVF   02,F
02032:  BNZ   2038
02034:  MOVF   03,F
02036:  BZ    204A
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
02038:  MOVFF  364,928
0203C:  MOVFF  363,927
02040:  MOVFF  362,926
02044:  MOVFF  361,925
....................     } 
02048:  BRA    206A
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
0204A:  MOVLW  06
0204C:  MOVLB  9
0204E:  ADDWF  x0A,W
02050:  MOVWF  FE9
02052:  MOVLW  00
02054:  ADDWFC x0B,W
02056:  MOVWF  FEA
02058:  MOVFF  FEF,925
0205C:  MOVFF  FEC,926
02060:  MOVFF  FEC,927
02064:  MOVFF  FEC,928
02068:  MOVLB  3
....................  
....................     SwapARPPacket(&packet); 
0206A:  MOVLW  09
0206C:  MOVLB  9
0206E:  MOVWF  x2B
02070:  MOVLW  0D
02072:  MOVWF  x2A
02074:  MOVLB  0
02076:  RCALL  1944
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
02078:  MOVLW  09
0207A:  MOVLB  9
0207C:  MOVWF  xA4
0207E:  MOVLW  1F
02080:  MOVWF  xA3
02082:  MOVLW  06
02084:  MOVWF  xA5
02086:  CLRF   xA7
02088:  MOVLW  1C
0208A:  MOVWF  xA6
0208C:  MOVLB  0
0208E:  RCALL  1C26
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
02090:  MOVLW  09
02092:  MOVLB  9
02094:  MOVWF  xAB
02096:  MOVLW  0D
02098:  MOVWF  xAA
0209A:  CLRF   xAD
0209C:  MOVLW  1C
0209E:  MOVWF  xAC
020A0:  MOVLB  0
020A2:  RCALL  1BDC
....................  
....................     MACFlush(); 
020A4:  RCALL  1CFC
....................     
....................    return TRUE; 
020A6:  MOVLW  01
020A8:  MOVWF  01
020AA:  MOVLB  9
020AC:  MOVLB  0
020AE:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
01944:  MOVLB  9
01946:  MOVFF  92A,01
0194A:  MOVFF  92B,92D
0194E:  MOVFF  01,92C
01952:  MOVFF  92A,FE9
01956:  MOVFF  92B,FEA
0195A:  MOVFF  FEC,9A6
0195E:  MOVF   FED,F
01960:  MOVFF  FEF,9A5
01964:  MOVLB  0
01966:  RCALL  17DC
01968:  MOVFF  92D,FEA
0196C:  MOVFF  92C,FE9
01970:  MOVFF  02,FEC
01974:  MOVF   FED,F
01976:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
0197A:  MOVLW  02
0197C:  MOVLB  9
0197E:  ADDWF  x2A,W
01980:  MOVWF  01
01982:  MOVLW  00
01984:  ADDWFC x2B,W
01986:  MOVWF  03
01988:  MOVFF  01,92C
0198C:  MOVWF  x2D
0198E:  MOVLW  02
01990:  ADDWF  x2A,W
01992:  MOVWF  FE9
01994:  MOVLW  00
01996:  ADDWFC x2B,W
01998:  MOVWF  FEA
0199A:  MOVFF  FEC,9A6
0199E:  MOVF   FED,F
019A0:  MOVFF  FEF,9A5
019A4:  MOVLB  0
019A6:  RCALL  17DC
019A8:  MOVFF  92D,FEA
019AC:  MOVFF  92C,FE9
019B0:  MOVFF  02,FEC
019B4:  MOVF   FED,F
019B6:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
019BA:  MOVLW  06
019BC:  MOVLB  9
019BE:  ADDWF  x2A,W
019C0:  MOVWF  01
019C2:  MOVLW  00
019C4:  ADDWFC x2B,W
019C6:  MOVWF  03
019C8:  MOVFF  01,92C
019CC:  MOVWF  x2D
019CE:  MOVLW  06
019D0:  ADDWF  x2A,W
019D2:  MOVWF  FE9
019D4:  MOVLW  00
019D6:  ADDWFC x2B,W
019D8:  MOVWF  FEA
019DA:  MOVFF  FEC,9A6
019DE:  MOVF   FED,F
019E0:  MOVFF  FEF,9A5
019E4:  MOVLB  0
019E6:  RCALL  17DC
019E8:  MOVFF  92D,FEA
019EC:  MOVFF  92C,FE9
019F0:  MOVFF  02,FEC
019F4:  MOVF   FED,F
019F6:  MOVFF  01,FEF
019FA:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
01294:  MOVLB  8
01296:  CLRF   x92
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
01298:  MOVLB  0
0129A:  BRA    0ACC
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
0129C:  BRA    0DEE
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
0129E:  BRA    0FC8
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
012A0:  BRA    1142
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
012A2:  GOTO   6CDE (RETURN)
....................    TFTPInit(); 
.................... #endif 
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
044A8:  MOVLB  8
044AA:  BCF    xFE.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
044AC:  BCF    xFE.0
....................         switch(smStack) 
044AE:  MOVF   x92,W
044B0:  ADDLW  F9
044B2:  BTFSC  FD8.0
044B4:  BRA    4660
044B6:  ADDLW  07
044B8:  MOVLB  0
044BA:  GOTO   466A
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
044BE:  MOVLW  08
044C0:  MOVLB  9
044C2:  MOVWF  x00
044C4:  MOVLW  93
044C6:  MOVLB  8
044C8:  MOVWF  xFF
044CA:  MOVLW  08
044CC:  MOVLB  9
044CE:  MOVWF  x02
044D0:  MOVLW  FD
044D2:  MOVWF  x01
044D4:  MOVLB  0
044D6:  GOTO   17F2
044DA:  MOVF   01,F
044DC:  BNZ   44E4
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
044DE:  MOVLB  8
044E0:  BRA    4660
044E2:  MOVLB  0
....................             } 
....................  
....................             debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
044E4:  MOVLB  8
044E6:  BSF    xFE.0
....................             if ( type.MACFrameType == MAC_IP ) { 
044E8:  MOVF   xFD,F
044EA:  BNZ   44F2
....................                 smStack = SM_STACK_IP; 
044EC:  MOVLW  02
044EE:  MOVWF  x92
....................                 debug_stack(debug_putc, "IP "); 
....................             } 
044F0:  BRA    4506
....................             else if ( type.MACFrameType == MAC_ARP ) { 
044F2:  MOVF   xFD,W
044F4:  SUBLW  06
044F6:  BNZ   44FE
....................                 smStack = SM_STACK_ARP; 
044F8:  MOVLW  05
044FA:  MOVWF  x92
....................                 debug_stack(debug_putc, "ARP "); 
....................             } 
044FC:  BRA    4506
....................             else { 
....................                 MACDiscardRx(); 
044FE:  MOVLB  0
04500:  CALL   1706
04504:  MOVLB  8
....................                 debug_stack(debug_putc, "DISCARD"); 
....................             } 
....................             break; 
04506:  BRA    4660
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
04508:  GOTO   20B0
0450C:  MOVF   01,F
0450E:  BZ    4516
....................                 smStack = SM_STACK_IDLE; 
04510:  MOVLB  8
04512:  CLRF   x92
04514:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
04516:  MOVLB  8
04518:  BRA    4660
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
0451A:  MOVLW  08
0451C:  MOVLB  9
0451E:  MOVWF  x00
04520:  MOVLW  F9
04522:  MOVLB  8
04524:  MOVWF  xFF
04526:  MOVLW  08
04528:  MOVLB  9
0452A:  MOVWF  x02
0452C:  MOVLW  93
0452E:  MOVWF  x01
04530:  MOVLW  08
04532:  MOVWF  x04
04534:  MOVLW  FD
04536:  MOVWF  x03
04538:  MOVLW  08
0453A:  MOVWF  x06
0453C:  MOVLW  9D
0453E:  MOVWF  x05
04540:  MOVLB  0
04542:  GOTO   239E
04546:  MOVF   01,F
04548:  BZ    4574
....................             { 
....................                 lbContinue = TRUE; 
0454A:  MOVLB  8
0454C:  BSF    xFE.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
0454E:  DECFSZ xFD,W
04550:  BRA    4558
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
04552:  MOVLW  03
04554:  MOVWF  x92
....................                     debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
04556:  BRA    4570
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
04558:  MOVF   xFD,W
0455A:  SUBLW  06
0455C:  BNZ   4564
....................                     smStack = SM_STACK_TCP; 
0455E:  MOVLW  06
04560:  MOVWF  x92
....................                     debug_stack(debug_putc, "TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
04562:  BRA    4570
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack(debug_putc, "UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
04564:  BCF    xFE.0
....................                     MACDiscardRx(); 
04566:  MOVLB  0
04568:  CALL   1706
....................  
....................                     smStack = SM_STACK_IDLE; 
0456C:  MOVLB  8
0456E:  CLRF   x92
....................                     debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................                 } 
....................             } 
04570:  BRA    457C
04572:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
04574:  CALL   1706
....................                 smStack = SM_STACK_IDLE; 
04578:  MOVLB  8
0457A:  CLRF   x92
....................                 debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................             } 
....................             break; 
0457C:  BRA    4660
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0457E:  MOVLW  08
04580:  MOVLB  9
04582:  MOVWF  x00
04584:  MOVLW  93
04586:  MOVLB  8
04588:  MOVWF  xFF
0458A:  MOVLW  08
0458C:  MOVLB  9
0458E:  MOVWF  x02
04590:  MOVLW  F9
04592:  MOVWF  x01
04594:  MOVFF  89E,904
04598:  MOVFF  89D,903
0459C:  MOVLB  0
0459E:  GOTO   3BC0
045A2:  MOVF   01,F
045A4:  BZ    45AC
....................             { 
....................                 debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
045A6:  MOVLB  8
045A8:  CLRF   x92
045AA:  MOVLB  0
....................             } 
....................             break; 
045AC:  MOVLB  8
045AE:  BRA    4660
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
045B0:  MOVLB  8
045B2:  CLRF   x92
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
045B4:  MOVF   x9E,F
045B6:  BNZ   460A
045B8:  MOVF   x9D,W
045BA:  SUBLW  48
045BC:  BNC   460A
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
045BE:  MOVLW  08
045C0:  MOVLB  9
045C2:  MOVWF  x00
045C4:  MOVLW  9D
045C6:  MOVLB  8
045C8:  MOVWF  xFF
045CA:  MOVLW  08
045CC:  MOVLB  9
045CE:  MOVWF  x02
045D0:  MOVLW  FD
045D2:  MOVWF  x01
045D4:  MOVLW  08
045D6:  MOVWF  x04
045D8:  MOVLW  9F
045DA:  MOVWF  x03
045DC:  MOVFF  900,906
045E0:  MOVFF  8FF,905
045E4:  MOVLW  08
045E6:  MOVWF  x08
045E8:  MOVLW  DF
045EA:  MOVWF  x07
045EC:  MOVLW  08
045EE:  MOVWF  x0A
045F0:  MOVLW  E1
045F2:  MOVWF  x09
045F4:  MOVLB  0
045F6:  BRA    3E24
045F8:  MOVF   01,F
045FA:  BZ    460C
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
045FC:  MOVLB  8
045FE:  MOVF   xFD,W
04600:  SUBLW  08
04602:  BNZ   460A
....................                     { 
....................                         debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
04604:  BSF    xFE.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
04606:  MOVLW  04
04608:  MOVWF  x92
0460A:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
0460C:  CALL   1706
....................             break; 
04610:  MOVLB  8
04612:  BRA    4660
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
04614:  MOVLW  01
04616:  MOVLB  9
04618:  MOVWF  x86
0461A:  MOVLB  0
0461C:  CALL   2C46
04620:  MOVF   01,F
04622:  BZ    465A
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
04624:  MOVLW  08
04626:  MOVLB  9
04628:  MOVWF  x00
0462A:  MOVLW  93
0462C:  MOVLB  8
0462E:  MOVWF  xFF
04630:  MOVLB  9
04632:  CLRF   x01
04634:  MOVLW  08
04636:  MOVWF  x03
04638:  MOVLW  9F
0463A:  MOVWF  x02
0463C:  MOVFF  89D,904
04640:  MOVFF  8E0,906
04644:  MOVFF  8DF,905
04648:  MOVFF  8E2,908
0464C:  MOVFF  8E1,907
04650:  MOVLB  0
04652:  BRA    3F06
....................  
....................                 debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
04654:  MOVLB  8
04656:  CLRF   x92
04658:  MOVLB  0
....................             } 
....................             break; 
0465A:  MOVLB  8
0465C:  BRA    4660
0465E:  MOVLB  8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
04660:  BTFSC  xFE.0
04662:  BRA    44AC
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
04664:  MOVLB  0
04666:  BRA    4016
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
04668:  RETURN 0
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
....................  
....................  
.................... // Dirección IP de la PC (destino). 
.................... IP_ADDR server; 
.................... // Puerto TCP. 
.................... #define EXAMPLE_TCP_PORT   (int16)7654 
.................... //int reintento_envio; 
.................... // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX. 
....................  
.................... void MACAddrInit(void) 
.................... { 
....................    MY_MAC_BYTE1=0x00; 
*
00A6A:  MOVLB  3
00A6C:  CLRF   x57
....................    MY_MAC_BYTE2=0x04; 
00A6E:  MOVLW  04
00A70:  MOVWF  x58
....................    MY_MAC_BYTE3=0xA3; 
00A72:  MOVLW  A3
00A74:  MOVWF  x59
....................    MY_MAC_BYTE4=0x00; 
00A76:  CLRF   x5A
....................    MY_MAC_BYTE5=0x00; 
00A78:  CLRF   x5B
....................    MY_MAC_BYTE6=0x11; 
00A7A:  MOVLW  11
00A7C:  MOVWF  x5C
00A7E:  MOVLB  0
00A80:  GOTO   6CD2 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    // IP del dispositivo. 
....................    MY_IP_BYTE1=192; 
00A84:  MOVLW  C0
00A86:  MOVLB  3
00A88:  MOVWF  x53
....................    MY_IP_BYTE2=168; 
00A8A:  MOVLW  A8
00A8C:  MOVWF  x54
....................    MY_IP_BYTE3=1; 
00A8E:  MOVLW  01
00A90:  MOVWF  x55
....................    MY_IP_BYTE4=151; 
00A92:  MOVLW  97
00A94:  MOVWF  x56
....................  
....................    // Puerta de enlace. 
....................    MY_GATE_BYTE1=192; 
00A96:  MOVLW  C0
00A98:  MOVWF  x61
....................    MY_GATE_BYTE2=168; 
00A9A:  MOVLW  A8
00A9C:  MOVWF  x62
....................    MY_GATE_BYTE3=1; 
00A9E:  MOVLW  01
00AA0:  MOVWF  x63
....................    MY_GATE_BYTE4=254; 
00AA2:  MOVLW  FE
00AA4:  MOVWF  x64
....................  
....................    // Máscara de Subred. 
....................    MY_MASK_BYTE1=255; 
00AA6:  SETF   x5D
....................    MY_MASK_BYTE2=255; 
00AA8:  SETF   x5E
....................    MY_MASK_BYTE3=255; 
00AAA:  SETF   x5F
....................    MY_MASK_BYTE4=0; 
00AAC:  CLRF   x60
00AAE:  MOVLB  0
00AB0:  GOTO   6CD6 (RETURN)
.................... } 
....................  
.................... void ServerAddrInit(void) { 
....................    // IP del servidor.. 
....................    server.v[0]=192; 
00AB4:  MOVLW  C0
00AB6:  MOVLB  8
00AB8:  MOVWF  xE3
....................    server.v[1]=168; 
00ABA:  MOVLW  A8
00ABC:  MOVWF  xE4
....................    server.v[2]=1; 
00ABE:  MOVLW  01
00AC0:  MOVWF  xE5
....................    server.v[3]=150; 
00AC2:  MOVLW  96
00AC4:  MOVWF  xE6
00AC6:  MOVLB  0
00AC8:  GOTO   6CDA (RETURN)
.................... } 
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
....................  
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    //static int8 counter; 
....................    //char str[20]; 
....................    static int8 button1_held; 
....................     
....................    if (TCPIsGetReady(socket)) {//ESCUCHA PUERTO TCP 
*
051CC:  MOVFF  8FC,8FE
051D0:  GOTO   498A
051D4:  MOVF   01,F
051D6:  BZ    525E
....................       //fprintf(DEBUG,"\r\nLEE SOCKET"); 
.................... //   if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      lcd_putc("LEE SOCKET          ");         } 
....................       edo_str=1;//bandera de dato recibido en socket actual 
051D8:  MOVLW  01
051DA:  MOVWF  4E
....................       i=0; 
051DC:  CLRF   41
051DE:  CLRF   40
....................       while ( TCPGet(socket, &c) ) { 
051E0:  MOVFF  8FC,8FE
051E4:  MOVLW  08
051E6:  MOVLB  9
051E8:  MOVWF  x00
051EA:  MOVLW  FD
051EC:  MOVLB  8
051EE:  MOVWF  xFF
051F0:  MOVLB  0
051F2:  GOTO   49D0
051F6:  MOVF   01,F
051F8:  BZ    525E
....................          rxtcp[i++]=c; 
051FA:  MOVFF  41,03
051FE:  MOVF   40,W
05200:  INCF   40,F
05202:  BTFSC  FD8.2
05204:  INCF   41,F
05206:  MOVLB  8
05208:  MOVWF  xFE
0520A:  MOVLW  60
0520C:  ADDWF  xFE,W
0520E:  MOVWF  FE9
05210:  MOVLW  01
05212:  ADDWFC 03,W
05214:  MOVWF  FEA
05216:  MOVFF  8FD,FEF
....................          if (c=='@') { 
0521A:  MOVF   xFD,W
0521C:  SUBLW  40
0521E:  BNZ   523C
....................             edo_str=0; 
05220:  CLRF   4E
....................             lcd_gotoxy(20,4); 
05222:  MOVLW  14
05224:  MOVLB  9
05226:  MOVWF  x00
05228:  MOVLW  04
0522A:  MOVWF  x01
0522C:  MOVLB  0
0522E:  CALL   060C
....................             printf(lcd_putc,"%c",c); 
05232:  MOVFF  8FD,8FF
05236:  CALL   065E
0523A:  MOVLB  8
....................          } 
....................          if (i>port_size) {i=port_size;} 
0523C:  MOVF   41,F
0523E:  BNZ   5246
05240:  MOVF   40,W
05242:  SUBLW  5A
05244:  BC    524C
05246:  CLRF   41
05248:  MOVLW  5A
0524A:  MOVWF  40
....................          rxtcp[i]=0; 
0524C:  MOVLW  60
0524E:  ADDWF  40,W
05250:  MOVWF  FE9
05252:  MOVLW  01
05254:  ADDWFC 41,W
05256:  MOVWF  FEA
05258:  CLRF   FEF
0525A:  MOVLB  0
0525C:  BRA    51E0
....................       } 
....................    } 
....................  
.................... //send message over TCP 
....................    //if(envia_pc) fprintf(DEBUG,"envia_pc:%u !button1_held:%u TCPIsPutReady(socket):%u\r\n",envia_pc,button1_held, TCPIsPutReady(socket) ); 
....................    if (envia_pc && !button1_held && TCPIsPutReady(socket)) {//ENVIA MENSAJE POR TCP 
0525E:  MOVF   1A,F
05260:  BZ    52A6
05262:  MOVLB  8
05264:  MOVF   xE7,F
05266:  BTFSC  FD8.2
05268:  BRA    526E
0526A:  MOVLB  0
0526C:  BRA    52A6
0526E:  MOVFF  8FC,90E
05272:  MOVLB  0
05274:  RCALL  4AB4
05276:  MOVF   01,F
05278:  BZ    52A6
....................       button1_held=TRUE; 
0527A:  MOVLW  01
0527C:  MOVLB  8
0527E:  MOVWF  xE7
....................       TCPPutArray(socket,txtcp,size_tx_tcp);//SOCKET,DATO,NO.BYTES 
05280:  MOVFF  8FC,8FE
05284:  MOVLB  9
05286:  MOVWF  x00
05288:  MOVLW  06
0528A:  MOVLB  8
0528C:  MOVWF  xFF
0528E:  MOVLB  9
05290:  CLRF   x02
05292:  MOVFF  48,901
05296:  MOVLB  0
05298:  BRA    4E60
....................       TCPFlush(socket); 
0529A:  MOVFF  8FC,909
0529E:  RCALL  4CC0
....................       reintento_envio=0; 
052A0:  CLRF   4F
....................       envia_pc=0; 
052A2:  CLRF   1A
....................       //fprintf(DEBUG,"Envio:%s\r\n",txtcp); 
.................... //      if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      printf(lcd_putc,"Envio:%s       ",txtcp);} 
....................    }////////////////// 
052A4:  BRA    52D2
....................    else if (envia_pc && !button1_held && !TCPIsPutReady(socket)) {//SI NO PUEDE VACIAR DATOS ROMPE CONEXION 
052A6:  MOVF   1A,F
052A8:  BZ    52D2
052AA:  MOVLB  8
052AC:  MOVF   xE7,F
052AE:  BTFSC  FD8.2
052B0:  BRA    52B6
052B2:  MOVLB  0
052B4:  BRA    52D2
052B6:  MOVFF  8FC,90E
052BA:  MOVLB  0
052BC:  CALL   4AB4
052C0:  MOVF   01,F
052C2:  BNZ   52D2
....................       reintento_envio++; 
052C4:  INCF   4F,F
....................       if(reintento_envio>=10) TCPDisconnect(socket); 
052C6:  MOVF   4F,W
052C8:  SUBLW  09
052CA:  BC    52D2
052CC:  MOVFF  8FC,8FE
052D0:  RCALL  5096
....................    }/////////////////// 
....................     
....................    if (!envia_pc) { 
052D2:  MOVF   1A,F
052D4:  BNZ   52DC
....................       button1_held=FALSE; 
052D6:  MOVLB  8
052D8:  CLRF   xE7
052DA:  MOVLB  0
....................    } 
....................     
....................    //#if defined(ESTADO_entrada04)//CIERRA LAS CONEXIONES 
....................    //if (ESTADO_entrada04) { 
....................      // return(TRUE); 
....................    //} 
....................   //#endif 
....................  
....................    return(TRUE); 
052DC:  MOVLW  01
052DE:  MOVWF  01
052E0:  GOTO   552E (RETURN)
.................... } 
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_ARP_REQ=1, MYTCP_STATE_ARP_WAIT=2, 
....................       MYTCP_STATE_CONNECT=3, MYTCP_STATE_CONNECT_WAIT=4, 
....................       MYTCP_STATE_CONNECTED=5, MYTCP_STATE_DISCONNECT=6, 
....................       MYTCP_STATE_FORCE_DISCONNECT=7 
....................    } state=0; 
....................    static NODE_INFO remote; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................  
....................    currTick=TickGet(); 
052E4:  CALL   2B2E
052E8:  MOVFF  02,8FA
052EC:  MOVFF  01,8F9
....................  
....................    switch (state) { 
052F0:  MOVLB  8
052F2:  MOVF   xEB,W
052F4:  ADDLW  F8
052F6:  BTFSC  FD8.0
052F8:  BRA    5622
052FA:  ADDLW  08
052FC:  MOVLB  0
052FE:  GOTO   5626
....................       case MYTCP_STATE_NEW: 
....................          memcpy(&remote.IPAddr, &server, sizeof(IP_ADDR)); 
05302:  MOVFF  8E3,8F2
05306:  MOVFF  8E4,8F3
0530A:  MOVFF  8E5,8F4
0530E:  MOVFF  8E6,8F5
....................          //fprintf(DEBUG,"\n Solicitud ARP."); 
....................          if(!espera)   { 
05312:  MOVLB  2
05314:  MOVF   x7D,F
05316:  BNZ   5336
....................          lcd_gotoxy(1,4); 
05318:  MOVLW  01
0531A:  MOVLB  9
0531C:  MOVWF  x00
0531E:  MOVLW  04
05320:  MOVWF  x01
05322:  MOVLB  0
05324:  CALL   060C
....................          lcd_putc("Solicitud ARP.      ");} 
05328:  MOVLW  2A
0532A:  MOVWF  FF6
0532C:  MOVLW  01
0532E:  MOVWF  FF7
05330:  CALL   06C2
05334:  MOVLB  2
....................          state=MYTCP_STATE_ARP_REQ; 
05336:  MOVLW  01
05338:  MOVLB  8
0533A:  MOVWF  xEB
0533C:  MOVLB  0
....................  
....................       case MYTCP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
0533E:  MOVLW  01
05340:  MOVLB  9
05342:  MOVWF  x86
05344:  MOVLB  0
05346:  CALL   2C46
0534A:  MOVF   01,F
0534C:  BZ    536E
....................             ARPResolve(&remote.IPAddr); 
0534E:  MOVLW  08
05350:  MOVLB  8
05352:  MOVWF  xFD
05354:  MOVLW  F2
05356:  MOVWF  xFC
05358:  MOVLB  0
0535A:  GOTO   4692
....................             lastTick=currTick; 
0535E:  MOVFF  8FA,8E9
05362:  MOVFF  8F9,8E8
....................             state=MYTCP_STATE_ARP_WAIT; 
05366:  MOVLW  02
05368:  MOVLB  8
0536A:  MOVWF  xEB
0536C:  MOVLB  0
....................          } 
....................          break; 
0536E:  MOVLB  8
05370:  BRA    5622
....................  
....................       case MYTCP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) { 
05372:  MOVLW  08
05374:  MOVLB  8
05376:  MOVWF  xFD
05378:  MOVLW  F2
0537A:  MOVWF  xFC
0537C:  MOVLW  08
0537E:  MOVWF  xFF
05380:  MOVLW  EC
05382:  MOVWF  xFE
05384:  MOVLB  0
05386:  GOTO   46C8
0538A:  MOVF   01,F
0538C:  BZ    53BA
....................             state=MYTCP_STATE_CONNECT; 
0538E:  MOVLW  03
05390:  MOVLB  8
05392:  MOVWF  xEB
....................             //fprintf(DEBUG,"\nCONECTANDO...      "); 
....................             if(!espera)   { 
05394:  MOVLB  2
05396:  MOVF   x7D,F
05398:  BNZ   53B8
....................             lcd_gotoxy(1,4); 
0539A:  MOVLW  01
0539C:  MOVLB  9
0539E:  MOVWF  x00
053A0:  MOVLW  04
053A2:  MOVWF  x01
053A4:  MOVLB  0
053A6:  CALL   060C
....................             lcd_putc("CONECTANDO...       ");} 
053AA:  MOVLW  40
053AC:  MOVWF  FF6
053AE:  MOVLW  01
053B0:  MOVWF  FF7
053B2:  CALL   06C2
053B6:  MOVLB  2
....................          } 
053B8:  BRA    5414
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) { 
053BA:  MOVLB  8
053BC:  MOVF   xFA,W
053BE:  SUBWF  xE9,W
053C0:  BNC   53CA
053C2:  BNZ   53CE
053C4:  MOVF   xE8,W
053C6:  SUBWF  xF9,W
053C8:  BNC   53CE
053CA:  MOVLW  00
053CC:  BRA    53D0
053CE:  MOVLW  01
053D0:  CLRF   03
053D2:  IORWF  03,W
053D4:  BZ    53FC
053D6:  MOVLW  FF
053D8:  BSF    FD8.0
053DA:  SUBFWB xE8,W
053DC:  MOVWF  xFC
053DE:  MOVLW  FF
053E0:  SUBFWB xE9,W
053E2:  MOVWF  xFD
053E4:  MOVF   xF9,W
053E6:  ADDWF  xFC,F
053E8:  MOVF   xFA,W
053EA:  ADDWFC xFD,F
053EC:  MOVLW  01
053EE:  ADDWF  xFC,W
053F0:  MOVWF  01
053F2:  MOVLW  00
053F4:  ADDWFC xFD,W
053F6:  MOVWF  03
053F8:  MOVF   01,W
053FA:  BRA    540A
053FC:  MOVF   xE8,W
053FE:  SUBWF  xF9,W
05400:  MOVWF  00
05402:  MOVF   xE9,W
05404:  SUBWFB xFA,W
05406:  MOVWF  03
05408:  MOVF   00,W
0540A:  SUBLW  18
0540C:  BC    5412
....................             state=MYTCP_STATE_ARP_REQ; 
0540E:  MOVLW  01
05410:  MOVWF  xEB
05412:  MOVLB  2
....................          } 
....................          break; 
05414:  MOVLB  8
05416:  BRA    5622
....................  
....................       case MYTCP_STATE_CONNECT: 
....................          socket2=socket=TCPConnect(&remote, EXAMPLE_TCP_PORT); 
05418:  MOVLW  08
0541A:  MOVLB  8
0541C:  MOVWF  xFD
0541E:  MOVLW  EC
05420:  MOVWF  xFC
05422:  MOVLW  1D
05424:  MOVWF  xFF
05426:  MOVLW  E6
05428:  MOVWF  xFE
0542A:  MOVLB  0
0542C:  GOTO   4752
05430:  MOVFF  01,8EA
05434:  MOVFF  8EA,51
....................          if (socket!=INVALID_SOCKET) { 
05438:  MOVLB  8
0543A:  MOVF   xEA,W
0543C:  SUBLW  FE
0543E:  BZ    5456
....................             lastTick=TickGet(); 
05440:  MOVLB  0
05442:  CALL   2B2E
05446:  MOVFF  02,8E9
0544A:  MOVFF  01,8E8
....................             state=MYTCP_STATE_CONNECT_WAIT; 
0544E:  MOVLW  04
05450:  MOVLB  8
05452:  MOVWF  xEB
....................          } 
05454:  BRA    547C
....................          else { 
....................             //fprintf(DEBUG,"\nError en el socket."); 
....................             if(!espera)   { 
05456:  MOVLB  2
05458:  MOVF   x7D,F
0545A:  BNZ   547A
....................                lcd_gotoxy(1,4);  
0545C:  MOVLW  01
0545E:  MOVLB  9
05460:  MOVWF  x00
05462:  MOVLW  04
05464:  MOVWF  x01
05466:  MOVLB  0
05468:  CALL   060C
....................                lcd_putc("Error en el socket. ");} 
0546C:  MOVLW  56
0546E:  MOVWF  FF6
05470:  MOVLW  01
05472:  MOVWF  FF7
05474:  CALL   06C2
05478:  MOVLB  2
0547A:  MOVLB  8
....................          } 
....................          break; 
0547C:  BRA    5622
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(socket)) { 
0547E:  MOVFF  8EA,8FC
05482:  CALL   494E
05486:  MOVF   01,F
05488:  BZ    54BE
....................             state=MYTCP_STATE_CONNECTED; 
0548A:  MOVLW  05
0548C:  MOVLB  8
0548E:  MOVWF  xEB
....................             //fprintf(DEBUG,"\nCONECTADO! "); 
....................             if(!espera)   { 
05490:  MOVLB  2
05492:  MOVF   x7D,F
05494:  BNZ   54B4
....................                lcd_gotoxy(1,4); 
05496:  MOVLW  01
05498:  MOVLB  9
0549A:  MOVWF  x00
0549C:  MOVLW  04
0549E:  MOVWF  x01
054A0:  MOVLB  0
054A2:  CALL   060C
....................                lcd_putc("CONECTADO           ");} 
054A6:  MOVLW  6C
054A8:  MOVWF  FF6
054AA:  MOVLW  01
054AC:  MOVWF  FF7
054AE:  CALL   06C2
054B2:  MOVLB  2
....................             output_high(salida06); 
054B4:  BCF    F94.2
054B6:  BSF    F8B.2
....................             inicializado=1; 
054B8:  MOVLW  01
054BA:  MOVWF  50
....................          } 
054BC:  BRA    5518
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
054BE:  MOVLB  8
054C0:  MOVF   xFA,W
054C2:  SUBWF  xE9,W
054C4:  BNC   54CE
054C6:  BNZ   54D2
054C8:  MOVF   xE8,W
054CA:  SUBWF  xF9,W
054CC:  BNC   54D2
054CE:  MOVLW  00
054D0:  BRA    54D4
054D2:  MOVLW  01
054D4:  CLRF   03
054D6:  IORWF  03,W
054D8:  BZ    5500
054DA:  MOVLW  FF
054DC:  BSF    FD8.0
054DE:  SUBFWB xE8,W
054E0:  MOVWF  xFC
054E2:  MOVLW  FF
054E4:  SUBFWB xE9,W
054E6:  MOVWF  xFD
054E8:  MOVF   xF9,W
054EA:  ADDWF  xFC,F
054EC:  MOVF   xFA,W
054EE:  ADDWFC xFD,F
054F0:  MOVLW  01
054F2:  ADDWF  xFC,W
054F4:  MOVWF  01
054F6:  MOVLW  00
054F8:  ADDWFC xFD,W
054FA:  MOVWF  03
054FC:  MOVF   01,W
054FE:  BRA    550E
05500:  MOVF   xE8,W
05502:  SUBWF  xF9,W
05504:  MOVWF  00
05506:  MOVF   xE9,W
05508:  SUBWFB xFA,W
0550A:  MOVWF  03
0550C:  MOVF   00,W
0550E:  SUBLW  78
05510:  BC    5516
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
05512:  MOVLW  07
05514:  MOVWF  xEB
05516:  MOVLB  2
....................          } 
....................          break; 
05518:  MOVLB  8
0551A:  BRA    5622
....................  
....................       case MYTCP_STATE_CONNECTED: 
....................          if (TCPIsConnected(socket)) { 
0551C:  MOVFF  8EA,8FC
05520:  CALL   494E
05524:  MOVF   01,F
05526:  BZ    5544
....................             dis=TCPConnectedTask(socket); 
05528:  MOVFF  8EA,8FC
0552C:  BRA    51CC
0552E:  MOVFF  01,8FB
....................             //fprintf(DEBUG,"\ndis:%u ",dis); 
....................             if (dis) { 
05532:  MOVLB  8
05534:  MOVF   xFB,F
05536:  BZ    5540
....................                //state=MYTCP_STATE_DISCONNECT; 
....................                lastTick=currTick; 
05538:  MOVFF  8FA,8E9
0553C:  MOVFF  8F9,8E8
....................             } 
....................          } 
05540:  BRA    554A
05542:  MOVLB  0
....................          else { 
....................             //fprintf(DEBUG,"\nDESCONECTADO.   "); 
....................             //state=MYTCP_STATE_CONNECT; 
....................             state=MYTCP_STATE_DISCONNECT; 
05544:  MOVLW  06
05546:  MOVLB  8
05548:  MOVWF  xEB
....................             //output_low(salida06); 
....................          } 
....................          break; 
0554A:  BRA    5622
....................  
....................       case MYTCP_STATE_DISCONNECT: 
....................          //fprintf(DEBUG,"\nDESCONECTANDO.   "); 
....................          if(!espera)   { 
0554C:  MOVLB  2
0554E:  MOVF   x7D,F
05550:  BNZ   5570
....................             lcd_gotoxy(1,4); 
05552:  MOVLW  01
05554:  MOVLB  9
05556:  MOVWF  x00
05558:  MOVLW  04
0555A:  MOVWF  x01
0555C:  MOVLB  0
0555E:  CALL   060C
....................             lcd_putc("DESCONECTADO       ");} 
05562:  MOVLW  82
05564:  MOVWF  FF6
05566:  MOVLW  01
05568:  MOVWF  FF7
0556A:  CALL   06C2
0556E:  MOVLB  2
....................          output_low(salida06); 
05570:  BCF    F94.2
05572:  BCF    F8B.2
....................          inicializado=0; 
05574:  CLRF   50
....................          if (TCPIsPutReady(socket)) { 
05576:  MOVFF  8EA,90E
0557A:  MOVLB  0
0557C:  CALL   4AB4
05580:  MOVF   01,F
05582:  BZ    558C
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
05584:  MOVLW  07
05586:  MOVLB  8
05588:  MOVWF  xEB
....................          } 
0558A:  BRA    55E4
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
0558C:  MOVLB  8
0558E:  MOVF   xFA,W
05590:  SUBWF  xE9,W
05592:  BNC   559C
05594:  BNZ   55A0
05596:  MOVF   xE8,W
05598:  SUBWF  xF9,W
0559A:  BNC   55A0
0559C:  MOVLW  00
0559E:  BRA    55A2
055A0:  MOVLW  01
055A2:  CLRF   03
055A4:  IORWF  03,W
055A6:  BZ    55CE
055A8:  MOVLW  FF
055AA:  BSF    FD8.0
055AC:  SUBFWB xE8,W
055AE:  MOVWF  xFC
055B0:  MOVLW  FF
055B2:  SUBFWB xE9,W
055B4:  MOVWF  xFD
055B6:  MOVF   xF9,W
055B8:  ADDWF  xFC,F
055BA:  MOVF   xFA,W
055BC:  ADDWFC xFD,F
055BE:  MOVLW  01
055C0:  ADDWF  xFC,W
055C2:  MOVWF  01
055C4:  MOVLW  00
055C6:  ADDWFC xFD,W
055C8:  MOVWF  03
055CA:  MOVF   01,W
055CC:  BRA    55DC
055CE:  MOVF   xE8,W
055D0:  SUBWF  xF9,W
055D2:  MOVWF  00
055D4:  MOVF   xE9,W
055D6:  SUBWFB xFA,W
055D8:  MOVWF  03
055DA:  MOVF   00,W
055DC:  SUBLW  78
055DE:  BC    55E4
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
055E0:  MOVLW  07
055E2:  MOVWF  xEB
....................          } 
....................          break; 
055E4:  BRA    5622
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
....................          TCPDisconnect(socket); 
055E6:  MOVFF  8EA,8FE
055EA:  RCALL  5096
....................          state=MYTCP_STATE_CONNECT; 
055EC:  MOVLW  03
055EE:  MOVLB  8
055F0:  MOVWF  xEB
....................          if(!espera)   { 
055F2:  MOVLB  2
055F4:  MOVF   x7D,F
055F6:  BNZ   5616
....................             lcd_gotoxy(1,4); 
055F8:  MOVLW  01
055FA:  MOVLB  9
055FC:  MOVWF  x00
055FE:  MOVLW  04
05600:  MOVWF  x01
05602:  MOVLB  0
05604:  CALL   060C
....................             lcd_putc("DESCONECTADO       ");} 
05608:  MOVLW  96
0560A:  MOVWF  FF6
0560C:  MOVLW  01
0560E:  MOVWF  FF7
05610:  CALL   06C2
05614:  MOVLB  2
....................          output_low(salida06); 
05616:  BCF    F94.2
05618:  BCF    F8B.2
....................          inicializado=0; 
0561A:  CLRF   50
....................          break; 
0561C:  MOVLB  8
0561E:  BRA    5622
05620:  MOVLB  8
....................    } 
05622:  MOVLB  0
05624:  RETURN 0
.................... } 
....................  
.................... ////wiegand/// 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... wiegand_cuenta++; 
*
001AA:  MOVLB  2
001AC:  INCF   x11,F
.................... time_relay1++; 
001AE:  INCF   1F,F
.................... time_boleto++; 
001B0:  INCF   x89,F
.................... cuenta++; 
001B2:  INCF   x7C,F
.................... cta_lcd++; 
001B4:  INCF   x8B,F
.................... set_timer1(3036); //50 ms 
001B6:  MOVLW  0B
001B8:  MOVWF  FCF
001BA:  MOVLW  DC
001BC:  MOVWF  FCE
.................... } 
....................  
001BE:  BCF    F9E.0
001C0:  MOVLB  0
001C2:  GOTO   0084
.................... #int_ext 
.................... void EXT_isr(void){//data1 
....................    while (!input(PIN_B0) ) {} 
001C6:  BSF    F93.0
001C8:  BTFSS  F81.0
001CA:  BRA    01C6
....................    wiegand_cuenta=0; 
001CC:  MOVLB  2
001CE:  CLRF   x11
....................    wieg=1; 
001D0:  MOVLW  01
001D2:  MOVWF  x0C
....................    data[sub_indice]=1; 
001D4:  CLRF   03
001D6:  MOVF   x0F,W
001D8:  ADDLW  16
001DA:  MOVWF  FE9
001DC:  MOVLW  02
001DE:  ADDWFC 03,W
001E0:  MOVWF  FEA
001E2:  MOVLW  01
001E4:  MOVWF  FEF
....................    sub_indice++; 
001E6:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
001E8:  MOVF   x0F,W
001EA:  SUBLW  1A
001EC:  BNZ   01F2
....................       wieg_full=1; 
001EE:  MOVLW  01
001F0:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
.................... } 
....................  
001F2:  BCF    FF2.1
001F4:  MOVLB  0
001F6:  GOTO   0084
.................... #int_ext1 
.................... void EXT1_isr(void){//data0 
....................    while (!input(PIN_B1) ) {} 
001FA:  BSF    F93.1
001FC:  BTFSS  F81.1
001FE:  BRA    01FA
....................    wiegand_cuenta=0; 
00200:  MOVLB  2
00202:  CLRF   x11
....................    wieg=1; 
00204:  MOVLW  01
00206:  MOVWF  x0C
....................    data[sub_indice]=0; 
00208:  CLRF   03
0020A:  MOVF   x0F,W
0020C:  ADDLW  16
0020E:  MOVWF  FE9
00210:  MOVLW  02
00212:  ADDWFC 03,W
00214:  MOVWF  FEA
00216:  CLRF   FEF
....................    sub_indice++; 
00218:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
0021A:  MOVF   x0F,W
0021C:  SUBLW  1A
0021E:  BNZ   0224
....................       wieg_full=1; 
00220:  MOVLW  01
00222:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
00224:  BCF    FF0.0
00226:  MOVLB  0
00228:  GOTO   0084
.................... } 
.................... /////////////////////// 
.................... //funciones extra 
.................... void wiegand_read_card(); 
.................... void enviar_tcp(); 
.................... /////////boleto//////////////////// 
.................... void reset(); 
.................... void encri(); 
.................... void barra1(); 
.................... void barra2(); 
.................... void CR(); 
.................... void LF(); 
.................... void ticket(); 
.................... void sensores(); 
.................... void llaves(); 
.................... void rd_eeprom(); 
.................... void zeller(); 
.................... void horario(); 
.................... void fecha(); 
....................  
.................... void main(void) { 
*
06B28:  CLRF   FF8
06B2A:  BCF    FD0.7
06B2C:  BSF    07.7
06B2E:  CLRF   19
06B30:  BCF    FB8.3
06B32:  MOVLW  40
06B34:  MOVWF  FAF
06B36:  MOVLW  A6
06B38:  MOVWF  FAC
06B3A:  MOVLW  90
06B3C:  MOVWF  FAB
06B3E:  MOVLB  2
06B40:  CLRF   x0F
06B42:  CLRF   x10
06B44:  MOVLB  3
06B46:  CLRF   x8C
06B48:  CLRF   x8B
06B4A:  CLRF   x8D
06B4C:  CLRF   x8E
06B4E:  CLRF   x96
06B50:  CLRF   x95
06B52:  MOVLW  04
06B54:  MOVWF  x99
06B56:  CLRF   x98
06B58:  MOVLW  FE
06B5A:  MOVLB  8
06B5C:  MOVWF  xEA
06B5E:  CLRF   xEB
06B60:  CLRF   xF7
06B62:  CLRF   xF6
06B64:  MOVF   FC1,W
06B66:  ANDLW  C0
06B68:  IORLW  0F
06B6A:  MOVWF  FC1
06B6C:  MOVLW  07
06B6E:  MOVWF  FB4
06B70:  MOVLB  3
06B72:  BCF    x93.1
06B74:  BRA    6C6C
06B76:  DATA 0B,02
06B78:  DATA 8D,42
06B7A:  DATA 4F,4C
06B7C:  DATA 45,54
06B7E:  DATA 4F,5F
06B80:  DATA 46,4F
06B82:  DATA 4C,00
06B84:  DATA 0B,02
06B86:  DATA 99,42
06B88:  DATA 4F,52
06B8A:  DATA 52,41
06B8C:  DATA 52,54
06B8E:  DATA 4F,44
06B90:  DATA 4F,00
06B92:  DATA 0B,02
06B94:  DATA A5,42
06B96:  DATA 4F,52
06B98:  DATA 52,41
06B9A:  DATA 52,5F
06B9C:  DATA 54,41
06B9E:  DATA 47,00
06BA0:  DATA 0B,02
06BA2:  DATA B1,41
06BA4:  DATA 42,52
06BA6:  DATA 49,52
06BA8:  DATA 5F,45
06BAA:  DATA 4E,54
06BAC:  DATA 52,00
06BAE:  DATA 0B,02
06BB0:  DATA BD,43
06BB2:  DATA 55,50
06BB4:  DATA 4F,5F
06BB6:  DATA 4C,4C
06BB8:  DATA 45,4E
06BBA:  DATA 4F,00
06BBC:  DATA 0B,02
06BBE:  DATA C9,43
06BC0:  DATA 55,50
06BC2:  DATA 4F,5F
06BC4:  DATA 44,49
06BC6:  DATA 53,50
06BC8:  DATA 4F,00
06BCA:  DATA 0B,02
06BCC:  DATA D5,4D
06BCE:  DATA 45,4E
06BD0:  DATA 53,41
06BD2:  DATA 4A,45
06BD4:  DATA 45,4E
06BD6:  DATA 31,00
06BD8:  DATA 0A,42
06BDA:  DATA E1,20
06BDC:  DATA 01,80
06BDE:  DATA 00,0B
06BE0:  DATA 02,ED
06BE2:  DATA 43,4F
06BE4:  DATA 4E,53
06BE6:  DATA 55,4C
06BE8:  DATA 54,41
06BEA:  DATA 30,31
06BEC:  DATA 00,0B
06BEE:  DATA 02,F9
06BF0:  DATA 43,4F
06BF2:  DATA 4E,46
06BF4:  DATA 49,47
06BF6:  DATA 44,41
06BF8:  DATA 54,45
06BFA:  DATA 00,0B
06BFC:  DATA 03,05
06BFE:  DATA 43,4F
06C00:  DATA 4E,46
06C02:  DATA 49,47
06C04:  DATA 55,52
06C06:  DATA 41,42
06C08:  DATA 00,0B
06C0A:  DATA 03,11
06C0C:  DATA 42,4F
06C0E:  DATA 52,52
06C10:  DATA 41,5F
06C12:  DATA 43,4F
06C14:  DATA 4E,31
06C16:  DATA 00,0B
06C18:  DATA 03,1D
06C1A:  DATA 46,4F
06C1C:  DATA 4C,49
06C1E:  DATA 4F,52
06C20:  DATA 45,53
06C22:  DATA 45,54
06C24:  DATA 00,06
06C26:  DATA 03,29
06C28:  DATA 50,41
06C2A:  DATA 47,41
06C2C:  DATA 44,4F
06C2E:  DATA 04,C0
06C30:  DATA 30,01
06C32:  DATA 80,00
06C34:  DATA 18,03
06C36:  DATA 35,42
06C38:  DATA 4F,4C
06C3A:  DATA 45,54
06C3C:  DATA 4F,00
06C3E:  DATA 42,41
06C40:  DATA 52,52
06C42:  DATA 45,52
06C44:  DATA 41,41
06C46:  DATA 42,49
06C48:  DATA 45,52
06C4A:  DATA 54,41
06C4C:  DATA 45,31
06C4E:  DATA 00,02
06C50:  DATA 03,84
06C52:  DATA 00,00
06C54:  DATA 01,03
06C56:  DATA 97,00
06C58:  DATA 0A,48
06C5A:  DATA 88,00
06C5C:  DATA 46,48
06C5E:  DATA 9D,00
06C60:  DATA 03,08
06C62:  DATA E7,00
06C64:  DATA 00,00
06C66:  DATA 0A,48
06C68:  DATA EC,00
06C6A:  DATA 00,00
06C6C:  MOVLW  00
06C6E:  MOVWF  FF8
06C70:  MOVLW  6B
06C72:  MOVWF  FF7
06C74:  MOVLW  76
06C76:  MOVWF  FF6
06C78:  TBLRD*+
06C7A:  MOVF   FF5,W
06C7C:  MOVWF  00
06C7E:  XORLW  00
06C80:  BZ    6CA8
06C82:  TBLRD*+
06C84:  MOVF   FF5,W
06C86:  MOVWF  01
06C88:  BTFSC  FE8.7
06C8A:  BRA    6C96
06C8C:  ANDLW  0F
06C8E:  MOVWF  FEA
06C90:  TBLRD*+
06C92:  MOVFF  FF5,FE9
06C96:  BTFSC  01.6
06C98:  TBLRD*+
06C9A:  BTFSS  01.6
06C9C:  TBLRD*+
06C9E:  MOVFF  FF5,FEE
06CA2:  DCFSNZ 00,F
06CA4:  BRA    6C78
06CA6:  BRA    6C9A
06CA8:  CLRF   FF8
....................    //fprintf(DEBUG,"\r\n\nCLIENTE TCP/IP\r\n"); 
....................    lcd_putc("\fINICIANDO"); 
06CAA:  MOVLW  2C
06CAC:  MOVWF  FF6
06CAE:  MOVLW  02
06CB0:  MOVWF  FF7
06CB2:  MOVLB  0
06CB4:  CALL   06C2
....................    setup_adc_ports(NO_ANALOGS); 
06CB8:  MOVF   FC1,W
06CBA:  ANDLW  C0
06CBC:  IORLW  0F
06CBE:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
06CC0:  BCF    FC2.0
....................     
....................    init_ext_eeprom();//iniciar memoria 
06CC2:  GOTO   06E2
....................    lcd_init();//iniciar LCD 
06CC6:  GOTO   06EA
....................    llaves(); 
06CCA:  GOTO   0766
....................     
....................    MACAddrInit(); 
06CCE:  GOTO   0A6A
....................    IPAddrInit(); 
06CD2:  GOTO   0A84
....................    ServerAddrInit(); 
06CD6:  GOTO   0AB4
....................    StackInit(); 
06CDA:  GOTO   1294
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
06CDE:  MOVLW  B5
06CE0:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);//Habilito interrupción particular del TIMER1 
06CE2:  BSF    F9D.0
....................    set_timer1(3036);//Carga del TMR1 
06CE4:  MOVLW  0B
06CE6:  MOVWF  FCF
06CE8:  MOVLW  DC
06CEA:  MOVWF  FCE
....................    ext_int_edge(0,L_TO_H);       //Asigno flancos de subida 
06CEC:  BSF    FF1.6
....................    ext_int_edge(1,L_TO_H);       //Asigno flancos de subida 
06CEE:  BSF    FF1.5
....................    enable_interrupts(INT_EXT1); 
06CF0:  BSF    FF0.3
....................    enable_interrupts(INT_EXT); 
06CF2:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);//Habilito interrupciones globales 
06CF4:  MOVLW  C0
06CF6:  IORWF  FF2,F
....................  
....................    envia_pc=0; 
06CF8:  CLRF   1A
....................    //int linked_out=0; 
....................    edo_str=envia_pc=0; 
06CFA:  CLRF   1A
06CFC:  MOVFF  1A,4E
....................    re_bol=0; 
06D00:  MOVLB  2
06D02:  CLRF   x8A
....................    //leyendo validacion de pago 
....................    int vigencia; 
....................    vigencia=read_ext_eeprom(10); 
06D04:  MOVLB  9
06D06:  CLRF   x0A
06D08:  MOVLW  0A
06D0A:  MOVWF  x09
06D0C:  MOVLB  0
06D0E:  CALL   1388
06D12:  MOVFF  01,8F8
....................    if(vigencia!=1) { 
06D16:  MOVLB  8
06D18:  DECFSZ xF8,W
06D1A:  BRA    6D1E
06D1C:  BRA    6D62
....................       write_ext_eeprom(10,1); 
06D1E:  MOVLB  9
06D20:  CLRF   x0A
06D22:  MOVLW  0A
06D24:  MOVWF  x09
06D26:  MOVLW  01
06D28:  MOVWF  x0B
06D2A:  MOVLB  0
06D2C:  CALL   1430
....................       write_ext_eeprom(11,0); 
06D30:  MOVLB  9
06D32:  CLRF   x0A
06D34:  MOVLW  0B
06D36:  MOVWF  x09
06D38:  CLRF   x0B
06D3A:  MOVLB  0
06D3C:  CALL   1430
....................       write_ext_eeprom(12,0); 
06D40:  MOVLB  9
06D42:  CLRF   x0A
06D44:  MOVLW  0C
06D46:  MOVWF  x09
06D48:  CLRF   x0B
06D4A:  MOVLB  0
06D4C:  CALL   1430
....................       write_ext_eeprom(13,0); 
06D50:  MOVLB  9
06D52:  CLRF   x0A
06D54:  MOVLW  0D
06D56:  MOVWF  x09
06D58:  CLRF   x0B
06D5A:  MOVLB  0
06D5C:  CALL   1430
06D60:  MOVLB  8
....................    } 
....................    pago=read_ext_eeprom(11);// 
06D62:  MOVLB  9
06D64:  CLRF   x0A
06D66:  MOVLW  0B
06D68:  MOVWF  x09
06D6A:  MOVLB  0
06D6C:  CALL   1388
06D70:  MOVFF  01,27B
....................    dias_prueba=read_ext_eeprom(12);//dias de prueba 
06D74:  MOVLB  9
06D76:  CLRF   x0A
06D78:  MOVLW  0C
06D7A:  MOVWF  x09
06D7C:  MOVLB  0
06D7E:  CALL   1388
06D82:  MOVFF  01,279
....................    dia_temp=read_ext_eeprom(13);// 
06D86:  MOVLB  9
06D88:  CLRF   x0A
06D8A:  MOVLW  0D
06D8C:  MOVWF  x09
06D8E:  MOVLB  0
06D90:  CALL   1388
06D94:  MOVFF  01,27A
....................    lcd_gotoxy(1,1); 
06D98:  MOVLW  01
06D9A:  MOVLB  9
06D9C:  MOVWF  x00
06D9E:  MOVWF  x01
06DA0:  MOVLB  0
06DA2:  CALL   060C
....................    printf(lcd_putc,"Dias:%u PAGO:%d",dias_prueba,pago); 
06DA6:  MOVLW  38
06DA8:  MOVWF  FF6
06DAA:  MOVLW  02
06DAC:  MOVWF  FF7
06DAE:  MOVLW  05
06DB0:  MOVLB  8
06DB2:  MOVWF  xFA
06DB4:  MOVLB  0
06DB6:  CALL   1536
06DBA:  MOVFF  279,8FA
06DBE:  MOVLW  1B
06DC0:  MOVLB  8
06DC2:  MOVWF  xFB
06DC4:  MOVLB  0
06DC6:  CALL   158C
06DCA:  MOVLW  3F
06DCC:  MOVWF  FF6
06DCE:  MOVLW  02
06DD0:  MOVWF  FF7
06DD2:  MOVLW  06
06DD4:  MOVLB  8
06DD6:  MOVWF  xFA
06DD8:  MOVLB  0
06DDA:  CALL   1536
06DDE:  MOVFF  27B,8F9
06DE2:  MOVLW  18
06DE4:  MOVLB  8
06DE6:  MOVWF  xFA
06DE8:  MOVLB  0
06DEA:  GOTO   160E
....................    lcd_gotoxy(1,2); 
06DEE:  MOVLW  01
06DF0:  MOVLB  9
06DF2:  MOVWF  x00
06DF4:  MOVLW  02
06DF6:  MOVWF  x01
06DF8:  MOVLB  0
06DFA:  CALL   060C
....................    printf(lcd_putc,"Restan:%u ",(dia_limite-dias_prueba) ); 
06DFE:  MOVLW  5A
06E00:  BSF    FD8.0
06E02:  MOVLB  2
06E04:  SUBFWB x79,W
06E06:  MOVLB  8
06E08:  MOVWF  xF9
06E0A:  MOVLW  48
06E0C:  MOVWF  FF6
06E0E:  MOVLW  02
06E10:  MOVWF  FF7
06E12:  MOVLW  07
06E14:  MOVWF  xFA
06E16:  MOVLB  0
06E18:  CALL   1536
06E1C:  MOVFF  8F9,8FA
06E20:  MOVLW  1B
06E22:  MOVLB  8
06E24:  MOVWF  xFB
06E26:  MOVLB  0
06E28:  CALL   158C
06E2C:  MOVLW  20
06E2E:  MOVLB  8
06E30:  MOVWF  xFF
06E32:  MOVLB  0
06E34:  CALL   065E
....................    delay_ms(1000); 
06E38:  MOVLW  04
06E3A:  MOVLB  8
06E3C:  MOVWF  xF9
06E3E:  MOVLW  FA
06E40:  MOVLB  9
06E42:  MOVWF  x00
06E44:  MOVLB  0
06E46:  CALL   05E4
06E4A:  MOVLB  8
06E4C:  DECFSZ xF9,F
06E4E:  BRA    6E3E
....................    setup_wdt(WDT_ON); 
06E50:  BSF    FD1.0
....................    ////////////////// 
....................    hrs2=espera=fmensaje=0; 
06E52:  MOVLB  3
06E54:  CLRF   x4D
06E56:  MOVFF  34D,27D
06E5A:  MOVFF  27D,27E
....................    reset(); 
06E5E:  MOVLB  0
06E60:  GOTO   16D8
....................    while(TRUE) { 
....................       restart_wdt(); 
06E64:  CLRWDT
....................       StackTask(); 
06E66:  CALL   44A8
....................       MyTCPTask(); 
06E6A:  CALL   52E4
....................       if( (dias_prueba>dia_limite)&&(pago!=1) ){//pruebas 
06E6E:  MOVLB  2
06E70:  MOVF   x79,W
06E72:  SUBLW  5A
06E74:  BC    6F42
06E76:  DECFSZ x7B,W
06E78:  BRA    6E7C
06E7A:  BRA    6F42
....................          lcd_gotoxy(1,1); 
06E7C:  MOVLW  01
06E7E:  MOVLB  9
06E80:  MOVWF  x00
06E82:  MOVWF  x01
06E84:  MOVLB  0
06E86:  CALL   060C
....................          lcd_putc("TIEMPO DE PRUEBA"); 
06E8A:  MOVLW  54
06E8C:  MOVWF  FF6
06E8E:  MOVLW  02
06E90:  MOVWF  FF7
06E92:  CALL   06C2
....................          lcd_gotoxy(1,2); 
06E96:  MOVLW  01
06E98:  MOVLB  9
06E9A:  MOVWF  x00
06E9C:  MOVLW  02
06E9E:  MOVWF  x01
06EA0:  MOVLB  0
06EA2:  CALL   060C
....................          lcd_putc("  HA EXPIRADO   "); 
06EA6:  MOVLW  66
06EA8:  MOVWF  FF6
06EAA:  MOVLW  02
06EAC:  MOVWF  FF7
06EAE:  CALL   06C2
....................          if(edo_str){ 
06EB2:  MOVF   4E,F
06EB4:  BZ    6F3C
....................             edo_str=0; 
06EB6:  CLRF   4E
....................             strcpy(XX,rxtcp); 
06EB8:  CLRF   FEA
06EBA:  MOVLW  52
06EBC:  MOVWF  FE9
06EBE:  MOVLW  01
06EC0:  MOVWF  FE2
06EC2:  MOVLW  60
06EC4:  MOVWF  FE1
06EC6:  MOVF   FE7,F
06EC8:  MOVFF  FE6,FEE
06ECC:  BNZ   6EC6
....................             if( (XX[0]=='P')&&(XX[1]=='A')&&(XX[2]=='G')&&(XX[3]=='A')&&(XX[4]=='D')&&(XX[5]=='O') ){ 
06ECE:  MOVF   52,W
06ED0:  SUBLW  50
06ED2:  BNZ   6F3C
06ED4:  MOVF   53,W
06ED6:  SUBLW  41
06ED8:  BNZ   6F3C
06EDA:  MOVF   54,W
06EDC:  SUBLW  47
06EDE:  BNZ   6F3C
06EE0:  MOVF   55,W
06EE2:  SUBLW  41
06EE4:  BNZ   6F3C
06EE6:  MOVF   56,W
06EE8:  SUBLW  44
06EEA:  BNZ   6F3C
06EEC:  MOVF   57,W
06EEE:  SUBLW  4F
06EF0:  BNZ   6F3C
....................                pago=1; 
06EF2:  MOVLW  01
06EF4:  MOVLB  2
06EF6:  MOVWF  x7B
....................                write_ext_eeprom(11,pago);// 
06EF8:  MOVLB  9
06EFA:  CLRF   x0A
06EFC:  MOVLW  0B
06EFE:  MOVWF  x09
06F00:  MOVFF  27B,90B
06F04:  MOVLB  0
06F06:  CALL   1430
....................                strcpy (txtcp, "BOLETERA_PAGADO"); 
06F0A:  MOVLW  01
06F0C:  MOVWF  FEA
06F0E:  MOVLW  06
06F10:  MOVWF  FE9
06F12:  MOVLW  00
06F14:  CALL   00E6
06F18:  TBLRD*-
06F1A:  TBLRD*+
06F1C:  MOVF   FF5,W
06F1E:  MOVWF  FEE
06F20:  IORLW  00
06F22:  BNZ   6F1A
....................                size_tx_tcp=strlen(txtcp); 
06F24:  MOVLW  01
06F26:  MOVLB  9
06F28:  MOVWF  x0F
06F2A:  MOVLW  06
06F2C:  MOVWF  x0E
06F2E:  MOVLB  0
06F30:  CALL   5650
06F34:  MOVFF  01,48
....................                enviar_tcp(); 
06F38:  CALL   568C
....................             } 
....................          } 
....................       } 
06F3C:  GOTO   7666
06F40:  MOVLB  2
....................       else{ 
....................          wiegand_read_card(); 
06F42:  MOVLB  0
06F44:  GOTO   5742
....................          sensores(); 
06F48:  GOTO   58E8
....................          if(edo_str){//bandera de dato recibido en socket actual 
06F4C:  MOVF   4E,F
06F4E:  BTFSC  FD8.2
06F50:  BRA    71EA
....................             edo_str=0; 
06F52:  CLRF   4E
....................             //fprintf(DEBUG,"\r\nrxtcp:%s",rxtcp); 
....................             //printf(lcd_putc,"\frxtcp:%s",rxtcp); 
....................             strcpy(XX,rxtcp); 
06F54:  CLRF   FEA
06F56:  MOVLW  52
06F58:  MOVWF  FE9
06F5A:  MOVLW  01
06F5C:  MOVWF  FE2
06F5E:  MOVLW  60
06F60:  MOVWF  FE1
06F62:  MOVF   FE7,F
06F64:  MOVFF  FE6,FEE
06F68:  BNZ   6F62
....................             //fprintf(U1PRINTER,"\frxtcp:%s",XX); 
....................             rd_eeprom(); 
06F6A:  GOTO   59B4
....................             //lcd_gotoxy(1,3); 
....................             //printf(lcd_putc,"rxtcp:%s",rxtcp); 
....................             //lcd_gotoxy(1,4); 
....................             //printf(lcd_putc,"b:%Ld                ",b); 
....................             switch (b) { 
06F6E:  MOVFF  44,00
06F72:  MOVF   45,W
06F74:  MOVWF  03
06F76:  BNZ   6F7E
06F78:  MOVLW  01
06F7A:  SUBWF  00,W
06F7C:  BZ    7006
06F7E:  MOVF   03,W
06F80:  BNZ   6F8A
06F82:  MOVLW  02
06F84:  SUBWF  00,W
06F86:  BTFSC  FD8.2
06F88:  BRA    7038
06F8A:  MOVF   03,W
06F8C:  BNZ   6F94
06F8E:  MOVLW  03
06F90:  SUBWF  00,W
06F92:  BZ    703A
06F94:  MOVF   03,W
06F96:  BNZ   6F9E
06F98:  MOVLW  04
06F9A:  SUBWF  00,W
06F9C:  BZ    703C
06F9E:  MOVF   03,W
06FA0:  BNZ   6FA8
06FA2:  MOVLW  05
06FA4:  SUBWF  00,W
06FA6:  BZ    7056
06FA8:  MOVF   03,W
06FAA:  BNZ   6FB2
06FAC:  MOVLW  06
06FAE:  SUBWF  00,W
06FB0:  BZ    7058
06FB2:  MOVF   03,W
06FB4:  BNZ   6FBC
06FB6:  MOVLW  07
06FB8:  SUBWF  00,W
06FBA:  BZ    705A
06FBC:  MOVF   03,W
06FBE:  BNZ   6FC8
06FC0:  MOVLW  08
06FC2:  SUBWF  00,W
06FC4:  BTFSC  FD8.2
06FC6:  BRA    7192
06FC8:  MOVF   03,W
06FCA:  BNZ   6FD4
06FCC:  MOVLW  09
06FCE:  SUBWF  00,W
06FD0:  BTFSC  FD8.2
06FD2:  BRA    7194
06FD4:  MOVF   03,W
06FD6:  BNZ   6FE0
06FD8:  MOVLW  0A
06FDA:  SUBWF  00,W
06FDC:  BTFSC  FD8.2
06FDE:  BRA    7196
06FE0:  MOVF   03,W
06FE2:  BNZ   6FEC
06FE4:  MOVLW  0B
06FE6:  SUBWF  00,W
06FE8:  BTFSC  FD8.2
06FEA:  BRA    719C
06FEC:  MOVF   03,W
06FEE:  BNZ   6FF8
06FF0:  MOVLW  0D
06FF2:  SUBWF  00,W
06FF4:  BTFSC  FD8.2
06FF6:  BRA    719E
06FF8:  MOVF   03,W
06FFA:  BNZ   7004
06FFC:  MOVLW  0E
06FFE:  SUBWF  00,W
07000:  BTFSC  FD8.2
07002:  BRA    71A0
07004:  BRA    71EA
....................               case 1: {//IMPRIMIR BOLETO 
....................                   espera=1; 
07006:  MOVLW  01
07008:  MOVLB  2
0700A:  MOVWF  x7D
....................                   printf(lcd_putc,"\f\n   TOME SU BOLETO\n Y AVANCE POR FAVOR"); 
0700C:  MOVLW  78
0700E:  MOVWF  FF6
07010:  MOVLW  02
07012:  MOVWF  FF7
07014:  MOVLB  0
07016:  CALL   06C2
....................                   ticket(); 
0701A:  GOTO   5E08
....................                   output_high(salida01);//abre entrada 
0701E:  BCF    F92.5
07020:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07022:  BCF    F96.0
07024:  BSF    F8D.0
....................                   relay1=1; 
07026:  MOVLW  01
07028:  MOVWF  1D
....................                   time_relay1=0; 
0702A:  CLRF   1F
....................                   flag_pluma=1; 
0702C:  MOVLB  2
0702E:  MOVWF  x88
....................                   //sprintf(txtcp,barra_codi);//CONFIRMACION DE BOLETO IMPRESO 
....................                   //size_tx_tcp=strlen(txtcp); 
....................                   //enviar_tcp(); 
....................                   cta_lcd=0; 
07030:  CLRF   x8B
....................                   re_bol=1; 
07032:  MOVWF  x8A
....................                   break;} 
07034:  MOVLB  0
07036:  BRA    71EA
....................               case 2: {//VIGENCIA POR VENCER O VENCIDA 
....................                   break;} 
07038:  BRA    71EA
....................               case 3: {//no activa en entrada 
....................                   break;} 
0703A:  BRA    71EA
....................               case 4: {//ABRIR ENTRADA 
....................                   //lcd_putc("\f\n     BIENVENIDO"); 
....................                   output_high(salida01);//abre entrada 
0703C:  BCF    F92.5
0703E:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07040:  BCF    F96.0
07042:  BSF    F8D.0
....................                   flag_pluma=1; 
07044:  MOVLW  01
07046:  MOVLB  2
07048:  MOVWF  x88
....................                   relay1=1; 
0704A:  MOVWF  1D
....................                   time_relay1=0; 
0704C:  CLRF   1F
....................                   b=0; 
0704E:  CLRF   45
07050:  CLRF   44
....................                   break;} 
07052:  MOVLB  0
07054:  BRA    71EA
....................               case 5: {//CUPO LLENO 
....................                   break;} 
07056:  BRA    71EA
....................               case 6: {//ACTIVA BOLETOS 
....................                   break;} 
07058:  BRA    71EA
....................               case 7: {//MENSAJES DE LCD 
....................                      memset(lcd_men, 0, sizeof(lcd_men) ); 
0705A:  MOVLW  01
0705C:  MOVWF  FEA
0705E:  MOVLW  BA
07060:  MOVWF  FE9
07062:  CLRF   00
07064:  CLRF   02
07066:  MOVLW  50
07068:  MOVWF  01
0706A:  CALL   5728
....................                      for(i=0;i<strlen(XX);i++) lcd_men[i]=XX[instruccion_size+i]; 
0706E:  CLRF   41
07070:  CLRF   40
07072:  MOVLB  9
07074:  CLRF   x0F
07076:  MOVLW  52
07078:  MOVWF  x0E
0707A:  MOVLB  0
0707C:  CALL   5650
07080:  MOVFF  02,03
07084:  MOVF   41,W
07086:  SUBWF  02,W
07088:  BNC   70CC
0708A:  BNZ   7092
0708C:  MOVF   01,W
0708E:  SUBWF  40,W
07090:  BC    70CC
07092:  MOVLW  BA
07094:  ADDWF  40,W
07096:  MOVWF  01
07098:  MOVLW  01
0709A:  ADDWFC 41,W
0709C:  MOVWF  03
0709E:  MOVFF  01,8F9
070A2:  MOVLB  8
070A4:  MOVWF  xFA
070A6:  MOVLW  5C
070A8:  ADDWF  40,W
070AA:  MOVWF  FE9
070AC:  MOVLW  00
070AE:  ADDWFC 41,W
070B0:  MOVWF  FEA
070B2:  MOVFF  FEF,8FD
070B6:  MOVFF  03,FEA
070BA:  MOVFF  01,FE9
070BE:  MOVFF  8FD,FEF
070C2:  INCF   40,F
070C4:  BTFSC  FD8.2
070C6:  INCF   41,F
070C8:  MOVLB  0
070CA:  BRA    7072
....................                      lcd_putc("\f"); 
070CC:  MOVLW  A0
070CE:  MOVWF  FF6
070D0:  MOVLW  02
070D2:  MOVWF  FF7
070D4:  CALL   06C2
....................                      for(i=0;i<strlen(lcd_men);i++){ 
070D8:  CLRF   41
070DA:  CLRF   40
070DC:  MOVLW  01
070DE:  MOVLB  9
070E0:  MOVWF  x0F
070E2:  MOVLW  BA
070E4:  MOVWF  x0E
070E6:  MOVLB  0
070E8:  CALL   5650
070EC:  MOVFF  02,03
070F0:  MOVF   41,W
070F2:  SUBWF  02,W
070F4:  BNC   7186
070F6:  BNZ   70FE
070F8:  MOVF   01,W
070FA:  SUBWF  40,W
070FC:  BC    7186
....................                         if(i==0)lcd_gotoxy(1,1); 
070FE:  MOVF   40,F
07100:  BTFSS  FD8.2
07102:  BRA    7118
07104:  MOVF   41,F
07106:  BNZ   7118
07108:  MOVLW  01
0710A:  MOVLB  9
0710C:  MOVWF  x00
0710E:  MOVWF  x01
07110:  MOVLB  0
07112:  CALL   060C
07116:  BRA    716A
....................                         else if(i==20) lcd_gotoxy(1,2); 
07118:  MOVF   40,W
0711A:  SUBLW  14
0711C:  BNZ   7134
0711E:  MOVF   41,F
07120:  BNZ   7134
07122:  MOVLW  01
07124:  MOVLB  9
07126:  MOVWF  x00
07128:  MOVLW  02
0712A:  MOVWF  x01
0712C:  MOVLB  0
0712E:  CALL   060C
07132:  BRA    716A
....................                         else if(i==40) lcd_gotoxy(1,3); 
07134:  MOVF   40,W
07136:  SUBLW  28
07138:  BNZ   7150
0713A:  MOVF   41,F
0713C:  BNZ   7150
0713E:  MOVLW  01
07140:  MOVLB  9
07142:  MOVWF  x00
07144:  MOVLW  03
07146:  MOVWF  x01
07148:  MOVLB  0
0714A:  CALL   060C
0714E:  BRA    716A
....................                         else if(i==60) lcd_gotoxy(1,4); 
07150:  MOVF   40,W
07152:  SUBLW  3C
07154:  BNZ   716A
07156:  MOVF   41,F
07158:  BNZ   716A
0715A:  MOVLW  01
0715C:  MOVLB  9
0715E:  MOVWF  x00
07160:  MOVLW  04
07162:  MOVWF  x01
07164:  MOVLB  0
07166:  CALL   060C
....................                         printf(lcd_putc,"%c",lcd_men[i]); 
0716A:  MOVLW  BA
0716C:  ADDWF  40,W
0716E:  MOVWF  FE9
07170:  MOVLW  01
07172:  ADDWFC 41,W
07174:  MOVWF  FEA
07176:  MOVFF  FEF,8FF
0717A:  CALL   065E
0717E:  INCF   40,F
07180:  BTFSC  FD8.2
07182:  INCF   41,F
07184:  BRA    70DC
....................                      } 
....................                      espera=1; 
07186:  MOVLW  01
07188:  MOVLB  2
0718A:  MOVWF  x7D
....................                      cta_lcd=0; 
0718C:  CLRF   x8B
....................                      break;}// 
0718E:  MOVLB  0
07190:  BRA    71EA
....................               case 8: {//MOITOREO DESACTIVADO 
....................                      break;}// 
07192:  BRA    71EA
....................               case 9: {//CONSULTA ENTRADAS SIN CONEXION 
....................                   break;} 
07194:  BRA    71EA
....................               case 10:{//CONFIGURA FECHA Y HORA 
....................                   fecha(); 
07196:  GOTO   64EE
....................                   break;} 
0719A:  BRA    71EA
....................               case 11:{//ultima conexion 
....................                   break;} 
0719C:  BRA    71EA
....................               case 13:{//RESET DE FOLIOS 
....................                   break;} 
0719E:  BRA    71EA
....................               case 14:{//PAGO EFECTUADO 
....................                   pago=1; 
071A0:  MOVLW  01
071A2:  MOVLB  2
071A4:  MOVWF  x7B
....................                   write_ext_eeprom(11,pago);// 
071A6:  MOVLB  9
071A8:  CLRF   x0A
071AA:  MOVLW  0B
071AC:  MOVWF  x09
071AE:  MOVFF  27B,90B
071B2:  MOVLB  0
071B4:  CALL   1430
....................                   strcpy (txtcp, "BOLETERA_PAGADO"); 
071B8:  MOVLW  01
071BA:  MOVWF  FEA
071BC:  MOVLW  06
071BE:  MOVWF  FE9
071C0:  MOVLW  00
071C2:  CALL   00E6
071C6:  TBLRD*-
071C8:  TBLRD*+
071CA:  MOVF   FF5,W
071CC:  MOVWF  FEE
071CE:  IORLW  00
071D0:  BNZ   71C8
....................                   size_tx_tcp=strlen(txtcp); 
071D2:  MOVLW  01
071D4:  MOVLB  9
071D6:  MOVWF  x0F
071D8:  MOVLW  06
071DA:  MOVWF  x0E
071DC:  MOVLB  0
071DE:  CALL   5650
071E2:  MOVFF  01,48
....................                   enviar_tcp(); 
071E6:  CALL   568C
....................                   break;} 
....................             }//end switch 
....................          }//end dato recibido tcp 
....................          ////////////////////////////////////// 
....................          if( (relay1)&&(time_relay1>=21) ){ 
071EA:  MOVF   1D,F
071EC:  BZ    71FE
071EE:  MOVF   1F,W
071F0:  SUBLW  14
071F2:  BC    71FE
....................             relay1=0; 
071F4:  CLRF   1D
....................             output_low(salida01); 
071F6:  BCF    F92.5
071F8:  BCF    F89.5
....................             output_low(salida02); 
071FA:  BCF    F96.0
071FC:  BCF    F8D.0
....................          } 
....................          //if( (time_boleto>60)&&(re_bol) )  re_bol=0; 
....................           
....................          if( (espera)&&(cta_lcd>=100) ) espera=0; 
071FE:  MOVLB  2
07200:  MOVF   x7D,F
07202:  BZ    720C
07204:  MOVF   x8B,W
07206:  SUBLW  63
07208:  BC    720C
0720A:  CLRF   x7D
....................           
....................          if( (cuenta>=20)&&(espera==0) ){//CADA 2 SEGUNDOS VERIFICA FECHA Y HORA 
0720C:  MOVF   x7C,W
0720E:  SUBLW  13
07210:  BTFSC  FD8.0
07212:  BRA    7664
07214:  MOVF   x7D,F
07216:  BTFSS  FD8.2
07218:  BRA    7664
....................              ds1307_get_time(hrs,min,sec); 
....................              ds1307_get_date(day,month,yr,dow); 
....................              if(hrs2!=hrs){ 
*
0740C:  MOVLB  2
0740E:  MOVF   x73,W
07410:  SUBWF  x7E,W
07412:  BZ    7464
....................                dia=31;//ultimo dia del mes 
07414:  CLRF   x82
07416:  MOVLW  1F
07418:  MOVWF  x81
....................                mes2=10;//octubre, mes en el que cambia horario invierno 
0741A:  CLRF   x80
0741C:  MOVLW  0A
0741E:  MOVWF  x7F
....................                zeller(); 
07420:  MOVLB  0
07422:  GOTO   665C
....................                hrs2=hrs; 
07426:  MOVFF  273,27E
....................                if( (dia_temp!=day)&&(pago!=1) ){ 
0742A:  MOVLB  2
0742C:  MOVF   x70,W
0742E:  SUBWF  x7A,W
07430:  BZ    7464
07432:  DECFSZ x7B,W
07434:  BRA    7438
07436:  BRA    7464
....................                   dia_temp=day; 
07438:  MOVFF  270,27A
....................                   dias_prueba++; 
0743C:  INCF   x79,F
....................                   write_ext_eeprom(12,dias_prueba);//dias de prueba 
0743E:  MOVLB  9
07440:  CLRF   x0A
07442:  MOVLW  0C
07444:  MOVWF  x09
07446:  MOVFF  279,90B
0744A:  MOVLB  0
0744C:  CALL   1430
....................                   write_ext_eeprom(13,dia_temp);// 
07450:  MOVLB  9
07452:  CLRF   x0A
07454:  MOVLW  0D
07456:  MOVWF  x09
07458:  MOVFF  27A,90B
0745C:  MOVLB  0
0745E:  CALL   1430
07462:  MOVLB  2
....................                } 
....................              }//FIN CONFIGURA AUTMATICO FECHA Y HORA 
....................              //cuenta_lcd=0; 
....................              puntos=!puntos; 
07464:  MOVF   x77,F
07466:  BZ    746C
07468:  MOVLW  00
0746A:  BRA    746E
0746C:  MOVLW  01
0746E:  MOVWF  x77
....................              if( (!espera)&&(!en1) ){ 
07470:  MOVF   x7D,F
07472:  BTFSS  FD8.2
07474:  BRA    7662
07476:  MOVF   x83,F
07478:  BTFSS  FD8.2
0747A:  BRA    7662
....................                lcd_gotoxy(1,1); 
0747C:  MOVLW  01
0747E:  MOVLB  9
07480:  MOVWF  x00
07482:  MOVWF  x01
07484:  MOVLB  0
07486:  CALL   060C
....................                lcd_putc("                    "); 
0748A:  MOVLW  A2
0748C:  MOVWF  FF6
0748E:  MOVLW  02
07490:  MOVWF  FF7
07492:  CALL   06C2
....................                lcd_gotoxy(1,2);//printf(lcd_putc,"  %02d %02d %02d %02d/%02d/%02d   ",hrs_e,min_e,sec_e,day_e,month,yr); 
07496:  MOVLW  01
07498:  MOVLB  9
0749A:  MOVWF  x00
0749C:  MOVLW  02
0749E:  MOVWF  x01
074A0:  MOVLB  0
074A2:  CALL   060C
....................                if(puntos==0)   printf(lcd_putc,"   %02d %02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
074A6:  MOVLB  2
074A8:  MOVF   x77,F
074AA:  BNZ   7558
074AC:  MOVLW  B8
074AE:  MOVWF  FF6
074B0:  MOVLW  02
074B2:  MOVWF  FF7
074B4:  MOVLW  03
074B6:  MOVLB  8
074B8:  MOVWF  xFA
074BA:  MOVLB  0
074BC:  CALL   1536
074C0:  MOVFF  273,8F9
074C4:  MOVLW  01
074C6:  MOVLB  8
074C8:  MOVWF  xFA
074CA:  MOVLB  0
074CC:  CALL   6A3C
074D0:  MOVLW  20
074D2:  MOVLB  8
074D4:  MOVWF  xFF
074D6:  MOVLB  0
074D8:  CALL   065E
074DC:  MOVFF  274,8F9
074E0:  MOVLW  01
074E2:  MOVLB  8
074E4:  MOVWF  xFA
074E6:  MOVLB  0
074E8:  CALL   6A3C
074EC:  MOVLW  20
074EE:  MOVLB  8
074F0:  MOVWF  xFF
074F2:  MOVLB  0
074F4:  CALL   065E
074F8:  MOVFF  270,8F9
074FC:  MOVLW  01
074FE:  MOVLB  8
07500:  MOVWF  xFA
07502:  MOVLB  0
07504:  CALL   6A3C
07508:  MOVLW  2F
0750A:  MOVLB  8
0750C:  MOVWF  xFF
0750E:  MOVLB  0
07510:  CALL   065E
07514:  MOVFF  271,8F9
07518:  MOVLW  01
0751A:  MOVLB  8
0751C:  MOVWF  xFA
0751E:  MOVLB  0
07520:  CALL   6A3C
07524:  MOVLW  2F
07526:  MOVLB  8
07528:  MOVWF  xFF
0752A:  MOVLB  0
0752C:  CALL   065E
07530:  MOVFF  272,8F9
07534:  MOVLW  01
07536:  MOVLB  8
07538:  MOVWF  xFA
0753A:  MOVLB  0
0753C:  CALL   6A3C
07540:  MOVLW  D3
07542:  MOVWF  FF6
07544:  MOVLW  02
07546:  MOVWF  FF7
07548:  MOVLW  04
0754A:  MOVLB  8
0754C:  MOVWF  xFA
0754E:  MOVLB  0
07550:  CALL   1536
07554:  BRA    7600
07556:  MOVLB  2
....................                else   printf(lcd_putc,"   %02d:%02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
07558:  MOVLW  D8
0755A:  MOVWF  FF6
0755C:  MOVLW  02
0755E:  MOVWF  FF7
07560:  MOVLW  03
07562:  MOVLB  8
07564:  MOVWF  xFA
07566:  MOVLB  0
07568:  CALL   1536
0756C:  MOVFF  273,8F9
07570:  MOVLW  01
07572:  MOVLB  8
07574:  MOVWF  xFA
07576:  MOVLB  0
07578:  CALL   6A3C
0757C:  MOVLW  3A
0757E:  MOVLB  8
07580:  MOVWF  xFF
07582:  MOVLB  0
07584:  CALL   065E
07588:  MOVFF  274,8F9
0758C:  MOVLW  01
0758E:  MOVLB  8
07590:  MOVWF  xFA
07592:  MOVLB  0
07594:  CALL   6A3C
07598:  MOVLW  20
0759A:  MOVLB  8
0759C:  MOVWF  xFF
0759E:  MOVLB  0
075A0:  CALL   065E
075A4:  MOVFF  270,8F9
075A8:  MOVLW  01
075AA:  MOVLB  8
075AC:  MOVWF  xFA
075AE:  MOVLB  0
075B0:  CALL   6A3C
075B4:  MOVLW  2F
075B6:  MOVLB  8
075B8:  MOVWF  xFF
075BA:  MOVLB  0
075BC:  CALL   065E
075C0:  MOVFF  271,8F9
075C4:  MOVLW  01
075C6:  MOVLB  8
075C8:  MOVWF  xFA
075CA:  MOVLB  0
075CC:  CALL   6A3C
075D0:  MOVLW  2F
075D2:  MOVLB  8
075D4:  MOVWF  xFF
075D6:  MOVLB  0
075D8:  CALL   065E
075DC:  MOVFF  272,8F9
075E0:  MOVLW  01
075E2:  MOVLB  8
075E4:  MOVWF  xFA
075E6:  MOVLB  0
075E8:  CALL   6A3C
075EC:  MOVLW  F3
075EE:  MOVWF  FF6
075F0:  MOVLW  02
075F2:  MOVWF  FF7
075F4:  MOVLW  04
075F6:  MOVLB  8
075F8:  MOVWF  xFA
075FA:  MOVLB  0
075FC:  CALL   1536
....................                cambio_msj++; 
07600:  MOVLB  2
07602:  INCF   x78,F
....................                lcd_gotoxy(1,3); 
07604:  MOVLW  01
07606:  MOVLB  9
07608:  MOVWF  x00
0760A:  MOVLW  03
0760C:  MOVWF  x01
0760E:  MOVLB  0
07610:  CALL   060C
....................                if(cambio_msj>=10) lcd_putc("   WWW.ACCESA.ME    ");//COMPLEJO CITY ANGELÓPOLIS   
07614:  MOVLB  2
07616:  MOVF   x78,W
07618:  SUBLW  09
0761A:  BC    762E
0761C:  MOVLW  F8
0761E:  MOVWF  FF6
07620:  MOVLW  02
07622:  MOVWF  FF7
07624:  MOVLB  0
07626:  CALL   06C2
0762A:  BRA    763C
0762C:  MOVLB  2
....................                else lcd_putc("       ACCESA       "); 
0762E:  MOVLW  0E
07630:  MOVWF  FF6
07632:  MOVLW  03
07634:  MOVWF  FF7
07636:  MOVLB  0
07638:  CALL   06C2
....................                lcd_gotoxy(1,4); 
0763C:  MOVLW  01
0763E:  MOVLB  9
07640:  MOVWF  x00
07642:  MOVLW  04
07644:  MOVWF  x01
07646:  MOVLB  0
07648:  CALL   060C
....................                lcd_putc("                    "); 
0764C:  MOVLW  24
0764E:  MOVWF  FF6
07650:  MOVLW  03
07652:  MOVWF  FF7
07654:  CALL   06C2
....................                if(cambio_msj>=20) cambio_msj=0; 
07658:  MOVLB  2
0765A:  MOVF   x78,W
0765C:  SUBLW  13
0765E:  BC    7662
07660:  CLRF   x78
....................              } 
....................              cuenta=0; 
07662:  CLRF   x7C
07664:  MOVLB  0
....................          }//END SEGUNDO 
....................       } 
....................       //if( (MACIsLinked()==0)&&(inicializado)&&(linked_out==0) ){//cable off 
....................       if( (MACIsLinked()==0)&&(inicializado) ){//cable off 
07666:  GOTO   6B08
0766A:  MOVF   01,F
0766C:  BNZ   767A
0766E:  MOVF   50,F
07670:  BZ    767A
....................          //linked_out=1; 
....................          TCPDisconnect(socket2); 
07672:  MOVFF  51,8FE
07676:  CALL   5096
....................       } 
....................       ////////////////////////////////////// 
....................       if( (time_bot>=80)&&(flag_time) ) flag_time=0; 
0767A:  MOVLB  3
0767C:  MOVF   x52,F
0767E:  BNZ   7686
07680:  MOVF   x51,W
07682:  SUBLW  4F
07684:  BC    768C
07686:  MOVF   x50,F
07688:  BZ    768C
0768A:  CLRF   x50
0768C:  MOVLB  0
0768E:  GOTO   6E64
....................    }//end true 
.................... }//end main 
....................  
07692:  SLEEP 
.................... int convertir_to_entero(char *cadena){ 
*
06326:  MOVLB  8
06328:  CLRF   xFC
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
0632A:  MOVF   xFA,W
0632C:  SUBLW  30
0632E:  BNZ   6338
06330:  MOVF   xFB,F
06332:  BNZ   6338
06334:  CLRF   xFC
06336:  BRA    63C6
....................    else if(cadena=='1') valor=1; 
06338:  MOVF   xFA,W
0633A:  SUBLW  31
0633C:  BNZ   6348
0633E:  MOVF   xFB,F
06340:  BNZ   6348
06342:  MOVLW  01
06344:  MOVWF  xFC
06346:  BRA    63C6
....................    else if(cadena=='2') valor=2; 
06348:  MOVF   xFA,W
0634A:  SUBLW  32
0634C:  BNZ   6358
0634E:  MOVF   xFB,F
06350:  BNZ   6358
06352:  MOVLW  02
06354:  MOVWF  xFC
06356:  BRA    63C6
....................    else if(cadena=='3') valor=3; 
06358:  MOVF   xFA,W
0635A:  SUBLW  33
0635C:  BNZ   6368
0635E:  MOVF   xFB,F
06360:  BNZ   6368
06362:  MOVLW  03
06364:  MOVWF  xFC
06366:  BRA    63C6
....................    else if(cadena=='4') valor=4; 
06368:  MOVF   xFA,W
0636A:  SUBLW  34
0636C:  BNZ   6378
0636E:  MOVF   xFB,F
06370:  BNZ   6378
06372:  MOVLW  04
06374:  MOVWF  xFC
06376:  BRA    63C6
....................    else if(cadena=='5') valor=5; 
06378:  MOVF   xFA,W
0637A:  SUBLW  35
0637C:  BNZ   6388
0637E:  MOVF   xFB,F
06380:  BNZ   6388
06382:  MOVLW  05
06384:  MOVWF  xFC
06386:  BRA    63C6
....................    else if(cadena=='6') valor=6; 
06388:  MOVF   xFA,W
0638A:  SUBLW  36
0638C:  BNZ   6398
0638E:  MOVF   xFB,F
06390:  BNZ   6398
06392:  MOVLW  06
06394:  MOVWF  xFC
06396:  BRA    63C6
....................    else if(cadena=='7') valor=7; 
06398:  MOVF   xFA,W
0639A:  SUBLW  37
0639C:  BNZ   63A8
0639E:  MOVF   xFB,F
063A0:  BNZ   63A8
063A2:  MOVLW  07
063A4:  MOVWF  xFC
063A6:  BRA    63C6
....................    else if(cadena=='8') valor=8; 
063A8:  MOVF   xFA,W
063AA:  SUBLW  38
063AC:  BNZ   63B8
063AE:  MOVF   xFB,F
063B0:  BNZ   63B8
063B2:  MOVLW  08
063B4:  MOVWF  xFC
063B6:  BRA    63C6
....................    else if(cadena=='9') valor=9; 
063B8:  MOVF   xFA,W
063BA:  SUBLW  39
063BC:  BNZ   63C6
063BE:  MOVF   xFB,F
063C0:  BNZ   63C6
063C2:  MOVLW  09
063C4:  MOVWF  xFC
....................    return valor; 
063C6:  MOVFF  8FC,01
063CA:  MOVLB  0
063CC:  RETURN 0
.................... } 
....................  
.................... void fecha(){//falta revisar si se deshabilitan las int globales 
....................    disable_interrupts(INT_RDA); 
*
064EE:  BCF    F9D.5
....................    //delay_ms(1000); 
.................... //   lcd_gotoxy(1,2); 
.................... //   lcd_putc("\f     CONFIGURA      ");// 
.................... //   lcd_gotoxy(1,3); 
.................... //   lcd_putc("     FECHA/HORA     "); 
....................     
....................    setup_wdt(WDT_ON); 
064F0:  BSF    FD1.0
....................    restart_wdt(); 
064F2:  CLRWDT
....................     
....................    day=(convertir_to_entero(XX[instruccion_size])*10)+convertir_to_entero(XX[instruccion_size+1]); 
064F4:  MOVLB  8
064F6:  CLRF   xFB
064F8:  MOVFF  5C,8FA
064FC:  MOVLB  0
064FE:  RCALL  6326
06500:  MOVF   01,W
06502:  MULLW  0A
06504:  MOVFF  FF3,8F9
06508:  MOVLB  8
0650A:  CLRF   xFB
0650C:  MOVFF  5D,8FA
06510:  MOVLB  0
06512:  RCALL  6326
06514:  MOVF   01,W
06516:  MOVLB  8
06518:  ADDWF  xF9,W
0651A:  MOVLB  2
0651C:  MOVWF  x70
....................    hrs=(convertir_to_entero(XX[instruccion_size+7])*10)+convertir_to_entero(XX[instruccion_size+8]); 
0651E:  MOVLB  8
06520:  CLRF   xFB
06522:  MOVFF  63,8FA
06526:  MOVLB  0
06528:  RCALL  6326
0652A:  MOVF   01,W
0652C:  MULLW  0A
0652E:  MOVFF  FF3,8F9
06532:  MOVLB  8
06534:  CLRF   xFB
06536:  MOVFF  64,8FA
0653A:  MOVLB  0
0653C:  RCALL  6326
0653E:  MOVF   01,W
06540:  MOVLB  8
06542:  ADDWF  xF9,W
06544:  MOVLB  2
06546:  MOVWF  x73
....................    min=(convertir_to_entero(XX[instruccion_size+9])*10)+convertir_to_entero(XX[instruccion_size+10]); 
06548:  MOVLB  8
0654A:  CLRF   xFB
0654C:  MOVFF  65,8FA
06550:  MOVLB  0
06552:  RCALL  6326
06554:  MOVF   01,W
06556:  MULLW  0A
06558:  MOVFF  FF3,8F9
0655C:  MOVLB  8
0655E:  CLRF   xFB
06560:  MOVFF  66,8FA
06564:  MOVLB  0
06566:  RCALL  6326
06568:  MOVF   01,W
0656A:  MOVLB  8
0656C:  ADDWF  xF9,W
0656E:  MOVLB  2
06570:  MOVWF  x74
....................    sec=(convertir_to_entero(XX[instruccion_size+11])*10)+convertir_to_entero(XX[instruccion_size+12]); 
06572:  MOVLB  8
06574:  CLRF   xFB
06576:  MOVFF  67,8FA
0657A:  MOVLB  0
0657C:  RCALL  6326
0657E:  MOVF   01,W
06580:  MULLW  0A
06582:  MOVFF  FF3,8F9
06586:  MOVLB  8
06588:  CLRF   xFB
0658A:  MOVFF  68,8FA
0658E:  MOVLB  0
06590:  RCALL  6326
06592:  MOVF   01,W
06594:  MOVLB  8
06596:  ADDWF  xF9,W
06598:  MOVLB  2
0659A:  MOVWF  x75
....................     
....................    month=(convertir_to_entero(XX[instruccion_size+2])*10)+convertir_to_entero(XX[instruccion_size+3]); 
0659C:  MOVLB  8
0659E:  CLRF   xFB
065A0:  MOVFF  5E,8FA
065A4:  MOVLB  0
065A6:  RCALL  6326
065A8:  MOVF   01,W
065AA:  MULLW  0A
065AC:  MOVFF  FF3,8F9
065B0:  MOVLB  8
065B2:  CLRF   xFB
065B4:  MOVFF  5F,8FA
065B8:  MOVLB  0
065BA:  RCALL  6326
065BC:  MOVF   01,W
065BE:  MOVLB  8
065C0:  ADDWF  xF9,W
065C2:  MOVLB  2
065C4:  MOVWF  x71
....................    yr= (convertir_to_entero(XX[instruccion_size+4])*10)+convertir_to_entero(XX[instruccion_size+5]); 
065C6:  MOVLB  8
065C8:  CLRF   xFB
065CA:  MOVFF  60,8FA
065CE:  MOVLB  0
065D0:  RCALL  6326
065D2:  MOVF   01,W
065D4:  MULLW  0A
065D6:  MOVFF  FF3,8F9
065DA:  MOVLB  8
065DC:  CLRF   xFB
065DE:  MOVFF  61,8FA
065E2:  MOVLB  0
065E4:  RCALL  6326
065E6:  MOVF   01,W
065E8:  MOVLB  8
065EA:  ADDWF  xF9,W
065EC:  MOVLB  2
065EE:  MOVWF  x72
....................    dow= convertir_to_entero(XX[instruccion_size+6]); 
065F0:  MOVLB  8
065F2:  CLRF   xFB
065F4:  MOVFF  62,8FA
065F8:  MOVLB  0
065FA:  RCALL  6326
065FC:  MOVFF  01,276
....................    ///////////////////// 
....................    ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos), ,hora,min,seg 
06600:  MOVFF  270,909
06604:  MOVFF  271,90A
06608:  MOVFF  272,90B
0660C:  MOVFF  276,90C
06610:  MOVFF  273,90D
06614:  MOVFF  274,90E
06618:  MOVFF  275,90F
0661C:  RCALL  63F6
....................    //lcd_gotoxy(1,1); 
....................    //printf(lcd_putc,"      %02d:%02d:%02d      ",hrs,min,sec); 
....................    //lcd_gotoxy(1,2); 
....................    //printf (lcd_putc,"     %02d/%02d/2%03d     ",day,month,yr); 
....................    //lcd_gotoxy(1,3); 
....................    //lcd_putc("  DATOS GUARDADOS   "); 
....................    lcd_gotoxy(1,4); 
0661E:  MOVLW  01
06620:  MOVLB  9
06622:  MOVWF  x00
06624:  MOVLW  04
06626:  MOVWF  x01
06628:  MOVLB  0
0662A:  CALL   060C
....................    lcd_putc("  Hora Actualizada  "); 
0662E:  MOVLW  3A
06630:  MOVWF  FF6
06632:  MOVLW  03
06634:  MOVWF  FF7
06636:  CALL   06C2
....................    delay_ms(2500); 
0663A:  MOVLW  0A
0663C:  MOVLB  8
0663E:  MOVWF  xF9
06640:  MOVLW  FA
06642:  MOVLB  9
06644:  MOVWF  x00
06646:  MOVLB  0
06648:  CALL   05E4
0664C:  MOVLB  8
0664E:  DECFSZ xF9,F
06650:  BRA    6640
....................    restart_wdt(); 
06652:  CLRWDT
....................    //if(demo==1) printf("\r\nXX:%s",XX); 
....................    enable_interrupts(INT_RDA); 
06654:  BSF    F9D.5
06656:  MOVLB  0
06658:  GOTO   71EA (RETURN)
.................... } 
....................  
.................... void wiegand_read_card(){ 
....................  if(wieg_full){ 
*
05742:  MOVLB  2
05744:  MOVF   x10,F
05746:  BTFSC  FD8.2
05748:  BRA    5874
....................    //disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
....................    deci=0; 
0574A:  CLRF   x15
0574C:  CLRF   x14
0574E:  CLRF   x13
05750:  CLRF   x12
....................    for(i=1;i<sub_indice-1;i++) deci = (deci<<1)|data[i]; 
05752:  CLRF   41
05754:  MOVLW  01
05756:  MOVWF  40
05758:  MOVLW  01
0575A:  SUBWF  x0F,W
0575C:  MOVF   41,F
0575E:  BNZ   57AE
05760:  SUBWF  40,W
05762:  BC    57AE
05764:  BCF    FD8.0
05766:  RLCF   x12,W
05768:  MOVLB  8
0576A:  MOVWF  xFA
0576C:  MOVLB  2
0576E:  RLCF   x13,W
05770:  MOVLB  8
05772:  MOVWF  xFB
05774:  MOVLB  2
05776:  RLCF   x14,W
05778:  MOVLB  8
0577A:  MOVWF  xFC
0577C:  MOVLB  2
0577E:  RLCF   x15,W
05780:  MOVLB  8
05782:  MOVWF  xFD
05784:  MOVLW  16
05786:  ADDWF  40,W
05788:  MOVWF  FE9
0578A:  MOVLW  02
0578C:  ADDWFC 41,W
0578E:  MOVWF  FEA
05790:  MOVF   FEF,W
05792:  IORWF  xFA,W
05794:  MOVLB  2
05796:  MOVWF  x12
05798:  MOVFF  8FB,213
0579C:  MOVFF  8FC,214
057A0:  MOVFF  8FD,215
057A4:  MOVLB  2
057A6:  INCF   40,F
057A8:  BTFSC  FD8.2
057AA:  INCF   41,F
057AC:  BRA    5758
....................    sprintf(YY,"%08LX",deci);// imprime en un arreglo (printf en ram) 
057AE:  MOVLB  8
057B0:  CLRF   xF7
057B2:  MOVLW  AC
057B4:  MOVWF  xF6
057B6:  MOVFF  215,8F9
057BA:  MOVLW  37
057BC:  MOVWF  xFA
057BE:  MOVLB  0
057C0:  RCALL  56B8
057C2:  MOVFF  214,8F9
057C6:  MOVLW  37
057C8:  MOVLB  8
057CA:  MOVWF  xFA
057CC:  MOVLB  0
057CE:  RCALL  56B8
057D0:  MOVFF  213,8F9
057D4:  MOVLW  37
057D6:  MOVLB  8
057D8:  MOVWF  xFA
057DA:  MOVLB  0
057DC:  RCALL  56B8
057DE:  MOVFF  212,8F9
057E2:  MOVLW  37
057E4:  MOVLB  8
057E6:  MOVWF  xFA
057E8:  MOVLB  0
057EA:  RCALL  56B8
....................    sprintf(txtcp,"EN1-%08LX",deci);// imprime en un arreglo (printf en ram) 
057EC:  MOVLW  01
057EE:  MOVLB  8
057F0:  MOVWF  xF7
057F2:  MOVLW  06
057F4:  MOVWF  xF6
057F6:  MOVLW  50
057F8:  MOVWF  FF6
057FA:  MOVLW  03
057FC:  MOVWF  FF7
057FE:  MOVLW  04
05800:  MOVWF  xF9
05802:  MOVLB  0
05804:  BRA    56FE
05806:  MOVFF  215,8F9
0580A:  MOVLW  37
0580C:  MOVLB  8
0580E:  MOVWF  xFA
05810:  MOVLB  0
05812:  RCALL  56B8
05814:  MOVFF  214,8F9
05818:  MOVLW  37
0581A:  MOVLB  8
0581C:  MOVWF  xFA
0581E:  MOVLB  0
05820:  RCALL  56B8
05822:  MOVFF  213,8F9
05826:  MOVLW  37
05828:  MOVLB  8
0582A:  MOVWF  xFA
0582C:  MOVLB  0
0582E:  RCALL  56B8
05830:  MOVFF  212,8F9
05834:  MOVLW  37
05836:  MOVLB  8
05838:  MOVWF  xFA
0583A:  MOVLB  0
0583C:  RCALL  56B8
....................    //fprintf(DEBUG,"TA:%s\r\n",txtcp); 
....................    //lcd_gotoxy(1,3); 
....................    //printf(lcd_putc,"TA:%s",txtcp); 
....................    size_tx_tcp=strlen(txtcp); 
0583E:  MOVLW  01
05840:  MOVLB  9
05842:  MOVWF  x0F
05844:  MOVLW  06
05846:  MOVWF  x0E
05848:  MOVLB  0
0584A:  RCALL  5650
0584C:  MOVFF  01,48
....................    enviar_tcp(); 
05850:  RCALL  568C
....................    //validar_tag_salida();//FUNCION PARA ABRIR AUTOMATICAMENTE Y GUARDAR ESTADO DE ANTIPASS 
....................    wieg_full=0; 
05852:  MOVLB  2
05854:  CLRF   x10
....................    wieg=sub_indice=0; 
05856:  CLRF   x0F
05858:  MOVFF  20F,20C
....................    wiegand_cuenta=0; 
0585C:  CLRF   x11
....................    memset(data, 0, sizeof(data) ); 
0585E:  MOVLW  02
05860:  MOVWF  FEA
05862:  MOVLW  16
05864:  MOVWF  FE9
05866:  CLRF   00
05868:  CLRF   02
0586A:  MOVLW  1A
0586C:  MOVWF  01
0586E:  MOVLB  0
05870:  RCALL  5728
05872:  MOVLB  2
....................  }//END TARJETA LEIDA 
....................  if( (wieg==1)&&(wiegand_cuenta>=3) ) { 
05874:  DECFSZ x0C,W
05876:  BRA    58C0
05878:  MOVF   x11,W
0587A:  SUBLW  02
0587C:  BC    58C0
....................       wigmal++; 
0587E:  INCF   x0D,F
....................       //fprintf(DEBUG,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_gotoxy(1,4); 
....................       //printf(lcd_putc,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_putc("CAPTURA INCOMPLETA  "); 
....................       wieg_full=0; 
05880:  CLRF   x10
....................       deci=0; 
05882:  CLRF   x15
05884:  CLRF   x14
05886:  CLRF   x13
05888:  CLRF   x12
....................       ///////////UNIFICANDO EL TAMAÑO DEL DATO LEIDO///////////////// 
....................       deteccion_nulo=0; 
0588A:  CLRF   x0A
....................       pre_cuenta=0; 
0588C:  CLRF   x0B
....................       ////////////////////// 
....................       wieg=sub_indice=i=0; 
0588E:  CLRF   41
05890:  CLRF   40
05892:  MOVFF  40,20F
05896:  MOVFF  20F,20C
....................       wiegand_cuenta=0; 
0589A:  CLRF   x11
....................       for(i=0;i<wieg_size;i++) data[i]=0; 
0589C:  CLRF   41
0589E:  CLRF   40
058A0:  MOVF   41,F
058A2:  BNZ   58C0
058A4:  MOVF   40,W
058A6:  SUBLW  19
058A8:  BNC   58C0
058AA:  MOVLW  16
058AC:  ADDWF  40,W
058AE:  MOVWF  FE9
058B0:  MOVLW  02
058B2:  ADDWFC 41,W
058B4:  MOVWF  FEA
058B6:  CLRF   FEF
058B8:  INCF   40,F
058BA:  BTFSC  FD8.2
058BC:  INCF   41,F
058BE:  BRA    58A0
....................  } 
058C0:  MOVLB  0
058C2:  GOTO   6F48 (RETURN)
.................... } 
....................  
.................... void enviar_tcp(){ 
....................    envia_pc=1; 
*
0568C:  MOVLW  01
0568E:  MOVWF  1A
....................    StackTask(); 
05690:  CALL   44A8
....................    MyTCPTask(); 
05694:  RCALL  52E4
05696:  RETURN 0
.................... } 
.................... //////////////////// 
.................... void zeller(){ 
.................... int16 dia_s1,dia_s2,dia_s3,diac,mesc,dia_fecha;//(day,month,yr,dow,hrs,min,sec 
....................    int siglo,asiglo,resultado,di2; 
....................    diac=31; 
*
0665C:  MOVLB  9
0665E:  CLRF   x00
06660:  MOVLW  1F
06662:  MOVLB  8
06664:  MOVWF  xFF
....................    mesc=10; 
06666:  MOVLB  9
06668:  CLRF   x02
0666A:  MOVLW  0A
0666C:  MOVWF  x01
....................    siglo=20; 
0666E:  MOVLW  14
06670:  MOVWF  x05
....................    asiglo=yr; 
06672:  MOVFF  272,906
....................    //fprintf(U1PRINTER,"Dia:%Ld mes:%Ld año:%d siglo:%d asiglo:%d\r\n",diac,mesc,asiglo,siglo,asiglo); 
....................    if(mesc<3){ 
06676:  MOVF   x02,F
06678:  BNZ   668A
0667A:  MOVF   x01,W
0667C:  SUBLW  02
0667E:  BNC   668A
....................       mesc+=12; 
06680:  MOVLW  0C
06682:  ADDWF  x01,F
06684:  MOVLW  00
06686:  ADDWFC x02,F
....................       asiglo--; 
06688:  DECF   x06,F
....................    } 
....................    dia_s1=(siglo/4)+5*siglo; 
0668A:  RRCF   x05,W
0668C:  MOVWF  x09
0668E:  RRCF   x09,F
06690:  MOVLW  3F
06692:  ANDWF  x09,F
06694:  MOVF   x05,W
06696:  MULLW  05
06698:  MOVF   FF3,W
0669A:  ADDWF  x09,W
0669C:  MOVLB  8
0669E:  MOVWF  xF9
066A0:  CLRF   xFA
....................    dia_s2=dia_s1+asiglo+(asiglo/4); 
066A2:  MOVLB  9
066A4:  MOVF   x06,W
066A6:  MOVLB  8
066A8:  ADDWF  xF9,W
066AA:  MOVLB  9
066AC:  MOVWF  x09
066AE:  MOVLW  00
066B0:  MOVLB  8
066B2:  ADDWFC xFA,W
066B4:  MOVLB  9
066B6:  MOVWF  x0A
066B8:  RRCF   x06,W
066BA:  MOVWF  00
066BC:  RRCF   00,F
066BE:  MOVLW  3F
066C0:  ANDWF  00,F
066C2:  MOVF   00,W
066C4:  ADDWF  x09,W
066C6:  MOVLB  8
066C8:  MOVWF  xFB
066CA:  MOVLW  00
066CC:  MOVLB  9
066CE:  ADDWFC x0A,W
066D0:  MOVLB  8
066D2:  MOVWF  xFC
....................    dia_s3=dia_s2+((mesc+1)*26)/10; 
066D4:  MOVLW  01
066D6:  MOVLB  9
066D8:  ADDWF  x01,W
066DA:  MOVWF  x09
066DC:  MOVLW  00
066DE:  ADDWFC x02,W
066E0:  MOVWF  x0A
066E2:  MOVWF  x4B
066E4:  MOVFF  909,94A
066E8:  CLRF   x4D
066EA:  MOVLW  1A
066EC:  MOVWF  x4C
066EE:  MOVLB  0
066F0:  CALL   0FE8
066F4:  MOVFF  02,90A
066F8:  MOVFF  01,909
066FC:  MOVFF  02,90C
06700:  MOVFF  01,90B
06704:  MOVLB  9
06706:  CLRF   x0E
06708:  MOVLW  0A
0670A:  MOVWF  x0D
0670C:  MOVLB  0
0670E:  CALL   107A
06712:  MOVF   01,W
06714:  MOVLB  8
06716:  ADDWF  xFB,W
06718:  MOVWF  xFD
0671A:  MOVF   02,W
0671C:  ADDWFC xFC,W
0671E:  MOVWF  xFE
....................    dia_fecha=(dia_s3+diac)%7;//dia de fin de mes 
06720:  MOVF   xFF,W
06722:  ADDWF  xFD,W
06724:  MOVLB  9
06726:  MOVWF  x09
06728:  MOVF   x00,W
0672A:  MOVLB  8
0672C:  ADDWFC xFE,W
0672E:  MOVLB  9
06730:  MOVWF  x0A
06732:  MOVWF  x0C
06734:  MOVFF  909,90B
06738:  CLRF   x0E
0673A:  MOVLW  07
0673C:  MOVWF  x0D
0673E:  MOVLB  0
06740:  CALL   107A
06744:  MOVFF  00,903
06748:  MOVLB  9
0674A:  MOVFF  03,904
....................    if(dia_fecha==0) dia_fecha=7; 
0674E:  MOVF   x03,F
06750:  BNZ   675C
06752:  MOVF   x04,F
06754:  BNZ   675C
06756:  CLRF   x04
06758:  MOVLW  07
0675A:  MOVWF  x03
....................    //fprintf(U1PRINTER,"Dia:%Ld ",dia_fecha); 
....................    resultado=31-(dia_fecha-1); 
0675C:  MOVLW  01
0675E:  SUBWF  x03,W
06760:  MOVWF  00
06762:  MOVLW  00
06764:  SUBWFB x04,W
06766:  MOVF   00,W
06768:  XORLW  FF
0676A:  ADDLW  20
0676C:  MOVWF  x07
....................    //fprintf(U1PRINTER,"Dia:%d ",resultado); 
.................... ///////////revisar cambio de horario//////////// 
.................... ds1307_get_date(day,month,yr,dow); 
.................... ds1307_get_time(hrs,min,sec); 
.................... di2=read_ext_eeprom(14); 
*
0695E:  MOVLB  9
06960:  CLRF   x0A
06962:  MOVLW  0E
06964:  MOVWF  x09
06966:  MOVLB  0
06968:  CALL   1388
0696C:  MOVFF  01,908
.................... if((month==4)&&(dow==1)&&(hrs>=2)&&(di2!=1)){//cambia a horario de verano 
06970:  MOVLB  2
06972:  MOVF   x71,W
06974:  SUBLW  04
06976:  BNZ   69CE
06978:  DECFSZ x76,W
0697A:  BRA    69CE
0697C:  MOVF   x73,W
0697E:  SUBLW  01
06980:  BC    69CE
06982:  MOVLB  9
06984:  DECFSZ x08,W
06986:  BRA    698E
06988:  MOVLB  2
0698A:  BRA    69CE
0698C:  MOVLB  9
....................  hrs=hrs+1; 
0698E:  MOVLW  01
06990:  MOVLB  2
06992:  ADDWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
06994:  MOVFF  270,909
06998:  MOVFF  271,90A
0699C:  MOVFF  272,90B
069A0:  MOVFF  276,90C
069A4:  MOVFF  273,90D
069A8:  MOVFF  274,90E
069AC:  MOVFF  275,90F
069B0:  MOVLB  0
069B2:  RCALL  63F6
....................  di2=1; 
069B4:  MOVLW  01
069B6:  MOVLB  9
069B8:  MOVWF  x08
....................  write_ext_eeprom(14,di2);//(1,0)horario de invierno 
069BA:  CLRF   x0A
069BC:  MOVLW  0E
069BE:  MOVWF  x09
069C0:  MOVFF  908,90B
069C4:  MOVLB  0
069C6:  CALL   1430
.................... } 
069CA:  BRA    6A34
069CC:  MOVLB  2
.................... //if((month==10)&&(dow==1)&&(day==resultado)&&(hrs==3)&&(di2!=day)){//cambia a horario de invierno 
.................... else if((month==10)&&(day==resultado)&&(hrs>=3)&&(hrs<=5)&&(di2!=day)){//cambia a horario de invierno 
069CE:  MOVF   x71,W
069D0:  SUBLW  0A
069D2:  BNZ   6A36
069D4:  MOVLB  9
069D6:  MOVF   x07,W
069D8:  MOVLB  2
069DA:  SUBWF  x70,W
069DC:  BNZ   6A36
069DE:  MOVF   x73,W
069E0:  SUBLW  02
069E2:  BC    6A36
069E4:  MOVF   x73,W
069E6:  SUBLW  05
069E8:  BNC   6A36
069EA:  MOVF   x70,W
069EC:  MOVLB  9
069EE:  SUBWF  x08,W
069F0:  BTFSS  FD8.2
069F2:  BRA    69F8
069F4:  MOVLB  2
069F6:  BRA    6A36
....................  hrs=hrs-1; 
069F8:  MOVLW  01
069FA:  MOVLB  2
069FC:  SUBWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
069FE:  MOVFF  270,909
06A02:  MOVFF  271,90A
06A06:  MOVFF  272,90B
06A0A:  MOVFF  276,90C
06A0E:  MOVFF  273,90D
06A12:  MOVFF  274,90E
06A16:  MOVFF  275,90F
06A1A:  MOVLB  0
06A1C:  RCALL  63F6
....................  di2=day; 
06A1E:  MOVFF  270,908
....................  write_ext_eeprom(14,di2); 
06A22:  MOVLB  9
06A24:  CLRF   x0A
06A26:  MOVLW  0E
06A28:  MOVWF  x09
06A2A:  MOVFF  908,90B
06A2E:  MOVLB  0
06A30:  CALL   1430
06A34:  MOVLB  2
....................  } 
06A36:  MOVLB  0
06A38:  GOTO   7426 (RETURN)
.................... } 
.................... //////////////////// 
.................... void sensores(){ 
.................... if(en1!=input(entrada01) ){//SENSOR 1 bobina DE ENTRADA 
*
058E8:  BSF    F95.4
058EA:  MOVLW  00
058EC:  BTFSC  F83.4
058EE:  MOVLW  01
058F0:  MOVLB  2
058F2:  SUBWF  x83,W
058F4:  BZ    5940
....................    delay_ms(20); 
058F6:  MOVLW  14
058F8:  MOVLB  9
058FA:  MOVWF  x00
058FC:  MOVLB  0
058FE:  CALL   05E4
....................    if(en1!=input(entrada01)){ 
05902:  BSF    F95.4
05904:  MOVLW  00
05906:  BTFSC  F83.4
05908:  MOVLW  01
0590A:  MOVLB  2
0590C:  SUBWF  x83,W
0590E:  BZ    5940
....................       en1=input(entrada01); 
05910:  BSF    F95.4
05912:  CLRF   x83
05914:  BTFSC  F83.4
05916:  INCF   x83,F
....................       //fen4=0; 
....................       if(en1==1){ 
05918:  DECFSZ x83,W
0591A:  BRA    593A
....................          lcd_putc("\f\n     BIENVENIDO"); 
0591C:  MOVLW  5A
0591E:  MOVWF  FF6
05920:  MOVLW  03
05922:  MOVWF  FF7
05924:  MOVLB  0
05926:  CALL   06C2
....................          re_bol=0; 
0592A:  MOVLB  2
0592C:  CLRF   x8A
....................          time_bot=0; 
0592E:  MOVLB  3
05930:  CLRF   x52
05932:  CLRF   x51
....................          flag_time=0; 
05934:  CLRF   x50
....................          //strcpy(txtcp,"EN1-ENTRADA"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
05936:  BRA    5942
05938:  MOVLB  2
....................       else { 
....................          output_low(salida04); 
0593A:  BCF    F95.3
0593C:  BCF    F8C.3
....................          re_bol=0; 
0593E:  CLRF   x8A
05940:  MOVLB  3
....................          //lcd_putc("\fEN1-SINDETECCION"); 
....................          //strcpy(txtcp,"EN1-SINDETECCION"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................    } 
.................... }//end S1 
....................  
.................... if(en4!=input(entrada04) ){//BOTON DE TICKET 
05942:  BSF    F95.0
05944:  MOVLW  00
05946:  BTFSC  F83.0
05948:  MOVLW  01
0594A:  MOVLB  2
0594C:  SUBWF  x86,W
0594E:  BZ    59AE
....................    //delay_ms(10); 
....................    if(en4!=input(entrada04)){ 
05950:  BSF    F95.0
05952:  MOVLW  00
05954:  BTFSC  F83.0
05956:  MOVLW  01
05958:  SUBWF  x86,W
0595A:  BZ    59AE
....................       en4=input(entrada04); 
0595C:  BSF    F95.0
0595E:  CLRF   x86
05960:  BTFSC  F83.0
05962:  INCF   x86,F
....................       //if( (en4)&&(en1)&&(!re_bol) ){ 
....................       if( (en4)&&(en1)&&(!re_bol)&&(!flag_time) ){ 
05964:  MOVF   x86,F
05966:  BZ    59AE
05968:  MOVF   x83,F
0596A:  BZ    59AE
0596C:  MOVF   x8A,F
0596E:  BNZ   59AE
05970:  MOVLB  3
05972:  MOVF   x50,F
05974:  BTFSC  FD8.2
05976:  BRA    597C
05978:  MOVLB  2
0597A:  BRA    59AE
....................          flag_time=1; 
0597C:  MOVLW  01
0597E:  MOVWF  x50
....................          time_boleto=0; 
05980:  MOVLB  2
05982:  CLRF   x89
....................          //re_bol=1; 
....................          sprintf(txtcp,"BOTON_BOLETO");//01-id de camion  
05984:  MOVLB  8
05986:  MOVWF  xF7
05988:  MOVLW  06
0598A:  MOVWF  xF6
0598C:  MOVLW  6C
0598E:  MOVWF  FF6
05990:  MOVLW  03
05992:  MOVWF  FF7
05994:  MOVLB  0
05996:  BRA    58C6
....................          size_tx_tcp=strlen(txtcp); 
05998:  MOVLW  01
0599A:  MOVLB  9
0599C:  MOVWF  x0F
0599E:  MOVLW  06
059A0:  MOVWF  x0E
059A2:  MOVLB  0
059A4:  RCALL  5650
059A6:  MOVFF  01,48
....................          enviar_tcp(); 
059AA:  RCALL  568C
059AC:  MOVLB  2
....................       }//end boton activado 
....................       /*else if( (en4==1)&&(cupo) ){ 
....................             lcd_gotoxy(1,2); 
....................             lcd_putc("     CUPO LLENO     "); 
....................       }*/ 
....................    }//verificacion boton 
.................... }//en boton ticket 
059AE:  MOVLB  0
059B0:  GOTO   6F4C (RETURN)
.................... ///////////////////// 
.................... /*if(en5!=input(entrada05) ){//SENSOR DE BARRERA ENTRADA 
....................    delay_ms(200); 
....................    if(en5!=input(entrada05) ){ 
....................       en5=input(entrada05); 
....................       if( (en5==0)&&(flag_pluma==0) ){ 
....................          espera_tcp(); 
....................          for(i=0;i<16;i++) tcp_XX[i]=barrera[i];//BARRERAABIERTAS2 
....................          size_tx_tcp=i; 
....................          enviar_tcp();//enviar a pc//avisar por tcp 
....................       } 
....................       else if(en5==1) flag_pluma=0; 
....................    } 
.................... }*/ 
.................... ///////////////////// 
.................... } 
.................... //EPSON 
.................... void ticket(){//U1PRINTER //HHMMSSFFFFFFFFZ 
....................    // 1-Direccion1 para Folio 
....................    // 2-Direccion2 para Folio 
....................    // 3-Direccion3 para Folio 
....................    //int cta_l,cta_m,cta_h; 
....................    char fol_bol[20]; 
....................    /*//leer 
....................    cta_l=read_ext_eeprom(3); 
....................    cta_m=read_ext_eeprom(2); 
....................    cta_h=read_ext_eeprom(1); 
....................    folio=0;//24bits 16,777,215 
....................    folio=cta_h;// 
....................    folio=(folio<<8)|cta_m; 
....................    folio=(folio<<8)|cta_l; 
....................    //fin de leer 
....................    folio++; 
....................    //printf("Total:%Ld\r\n",folio); 
....................    write_ext_eeprom(3,folio);//graba 
....................    write_ext_eeprom(2,folio>>8);//graba 
....................    write_ext_eeprom(1,folio>>16);//graba 
....................    */ 
....................    //////////////////////////////// 
....................    ds1307_get_date(day,month,yr,dow); 
....................    ds1307_get_time(hrs,min,sec); 
....................    ////////texto////// 
....................    //inicializa el envio de codigos esc/pos 
....................    fputc(27, U1PRINTER); 
*
05FD2:  MOVLW  1B
05FD4:  MOVLB  9
05FD6:  MOVWF  x13
05FD8:  MOVLB  0
05FDA:  RCALL  5B7E
....................    fputc('@', U1PRINTER); 
05FDC:  MOVLW  40
05FDE:  MOVLB  9
05FE0:  MOVWF  x13
05FE2:  MOVLB  0
05FE4:  RCALL  5B7E
....................    //linea de justificacion 1B "a" 0izquierda 1centrado 2derecha 
....................    fputc(27, U1PRINTER); 
05FE6:  MOVLW  1B
05FE8:  MOVLB  9
05FEA:  MOVWF  x13
05FEC:  MOVLB  0
05FEE:  RCALL  5B7E
....................    fputc(97, U1PRINTER); 
05FF0:  MOVLW  61
05FF2:  MOVLB  9
05FF4:  MOVWF  x13
05FF6:  MOVLB  0
05FF8:  RCALL  5B7E
....................    fputc(1, U1PRINTER); 
05FFA:  MOVLW  01
05FFC:  MOVLB  9
05FFE:  MOVWF  x13
06000:  MOVLB  0
06002:  RCALL  5B7E
....................    //////interlineado//////// 
....................    //fprintf(U1PRINTER,"\x1B"); 
....................    //fprintf(U1PRINTER,"3"); 
....................    fputc(27, U1PRINTER); 
06004:  MOVLW  1B
06006:  MOVLB  9
06008:  MOVWF  x13
0600A:  MOVLB  0
0600C:  RCALL  5B7E
....................    fputc(51, U1PRINTER); 
0600E:  MOVLW  33
06010:  MOVLB  9
06012:  MOVWF  x13
06014:  MOVLB  0
06016:  RCALL  5B7E
....................    fputc(40, U1PRINTER); 
06018:  MOVLW  28
0601A:  MOVLB  9
0601C:  MOVWF  x13
0601E:  MOVLB  0
06020:  RCALL  5B7E
....................    //////////// 
....................    /////negritas activas 
....................    fprintf(U1PRINTER,"\x1B"); 
06022:  MOVLW  1B
06024:  MOVLB  9
06026:  MOVWF  x13
06028:  MOVLB  0
0602A:  RCALL  5B7E
....................    fprintf(U1PRINTER,"G"); 
0602C:  MOVLW  47
0602E:  MOVLB  9
06030:  MOVWF  x13
06032:  MOVLB  0
06034:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\x01"); 
06036:  MOVLW  01
06038:  MOVLB  9
0603A:  MOVWF  x13
0603C:  MOVLB  0
0603E:  RCALL  5B7E
....................    /////Tipo de fuente 
....................    fprintf(U1PRINTER,"\x1B"); 
06040:  MOVLW  1B
06042:  MOVLB  9
06044:  MOVWF  x13
06046:  MOVLB  0
06048:  RCALL  5B7E
....................    fprintf(U1PRINTER,"!"); 
0604A:  MOVLW  21
0604C:  MOVLB  9
0604E:  MOVWF  x13
06050:  MOVLB  0
06052:  RCALL  5B7E
....................    fputc(1, U1PRINTER); 
06054:  MOVLW  01
06056:  MOVLB  9
06058:  MOVWF  x13
0605A:  MOVLB  0
0605C:  RCALL  5B7E
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
0605E:  MOVLW  1D
06060:  MOVLB  9
06062:  MOVWF  x13
06064:  MOVLB  0
06066:  RCALL  5B7E
....................    fprintf(U1PRINTER,"!"); 
06068:  MOVLW  21
0606A:  MOVLB  9
0606C:  MOVWF  x13
0606E:  MOVLB  0
06070:  RCALL  5B7E
....................    fputc(17, U1PRINTER); 
06072:  MOVLW  11
06074:  MOVLB  9
06076:  MOVWF  x13
06078:  MOVLB  0
0607A:  RCALL  5B7E
....................    //printf("\x0A");//limpia la justificación 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    memset(fol_bol, 0, sizeof(fol_bol)); 
0607C:  MOVLW  08
0607E:  MOVWF  FEA
06080:  MOVLW  F9
06082:  MOVWF  FE9
06084:  CLRF   00
06086:  CLRF   02
06088:  MOVLW  14
0608A:  MOVWF  01
0608C:  CALL   5728
....................    for(i=0;i<strlen(XX);i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
06090:  CLRF   41
06092:  CLRF   40
06094:  MOVLB  9
06096:  CLRF   x0F
06098:  MOVLW  52
0609A:  MOVWF  x0E
0609C:  MOVLB  0
0609E:  CALL   5650
060A2:  MOVFF  02,03
060A6:  MOVF   41,W
060A8:  SUBWF  02,W
060AA:  BNC   60EE
060AC:  BNZ   60B4
060AE:  MOVF   01,W
060B0:  SUBWF  40,W
060B2:  BC    60EE
060B4:  MOVLW  F9
060B6:  ADDWF  40,W
060B8:  MOVWF  01
060BA:  MOVLW  08
060BC:  ADDWFC 41,W
060BE:  MOVWF  03
060C0:  MOVFF  01,90D
060C4:  MOVLB  9
060C6:  MOVWF  x0E
060C8:  MOVLW  5C
060CA:  ADDWF  40,W
060CC:  MOVWF  FE9
060CE:  MOVLW  00
060D0:  ADDWFC 41,W
060D2:  MOVWF  FEA
060D4:  MOVFF  FEF,911
060D8:  MOVFF  03,FEA
060DC:  MOVFF  01,FE9
060E0:  MOVFF  911,FEF
060E4:  INCF   40,F
060E6:  BTFSC  FD8.2
060E8:  INCF   41,F
060EA:  BRA    6096
060EC:  MOVLB  0
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //folio = atoi32(fol_bol); 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    fprintf(U1PRINTER,"Folio:%s",fol_bol); 
060EE:  MOVLW  7A
060F0:  MOVWF  FF6
060F2:  MOVLW  03
060F4:  MOVWF  FF7
060F6:  MOVLW  06
060F8:  MOVLB  9
060FA:  MOVWF  x0D
060FC:  MOVLB  0
060FE:  RCALL  5B8E
06100:  MOVLW  08
06102:  MOVWF  FEA
06104:  MOVLW  F9
06106:  MOVWF  FE9
06108:  RCALL  5BB6
....................    strcpy(barra_codi,fol_bol); 
0610A:  MOVLW  02
0610C:  MOVWF  FEA
0610E:  MOVLW  4E
06110:  MOVWF  FE9
06112:  MOVLW  08
06114:  MOVWF  FE2
06116:  MOVLW  F9
06118:  MOVWF  FE1
0611A:  MOVF   FE7,F
0611C:  MOVFF  FE6,FEE
06120:  BNZ   611A
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06122:  MOVLW  0A
06124:  MOVLB  9
06126:  MOVWF  x13
06128:  MOVLB  0
0612A:  RCALL  5B7E
....................    LF(); 
0612C:  RCALL  5BDA
....................    /////////////////////////////////////////////////////////// 
....................    //fprintf(U1PRINTER,"MARIA TERESA BAEZ MONROY"); 
....................    fprintf(U1PRINTER,"PLAZA COMERCIAL 4 y 13"); 
0612E:  MOVLW  84
06130:  MOVWF  FF6
06132:  MOVLW  03
06134:  MOVWF  FF7
06136:  RCALL  5BE6
....................    //printf("\x0A");//limpia la justificación  
....................    ////desactiva negritas 
....................    fprintf(U1PRINTER,"\x1B"); 
06138:  MOVLW  1B
0613A:  MOVLB  9
0613C:  MOVWF  x13
0613E:  MOVLB  0
06140:  RCALL  5B7E
....................    fprintf(U1PRINTER,"G"); 
06142:  MOVLW  47
06144:  MOVLB  9
06146:  MOVWF  x13
06148:  MOVLB  0
0614A:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\x00"); 
....................    /////////////////////////////////////////////////////////// 
....................    LF(); 
0614C:  RCALL  5BDA
....................    LF(); 
0614E:  RCALL  5BDA
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
06150:  MOVLW  1D
06152:  MOVLB  9
06154:  MOVWF  x13
06156:  MOVLB  0
06158:  RCALL  5B7E
....................    fprintf(U1PRINTER,"!"); 
0615A:  MOVLW  21
0615C:  MOVLB  9
0615E:  MOVWF  x13
06160:  MOVLB  0
06162:  RCALL  5B7E
....................    fputc(0, U1PRINTER); 
06164:  MOVLB  9
06166:  CLRF   x13
06168:  MOVLB  0
0616A:  RCALL  5B7E
....................    ///// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0616C:  MOVLW  0A
0616E:  MOVLB  9
06170:  MOVWF  x13
06172:  MOVLB  0
06174:  RCALL  5B7E
....................    fprintf(U1PRINTER,"RFC:BAMT97052884A\x0A"); 
06176:  MOVLW  9C
06178:  MOVWF  FF6
0617A:  MOVLW  03
0617C:  MOVWF  FF7
0617E:  RCALL  5BE6
....................    fprintf(U1PRINTER,"4 poniente 1302, colonia Centro  CP 72000\x0APuebla, Puebla\x0A"); 
06180:  MOVLW  B0
06182:  MOVWF  FF6
06184:  MOVLW  03
06186:  MOVWF  FF7
06188:  RCALL  5BE6
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
0618A:  MOVLW  1D
0618C:  MOVLB  9
0618E:  MOVWF  x13
06190:  MOVLB  0
06192:  RCALL  5B7E
....................    fprintf(U1PRINTER,"!"); 
06194:  MOVLW  21
06196:  MOVLB  9
06198:  MOVWF  x13
0619A:  MOVLB  0
0619C:  RCALL  5B7E
....................    fputc(17, U1PRINTER); 
0619E:  MOVLW  11
061A0:  MOVLB  9
061A2:  MOVWF  x13
061A4:  MOVLB  0
061A6:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
061A8:  MOVLW  0A
061AA:  MOVLB  9
061AC:  MOVWF  x13
061AE:  MOVLB  0
061B0:  RCALL  5B7E
....................    fprintf(U1PRINTER,"%02d/%02d/20%02d %02d:%02d:%02d",day,month,yr,hrs,min,sec); 
061B2:  MOVFF  270,90D
061B6:  MOVLW  01
061B8:  MOVLB  9
061BA:  MOVWF  x0E
061BC:  MOVLB  0
061BE:  RCALL  5C06
061C0:  MOVLW  2F
061C2:  MOVLB  9
061C4:  MOVWF  x13
061C6:  MOVLB  0
061C8:  RCALL  5B7E
061CA:  MOVFF  271,90D
061CE:  MOVLW  01
061D0:  MOVLB  9
061D2:  MOVWF  x0E
061D4:  MOVLB  0
061D6:  RCALL  5C06
061D8:  MOVLW  F3
061DA:  MOVWF  FF6
061DC:  MOVLW  03
061DE:  MOVWF  FF7
061E0:  MOVLW  03
061E2:  MOVLB  9
061E4:  MOVWF  x0D
061E6:  MOVLB  0
061E8:  RCALL  5B8E
061EA:  MOVFF  272,90D
061EE:  MOVLW  01
061F0:  MOVLB  9
061F2:  MOVWF  x0E
061F4:  MOVLB  0
061F6:  RCALL  5C06
061F8:  MOVLW  20
061FA:  MOVLB  9
061FC:  MOVWF  x13
061FE:  MOVLB  0
06200:  RCALL  5B7E
06202:  MOVFF  273,90D
06206:  MOVLW  01
06208:  MOVLB  9
0620A:  MOVWF  x0E
0620C:  MOVLB  0
0620E:  RCALL  5C06
06210:  MOVLW  3A
06212:  MOVLB  9
06214:  MOVWF  x13
06216:  MOVLB  0
06218:  RCALL  5B7E
0621A:  MOVFF  274,90D
0621E:  MOVLW  01
06220:  MOVLB  9
06222:  MOVWF  x0E
06224:  MOVLB  0
06226:  RCALL  5C06
06228:  MOVLW  3A
0622A:  MOVLB  9
0622C:  MOVWF  x13
0622E:  MOVLB  0
06230:  RCALL  5B7E
06232:  MOVFF  275,90D
06236:  MOVLW  01
06238:  MOVLB  9
0623A:  MOVWF  x0E
0623C:  MOVLB  0
0623E:  RCALL  5C06
....................    LF(); 
06240:  RCALL  5BDA
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
06242:  MOVLW  1D
06244:  MOVLB  9
06246:  MOVWF  x13
06248:  MOVLB  0
0624A:  RCALL  5B7E
....................    fprintf(U1PRINTER,"!"); 
0624C:  MOVLW  21
0624E:  MOVLB  9
06250:  MOVWF  x13
06252:  MOVLB  0
06254:  RCALL  5B7E
....................    fputc(0, U1PRINTER); 
06256:  MOVLB  9
06258:  CLRF   x13
0625A:  MOVLB  0
0625C:  RCALL  5B7E
....................    ///// 
....................    barra1(); 
0625E:  BRA    5CC6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06260:  MOVLW  0A
06262:  MOVLB  9
06264:  MOVWF  x13
06266:  MOVLB  0
06268:  RCALL  5B7E
....................    fprintf(U1PRINTER,"TARIFA:$17 Hora o Fraccion                     \x0A"); 
0626A:  MOVLW  0A
0626C:  MOVWF  FF6
0626E:  MOVLW  04
06270:  MOVWF  FF7
06272:  RCALL  5BE6
....................    fprintf(U1PRINTER,"TOLERANCIA:5 min. la primera hora              \x0A"); 
06274:  MOVLW  3C
06276:  MOVWF  FF6
06278:  MOVLW  04
0627A:  MOVWF  FF7
0627C:  RCALL  5BE6
....................    fprintf(U1PRINTER,"Horarios:de 7:00 a 21:00hrs. de lunes a viernes\x0A"); 
0627E:  MOVLW  6E
06280:  MOVWF  FF6
06282:  MOVLW  04
06284:  MOVWF  FF7
06286:  RCALL  5BE6
....................    fprintf(U1PRINTER,"Sabado   de 8:00 a 20:00hrs.                   \x0A"); 
06288:  MOVLW  A0
0628A:  MOVWF  FF6
0628C:  MOVLW  04
0628E:  MOVWF  FF7
06290:  RCALL  5BE6
....................    fprintf(U1PRINTER,"Domingo  de 8:00 a 19:00hrs.                   \x0A"); 
06292:  MOVLW  D2
06294:  MOVWF  FF6
06296:  MOVLW  04
06298:  MOVWF  FF7
0629A:  RCALL  5BE6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0629C:  MOVLW  0A
0629E:  MOVLB  9
062A0:  MOVWF  x13
062A2:  MOVLB  0
062A4:  RCALL  5B7E
....................    //////////////////// 
....................    barra2(); 
062A6:  BRA    5D74
....................    //////////////////// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
062A8:  MOVLW  0A
062AA:  MOVLB  9
062AC:  MOVWF  x13
062AE:  MOVLB  0
062B0:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
062B2:  MOVLW  0A
062B4:  MOVLB  9
062B6:  MOVWF  x13
062B8:  MOVLB  0
062BA:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\"ACCESA\" automatizacion "); 
062BC:  MOVLW  04
062BE:  MOVWF  FF6
062C0:  MOVLW  05
062C2:  MOVWF  FF7
062C4:  RCALL  5BE6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
062C6:  MOVLW  0A
062C8:  MOVLB  9
062CA:  MOVWF  x13
062CC:  MOVLB  0
062CE:  RCALL  5B7E
....................    fprintf(U1PRINTER,"www.accesa.me  automatizacion@accesa.me"); 
062D0:  MOVLW  1E
062D2:  MOVWF  FF6
062D4:  MOVLW  05
062D6:  MOVWF  FF7
062D8:  RCALL  5BE6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
062DA:  MOVLW  0A
062DC:  MOVLB  9
062DE:  MOVWF  x13
062E0:  MOVLB  0
062E2:  RCALL  5B7E
....................    /////////feed para corte de papel////////////// 
....................    fprintf(U1PRINTER,"\x1B"); 
062E4:  MOVLW  1B
062E6:  MOVLB  9
062E8:  MOVWF  x13
062EA:  MOVLB  0
062EC:  RCALL  5B7E
....................    fprintf(U1PRINTER,"J"); 
062EE:  MOVLW  4A
062F0:  MOVLB  9
062F2:  MOVWF  x13
062F4:  MOVLB  0
062F6:  RCALL  5B7E
....................    //fputc(190, U1PRINTER); 
....................    fputc(250, U1PRINTER); 
062F8:  MOVLW  FA
062FA:  MOVLB  9
062FC:  MOVWF  x13
062FE:  MOVLB  0
06300:  RCALL  5B7E
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación  
06302:  MOVLW  0A
06304:  MOVLB  9
06306:  MOVWF  x13
06308:  MOVLB  0
0630A:  RCALL  5B7E
....................    LF(); 
0630C:  RCALL  5BDA
....................    ///////// 
....................    //ESC i 69 Corte total de papel 
....................    //ESC m 6D Corte parcial de papel 
....................    fprintf(U1PRINTER,"\x1B"); 
0630E:  MOVLW  1B
06310:  MOVLB  9
06312:  MOVWF  x13
06314:  MOVLB  0
06316:  RCALL  5B7E
....................    fprintf(U1PRINTER,"m"); 
06318:  MOVLW  6D
0631A:  MOVLB  9
0631C:  MOVWF  x13
0631E:  MOVLB  0
06320:  RCALL  5B7E
06322:  GOTO   701E (RETURN)
....................    //////////////////////////////////////// 
.................... } 
....................  
.................... void LF(){ 
.................... fprintf(U1PRINTER,"\x0A"); 
*
05BDA:  MOVLW  0A
05BDC:  MOVLB  9
05BDE:  MOVWF  x13
05BE0:  MOVLB  0
05BE2:  RCALL  5B7E
05BE4:  RETURN 0
.................... } 
....................  
.................... void CR(){ 
.................... fprintf(U1PRINTER,"\x0D");//enter 
.................... } 
....................  
.................... void barra1(){ 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d",folio,yr,month,day,hrs,min,sec);// 
....................    //sprintf(con_barra,"%08Ld%d",folio,idbar);//01-id de camion 
....................     
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //fprintf(U1PRINTER,"%08Ld/%02d/%02d/%02d/%02d/%02d/%02d/%d/",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi)+2; 
*
05CC6:  MOVLW  02
05CC8:  MOVLB  9
05CCA:  MOVWF  x0F
05CCC:  MOVLW  4E
05CCE:  MOVWF  x0E
05CD0:  MOVLB  0
05CD2:  RCALL  5650
05CD4:  MOVLW  02
05CD6:  MOVLB  9
05CD8:  ADDWF  01,W
05CDA:  MOVWF  x0D
....................    //printf (lcd_putc,"\fsize_bar:%u",size_bar); 
....................    //delay_ms(2000); 
.................... //////bar code/////// 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05CDC:  MOVLW  46
05CDE:  MOVWF  FF6
05CE0:  MOVLW  05
05CE2:  MOVWF  FF7
05CE4:  MOVLB  0
05CE6:  RCALL  5BE6
....................    fprintf(U1PRINTER,"\x1D\x77\x01");// 
05CE8:  MOVLW  4A
05CEA:  MOVWF  FF6
05CEC:  MOVLW  05
05CEE:  MOVWF  FF7
05CF0:  RCALL  5BE6
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05CF2:  MOVLW  1D
05CF4:  MOVLB  9
05CF6:  MOVWF  x13
05CF8:  MOVLB  0
05CFA:  RCALL  5B7E
....................    fputc(72,U1PRINTER);// 
05CFC:  MOVLW  48
05CFE:  MOVLB  9
05D00:  MOVWF  x13
05D02:  MOVLB  0
05D04:  RCALL  5B7E
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05D06:  MOVLW  02
05D08:  MOVLB  9
05D0A:  MOVWF  x13
05D0C:  MOVLB  0
05D0E:  RCALL  5B7E
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05D10:  MOVLW  1D
05D12:  MOVLB  9
05D14:  MOVWF  x13
05D16:  MOVLB  0
05D18:  RCALL  5B7E
....................    fputc(102,U1PRINTER);// 
05D1A:  MOVLW  66
05D1C:  MOVLB  9
05D1E:  MOVWF  x13
05D20:  MOVLB  0
05D22:  RCALL  5B7E
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05D24:  MOVLW  01
05D26:  MOVLB  9
05D28:  MOVWF  x13
05D2A:  MOVLB  0
05D2C:  RCALL  5B7E
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05D2E:  MOVLW  1D
05D30:  MOVLB  9
05D32:  MOVWF  x13
05D34:  MOVLB  0
05D36:  RCALL  5B7E
....................    fputc('k',U1PRINTER); 
05D38:  MOVLW  6B
05D3A:  MOVLB  9
05D3C:  MOVWF  x13
05D3E:  MOVLB  0
05D40:  RCALL  5B7E
....................    fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
05D42:  MOVLW  49
05D44:  MOVLB  9
05D46:  MOVWF  x13
05D48:  MOVLB  0
05D4A:  RCALL  5B7E
....................    //fputc(23,U1PRINTER); //numero de caracteres+2 (solo code128) 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05D4C:  MOVFF  90D,913
05D50:  RCALL  5B7E
....................    fputc(123,U1PRINTER);// d1 (solo code128) 
05D52:  MOVLW  7B
05D54:  MOVLB  9
05D56:  MOVWF  x13
05D58:  MOVLB  0
05D5A:  RCALL  5B7E
....................    fputc(65,U1PRINTER); // d2 (solo code128) 
05D5C:  MOVLW  41
05D5E:  MOVLB  9
05D60:  MOVWF  x13
05D62:  MOVLB  0
05D64:  RCALL  5B7E
....................     
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05D66:  MOVLW  02
05D68:  MOVWF  FEA
05D6A:  MOVLW  4E
05D6C:  MOVWF  FE9
05D6E:  RCALL  5BB6
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05D70:  GOTO   6260 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void barra2(){ 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi); 
05D74:  MOVLW  02
05D76:  MOVLB  9
05D78:  MOVWF  x0F
05D7A:  MOVLW  4E
05D7C:  MOVWF  x0E
05D7E:  MOVLB  0
05D80:  RCALL  5650
05D82:  MOVFF  01,90D
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    //CODIGO DE BARRAS 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05D86:  MOVLW  4E
05D88:  MOVWF  FF6
05D8A:  MOVLW  05
05D8C:  MOVWF  FF7
05D8E:  RCALL  5BE6
....................    fprintf(U1PRINTER,"\x1D\x77\x01");//setea ancho 
05D90:  MOVLW  52
05D92:  MOVWF  FF6
05D94:  MOVLW  05
05D96:  MOVWF  FF7
05D98:  RCALL  5BE6
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05D9A:  MOVLW  1D
05D9C:  MOVLB  9
05D9E:  MOVWF  x13
05DA0:  MOVLB  0
05DA2:  RCALL  5B7E
....................    fputc(72,U1PRINTER);// 
05DA4:  MOVLW  48
05DA6:  MOVLB  9
05DA8:  MOVWF  x13
05DAA:  MOVLB  0
05DAC:  RCALL  5B7E
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05DAE:  MOVLW  02
05DB0:  MOVLB  9
05DB2:  MOVWF  x13
05DB4:  MOVLB  0
05DB6:  RCALL  5B7E
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05DB8:  MOVLW  1D
05DBA:  MOVLB  9
05DBC:  MOVWF  x13
05DBE:  MOVLB  0
05DC0:  RCALL  5B7E
....................    fputc(102,U1PRINTER);// 
05DC2:  MOVLW  66
05DC4:  MOVLB  9
05DC6:  MOVWF  x13
05DC8:  MOVLB  0
05DCA:  RCALL  5B7E
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05DCC:  MOVLW  01
05DCE:  MOVLB  9
05DD0:  MOVWF  x13
05DD2:  MOVLB  0
05DD4:  RCALL  5B7E
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05DD6:  MOVLW  1D
05DD8:  MOVLB  9
05DDA:  MOVWF  x13
05DDC:  MOVLB  0
05DDE:  RCALL  5B7E
....................    fputc('k',U1PRINTER); 
05DE0:  MOVLW  6B
05DE2:  MOVLB  9
05DE4:  MOVWF  x13
05DE6:  MOVLB  0
05DE8:  RCALL  5B7E
....................    fputc(69,U1PRINTER);//69=code39//72=code93//73=code128//70=ITF(solo cantidades pares)// 
05DEA:  MOVLW  45
05DEC:  MOVLB  9
05DEE:  MOVWF  x13
05DF0:  MOVLB  0
05DF2:  RCALL  5B7E
....................    //fputc(21,U1PRINTER);//numero de caracteres 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05DF4:  MOVFF  90D,913
05DF8:  RCALL  5B7E
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05DFA:  MOVLW  02
05DFC:  MOVWF  FEA
05DFE:  MOVLW  4E
05E00:  MOVWF  FE9
05E02:  RCALL  5BB6
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05E04:  GOTO   62A8 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void encri(){ 
....................  int tem; 
....................  //fprintf(U1PRINTER,"con_barra:%Lu\r\n",strlen(con_barra)); 
....................   
....................  for(tem=0;tem<=strlen(con_barra);tem++){ 
....................          if(con_barra[tem]=='0') barra_codi[tem]='5'; 
....................     else if(con_barra[tem]=='1') barra_codi[tem]='7'; 
....................     else if(con_barra[tem]=='2') barra_codi[tem]='8'; 
....................     else if(con_barra[tem]=='3') barra_codi[tem]='2'; 
....................     else if(con_barra[tem]=='4') barra_codi[tem]='9'; 
....................     else if(con_barra[tem]=='5') barra_codi[tem]='0'; 
....................     else if(con_barra[tem]=='6') barra_codi[tem]='6'; 
....................     else if(con_barra[tem]=='7') barra_codi[tem]='4'; 
....................     else if(con_barra[tem]=='8') barra_codi[tem]='1'; 
....................     else if(con_barra[tem]=='9') barra_codi[tem]='3'; 
....................  }//end for 
.................... } 
....................  
.................... ///////////////////// 
.................... void llaves(){ 
....................    int tem; 
....................    char texto[12]; 
....................    ////////////////llaves//////////// 
....................    ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
*
00766:  MOVLW  01
00768:  MOVLB  8
0076A:  MOVWF  xF9
0076C:  MOVF   xF9,W
0076E:  SUBLW  0E
00770:  BTFSS  FD8.0
00772:  BRA    0A2E
....................       switch (tem) { 
00774:  MOVLW  01
00776:  SUBWF  xF9,W
00778:  ADDLW  F2
0077A:  BTFSC  FD8.0
0077C:  BRA    092C
0077E:  ADDLW  0E
00780:  MOVLB  0
00782:  GOTO   0A34
....................            case 1: {// 
....................                strcpy(texto,texto1); 
00786:  MOVLW  08
00788:  MOVWF  FEA
0078A:  MOVLW  FA
0078C:  MOVWF  FE9
0078E:  MOVLW  02
00790:  MOVWF  FE2
00792:  MOVLW  8D
00794:  MOVWF  FE1
00796:  MOVF   FE7,F
00798:  MOVFF  FE6,FEE
0079C:  BNZ   0796
....................                break;} 
0079E:  MOVLB  8
007A0:  BRA    092C
007A2:  MOVLB  0
....................            case 2: {// 
....................                strcpy(texto,texto2); 
007A4:  MOVLW  08
007A6:  MOVWF  FEA
007A8:  MOVLW  FA
007AA:  MOVWF  FE9
007AC:  MOVLW  02
007AE:  MOVWF  FE2
007B0:  MOVLW  99
007B2:  MOVWF  FE1
007B4:  MOVF   FE7,F
007B6:  MOVFF  FE6,FEE
007BA:  BNZ   07B4
....................                break;} 
007BC:  MOVLB  8
007BE:  BRA    092C
007C0:  MOVLB  0
....................            case 3: {// 
....................                strcpy(texto,texto3); 
007C2:  MOVLW  08
007C4:  MOVWF  FEA
007C6:  MOVLW  FA
007C8:  MOVWF  FE9
007CA:  MOVLW  02
007CC:  MOVWF  FE2
007CE:  MOVLW  A5
007D0:  MOVWF  FE1
007D2:  MOVF   FE7,F
007D4:  MOVFF  FE6,FEE
007D8:  BNZ   07D2
....................                break;} 
007DA:  MOVLB  8
007DC:  BRA    092C
007DE:  MOVLB  0
....................            case 4: {// 
....................                strcpy(texto,texto4); 
007E0:  MOVLW  08
007E2:  MOVWF  FEA
007E4:  MOVLW  FA
007E6:  MOVWF  FE9
007E8:  MOVLW  02
007EA:  MOVWF  FE2
007EC:  MOVLW  B1
007EE:  MOVWF  FE1
007F0:  MOVF   FE7,F
007F2:  MOVFF  FE6,FEE
007F6:  BNZ   07F0
....................                break;} 
007F8:  MOVLB  8
007FA:  BRA    092C
007FC:  MOVLB  0
....................            case 5: {// 
....................                strcpy(texto,texto5); 
007FE:  MOVLW  08
00800:  MOVWF  FEA
00802:  MOVLW  FA
00804:  MOVWF  FE9
00806:  MOVLW  02
00808:  MOVWF  FE2
0080A:  MOVLW  BD
0080C:  MOVWF  FE1
0080E:  MOVF   FE7,F
00810:  MOVFF  FE6,FEE
00814:  BNZ   080E
....................                break;} 
00816:  MOVLB  8
00818:  BRA    092C
0081A:  MOVLB  0
....................            case 6: {// 
....................                strcpy(texto,texto6); 
0081C:  MOVLW  08
0081E:  MOVWF  FEA
00820:  MOVLW  FA
00822:  MOVWF  FE9
00824:  MOVLW  02
00826:  MOVWF  FE2
00828:  MOVLW  C9
0082A:  MOVWF  FE1
0082C:  MOVF   FE7,F
0082E:  MOVFF  FE6,FEE
00832:  BNZ   082C
....................                break;} 
00834:  MOVLB  8
00836:  BRA    092C
00838:  MOVLB  0
....................            case 7: {// 
....................                strcpy(texto,texto7); 
0083A:  MOVLW  08
0083C:  MOVWF  FEA
0083E:  MOVLW  FA
00840:  MOVWF  FE9
00842:  MOVLW  02
00844:  MOVWF  FE2
00846:  MOVLW  D5
00848:  MOVWF  FE1
0084A:  MOVF   FE7,F
0084C:  MOVFF  FE6,FEE
00850:  BNZ   084A
....................                break;} 
00852:  MOVLB  8
00854:  BRA    092C
00856:  MOVLB  0
....................            case 8: {// 
....................                strcpy(texto,texto8); 
00858:  MOVLW  08
0085A:  MOVWF  FEA
0085C:  MOVLW  FA
0085E:  MOVWF  FE9
00860:  MOVLW  02
00862:  MOVWF  FE2
00864:  MOVLW  E1
00866:  MOVWF  FE1
00868:  MOVF   FE7,F
0086A:  MOVFF  FE6,FEE
0086E:  BNZ   0868
....................                break;} 
00870:  MOVLB  8
00872:  BRA    092C
00874:  MOVLB  0
....................            case 9: {// 
....................                strcpy(texto,texto9); 
00876:  MOVLW  08
00878:  MOVWF  FEA
0087A:  MOVLW  FA
0087C:  MOVWF  FE9
0087E:  MOVLW  02
00880:  MOVWF  FE2
00882:  MOVLW  ED
00884:  MOVWF  FE1
00886:  MOVF   FE7,F
00888:  MOVFF  FE6,FEE
0088C:  BNZ   0886
....................                break;} 
0088E:  MOVLB  8
00890:  BRA    092C
00892:  MOVLB  0
....................            case 10: {// 
....................                strcpy(texto,texto10); 
00894:  MOVLW  08
00896:  MOVWF  FEA
00898:  MOVLW  FA
0089A:  MOVWF  FE9
0089C:  MOVLW  02
0089E:  MOVWF  FE2
008A0:  MOVLW  F9
008A2:  MOVWF  FE1
008A4:  MOVF   FE7,F
008A6:  MOVFF  FE6,FEE
008AA:  BNZ   08A4
....................                break;} 
008AC:  MOVLB  8
008AE:  BRA    092C
008B0:  MOVLB  0
....................            case 11: {// 
....................                strcpy(texto,texto11); 
008B2:  MOVLW  08
008B4:  MOVWF  FEA
008B6:  MOVLW  FA
008B8:  MOVWF  FE9
008BA:  MOVLW  03
008BC:  MOVWF  FE2
008BE:  MOVLW  05
008C0:  MOVWF  FE1
008C2:  MOVF   FE7,F
008C4:  MOVFF  FE6,FEE
008C8:  BNZ   08C2
....................                break;} 
008CA:  MOVLB  8
008CC:  BRA    092C
008CE:  MOVLB  0
....................            case 12: {// 
....................                strcpy(texto,texto12); 
008D0:  MOVLW  08
008D2:  MOVWF  FEA
008D4:  MOVLW  FA
008D6:  MOVWF  FE9
008D8:  MOVLW  03
008DA:  MOVWF  FE2
008DC:  MOVLW  11
008DE:  MOVWF  FE1
008E0:  MOVF   FE7,F
008E2:  MOVFF  FE6,FEE
008E6:  BNZ   08E0
....................                break;} 
008E8:  MOVLB  8
008EA:  BRA    092C
008EC:  MOVLB  0
....................            case 13: {// 
....................                strcpy(texto,texto13); 
008EE:  MOVLW  08
008F0:  MOVWF  FEA
008F2:  MOVLW  FA
008F4:  MOVWF  FE9
008F6:  MOVLW  03
008F8:  MOVWF  FE2
008FA:  MOVLW  1D
008FC:  MOVWF  FE1
008FE:  MOVF   FE7,F
00900:  MOVFF  FE6,FEE
00904:  BNZ   08FE
....................                break;} 
00906:  MOVLB  8
00908:  BRA    092C
0090A:  MOVLB  0
....................            case 14: {// 
....................                strcpy(texto,texto14); 
0090C:  MOVLW  08
0090E:  MOVWF  FEA
00910:  MOVLW  FA
00912:  MOVWF  FE9
00914:  MOVLW  03
00916:  MOVWF  FE2
00918:  MOVLW  29
0091A:  MOVWF  FE1
0091C:  MOVF   FE7,F
0091E:  MOVFF  FE6,FEE
00922:  BNZ   091C
....................                break;} 
00924:  MOVLB  8
00926:  BRA    092C
00928:  MOVLB  0
0092A:  MOVLB  8
....................       } 
....................       a=i=0; 
0092C:  CLRF   41
0092E:  CLRF   40
00930:  MOVFF  40,1B
....................       while (i < instruccion_size) {  //word_size=8 
00934:  MOVF   41,F
00936:  BNZ   09B8
00938:  MOVF   40,W
0093A:  SUBLW  09
0093C:  BNC   09B8
....................            memory[i] = read_eeprom( (tem*instruccion_size)+i); 
0093E:  MOVLW  22
00940:  ADDWF  40,W
00942:  MOVWF  FE9
00944:  MOVLW  00
00946:  ADDWFC 41,W
00948:  MOVWF  FEA
0094A:  MOVF   xF9,W
0094C:  MULLW  0A
0094E:  MOVF   FF3,W
00950:  ADDWF  40,W
00952:  MOVLB  9
00954:  MOVWF  x08
00956:  MOVLW  00
00958:  ADDWFC 41,W
0095A:  MOVWF  x09
0095C:  MOVFF  FF2,90A
00960:  BCF    FF2.7
00962:  MOVFF  909,FAA
00966:  MOVFF  908,FA9
0096A:  BCF    FA6.6
0096C:  BCF    FA6.7
0096E:  BSF    FA6.0
00970:  MOVF   FA8,W
00972:  BTFSC  x0A.7
00974:  BSF    FF2.7
00976:  MOVWF  FEF
....................            if (memory[i] != texto[i])  break; 
00978:  MOVLW  22
0097A:  ADDWF  40,W
0097C:  MOVWF  FE9
0097E:  MOVLW  00
00980:  ADDWFC 41,W
00982:  MOVWF  FEA
00984:  MOVFF  FEF,906
00988:  MOVLW  FA
0098A:  ADDWF  40,W
0098C:  MOVWF  FE9
0098E:  MOVLW  08
00990:  ADDWFC 41,W
00992:  MOVWF  FEA
00994:  MOVF   FEF,W
00996:  SUBWF  x06,W
00998:  BZ    09A0
0099A:  MOVLB  8
0099C:  BRA    09B8
0099E:  MOVLB  9
....................            i++; 
009A0:  INCF   40,F
009A2:  BTFSC  FD8.2
009A4:  INCF   41,F
....................            if (i==instruccion_size) a=1; 
009A6:  MOVF   40,W
009A8:  SUBLW  0A
009AA:  BNZ   09B4
009AC:  MOVF   41,F
009AE:  BNZ   09B4
009B0:  MOVLW  01
009B2:  MOVWF  1B
009B4:  MOVLB  8
009B6:  BRA    0934
....................       } 
....................       //fprintf(U1PRINTER,"\r\n"); 
....................       if (a==0){ 
009B8:  MOVF   1B,F
009BA:  BNZ   0A2A
....................          i=0; 
009BC:  CLRF   41
009BE:  CLRF   40
....................          while (texto[i] != 0x00){ 
009C0:  MOVLW  FA
009C2:  ADDWF  40,W
009C4:  MOVWF  FE9
009C6:  MOVLW  08
009C8:  ADDWFC 41,W
009CA:  MOVWF  FEA
009CC:  MOVF   FEF,F
009CE:  BZ    0A2A
....................             write_eeprom(i+(tem*instruccion_size),texto[i]); 
009D0:  MOVF   xF9,W
009D2:  MULLW  0A
009D4:  MOVF   FF3,W
009D6:  ADDWF  40,W
009D8:  MOVLB  9
009DA:  MOVWF  x06
009DC:  MOVLW  00
009DE:  ADDWFC 41,W
009E0:  MOVWF  x07
009E2:  MOVLW  FA
009E4:  ADDWF  40,W
009E6:  MOVWF  FE9
009E8:  MOVLW  08
009EA:  ADDWFC 41,W
009EC:  MOVWF  FEA
009EE:  MOVFF  FEF,908
009F2:  MOVF   FF2,W
009F4:  MOVWF  00
009F6:  BCF    FF2.7
009F8:  MOVFF  907,FAA
009FC:  MOVFF  906,FA9
00A00:  MOVFF  908,FA8
00A04:  BCF    FA6.6
00A06:  BCF    FA6.7
00A08:  BSF    FA6.2
00A0A:  MOVLB  F
00A0C:  MOVLW  55
00A0E:  MOVWF  FA7
00A10:  MOVLW  AA
00A12:  MOVWF  FA7
00A14:  BSF    FA6.1
00A16:  BTFSC  FA6.1
00A18:  BRA    0A16
00A1A:  BCF    FA6.2
00A1C:  MOVF   00,W
00A1E:  IORWF  FF2,F
....................             //fprintf(U1PRINTER,"%c",texto[i]); 
....................             i++; 
00A20:  INCF   40,F
00A22:  BTFSC  FD8.2
00A24:  INCF   41,F
00A26:  MOVLB  8
00A28:  BRA    09C0
....................          }//end grabar 
....................       }//END a 
00A2A:  INCF   xF9,F
00A2C:  BRA    076C
....................    }//end for 
00A2E:  MOVLB  0
00A30:  GOTO   6CCE (RETURN)
.................... } 
....................  
.................... void rd_eeprom(){ 
.................... n=a=b=0; 
*
059B4:  CLRF   45
059B6:  CLRF   44
059B8:  MOVFF  44,1B
059BC:  CLRF   43
059BE:  MOVFF  1B,42
.................... n=instruccion_size;// 
059C2:  CLRF   43
059C4:  MOVLW  0A
059C6:  MOVWF  42
.................... i=0; 
059C8:  CLRF   41
059CA:  CLRF   40
.................... while ((b <=data_numbers)&&(a==0)){//NUMERO TOTAL DE TARJETAS 
059CC:  MOVF   45,F
059CE:  BNZ   5A70
059D0:  MOVF   44,W
059D2:  SUBLW  0E
059D4:  BNC   5A70
059D6:  MOVF   1B,F
059D8:  BNZ   5A70
....................     i=0; 
059DA:  CLRF   41
059DC:  CLRF   40
....................     b++; 
059DE:  INCF   44,F
059E0:  BTFSC  FD8.2
059E2:  INCF   45,F
....................     while (i < instruccion_size) {//WORD_SIZE_2=10 
059E4:  MOVF   41,F
059E6:  BNZ   5A64
059E8:  MOVF   40,W
059EA:  SUBLW  09
059EC:  BNC   5A64
....................         memory[i] = read_eeprom(n+i); 
059EE:  MOVLW  22
059F0:  ADDWF  40,W
059F2:  MOVWF  FE9
059F4:  MOVLW  00
059F6:  ADDWFC 41,W
059F8:  MOVWF  FEA
059FA:  MOVF   40,W
059FC:  ADDWF  42,W
059FE:  MOVLB  8
05A00:  MOVWF  xFB
05A02:  MOVF   41,W
05A04:  ADDWFC 43,W
05A06:  MOVWF  xFC
05A08:  MOVFF  FF2,8FD
05A0C:  BCF    FF2.7
05A0E:  MOVFF  8FC,FAA
05A12:  MOVFF  8FB,FA9
05A16:  BCF    FA6.6
05A18:  BCF    FA6.7
05A1A:  BSF    FA6.0
05A1C:  MOVF   FA8,W
05A1E:  BTFSC  xFD.7
05A20:  BSF    FF2.7
05A22:  MOVWF  FEF
....................         //fprintf(U1PRINTER,"m[%Ld]=%c",i,memory[i]); 
....................         //fprintf(U1PRINTER,"X[%Ld]=%c",i,XX[i]); 
....................         if (memory[i] != XX[i]) 
05A24:  MOVLW  22
05A26:  ADDWF  40,W
05A28:  MOVWF  FE9
05A2A:  MOVLW  00
05A2C:  ADDWFC 41,W
05A2E:  MOVWF  FEA
05A30:  MOVFF  FEF,8F9
05A34:  MOVLW  52
05A36:  ADDWF  40,W
05A38:  MOVWF  FE9
05A3A:  MOVLW  00
05A3C:  ADDWFC 41,W
05A3E:  MOVWF  FEA
05A40:  MOVF   FEF,W
05A42:  SUBWF  xF9,W
05A44:  BZ    5A4C
....................             break; 
05A46:  MOVLB  0
05A48:  BRA    5A64
05A4A:  MOVLB  8
....................         i++; 
05A4C:  INCF   40,F
05A4E:  BTFSC  FD8.2
05A50:  INCF   41,F
....................         if (i==instruccion_size) a=1; 
05A52:  MOVF   40,W
05A54:  SUBLW  0A
05A56:  BNZ   5A60
05A58:  MOVF   41,F
05A5A:  BNZ   5A60
05A5C:  MOVLW  01
05A5E:  MOVWF  1B
05A60:  MOVLB  0
05A62:  BRA    59E4
....................     } 
....................     //fprintf(PRINTER," \r\n"); 
....................     //fprintf(PRINTER," n=%Ld ",n); 
....................     n=n+instruccion_size;//WORD_SIZE=30 
05A64:  MOVLW  0A
05A66:  ADDWF  42,F
05A68:  MOVLW  00
05A6A:  ADDWFC 43,F
....................     restart_wdt(); 
05A6C:  CLRWDT
05A6E:  BRA    59CC
....................     //fprintf(U1PRINTER," \r\n"); 
....................     //fprintf(U1PRINTER,"b=%Ld",b); 
....................     } 
05A70:  GOTO   6F6E (RETURN)
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) 
*
016D8:  MOVF   FD0,W
016DA:  ANDLW  0F
016DC:  BTFSS  FD0.4
016DE:  MOVLW  00
016E0:  BSF    FD0.0
016E2:  BSF    FD0.1
016E4:  BSF    FD0.4
016E6:  BSF    FD8.3
016E8:  BSF    FD8.4
016EA:  XORLW  07
016EC:  BZ    16FC
016EE:  XORLW  08
016F0:  BZ    16FE
016F2:  XORLW  01
016F4:  BZ    1700
016F6:  XORLW  02
016F8:  BZ    1702
016FA:  BRA    1702
....................    { 
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-WD"); 
....................          break;} 
016FC:  BRA    1702
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          //fprintf(U1PRINTER,"\r\nREINICIO-MCLR"); 
....................          break;} 
016FE:  BRA    1702
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-VOLTAJE_BAJO"); 
....................          break; 
01700:  BRA    1702
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          //fprintf(U1PRINTER,"\r\nPOWER_UP"); 
....................          /* 
....................          #define WDT_TIMEOUT       7      
....................          #define MCLR_FROM_SLEEP  11      
....................          #define MCLR_FROM_RUN    15      
....................          #define NORMAL_POWER_UP  12      
....................          #define BROWNOUT_RESTART 14      
....................          #define WDT_FROM_SLEEP    3      
....................          #define RESET_INSTRUCTION 0     */ 
....................          break; 
....................       } 
....................    } 
01702:  GOTO   6E64 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1918   PUT NOBROWNOUT BORV21 WDT WDT4096
   Word  3: 8000   NOPBADEN NOLPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
