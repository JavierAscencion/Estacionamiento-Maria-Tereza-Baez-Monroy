CCS PCH C Compiler, Version 5.070, 56587               12-jun.-18 17:18

               Filename:   E:\Google Drive\01 ESTACIONAMIENTOS\CENTRO_NUEVO\ENTRADA_TEST_IMPRESORA\ENTRADA_CLIENTE.lst

               ROM used:   30858 bytes (47%)
                           Largest free fragment is 34676
               RAM used:   2299 (69%) at main() level
                           2481 (75%) worst case
               Stack used: 10 locations (9 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   6CD8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0124
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   01C8
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   01E4
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   0218
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... //2018/03/12 
.................... // Basado en: Programa de ejemplo 10 para comunicarme con el módulo ENC28J60. 
.................... // Cliente TCP. 
.................... // Incluimos las definiciones necesarias de la placa utilizada. 
.................... #include "Plantilla_Inicio.c" 
.................... // Controlador ETHERNET 
.................... // Fecha: 2018/02/19. 
.................... // Versión del compilador: v5.070 
.................... // Versión del programa: v0.1 
.................... // Revisión del programa: 0.00 
....................  
.................... // Definimos el microcontrolador utilizado. 
.................... #include <18F4680.h> // Definición de registros internos del PIC18F4520. 
.................... //////////// Standard Header file for the PIC18F4680 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4680 
000D2:  CLRF   FF7
000D4:  ADDLW  E2
000D6:  MOVWF  FF6
000D8:  MOVLW  00
000DA:  ADDWFC FF7,F
000DC:  TBLRD*+
000DE:  MOVF   FF5,W
000E0:  RETURN 0
000E2:  DATA 28,0C
000E4:  DATA 01,06
000E6:  CLRF   FF7
000E8:  ADDLW  F6
000EA:  MOVWF  FF6
000EC:  MOVLW  00
000EE:  ADDWFC FF7,F
000F0:  TBLRD*+
000F2:  MOVF   FF5,W
000F4:  RETURN 0
000F6:  DATA 42,4F
000F8:  DATA 4C,45
000FA:  DATA 54,45
000FC:  DATA 52,41
000FE:  DATA 5F,50
00100:  DATA 41,47
00102:  DATA 41,44
00104:  DATA 4F,00
00106:  CLRF   FF7
00108:  ADDLW  16
0010A:  MOVWF  FF6
0010C:  MOVLW  01
0010E:  ADDWFC FF7,F
00110:  TBLRD*+
00112:  MOVF   FF5,W
00114:  RETURN 0
00116:  DATA 41,42
00118:  DATA 43,31
0011A:  DATA 32,33
0011C:  DATA 34,35
0011E:  DATA 36,37
00120:  DATA 38,39
00122:  DATA 30,00
*
00148:  DATA 53,6F
0014A:  DATA 6C,69
0014C:  DATA 63,69
0014E:  DATA 74,75
00150:  DATA 64,20
00152:  DATA 41,52
00154:  DATA 50,2E
00156:  DATA 20,20
00158:  DATA 20,20
0015A:  DATA 20,20
0015C:  DATA 00,00
0015E:  DATA 43,4F
00160:  DATA 4E,45
00162:  DATA 43,54
00164:  DATA 41,4E
00166:  DATA 44,4F
00168:  DATA 2E,2E
0016A:  DATA 2E,20
0016C:  DATA 20,20
0016E:  DATA 20,20
00170:  DATA 20,20
00172:  DATA 00,00
00174:  DATA 45,72
00176:  DATA 72,6F
00178:  DATA 72,20
0017A:  DATA 65,6E
0017C:  DATA 20,65
0017E:  DATA 6C,20
00180:  DATA 73,6F
00182:  DATA 63,6B
00184:  DATA 65,74
00186:  DATA 2E,20
00188:  DATA 00,00
0018A:  DATA 43,4F
0018C:  DATA 4E,45
0018E:  DATA 43,54
00190:  DATA 41,44
00192:  DATA 4F,20
00194:  DATA 20,20
00196:  DATA 20,20
00198:  DATA 20,20
0019A:  DATA 20,20
0019C:  DATA 20,20
0019E:  DATA 00,00
001A0:  DATA 44,45
001A2:  DATA 53,43
001A4:  DATA 4F,4E
001A6:  DATA 45,43
001A8:  DATA 54,41
001AA:  DATA 44,4F
001AC:  DATA 20,20
001AE:  DATA 20,20
001B0:  DATA 20,20
001B2:  DATA 20,00
001B4:  DATA 44,45
001B6:  DATA 53,43
001B8:  DATA 4F,4E
001BA:  DATA 45,43
001BC:  DATA 54,41
001BE:  DATA 44,4F
001C0:  DATA 20,20
001C2:  DATA 20,20
001C4:  DATA 20,20
001C6:  DATA 20,00
*
0024A:  DATA 0C,49
0024C:  DATA 4E,49
0024E:  DATA 43,49
00250:  DATA 41,4E
00252:  DATA 44,4F
00254:  DATA 00,00
00256:  DATA 44,69
00258:  DATA 61,73
0025A:  DATA 3A,25
0025C:  DATA 75,20
0025E:  DATA 50,41
00260:  DATA 47,4F
00262:  DATA 3A,25
00264:  DATA 64,00
00266:  DATA 52,65
00268:  DATA 73,74
0026A:  DATA 61,6E
0026C:  DATA 3A,25
0026E:  DATA 75,20
00270:  DATA 00,00
00272:  DATA 54,49
00274:  DATA 45,4D
00276:  DATA 50,4F
00278:  DATA 20,44
0027A:  DATA 45,20
0027C:  DATA 50,52
0027E:  DATA 55,45
00280:  DATA 42,41
00282:  DATA 00,00
00284:  DATA 20,20
00286:  DATA 48,41
00288:  DATA 20,45
0028A:  DATA 58,50
0028C:  DATA 49,52
0028E:  DATA 41,44
00290:  DATA 4F,20
00292:  DATA 20,20
00294:  DATA 00,00
00296:  DATA 72,78
00298:  DATA 74,63
0029A:  DATA 70,3A
0029C:  DATA 25,73
0029E:  DATA 00,00
002A0:  DATA 62,3A
002A2:  DATA 25,4C
002A4:  DATA 64,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 20,20
002B2:  DATA 20,20
002B4:  DATA 20,00
002B6:  DATA 0C,20
002B8:  DATA 54,4F
002BA:  DATA 4D,45
002BC:  DATA 20,53
002BE:  DATA 55,20
002C0:  DATA 42,4F
002C2:  DATA 4C,45
002C4:  DATA 54,4F
002C6:  DATA 20,0A
002C8:  DATA 59,20
002CA:  DATA 41,56
002CC:  DATA 41,4E
002CE:  DATA 43,45
002D0:  DATA 20,50
002D2:  DATA 4F,52
002D4:  DATA 20,46
002D6:  DATA 41,56
002D8:  DATA 4F,52
002DA:  DATA 00,00
002DC:  DATA 0C,00
002DE:  DATA 20,20
002E0:  DATA 20,25
002E2:  DATA 30,32
002E4:  DATA 64,20
002E6:  DATA 25,30
002E8:  DATA 32,64
002EA:  DATA 20,25
002EC:  DATA 30,32
002EE:  DATA 64,2F
002F0:  DATA 25,30
002F2:  DATA 32,64
002F4:  DATA 2F,25
002F6:  DATA 30,32
002F8:  DATA 64,20
002FA:  DATA 20,20
002FC:  DATA 20,00
002FE:  DATA 20,20
00300:  DATA 20,25
00302:  DATA 30,32
00304:  DATA 64,3A
00306:  DATA 25,30
00308:  DATA 32,64
0030A:  DATA 20,25
0030C:  DATA 30,32
0030E:  DATA 64,2F
00310:  DATA 25,30
00312:  DATA 32,64
00314:  DATA 2F,25
00316:  DATA 30,32
00318:  DATA 64,20
0031A:  DATA 20,20
0031C:  DATA 20,00
0031E:  DATA 20,20
00320:  DATA 20,57
00322:  DATA 57,57
00324:  DATA 2E,41
00326:  DATA 43,43
00328:  DATA 45,53
0032A:  DATA 41,2E
0032C:  DATA 4D,45
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 00,00
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 20,20
0033A:  DATA 20,41
0033C:  DATA 43,43
0033E:  DATA 45,53
00340:  DATA 41,20
00342:  DATA 20,20
00344:  DATA 20,20
00346:  DATA 20,20
00348:  DATA 00,00
0034A:  DATA 20,20
0034C:  DATA 20,20
0034E:  DATA 20,20
00350:  DATA 20,20
00352:  DATA 20,20
00354:  DATA 20,20
00356:  DATA 20,20
00358:  DATA 20,20
0035A:  DATA 20,20
0035C:  DATA 20,20
0035E:  DATA 00,00
00360:  DATA 20,20
00362:  DATA 20,20
00364:  DATA 20,20
00366:  DATA 20,20
00368:  DATA 20,20
0036A:  DATA 20,20
0036C:  DATA 20,20
0036E:  DATA 20,20
00370:  DATA 20,20
00372:  DATA 20,20
00374:  DATA 00,00
00376:  DATA 0C,20
00378:  DATA 20,20
0037A:  DATA 20,20
0037C:  DATA 43,4F
0037E:  DATA 4E,46
00380:  DATA 49,47
00382:  DATA 55,52
00384:  DATA 41,20
00386:  DATA 20,20
00388:  DATA 20,20
0038A:  DATA 20,00
0038C:  DATA 20,20
0038E:  DATA 20,20
00390:  DATA 20,46
00392:  DATA 45,43
00394:  DATA 48,41
00396:  DATA 2F,48
00398:  DATA 4F,52
0039A:  DATA 41,20
0039C:  DATA 20,20
0039E:  DATA 20,20
003A0:  DATA 00,00
003A2:  DATA 20,20
003A4:  DATA 20,20
003A6:  DATA 20,20
003A8:  DATA 25,30
003AA:  DATA 32,64
003AC:  DATA 3A,25
003AE:  DATA 30,32
003B0:  DATA 64,3A
003B2:  DATA 25,30
003B4:  DATA 32,64
003B6:  DATA 20,20
003B8:  DATA 20,20
003BA:  DATA 20,20
003BC:  DATA 00,00
003BE:  DATA 20,20
003C0:  DATA 20,20
003C2:  DATA 20,25
003C4:  DATA 30,32
003C6:  DATA 64,2F
003C8:  DATA 25,30
003CA:  DATA 32,64
003CC:  DATA 2F,32
003CE:  DATA 25,30
003D0:  DATA 33,64
003D2:  DATA 20,20
003D4:  DATA 20,20
003D6:  DATA 20,00
003D8:  DATA 20,20
003DA:  DATA 44,41
003DC:  DATA 54,4F
003DE:  DATA 53,20
003E0:  DATA 47,55
003E2:  DATA 41,52
003E4:  DATA 44,41
003E6:  DATA 44,4F
003E8:  DATA 53,20
003EA:  DATA 20,20
003EC:  DATA 00,00
003EE:  DATA 45,4E
003F0:  DATA 31,2D
003F2:  DATA 25,30
003F4:  DATA 38,4C
003F6:  DATA 58,00
003F8:  DATA 46,6F
003FA:  DATA 6C,69
003FC:  DATA 6F,3A
003FE:  DATA 25,73
00400:  DATA 00,00
00402:  DATA 4D,41
00404:  DATA 52,49
00406:  DATA 41,20
00408:  DATA 54,45
0040A:  DATA 52,45
0040C:  DATA 53,41
0040E:  DATA 20,42
00410:  DATA 41,45
00412:  DATA 5A,20
00414:  DATA 4D,4F
00416:  DATA 4E,52
00418:  DATA 4F,59
0041A:  DATA 00,00
0041C:  DATA 52,46
0041E:  DATA 43,3A
00420:  DATA 42,41
00422:  DATA 4D,54
00424:  DATA 39,37
00426:  DATA 30,35
00428:  DATA 32,38
0042A:  DATA 38,34
0042C:  DATA 41,0A
0042E:  DATA 00,00
00430:  DATA 34,20
00432:  DATA 70,6F
00434:  DATA 6E,69
00436:  DATA 65,6E
00438:  DATA 74,65
0043A:  DATA 20,31
0043C:  DATA 33,30
0043E:  DATA 32,2C
00440:  DATA 20,63
00442:  DATA 6F,6C
00444:  DATA 6F,6E
00446:  DATA 69,61
00448:  DATA 20,43
0044A:  DATA 65,6E
0044C:  DATA 74,72
0044E:  DATA 6F,20
00450:  DATA 20,43
00452:  DATA 50,20
00454:  DATA 37,32
00456:  DATA 30,30
00458:  DATA 30,0A
0045A:  DATA 50,75
0045C:  DATA 65,62
0045E:  DATA 6C,61
00460:  DATA 2C,20
00462:  DATA 50,75
00464:  DATA 65,62
00466:  DATA 6C,61
00468:  DATA 0A,00
0046A:  DATA 25,30
0046C:  DATA 32,64
0046E:  DATA 2F,25
00470:  DATA 30,32
00472:  DATA 64,2F
00474:  DATA 32,30
00476:  DATA 25,30
00478:  DATA 32,64
0047A:  DATA 20,25
0047C:  DATA 30,32
0047E:  DATA 64,3A
00480:  DATA 25,30
00482:  DATA 32,64
00484:  DATA 3A,25
00486:  DATA 30,32
00488:  DATA 64,00
0048A:  DATA 54,41
0048C:  DATA 52,49
0048E:  DATA 46,41
00490:  DATA 3A,24
00492:  DATA 31,35
00494:  DATA 20,48
00496:  DATA 6F,72
00498:  DATA 61,20
0049A:  DATA 6F,20
0049C:  DATA 46,72
0049E:  DATA 61,63
004A0:  DATA 63,69
004A2:  DATA 6F,6E
004A4:  DATA 2C,20
004A6:  DATA 54,4F
004A8:  DATA 4C,45
004AA:  DATA 52,41
004AC:  DATA 4E,43
004AE:  DATA 49,41
004B0:  DATA 3A,35
004B2:  DATA 20,6D
004B4:  DATA 69,6E
004B6:  DATA 2E,20
004B8:  DATA 20,0A
004BA:  DATA 00,00
004BC:  DATA 48,6F
004BE:  DATA 72,61
004C0:  DATA 72,69
004C2:  DATA 6F,73
004C4:  DATA 3A,64
004C6:  DATA 65,20
004C8:  DATA 38,3A
004CA:  DATA 30,30
004CC:  DATA 20,61
004CE:  DATA 20,32
004D0:  DATA 31,3A
004D2:  DATA 30,30
004D4:  DATA 68,72
004D6:  DATA 73,2E
004D8:  DATA 20,64
004DA:  DATA 65,20
004DC:  DATA 6C,75
004DE:  DATA 6E,65
004E0:  DATA 73,20
004E2:  DATA 61,20
004E4:  DATA 76,69
004E6:  DATA 65,72
004E8:  DATA 6E,65
004EA:  DATA 73,0A
004EC:  DATA 00,00
004EE:  DATA 53,61
004F0:  DATA 62,61
004F2:  DATA 64,6F
004F4:  DATA 73,20
004F6:  DATA 64,65
004F8:  DATA 20,38
004FA:  DATA 3A,30
004FC:  DATA 30,20
004FE:  DATA 61,20
00500:  DATA 31,34
00502:  DATA 3A,30
00504:  DATA 30,68
00506:  DATA 72,73
00508:  DATA 2E,20
0050A:  DATA 20,20
0050C:  DATA 20,20
0050E:  DATA 20,20
00510:  DATA 20,20
00512:  DATA 20,20
00514:  DATA 20,20
00516:  DATA 20,20
00518:  DATA 20,20
0051A:  DATA 20,20
0051C:  DATA 20,0A
0051E:  DATA 00,00
00520:  DATA 22,41
00522:  DATA 43,43
00524:  DATA 45,53
00526:  DATA 41,22
00528:  DATA 20,61
0052A:  DATA 75,74
0052C:  DATA 6F,6D
0052E:  DATA 61,74
00530:  DATA 69,7A
00532:  DATA 61,63
00534:  DATA 69,6F
00536:  DATA 6E,20
00538:  DATA 00,00
0053A:  DATA 77,77
0053C:  DATA 77,2E
0053E:  DATA 61,63
00540:  DATA 63,65
00542:  DATA 73,61
00544:  DATA 2E,6D
00546:  DATA 65,20
00548:  DATA 20,61
0054A:  DATA 75,74
0054C:  DATA 6F,6D
0054E:  DATA 61,74
00550:  DATA 69,7A
00552:  DATA 61,63
00554:  DATA 69,6F
00556:  DATA 6E,40
00558:  DATA 61,63
0055A:  DATA 63,65
0055C:  DATA 73,61
0055E:  DATA 2E,6D
00560:  DATA 65,00
00562:  DATA 1D,68
00564:  DATA 8C,00
00566:  DATA 1D,77
00568:  DATA 01,00
0056A:  DATA 1D,68
0056C:  DATA 8C,00
0056E:  DATA 1D,77
00570:  DATA 01,00
*
006DE:  TBLRD*+
006E0:  MOVF   FF5,F
006E2:  BZ    06FC
006E4:  MOVFF  FF6,8F9
006E8:  MOVFF  FF7,8FA
006EC:  MOVFF  FF5,8FF
006F0:  RCALL  067A
006F2:  MOVFF  8F9,FF6
006F6:  MOVFF  8FA,FF7
006FA:  BRA    06DE
006FC:  RETURN 0
*
00A50:  ADDWF  FE8,W
00A52:  CLRF   FF7
00A54:  RLCF   FF7,F
00A56:  ADDLW  6B
00A58:  MOVWF  FF6
00A5A:  MOVLW  0A
00A5C:  ADDWFC FF7,F
00A5E:  TBLRD*-
00A60:  MOVF   FF5,W
00A62:  MOVWF  FFA
00A64:  TBLRD*
00A66:  MOVF   FF5,W
00A68:  MOVWF  FF9
00A6A:  DATA A2,07
00A6C:  DATA C0,07
00A6E:  DATA DE,07
00A70:  DATA FC,07
00A72:  DATA 1A,08
00A74:  DATA 38,08
00A76:  DATA 56,08
00A78:  DATA 74,08
00A7A:  DATA 92,08
00A7C:  DATA B0,08
00A7E:  DATA CE,08
00A80:  DATA EC,08
00A82:  DATA 0A,09
00A84:  DATA 28,09
*
01006:  MOVLB  9
01008:  MOVF   x46,W
0100A:  MULWF  x48
0100C:  MOVFF  FF3,01
01010:  MOVFF  FF4,00
01014:  MULWF  x49
01016:  MOVF   FF3,W
01018:  ADDWF  00,F
0101A:  MOVF   x47,W
0101C:  MULWF  x48
0101E:  MOVF   FF3,W
01020:  ADDWFC 00,W
01022:  MOVWF  02
01024:  MOVLB  0
01026:  RETURN 0
*
0103C:  MOVLB  9
0103E:  CLRF   x01
01040:  CLRF   x02
01042:  MOVLW  01
01044:  MOVWF  x03
01046:  CLRF   FDA
01048:  CLRF   FD9
0104A:  MOVLW  08
0104C:  MOVWF  x06
0104E:  MOVLW  F9
01050:  MOVWF  x05
01052:  MOVLW  08
01054:  MOVWF  FEA
01056:  MOVLW  FD
01058:  MOVWF  FE9
0105A:  MOVFF  906,FE2
0105E:  MOVFF  905,FE1
01062:  MOVFF  903,904
01066:  BCF    FD8.0
01068:  MOVF   FE5,W
0106A:  MULWF  FEE
0106C:  MOVF   FF3,W
0106E:  ADDWFC x01,F
01070:  MOVF   FF4,W
01072:  ADDWFC x02,F
01074:  DECFSZ x04,F
01076:  BRA    1066
01078:  MOVFF  901,FDE
0107C:  MOVFF  902,901
01080:  CLRF   x02
01082:  BTFSC  FD8.0
01084:  INCF   x02,F
01086:  INCF   x05,F
01088:  BTFSC  FD8.2
0108A:  INCF   x06,F
0108C:  INCF   x03,F
0108E:  MOVF   x03,W
01090:  SUBLW  05
01092:  BNZ   1052
01094:  MOVLB  0
01096:  GOTO   1108 (RETURN)
0109A:  CLRF   01
0109C:  CLRF   02
0109E:  CLRF   00
010A0:  CLRF   03
010A2:  MOVLB  9
010A4:  MOVF   x0B,W
010A6:  BNZ   10AC
010A8:  MOVF   x0A,W
010AA:  BZ    10DC
010AC:  MOVLW  10
010AE:  MOVWF  x0C
010B0:  BCF    FD8.0
010B2:  RLCF   x08,F
010B4:  RLCF   x09,F
010B6:  RLCF   00,F
010B8:  RLCF   03,F
010BA:  MOVF   x0B,W
010BC:  SUBWF  03,W
010BE:  BNZ   10C4
010C0:  MOVF   x0A,W
010C2:  SUBWF  00,W
010C4:  BNC   10D4
010C6:  MOVF   x0A,W
010C8:  SUBWF  00,F
010CA:  BTFSS  FD8.0
010CC:  DECF   03,F
010CE:  MOVF   x0B,W
010D0:  SUBWF  03,F
010D2:  BSF    FD8.0
010D4:  RLCF   01,F
010D6:  RLCF   02,F
010D8:  DECFSZ x0C,F
010DA:  BRA    10B0
010DC:  MOVLB  0
010DE:  RETURN 0
*
01558:  TBLRD*+
0155A:  MOVFF  FF6,8F8
0155E:  MOVFF  FF7,8F9
01562:  MOVFF  FF5,8FF
01566:  CALL   067A
0156A:  MOVFF  8F8,FF6
0156E:  MOVFF  8F9,FF7
01572:  MOVLB  8
01574:  DECFSZ xF7,F
01576:  BRA    157A
01578:  BRA    157E
0157A:  MOVLB  0
0157C:  BRA    1558
0157E:  MOVLB  0
01580:  RETURN 0
01582:  MOVLB  9
01584:  MOVF   x11,W
01586:  CLRF   01
01588:  SUBWF  x10,W
0158A:  BC    1592
0158C:  MOVFF  910,00
01590:  BRA    15AA
01592:  CLRF   00
01594:  MOVLW  08
01596:  MOVWF  x12
01598:  RLCF   x10,F
0159A:  RLCF   00,F
0159C:  MOVF   x11,W
0159E:  SUBWF  00,W
015A0:  BTFSC  FD8.0
015A2:  MOVWF  00
015A4:  RLCF   01,F
015A6:  DECFSZ x12,F
015A8:  BRA    1598
015AA:  MOVLB  0
015AC:  RETURN 0
015AE:  MOVF   01,W
015B0:  MOVFF  8F7,910
015B4:  MOVLW  64
015B6:  MOVLB  9
015B8:  MOVWF  x11
015BA:  MOVLB  0
015BC:  RCALL  1582
015BE:  MOVFF  00,8F7
015C2:  MOVF   01,W
015C4:  MOVLW  30
015C6:  BNZ   15D8
015C8:  MOVLB  8
015CA:  BTFSS  xF8.1
015CC:  BRA    15EC
015CE:  BTFSC  xF8.3
015D0:  BRA    15EC
015D2:  BTFSC  xF8.4
015D4:  MOVLW  20
015D6:  BRA    15E0
015D8:  MOVLB  8
015DA:  BCF    xF8.3
015DC:  BCF    xF8.4
015DE:  BSF    xF8.0
015E0:  ADDWF  01,F
015E2:  MOVFF  01,8FF
015E6:  MOVLB  0
015E8:  CALL   067A
015EC:  MOVFF  8F7,910
015F0:  MOVLW  0A
015F2:  MOVLB  9
015F4:  MOVWF  x11
015F6:  MOVLB  0
015F8:  RCALL  1582
015FA:  MOVFF  00,8F7
015FE:  MOVF   01,W
01600:  MOVLW  30
01602:  BNZ   1614
01604:  MOVLB  8
01606:  BTFSC  xF8.3
01608:  BRA    1620
0160A:  BTFSS  xF8.0
0160C:  BRA    1620
0160E:  BTFSC  xF8.4
01610:  MOVLW  20
01612:  MOVLB  0
01614:  ADDWF  01,F
01616:  MOVFF  01,8FF
0161A:  CALL   067A
0161E:  MOVLB  8
01620:  MOVLW  30
01622:  ADDWF  xF7,F
01624:  MOVFF  8F7,8FF
01628:  MOVLB  0
0162A:  CALL   067A
0162E:  RETURN 0
01630:  MOVLW  20
01632:  MOVLB  8
01634:  BTFSS  xF7.4
01636:  MOVLW  30
01638:  MOVWF  xF8
0163A:  MOVFF  8F6,00
0163E:  BTFSS  xF6.7
01640:  BRA    1652
01642:  COMF   00,F
01644:  INCF   00,F
01646:  MOVFF  00,8F6
0164A:  MOVLW  2D
0164C:  MOVWF  xF8
0164E:  BSF    xF7.7
01650:  BSF    xF7.0
01652:  MOVF   01,W
01654:  MOVFF  8F6,910
01658:  MOVLW  64
0165A:  MOVLB  9
0165C:  MOVWF  x11
0165E:  MOVLB  0
01660:  RCALL  1582
01662:  MOVFF  00,8F6
01666:  MOVLW  30
01668:  ADDWF  01,W
0166A:  MOVLB  8
0166C:  MOVWF  xF9
0166E:  MOVFF  8F6,910
01672:  MOVLW  0A
01674:  MOVLB  9
01676:  MOVWF  x11
01678:  MOVLB  0
0167A:  RCALL  1582
0167C:  MOVLW  30
0167E:  ADDWF  00,W
01680:  MOVLB  8
01682:  MOVWF  xFB
01684:  MOVLW  30
01686:  ADDWF  01,W
01688:  MOVWF  xFA
0168A:  MOVFF  8F8,00
0168E:  MOVLW  30
01690:  SUBWF  xF9,W
01692:  BZ    169C
01694:  BSF    xF7.1
01696:  BTFSC  xF7.7
01698:  BSF    xF7.2
0169A:  BRA    16C0
0169C:  MOVFF  8F8,8F9
016A0:  MOVLW  20
016A2:  MOVWF  xF8
016A4:  MOVLW  30
016A6:  SUBWF  xFA,W
016A8:  BZ    16B2
016AA:  BSF    xF7.0
016AC:  BTFSC  xF7.7
016AE:  BSF    xF7.1
016B0:  BRA    16C0
016B2:  BTFSS  FD8.2
016B4:  BSF    xF7.0
016B6:  BNZ   16C0
016B8:  MOVFF  8F9,8FA
016BC:  MOVLW  20
016BE:  MOVWF  xF9
016C0:  BTFSC  xF7.2
016C2:  BRA    16CE
016C4:  BTFSC  xF7.1
016C6:  BRA    16D8
016C8:  BTFSC  xF7.0
016CA:  BRA    16E2
016CC:  BRA    16EC
016CE:  MOVFF  8F8,8FF
016D2:  MOVLB  0
016D4:  CALL   067A
016D8:  MOVFF  8F9,8FF
016DC:  MOVLB  0
016DE:  CALL   067A
016E2:  MOVFF  8FA,8FF
016E6:  MOVLB  0
016E8:  CALL   067A
016EC:  MOVFF  8FB,8FF
016F0:  MOVLB  0
016F2:  CALL   067A
016F6:  GOTO   6F9E (RETURN)
*
04466:  ADDWF  FE8,W
04468:  CLRF   FF7
0446A:  RLCF   FF7,F
0446C:  ADDLW  81
0446E:  MOVWF  FF6
04470:  MOVLW  44
04472:  ADDWFC FF7,F
04474:  TBLRD*-
04476:  MOVF   FF5,W
04478:  MOVWF  FFA
0447A:  TBLRD*
0447C:  MOVF   FF5,W
0447E:  MOVWF  FF9
04480:  DATA FE,41
04482:  DATA 06,42
04484:  DATA 4E,42
04486:  DATA EE,42
04488:  DATA 1A,43
0448A:  DATA 1A,43
0448C:  DATA 2A,43
0448E:  DATA 3A,43
04490:  DATA 4E,43
*
04646:  ADDWF  FE8,W
04648:  CLRF   FF7
0464A:  RLCF   FF7,F
0464C:  ADDLW  61
0464E:  MOVWF  FF6
04650:  MOVLW  46
04652:  ADDWFC FF7,F
04654:  TBLRD*-
04656:  MOVF   FF5,W
04658:  MOVWF  FFA
0465A:  TBLRD*
0465C:  MOVF   FF5,W
0465E:  MOVWF  FF9
04660:  DATA A8,44
04662:  DATA A8,44
04664:  DATA 00,45
04666:  DATA 90,45
04668:  DATA F0,45
0466A:  DATA EE,44
0466C:  DATA 62,45
*
0560C:  ADDWF  FE8,W
0560E:  CLRF   FF7
05610:  RLCF   FF7,F
05612:  ADDLW  27
05614:  MOVWF  FF6
05616:  MOVLW  56
05618:  ADDWFC FF7,F
0561A:  TBLRD*-
0561C:  MOVF   FF5,W
0561E:  MOVWF  FFA
05620:  TBLRD*
05622:  MOVF   FF5,W
05624:  MOVWF  FF9
05626:  DATA E8,52
05628:  DATA 24,53
0562A:  DATA 58,53
0562C:  DATA FE,53
0562E:  DATA 64,54
05630:  DATA 02,55
05632:  DATA 32,55
05634:  DATA CC,55
*
0567E:  MOVFF  8F4,FEA
05682:  MOVFF  8F3,FE9
05686:  MOVLB  8
05688:  MOVFF  8F9,FEF
0568C:  INCF   FE9,F
0568E:  BTFSC  FD8.2
05690:  INCF   FEA,F
05692:  CLRF   FEF
05694:  INCF   xF3,F
05696:  BTFSC  FD8.2
05698:  INCF   xF4,F
0569A:  MOVLB  0
0569C:  RETURN 0
0569E:  MOVLB  8
056A0:  BTFSC  xF7.7
056A2:  BRA    56C6
056A4:  MOVLW  0F
056A6:  MOVWF  00
056A8:  SWAPF  xF6,W
056AA:  ANDWF  00,F
056AC:  MOVLW  0A
056AE:  SUBWF  00,W
056B0:  BC    56B8
056B2:  MOVLW  30
056B4:  ADDWF  00,F
056B6:  BRA    56BC
056B8:  MOVF   xF7,W
056BA:  ADDWF  00,F
056BC:  MOVFF  00,8F9
056C0:  MOVLB  0
056C2:  RCALL  567E
056C4:  MOVLB  8
056C6:  MOVLW  0F
056C8:  ANDWF  xF6,F
056CA:  MOVLW  0A
056CC:  SUBWF  xF6,W
056CE:  BC    56D4
056D0:  MOVLW  30
056D2:  BRA    56D8
056D4:  BCF    xF7.7
056D6:  MOVF   xF7,W
056D8:  ADDWF  xF6,F
056DA:  MOVFF  8F6,8F9
056DE:  MOVLB  0
056E0:  RCALL  567E
056E2:  RETURN 0
056E4:  TBLRD*+
056E6:  MOVFF  FF6,8F7
056EA:  MOVFF  FF7,8F8
056EE:  MOVFF  FF5,8F9
056F2:  RCALL  567E
056F4:  MOVFF  8F7,FF6
056F8:  MOVFF  8F8,FF7
056FC:  MOVLB  8
056FE:  DECFSZ xF6,F
05700:  BRA    5704
05702:  BRA    5708
05704:  MOVLB  0
05706:  BRA    56E4
05708:  MOVLB  0
0570A:  GOTO   57EC (RETURN)
0570E:  TSTFSZ 01
05710:  BRA    5718
05712:  TSTFSZ 02
05714:  BRA    571A
05716:  BRA    5726
05718:  INCF   02,F
0571A:  MOVFF  00,FEE
0571E:  DECFSZ 01,F
05720:  BRA    571A
05722:  DECFSZ 02,F
05724:  BRA    571A
05726:  RETURN 0
*
059C6:  TBLRD*+
059C8:  MOVFF  FF6,90B
059CC:  MOVFF  FF7,90C
059D0:  MOVFF  FF5,910
059D4:  RCALL  59B6
059D6:  MOVFF  90B,FF6
059DA:  MOVFF  90C,FF7
059DE:  MOVLB  9
059E0:  DECFSZ x0A,F
059E2:  BRA    59E6
059E4:  BRA    59EA
059E6:  MOVLB  0
059E8:  BRA    59C6
059EA:  MOVLB  0
059EC:  RETURN 0
059EE:  MOVF   FEF,F
059F0:  BZ    5A10
059F2:  MOVFF  FEA,90C
059F6:  MOVFF  FE9,90B
059FA:  MOVFF  FEF,910
059FE:  RCALL  59B6
05A00:  MOVFF  90C,FEA
05A04:  MOVFF  90B,FE9
05A08:  INCF   FE9,F
05A0A:  BTFSC  FD8.2
05A0C:  INCF   FEA,F
05A0E:  BRA    59EE
05A10:  RETURN 0
*
05A1E:  TBLRD*+
05A20:  MOVF   FF5,F
05A22:  BZ    5A3C
05A24:  MOVFF  FF6,90B
05A28:  MOVFF  FF7,90C
05A2C:  MOVFF  FF5,910
05A30:  RCALL  59B6
05A32:  MOVFF  90B,FF6
05A36:  MOVFF  90C,FF7
05A3A:  BRA    5A1E
05A3C:  RETURN 0
05A3E:  MOVLW  20
05A40:  MOVLB  9
05A42:  BTFSS  x0B.4
05A44:  MOVLW  30
05A46:  MOVWF  x0C
05A48:  MOVFF  90A,00
05A4C:  BTFSS  x0A.7
05A4E:  BRA    5A60
05A50:  COMF   00,F
05A52:  INCF   00,F
05A54:  MOVFF  00,90A
05A58:  MOVLW  2D
05A5A:  MOVWF  x0C
05A5C:  BSF    x0B.7
05A5E:  BSF    x0B.0
05A60:  MOVF   01,W
05A62:  MOVFF  90A,910
05A66:  MOVLW  64
05A68:  MOVWF  x11
05A6A:  MOVLB  0
05A6C:  CALL   1582
05A70:  MOVFF  00,90A
05A74:  MOVLW  30
05A76:  ADDWF  01,W
05A78:  MOVLB  9
05A7A:  MOVWF  x0D
05A7C:  MOVFF  90A,910
05A80:  MOVLW  0A
05A82:  MOVWF  x11
05A84:  MOVLB  0
05A86:  CALL   1582
05A8A:  MOVLW  30
05A8C:  ADDWF  00,W
05A8E:  MOVLB  9
05A90:  MOVWF  x0F
05A92:  MOVLW  30
05A94:  ADDWF  01,W
05A96:  MOVWF  x0E
05A98:  MOVFF  90C,00
05A9C:  MOVLW  30
05A9E:  SUBWF  x0D,W
05AA0:  BZ    5AAA
05AA2:  BSF    x0B.1
05AA4:  BTFSC  x0B.7
05AA6:  BSF    x0B.2
05AA8:  BRA    5ACE
05AAA:  BTFSC  x0B.2
05AAC:  BRA    5ACE
05AAE:  MOVFF  90C,90D
05AB2:  BTFSC  x0B.1
05AB4:  BRA    5ABE
05AB6:  MOVLW  30
05AB8:  SUBWF  x0E,W
05ABA:  BZ    5AC4
05ABC:  BSF    x0B.0
05ABE:  BTFSC  x0B.7
05AC0:  BSF    x0B.1
05AC2:  BRA    5ACE
05AC4:  BTFSS  FD8.2
05AC6:  BSF    x0B.0
05AC8:  BTFSC  FD8.2
05ACA:  MOVFF  90D,90E
05ACE:  BTFSC  x0B.2
05AD0:  BRA    5ADC
05AD2:  BTFSC  x0B.1
05AD4:  BRA    5AE4
05AD6:  BTFSC  x0B.0
05AD8:  BRA    5AEC
05ADA:  BRA    5AF4
05ADC:  MOVFF  90C,910
05AE0:  MOVLB  0
05AE2:  RCALL  59B6
05AE4:  MOVFF  90D,910
05AE8:  MOVLB  0
05AEA:  RCALL  59B6
05AEC:  MOVFF  90E,910
05AF0:  MOVLB  0
05AF2:  RCALL  59B6
05AF4:  MOVFF  90F,910
05AF8:  MOVLB  0
05AFA:  RCALL  59B6
05AFC:  RETURN 0
*
06278:  MOVF   FEF,F
0627A:  BZ    629C
0627C:  MOVFF  FEA,8F7
06280:  MOVFF  FE9,8F6
06284:  MOVFF  FEF,8FF
06288:  CALL   067A
0628C:  MOVFF  8F7,FEA
06290:  MOVFF  8F6,FE9
06294:  INCF   FE9,F
06296:  BTFSC  FD8.2
06298:  INCF   FEA,F
0629A:  BRA    6278
0629C:  GOTO   7146 (RETURN)
062A0:  MOVFF  FEA,8FE
062A4:  MOVFF  FE9,8FD
062A8:  MOVLB  8
062AA:  BTFSS  xF7.7
062AC:  BRA    62BE
062AE:  BSF    xFD.7
062B0:  BTFSS  xFD.4
062B2:  INCF   xFD,F
062B4:  COMF   xF6,F
062B6:  COMF   xF7,F
062B8:  INCF   xF6,F
062BA:  BTFSC  FD8.2
062BC:  INCF   xF7,F
062BE:  SWAPF  xF7,W
062C0:  IORLW  F0
062C2:  MOVWF  xF9
062C4:  ADDWF  xF9,F
062C6:  ADDLW  E2
062C8:  MOVWF  xFA
062CA:  ADDLW  32
062CC:  MOVWF  xFC
062CE:  MOVF   xF7,W
062D0:  ANDLW  0F
062D2:  ADDWF  xFA,F
062D4:  ADDWF  xFA,F
062D6:  ADDWF  xFC,F
062D8:  ADDLW  E9
062DA:  MOVWF  xFB
062DC:  ADDWF  xFB,F
062DE:  ADDWF  xFB,F
062E0:  SWAPF  xF6,W
062E2:  ANDLW  0F
062E4:  ADDWF  xFB,F
062E6:  ADDWF  xFC,F
062E8:  RLCF   xFB,F
062EA:  RLCF   xFC,F
062EC:  COMF   xFC,F
062EE:  RLCF   xFC,F
062F0:  MOVF   xF6,W
062F2:  ANDLW  0F
062F4:  ADDWF  xFC,F
062F6:  RLCF   xF9,F
062F8:  MOVLW  07
062FA:  MOVWF  xF8
062FC:  MOVLW  0A
062FE:  DECF   xFB,F
06300:  ADDWF  xFC,F
06302:  BNC   62FE
06304:  DECF   xFA,F
06306:  ADDWF  xFB,F
06308:  BNC   6304
0630A:  DECF   xF9,F
0630C:  ADDWF  xFA,F
0630E:  BNC   630A
06310:  DECF   xF8,F
06312:  ADDWF  xF9,F
06314:  BNC   6310
06316:  MOVLW  08
06318:  MOVWF  FEA
0631A:  MOVLW  F8
0631C:  MOVWF  FE9
0631E:  MOVLW  07
06320:  ANDWF  xFD,W
06322:  BCF    xFD.6
06324:  MOVF   FED,F
06326:  ANDWF  xFD,W
06328:  BNZ   6338
0632A:  BTFSC  xFD.4
0632C:  MOVF   FEE,F
0632E:  BTFSC  xFD.4
06330:  BRA    6338
06332:  MOVLW  20
06334:  MOVWF  00
06336:  BRA    637A
06338:  ADDWF  FE9,F
0633A:  MOVLW  00
0633C:  ADDWFC FEA,F
0633E:  MOVF   FE9,W
06340:  SUBLW  FC
06342:  BNZ   634C
06344:  MOVF   FEA,W
06346:  SUBLW  08
06348:  BNZ   634C
0634A:  BSF    xFD.6
0634C:  MOVF   FEF,W
0634E:  MOVWF  00
06350:  BNZ   6362
06352:  BTFSC  xFD.6
06354:  BRA    6362
06356:  BTFSC  xFD.4
06358:  BRA    6396
0635A:  BTFSC  xFD.3
0635C:  BRA    6362
0635E:  MOVLW  20
06360:  BRA    6378
06362:  BTFSS  xFD.7
06364:  BRA    6372
06366:  MOVLW  2D
06368:  MOVWF  00
0636A:  MOVF   FED,W
0636C:  BCF    xFD.6
0636E:  BCF    xFD.7
06370:  BRA    637A
06372:  BSF    xFD.3
06374:  BCF    xFD.4
06376:  MOVLW  30
06378:  ADDWF  00,F
0637A:  MOVFF  FEA,8F7
0637E:  MOVFF  FE9,8F6
06382:  MOVFF  00,8FF
06386:  MOVLB  0
06388:  CALL   067A
0638C:  MOVFF  8F7,FEA
06390:  MOVFF  8F6,FE9
06394:  MOVLB  8
06396:  MOVF   FEE,W
06398:  BTFSS  xFD.6
0639A:  BRA    633E
0639C:  MOVLB  0
0639E:  GOTO   717E (RETURN)
*
0655E:  MOVLW  20
06560:  MOVLB  8
06562:  BTFSS  xF7.4
06564:  MOVLW  30
06566:  MOVWF  xF8
06568:  MOVFF  8F6,00
0656C:  BTFSS  xF6.7
0656E:  BRA    6580
06570:  COMF   00,F
06572:  INCF   00,F
06574:  MOVFF  00,8F6
06578:  MOVLW  2D
0657A:  MOVWF  xF8
0657C:  BSF    xF7.7
0657E:  BSF    xF7.0
06580:  MOVF   01,W
06582:  MOVFF  8F6,910
06586:  MOVLW  64
06588:  MOVLB  9
0658A:  MOVWF  x11
0658C:  MOVLB  0
0658E:  CALL   1582
06592:  MOVFF  00,8F6
06596:  MOVLW  30
06598:  ADDWF  01,W
0659A:  MOVLB  8
0659C:  MOVWF  xF9
0659E:  MOVFF  8F6,910
065A2:  MOVLW  0A
065A4:  MOVLB  9
065A6:  MOVWF  x11
065A8:  MOVLB  0
065AA:  CALL   1582
065AE:  MOVLW  30
065B0:  ADDWF  00,W
065B2:  MOVLB  8
065B4:  MOVWF  xFB
065B6:  MOVLW  30
065B8:  ADDWF  01,W
065BA:  MOVWF  xFA
065BC:  MOVFF  8F8,00
065C0:  MOVLW  30
065C2:  SUBWF  xF9,W
065C4:  BZ    65CE
065C6:  BSF    xF7.1
065C8:  BTFSC  xF7.7
065CA:  BSF    xF7.2
065CC:  BRA    65F2
065CE:  BTFSC  xF7.2
065D0:  BRA    65F2
065D2:  MOVFF  8F8,8F9
065D6:  BTFSC  xF7.1
065D8:  BRA    65E2
065DA:  MOVLW  30
065DC:  SUBWF  xFA,W
065DE:  BZ    65E8
065E0:  BSF    xF7.0
065E2:  BTFSC  xF7.7
065E4:  BSF    xF7.1
065E6:  BRA    65F2
065E8:  BTFSS  FD8.2
065EA:  BSF    xF7.0
065EC:  BTFSC  FD8.2
065EE:  MOVFF  8F9,8FA
065F2:  BTFSC  xF7.2
065F4:  BRA    6600
065F6:  BTFSC  xF7.1
065F8:  BRA    660A
065FA:  BTFSC  xF7.0
065FC:  BRA    6614
065FE:  BRA    661E
06600:  MOVFF  8F8,8FF
06604:  MOVLB  0
06606:  CALL   067A
0660A:  MOVFF  8F9,8FF
0660E:  MOVLB  0
06610:  CALL   067A
06614:  MOVFF  8FA,8FF
06618:  MOVLB  0
0661A:  CALL   067A
0661E:  MOVFF  8FB,8FF
06622:  MOVLB  0
06624:  CALL   067A
06628:  RETURN 0
....................  
.................... #list 
....................  
.................... // Conversor de 10 bits con justificación a la derecha. 
.................... //#device ADC=10 
.................... // Configuramos velocidad de operación. 
.................... #use delay(clock=40000000) // Trabajamos a 20.00Mhz.  
*
00600:  MOVLW  09
00602:  MOVWF  FEA
00604:  CLRF   FE9
00606:  MOVF   FEF,W
00608:  BZ    0626
0060A:  MOVLW  0C
0060C:  MOVWF  01
0060E:  CLRF   00
00610:  DECFSZ 00,F
00612:  BRA    0610
00614:  DECFSZ 01,F
00616:  BRA    060E
00618:  MOVLW  F7
0061A:  MOVWF  00
0061C:  DECFSZ 00,F
0061E:  BRA    061C
00620:  BRA    0622
00622:  DECFSZ FEF,F
00624:  BRA    060A
00626:  RETURN 0
....................  
.................... // Configuramos fusibles de programación. 
....................  
.................... #FUSES NOWDT                    // No utilizamos el perro guardían. 
.................... #FUSES H4                       // Oscilador de alta velocidad 40Mhz. 
.................... #FUSES FCMEN                    // Monitor de reloj activado. 
.................... #FUSES PUT                      // Temporizador de encendido. 
.................... #FUSES NOBROWNOUT               // No activamos el reset por bajo voltaje. 
.................... #FUSES NOPBADEN                 // Deshabilitamos el módulo conversor ADC del puerto B. 
.................... #FUSES NOLPT1OSC                // Timer 1 configurado para una alta potencia de operación. 
.................... //#FUSES NOMCLR                   // Pin Master Clear deshabilitado. 
.................... #FUSES MCLR                     // Pin Master Clear habilitado. 
.................... #FUSES STVREN                   // Si se rebalsa o llena el stack el microcontrolador se resetea. 
.................... #FUSES NOLVP                    // No utilizamos bajo voltaje para programación. 
.................... #FUSES NOXINST                  // Set de instruccciones ampliado, desactivado. 
.................... #FUSES NODEBUG                  // No utilizamos código para debug. 
.................... #FUSES PROTECT                  // Código protejido contra lecturas. 
.................... #FUSES NOCPB                    // Sector de booteo no protejido. 
.................... #FUSES NOCPD                    // Sin protección de código en la EEPROM. 
.................... #FUSES NOWRT                    // Memoria de programa no protejida contra escrituras. 
.................... #FUSES NOWRTC                   // Registros de configuración no protegido contra escritura. 
.................... #FUSES NOWRTB                   // Bloque de booteo no protejido contra escritura. 
.................... #FUSES NOWRTD                   // Memoria EEPROM no protejida contra escritura. 
.................... #FUSES NOEBTR                   // Memoria no protejida contra lectuas de tablas de memoria. 
.................... #FUSES NOEBTRB                  // Bloque de booteo no protejido contra lectura de tablas de memoria. 
....................  
.................... // Configuramos los puertos RS232 utilizados. 
.................... #use RS232(uart1, baud=38400,RESTART_WDT,stream=U1PRINTER,TIMEOUT=40,DISABLE_INTS) 
*
059B6:  CLRWDT
059B8:  BTFSS  F9E.4
059BA:  BRA    59B6
059BC:  MOVLB  9
059BE:  MOVFF  910,FAD
059C2:  MOVLB  0
059C4:  RETURN 0
....................  
.................... const int data_set=14;//CANTIDAD DE INSTRUCCIONES GRABADAS 
.................... const int port_size=90; 
.................... const int tag_size = 8; 
.................... const int word_size_reg =12;//TAMAÑO DE REGISTRO 
.................... const int16 lim_reg=300; 
.................... const int16 data_numbers_ext=2000;//maximo de tags en eeprom 
.................... const int instruccion_size = 10; 
....................  
.................... int envia_pc,a,b2,relay1,tcp_recibe,time_relay1,falla_grabar,f_graba; 
.................... char memory[30]; 
.................... int16 i,n,b,c_envia; 
.................... int size_tx_tcp,con_activas; 
.................... unsigned int16 m,dir; 
....................  
.................... int edo_str, reintento_envio,inicializado,socket2; 
.................... char XX[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RECIBIDOS DE TCP) 
.................... char YY[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RESPALDO EN RAM) 
.................... char txtcp[port_size];//ARREGLO DE TRANSMICION 
.................... char rxtcp[port_size];//1536->112 tags,se direcciona mal la ram con valores mas grandes 
.................... //500-alcanza para 54 tags, mas no alcanza la ram, 700au cabe 
.................... char lcd_men[port_size-10]; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size=26;//34;// 
.................... int deteccion_nulo,pre_cuenta; 
.................... int wieg,wigmal,tecla; 
.................... int sub_indice=0; 
.................... int wieg_full=0; 
.................... int wiegand_cuenta; 
.................... unsigned int32 deci; 
.................... char data[wieg_size]; 
.................... char con_barra[30],barra_codi[30]; 
.................... int32 folio; 
.................... const int idbar=1; 
.................... const int data_numbers=14; 
.................... //RELOJ/CALENDARIO 
.................... int day,month,yr,hrs,min,sec,dow,puntos,cambio_msj; 
.................... int dias_prueba,dia_temp,pago,cuenta,espera,hrs2; 
.................... int16 mes2,dia; 
.................... const int dia_limite=90; 
.................... //variables de entradas 
.................... int en1,en2,en3,en4,en5,flag_pluma; 
.................... //boleto 
.................... int time_boleto,re_bol,cta_lcd; 
.................... // Definimos macros hardware: 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00572:  MOVLB  9
00574:  BTFSC  x07.0
00576:  BRA    057C
00578:  BCF    F89.4
0057A:  BRA    057E
0057C:  BSF    F89.4
0057E:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00580:  BTFSC  x07.1
00582:  BRA    0588
00584:  BCF    F89.2
00586:  BRA    058A
00588:  BSF    F89.2
0058A:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0058C:  BTFSC  x07.2
0058E:  BRA    0594
00590:  BCF    F89.1
00592:  BRA    0596
00594:  BSF    F89.1
00596:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
00598:  BTFSC  x07.3
0059A:  BRA    05A0
0059C:  BCF    F89.0
0059E:  BRA    05A2
005A0:  BSF    F89.0
005A2:  BCF    F92.0
....................  
....................  delay_cycles(1);  
005A4:  NOP   
....................  output_high(LCD_E);  
005A6:  BCF    F92.3
005A8:  BSF    F89.3
....................  delay_us(2);  
005AA:  MOVLW  06
005AC:  MOVWF  00
005AE:  DECFSZ 00,F
005B0:  BRA    05AE
005B2:  NOP   
....................  output_low(LCD_E);  
005B4:  BCF    F92.3
005B6:  BCF    F89.3
005B8:  MOVLB  0
005BA:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
005BC:  BCF    F96.2
005BE:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
005C0:  MOVLW  C7
005C2:  MOVWF  00
005C4:  DECFSZ 00,F
005C6:  BRA    05C4
005C8:  BRA    05CA
.................... #endif  
....................  
.................... if(address)  
005CA:  MOVLB  9
005CC:  MOVF   x04,F
005CE:  BZ    05D6
....................    output_high(LCD_RS);  
005D0:  BCF    F96.2
005D2:  BSF    F8D.2
005D4:  BRA    05DA
.................... else  
....................    output_low(LCD_RS);  
005D6:  BCF    F96.2
005D8:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
005DA:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
005DC:  BCF    F92.3
005DE:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
005E0:  SWAPF  x05,W
005E2:  MOVWF  x06
005E4:  MOVLW  0F
005E6:  ANDWF  x06,F
005E8:  MOVFF  906,907
005EC:  MOVLB  0
005EE:  RCALL  0572
.................... lcd_send_nibble(n & 0xf);  
005F0:  MOVLB  9
005F2:  MOVF   x05,W
005F4:  ANDLW  0F
005F6:  MOVWF  x06
005F8:  MOVWF  x07
005FA:  MOVLB  0
005FC:  RCALL  0572
005FE:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
*
00706:  MOVLW  01
00708:  MOVLB  2
0070A:  MOVWF  x8C
....................  
....................    output_low(LCD_RS);  
0070C:  BCF    F96.2
0070E:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
00710:  BCF    F92.3
00712:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
00714:  MOVLW  23
00716:  MOVLB  9
00718:  MOVWF  x00
0071A:  MOVLB  0
0071C:  RCALL  0600
....................  
....................    for(i=0 ;i < 3; i++)  
0071E:  MOVLB  8
00720:  CLRF   xF6
00722:  MOVF   xF6,W
00724:  SUBLW  02
00726:  BNC   0742
....................    {  
....................       lcd_send_nibble(0x03);  
00728:  MOVLW  03
0072A:  MOVLB  9
0072C:  MOVWF  x07
0072E:  MOVLB  0
00730:  RCALL  0572
....................       delay_ms(5);  
00732:  MOVLW  05
00734:  MOVLB  9
00736:  MOVWF  x00
00738:  MOVLB  0
0073A:  RCALL  0600
0073C:  MOVLB  8
0073E:  INCF   xF6,F
00740:  BRA    0722
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
00742:  MOVLW  02
00744:  MOVLB  9
00746:  MOVWF  x07
00748:  MOVLB  0
0074A:  RCALL  0572
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0074C:  MOVLB  8
0074E:  CLRF   xF6
00750:  MOVF   xF6,W
00752:  SUBLW  03
00754:  BNC   077C
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
00756:  CLRF   03
00758:  MOVF   xF6,W
0075A:  MOVLB  0
0075C:  RCALL  00D2
0075E:  MOVLB  8
00760:  MOVWF  xF7
00762:  MOVLB  9
00764:  CLRF   x04
00766:  MOVWF  x05
00768:  MOVLB  0
0076A:  RCALL  05BC
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
0076C:  MOVLW  05
0076E:  MOVLB  9
00770:  MOVWF  x00
00772:  MOVLB  0
00774:  RCALL  0600
....................       #endif  
00776:  MOVLB  8
00778:  INCF   xF6,F
0077A:  BRA    0750
....................    }  
0077C:  MOVLB  0
0077E:  GOTO   6E7A (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
00628:  MOVLB  9
0062A:  MOVF   x01,W
0062C:  XORLW  01
0062E:  MOVLB  0
00630:  BZ    0640
00632:  XORLW  03
00634:  BZ    0646
00636:  XORLW  01
00638:  BZ    064E
0063A:  XORLW  07
0063C:  BZ    0656
0063E:  BRA    0660
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
00640:  MOVLB  9
00642:  CLRF   x02
....................      break;  
00644:  BRA    0664
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
00646:  MOVLW  40
00648:  MOVLB  9
0064A:  MOVWF  x02
....................      break;  
0064C:  BRA    0664
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0064E:  MOVLW  14
00650:  MOVLB  9
00652:  MOVWF  x02
....................      break;  
00654:  BRA    0664
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
00656:  MOVLW  54
00658:  MOVLB  9
0065A:  MOVWF  x02
....................      break;  
0065C:  BRA    0664
0065E:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
00660:  MOVLB  9
00662:  CLRF   x02
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
00664:  MOVLW  01
00666:  SUBWF  x00,W
00668:  ADDWF  x02,F
.................... lcd_send_byte(0, 0x80 | address);  
0066A:  MOVF   x02,W
0066C:  IORLW  80
0066E:  MOVWF  x03
00670:  CLRF   x04
00672:  MOVWF  x05
00674:  MOVLB  0
00676:  RCALL  05BC
00678:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
0067A:  MOVLB  8
0067C:  MOVF   xFF,W
0067E:  XORLW  0C
00680:  MOVLB  0
00682:  BZ    068E
00684:  XORLW  06
00686:  BZ    06AC
00688:  XORLW  02
0068A:  BZ    06C0
0068C:  BRA    06CE
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
0068E:  MOVLB  9
00690:  CLRF   x04
00692:  MOVLW  01
00694:  MOVWF  x05
00696:  MOVLB  0
00698:  RCALL  05BC
....................       lcd_line = 1;  
0069A:  MOVLW  01
0069C:  MOVLB  2
0069E:  MOVWF  x8C
....................       delay_ms(2);  
006A0:  MOVLW  02
006A2:  MOVLB  9
006A4:  MOVWF  x00
006A6:  MOVLB  0
006A8:  RCALL  0600
....................       break;  
006AA:  BRA    06DC
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
006AC:  MOVLB  2
006AE:  INCF   x8C,F
006B0:  MOVLW  01
006B2:  MOVLB  9
006B4:  MOVWF  x00
006B6:  MOVFF  28C,901
006BA:  MOVLB  0
006BC:  RCALL  0628
....................        break;  
006BE:  BRA    06DC
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
006C0:  MOVLB  9
006C2:  CLRF   x04
006C4:  MOVLW  10
006C6:  MOVWF  x05
006C8:  MOVLB  0
006CA:  RCALL  05BC
....................        break;  
006CC:  BRA    06DC
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
006CE:  MOVLW  01
006D0:  MOVLB  9
006D2:  MOVWF  x04
006D4:  MOVFF  8FF,905
006D8:  MOVLB  0
006DA:  RCALL  05BC
....................        break;  
....................    }  
006DC:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_SEGUINT.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B5//PIN_B7 
.................... #define EEPROM_SCL  PIN_B4//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
012C8:  MOVLW  08
012CA:  MOVWF  01
012CC:  MOVLW  0E
012CE:  MOVWF  00
012D0:  DECFSZ 00,F
012D2:  BRA    12D0
012D4:  BCF    F8A.4
012D6:  BCF    F93.4
012D8:  MOVLW  0E
012DA:  MOVWF  00
012DC:  DECFSZ 00,F
012DE:  BRA    12DC
012E0:  MOVLB  9
012E2:  RLCF   x0C,F
012E4:  BCF    F8A.5
012E6:  BTFSC  FD8.0
012E8:  BSF    F93.5
012EA:  BTFSS  FD8.0
012EC:  BCF    F93.5
012EE:  BSF    F93.4
012F0:  BTFSS  F81.4
012F2:  BRA    12F0
012F4:  DECFSZ 01,F
012F6:  BRA    12FA
012F8:  BRA    12FE
012FA:  MOVLB  0
012FC:  BRA    12CC
012FE:  MOVLW  0E
01300:  MOVWF  00
01302:  DECFSZ 00,F
01304:  BRA    1302
01306:  BCF    F8A.4
01308:  BCF    F93.4
0130A:  NOP   
0130C:  BSF    F93.5
0130E:  MOVLW  0E
01310:  MOVWF  00
01312:  DECFSZ 00,F
01314:  BRA    1312
01316:  MOVLW  0E
01318:  MOVWF  00
0131A:  DECFSZ 00,F
0131C:  BRA    131A
0131E:  BSF    F93.4
01320:  BTFSS  F81.4
01322:  BRA    1320
01324:  CLRF   01
01326:  MOVLW  0E
01328:  MOVWF  00
0132A:  DECFSZ 00,F
0132C:  BRA    132A
0132E:  BTFSC  F81.5
01330:  BSF    01.0
01332:  BCF    F8A.4
01334:  BCF    F93.4
01336:  BCF    F8A.5
01338:  BCF    F93.5
0133A:  MOVLB  0
0133C:  RETURN 0
0133E:  MOVLW  08
01340:  MOVLB  9
01342:  MOVWF  x0A
01344:  MOVFF  00,90B
01348:  BSF    F93.5
0134A:  MOVLW  0E
0134C:  MOVWF  00
0134E:  DECFSZ 00,F
01350:  BRA    134E
01352:  BSF    F93.4
01354:  BTFSS  F81.4
01356:  BRA    1354
01358:  BTFSC  F81.5
0135A:  BSF    FD8.0
0135C:  BTFSS  F81.5
0135E:  BCF    FD8.0
01360:  RLCF   01,F
01362:  MOVLW  0E
01364:  MOVWF  00
01366:  DECFSZ 00,F
01368:  BRA    1366
0136A:  BCF    F93.4
0136C:  BCF    F8A.4
0136E:  DECFSZ x0A,F
01370:  BRA    1348
01372:  BSF    F93.5
01374:  MOVLW  0E
01376:  MOVWF  00
01378:  DECFSZ 00,F
0137A:  BRA    1378
0137C:  BCF    F8A.5
0137E:  MOVF   x0B,W
01380:  BTFSS  FD8.2
01382:  BCF    F93.5
01384:  NOP   
01386:  BSF    F93.4
01388:  BTFSS  F81.4
0138A:  BRA    1388
0138C:  MOVLW  0E
0138E:  MOVWF  00
01390:  DECFSZ 00,F
01392:  BRA    1390
01394:  BCF    F8A.4
01396:  BCF    F93.4
01398:  MOVLW  0E
0139A:  MOVWF  00
0139C:  DECFSZ 00,F
0139E:  BRA    139C
013A0:  BCF    F8A.5
013A2:  BCF    F93.5
013A4:  MOVLB  0
013A6:  GOTO   1424 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
006FE:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
00700:  BSF    F93.5
00702:  GOTO   6E76 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data){ 
....................    short int status; 
....................    i2c_start(); 
*
01452:  BSF    F93.5
01454:  MOVLW  0E
01456:  MOVWF  00
01458:  DECFSZ 00,F
0145A:  BRA    1458
0145C:  BSF    F93.4
0145E:  MOVLW  0E
01460:  MOVWF  00
01462:  DECFSZ 00,F
01464:  BRA    1462
01466:  BCF    F8A.5
01468:  BCF    F93.5
0146A:  MOVLW  0E
0146C:  MOVWF  00
0146E:  DECFSZ 00,F
01470:  BRA    146E
01472:  BCF    F8A.4
01474:  BCF    F93.4
....................    i2c_write(0xa0); 
01476:  MOVLW  A0
01478:  MOVLB  9
0147A:  MOVWF  x0C
0147C:  MOVLB  0
0147E:  RCALL  12C8
....................    i2c_write(address>>8); 
01480:  MOVFF  907,90A
01484:  MOVLB  9
01486:  CLRF   x0B
01488:  MOVFF  907,90C
0148C:  MOVLB  0
0148E:  RCALL  12C8
....................    i2c_write(address); 
01490:  MOVFF  906,90C
01494:  RCALL  12C8
....................    i2c_write(data); 
01496:  MOVFF  908,90C
0149A:  RCALL  12C8
....................    i2c_stop(); 
0149C:  BCF    F93.5
0149E:  NOP   
014A0:  BSF    F93.4
014A2:  BTFSS  F81.4
014A4:  BRA    14A2
014A6:  MOVLW  0E
014A8:  MOVWF  00
014AA:  DECFSZ 00,F
014AC:  BRA    14AA
014AE:  BRA    14B0
014B0:  NOP   
014B2:  BSF    F93.5
014B4:  MOVLW  0E
014B6:  MOVWF  00
014B8:  DECFSZ 00,F
014BA:  BRA    14B8
....................    i2c_start(); 
014BC:  BSF    F93.5
014BE:  MOVLW  0E
014C0:  MOVWF  00
014C2:  DECFSZ 00,F
014C4:  BRA    14C2
014C6:  BSF    F93.4
014C8:  MOVLW  0E
014CA:  MOVWF  00
014CC:  DECFSZ 00,F
014CE:  BRA    14CC
014D0:  BCF    F8A.5
014D2:  BCF    F93.5
014D4:  MOVLW  0E
014D6:  MOVWF  00
014D8:  DECFSZ 00,F
014DA:  BRA    14D8
014DC:  BCF    F8A.4
014DE:  BCF    F93.4
....................    status=i2c_write(0xa0); 
014E0:  MOVLW  A0
014E2:  MOVLB  9
014E4:  MOVWF  x0C
014E6:  MOVLB  0
014E8:  RCALL  12C8
014EA:  MOVF   01,W
014EC:  MOVLB  9
014EE:  BCF    x09.0
014F0:  BTFSC  01.0
014F2:  BSF    x09.0
....................    while(status==1) 
014F4:  BTFSS  x09.0
014F6:  BRA    1534
....................    { 
....................    i2c_start(); 
014F8:  BSF    F93.5
014FA:  MOVLW  0E
014FC:  MOVWF  00
014FE:  DECFSZ 00,F
01500:  BRA    14FE
01502:  BSF    F93.4
01504:  MOVLW  0E
01506:  MOVWF  00
01508:  DECFSZ 00,F
0150A:  BRA    1508
0150C:  BTFSS  F81.4
0150E:  BRA    150C
01510:  BCF    F8A.5
01512:  BCF    F93.5
01514:  MOVLW  0E
01516:  MOVWF  00
01518:  DECFSZ 00,F
0151A:  BRA    1518
0151C:  BCF    F8A.4
0151E:  BCF    F93.4
....................    status=i2c_write(0xa0); 
01520:  MOVLW  A0
01522:  MOVWF  x0C
01524:  MOVLB  0
01526:  RCALL  12C8
01528:  MOVF   01,W
0152A:  MOVLB  9
0152C:  BCF    x09.0
0152E:  BTFSC  01.0
01530:  BSF    x09.0
01532:  BRA    14F4
....................    } 
....................    i2c_stop(); 
01534:  BCF    F93.5
01536:  NOP   
01538:  BSF    F93.4
0153A:  BTFSS  F81.4
0153C:  BRA    153A
0153E:  MOVLW  0E
01540:  MOVWF  00
01542:  DECFSZ 00,F
01544:  BRA    1542
01546:  BRA    1548
01548:  NOP   
0154A:  BSF    F93.5
0154C:  MOVLW  0E
0154E:  MOVWF  00
01550:  DECFSZ 00,F
01552:  BRA    1550
01554:  MOVLB  0
01556:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
013AA:  BSF    F93.5
013AC:  MOVLW  0E
013AE:  MOVWF  00
013B0:  DECFSZ 00,F
013B2:  BRA    13B0
013B4:  BSF    F93.4
013B6:  MOVLW  0E
013B8:  MOVWF  00
013BA:  DECFSZ 00,F
013BC:  BRA    13BA
013BE:  BCF    F8A.5
013C0:  BCF    F93.5
013C2:  MOVLW  0E
013C4:  MOVWF  00
013C6:  DECFSZ 00,F
013C8:  BRA    13C6
013CA:  BCF    F8A.4
013CC:  BCF    F93.4
....................    i2c_write(0xa0); 
013CE:  MOVLW  A0
013D0:  MOVLB  9
013D2:  MOVWF  x0C
013D4:  MOVLB  0
013D6:  RCALL  12C8
....................    i2c_write(address>>8); 
013D8:  MOVFF  907,909
013DC:  MOVLB  9
013DE:  CLRF   x0A
013E0:  MOVFF  907,90C
013E4:  MOVLB  0
013E6:  RCALL  12C8
....................    i2c_write(address); 
013E8:  MOVFF  906,90C
013EC:  RCALL  12C8
....................    i2c_start(); 
013EE:  BSF    F93.5
013F0:  MOVLW  0E
013F2:  MOVWF  00
013F4:  DECFSZ 00,F
013F6:  BRA    13F4
013F8:  BSF    F93.4
013FA:  MOVLW  0E
013FC:  MOVWF  00
013FE:  DECFSZ 00,F
01400:  BRA    13FE
01402:  BTFSS  F81.4
01404:  BRA    1402
01406:  BCF    F8A.5
01408:  BCF    F93.5
0140A:  MOVLW  0E
0140C:  MOVWF  00
0140E:  DECFSZ 00,F
01410:  BRA    140E
01412:  BCF    F8A.4
01414:  BCF    F93.4
....................    i2c_write(0xa1); 
01416:  MOVLW  A1
01418:  MOVLB  9
0141A:  MOVWF  x0C
0141C:  MOVLB  0
0141E:  RCALL  12C8
....................    data=i2c_read(0); 
01420:  CLRF   00
01422:  BRA    133E
01424:  MOVFF  01,908
....................    i2c_stop(); 
01428:  BCF    F93.5
0142A:  NOP   
0142C:  BSF    F93.4
0142E:  BTFSS  F81.4
01430:  BRA    142E
01432:  MOVLW  0E
01434:  MOVWF  00
01436:  DECFSZ 00,F
01438:  BRA    1436
0143A:  BRA    143C
0143C:  NOP   
0143E:  BSF    F93.5
01440:  MOVLW  0E
01442:  MOVWF  00
01444:  DECFSZ 00,F
01446:  BRA    1444
....................    return(data); 
01448:  MOVLB  9
0144A:  MOVFF  908,01
0144E:  MOVLB  0
01450:  RETURN 0
.................... } 
....................  
.................... #include "ds1307_3.c" //reloj 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_D6 
.................... #define RTC_SCL  PIN_E1 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
058AC:  MOVLW  08
058AE:  MOVWF  01
058B0:  MOVLW  0E
058B2:  MOVWF  00
058B4:  DECFSZ 00,F
058B6:  BRA    58B4
058B8:  BCF    F8D.1
058BA:  BCF    F96.1
058BC:  MOVLW  0E
058BE:  MOVWF  00
058C0:  DECFSZ 00,F
058C2:  BRA    58C0
058C4:  MOVLB  9
058C6:  RLCF   x0E,F
058C8:  BCF    F8C.6
058CA:  BTFSC  FD8.0
058CC:  BSF    F95.6
058CE:  BTFSS  FD8.0
058D0:  BCF    F95.6
058D2:  BSF    F96.1
058D4:  BTFSS  F84.1
058D6:  BRA    58D4
058D8:  DECFSZ 01,F
058DA:  BRA    58DE
058DC:  BRA    58E2
058DE:  MOVLB  0
058E0:  BRA    58B0
058E2:  MOVLW  0E
058E4:  MOVWF  00
058E6:  DECFSZ 00,F
058E8:  BRA    58E6
058EA:  BCF    F8D.1
058EC:  BCF    F96.1
058EE:  NOP   
058F0:  BSF    F95.6
058F2:  MOVLW  0E
058F4:  MOVWF  00
058F6:  DECFSZ 00,F
058F8:  BRA    58F6
058FA:  MOVLW  0E
058FC:  MOVWF  00
058FE:  DECFSZ 00,F
05900:  BRA    58FE
05902:  BSF    F96.1
05904:  BTFSS  F84.1
05906:  BRA    5904
05908:  CLRF   01
0590A:  MOVLW  0E
0590C:  MOVWF  00
0590E:  DECFSZ 00,F
05910:  BRA    590E
05912:  BTFSC  F83.6
05914:  BSF    01.0
05916:  BCF    F8D.1
05918:  BCF    F96.1
0591A:  BCF    F8C.6
0591C:  BCF    F95.6
0591E:  MOVLB  0
05920:  RETURN 0
05922:  MOVLW  08
05924:  MOVLB  9
05926:  MOVWF  x0F
05928:  MOVFF  00,910
0592C:  BSF    F95.6
0592E:  MOVLW  0E
05930:  MOVWF  00
05932:  DECFSZ 00,F
05934:  BRA    5932
05936:  BSF    F96.1
05938:  BTFSS  F84.1
0593A:  BRA    5938
0593C:  BTFSC  F83.6
0593E:  BSF    FD8.0
05940:  BTFSS  F83.6
05942:  BCF    FD8.0
05944:  RLCF   01,F
05946:  MOVLW  0E
05948:  MOVWF  00
0594A:  DECFSZ 00,F
0594C:  BRA    594A
0594E:  BCF    F96.1
05950:  BCF    F8D.1
05952:  DECFSZ x0F,F
05954:  BRA    592C
05956:  BSF    F95.6
05958:  MOVLW  0E
0595A:  MOVWF  00
0595C:  DECFSZ 00,F
0595E:  BRA    595C
05960:  BCF    F8C.6
05962:  MOVF   x10,W
05964:  BTFSS  FD8.2
05966:  BCF    F95.6
05968:  NOP   
0596A:  BSF    F96.1
0596C:  BTFSS  F84.1
0596E:  BRA    596C
05970:  MOVLW  0E
05972:  MOVWF  00
05974:  DECFSZ 00,F
05976:  BRA    5974
05978:  BCF    F8D.1
0597A:  BCF    F96.1
0597C:  MOVLW  0E
0597E:  MOVWF  00
05980:  DECFSZ 00,F
05982:  BRA    5980
05984:  BCF    F8C.6
05986:  BCF    F95.6
05988:  MOVLB  0
0598A:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
....................  
.................... }  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
*
06472:  MOVLB  9
06474:  BCF    x0C.7
....................   hr &= 0x3F;  
06476:  MOVLW  3F
06478:  ANDWF  x0A,F
....................  
....................   i2c_start();  
0647A:  BSF    F95.6
0647C:  MOVLW  0E
0647E:  MOVWF  00
06480:  DECFSZ 00,F
06482:  BRA    6480
06484:  BSF    F96.1
06486:  MOVLW  0E
06488:  MOVWF  00
0648A:  DECFSZ 00,F
0648C:  BRA    648A
0648E:  BCF    F8C.6
06490:  BCF    F95.6
06492:  MOVLW  0E
06494:  MOVWF  00
06496:  DECFSZ 00,F
06498:  BRA    6496
0649A:  BCF    F8D.1
0649C:  BCF    F96.1
....................   i2c_write(0xD0);            // I2C write address  
0649E:  MOVLW  D0
064A0:  MOVWF  x0E
064A2:  MOVLB  0
064A4:  CALL   58AC
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
064A8:  MOVLB  9
064AA:  CLRF   x0E
064AC:  MOVLB  0
064AE:  CALL   58AC
....................   i2c_write(bin2bcd(sec));      // REG 0  
064B2:  MOVFF  90C,90D
064B6:  RCALL  644A
064B8:  MOVFF  01,90D
064BC:  MOVFF  01,90E
064C0:  CALL   58AC
....................   i2c_write(bin2bcd(min));      // REG 1  
064C4:  MOVFF  90B,90D
064C8:  RCALL  644A
064CA:  MOVFF  01,90D
064CE:  MOVFF  01,90E
064D2:  CALL   58AC
....................   i2c_write(bin2bcd(hr));      // REG 2  
064D6:  MOVFF  90A,90D
064DA:  RCALL  644A
064DC:  MOVFF  01,90D
064E0:  MOVFF  01,90E
064E4:  CALL   58AC
....................   i2c_write(bin2bcd(dow));      // REG 3  
064E8:  MOVFF  909,90D
064EC:  RCALL  644A
064EE:  MOVFF  01,90D
064F2:  MOVFF  01,90E
064F6:  CALL   58AC
....................   i2c_write(bin2bcd(day));      // REG 4  
064FA:  MOVFF  906,90D
064FE:  RCALL  644A
06500:  MOVFF  01,90D
06504:  MOVFF  01,90E
06508:  CALL   58AC
....................   i2c_write(bin2bcd(mth));      // REG 5  
0650C:  MOVFF  907,90D
06510:  RCALL  644A
06512:  MOVFF  01,90D
06516:  MOVFF  01,90E
0651A:  CALL   58AC
....................   i2c_write(bin2bcd(year));      // REG 6  
0651E:  MOVFF  908,90D
06522:  RCALL  644A
06524:  MOVFF  01,90D
06528:  MOVFF  01,90E
0652C:  CALL   58AC
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
06530:  MOVLW  80
06532:  MOVLB  9
06534:  MOVWF  x0E
06536:  MOVLB  0
06538:  CALL   58AC
....................   i2c_stop();  
0653C:  BCF    F95.6
0653E:  NOP   
06540:  BSF    F96.1
06542:  BTFSS  F84.1
06544:  BRA    6542
06546:  MOVLW  0E
06548:  MOVWF  00
0654A:  DECFSZ 00,F
0654C:  BRA    654A
0654E:  BRA    6550
06550:  NOP   
06552:  BSF    F95.6
06554:  MOVLW  0E
06556:  MOVWF  00
06558:  DECFSZ 00,F
0655A:  BRA    6558
0655C:  RETURN 0
.................... }  
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
*
05C40:  BSF    F95.6
05C42:  MOVLW  0E
05C44:  MOVWF  00
05C46:  DECFSZ 00,F
05C48:  BRA    5C46
05C4A:  BSF    F96.1
05C4C:  MOVLW  0E
05C4E:  MOVWF  00
05C50:  DECFSZ 00,F
05C52:  BRA    5C50
05C54:  BCF    F8C.6
05C56:  BCF    F95.6
05C58:  MOVLW  0E
05C5A:  MOVWF  00
05C5C:  DECFSZ 00,F
05C5E:  BRA    5C5C
05C60:  BCF    F8D.1
05C62:  BCF    F96.1
*
06A00:  BSF    F95.6
06A02:  MOVLW  0E
06A04:  MOVWF  00
06A06:  DECFSZ 00,F
06A08:  BRA    6A06
06A0A:  BSF    F96.1
06A0C:  MOVLW  0E
06A0E:  MOVWF  00
06A10:  DECFSZ 00,F
06A12:  BRA    6A10
06A14:  BCF    F8C.6
06A16:  BCF    F95.6
06A18:  MOVLW  0E
06A1A:  MOVWF  00
06A1C:  DECFSZ 00,F
06A1E:  BRA    6A1C
06A20:  BCF    F8D.1
06A22:  BCF    F96.1
*
0751E:  BSF    F95.6
07520:  MOVLW  0E
07522:  MOVWF  00
07524:  DECFSZ 00,F
07526:  BRA    7524
07528:  BSF    F96.1
0752A:  MOVLW  0E
0752C:  MOVWF  00
0752E:  DECFSZ 00,F
07530:  BRA    752E
07532:  BCF    F8C.6
07534:  BCF    F95.6
07536:  MOVLW  0E
07538:  MOVWF  00
0753A:  DECFSZ 00,F
0753C:  BRA    753A
0753E:  BCF    F8D.1
07540:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05C64:  MOVLW  D0
05C66:  MOVLB  9
05C68:  MOVWF  x0E
05C6A:  MOVLB  0
05C6C:  RCALL  58AC
*
06A24:  MOVLW  D0
06A26:  MOVWF  x0E
06A28:  MOVLB  0
06A2A:  CALL   58AC
*
07542:  MOVLW  D0
07544:  MOVLB  9
07546:  MOVWF  x0E
07548:  MOVLB  0
0754A:  CALL   58AC
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
*
05C6E:  MOVLW  03
05C70:  MOVLB  9
05C72:  MOVWF  x0E
05C74:  MOVLB  0
05C76:  RCALL  58AC
*
06A2E:  MOVLW  03
06A30:  MOVLB  9
06A32:  MOVWF  x0E
06A34:  MOVLB  0
06A36:  CALL   58AC
*
0754E:  MOVLW  03
07550:  MOVLB  9
07552:  MOVWF  x0E
07554:  MOVLB  0
07556:  CALL   58AC
....................   i2c_start();  
*
05C78:  BSF    F95.6
05C7A:  MOVLW  0E
05C7C:  MOVWF  00
05C7E:  DECFSZ 00,F
05C80:  BRA    5C7E
05C82:  BSF    F96.1
05C84:  MOVLW  0E
05C86:  MOVWF  00
05C88:  DECFSZ 00,F
05C8A:  BRA    5C88
05C8C:  BTFSS  F84.1
05C8E:  BRA    5C8C
05C90:  BCF    F8C.6
05C92:  BCF    F95.6
05C94:  MOVLW  0E
05C96:  MOVWF  00
05C98:  DECFSZ 00,F
05C9A:  BRA    5C98
05C9C:  BCF    F8D.1
05C9E:  BCF    F96.1
*
06A3A:  BSF    F95.6
06A3C:  MOVLW  0E
06A3E:  MOVWF  00
06A40:  DECFSZ 00,F
06A42:  BRA    6A40
06A44:  BSF    F96.1
06A46:  MOVLW  0E
06A48:  MOVWF  00
06A4A:  DECFSZ 00,F
06A4C:  BRA    6A4A
06A4E:  BTFSS  F84.1
06A50:  BRA    6A4E
06A52:  BCF    F8C.6
06A54:  BCF    F95.6
06A56:  MOVLW  0E
06A58:  MOVWF  00
06A5A:  DECFSZ 00,F
06A5C:  BRA    6A5A
06A5E:  BCF    F8D.1
06A60:  BCF    F96.1
*
0755A:  BSF    F95.6
0755C:  MOVLW  0E
0755E:  MOVWF  00
07560:  DECFSZ 00,F
07562:  BRA    7560
07564:  BSF    F96.1
07566:  MOVLW  0E
07568:  MOVWF  00
0756A:  DECFSZ 00,F
0756C:  BRA    756A
0756E:  BTFSS  F84.1
07570:  BRA    756E
07572:  BCF    F8C.6
07574:  BCF    F95.6
07576:  MOVLW  0E
07578:  MOVWF  00
0757A:  DECFSZ 00,F
0757C:  BRA    757A
0757E:  BCF    F8D.1
07580:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05CA0:  MOVLW  D1
05CA2:  MOVLB  9
05CA4:  MOVWF  x0E
05CA6:  MOVLB  0
05CA8:  RCALL  58AC
*
06A62:  MOVLW  D1
06A64:  MOVLB  9
06A66:  MOVWF  x0E
06A68:  MOVLB  0
06A6A:  CALL   58AC
*
07582:  MOVLW  D1
07584:  MOVLB  9
07586:  MOVWF  x0E
07588:  MOVLB  0
0758A:  CALL   58AC
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
*
05CAA:  MOVLW  01
05CAC:  MOVWF  00
05CAE:  RCALL  5922
05CB0:  MOVF   01,W
05CB2:  ANDLW  7F
05CB4:  MOVLB  9
05CB6:  MOVWF  x0A
05CB8:  MOVWF  x0F
05CBA:  MOVLB  0
05CBC:  RCALL  598C
05CBE:  MOVFF  01,276
*
06A6E:  MOVLW  01
06A70:  MOVWF  00
06A72:  CALL   5922
06A76:  MOVF   01,W
06A78:  ANDLW  7F
06A7A:  MOVLB  9
06A7C:  MOVWF  x0A
06A7E:  MOVWF  x0F
06A80:  MOVLB  0
06A82:  CALL   598C
06A86:  MOVFF  01,276
*
0758E:  MOVLW  01
07590:  MOVWF  00
07592:  CALL   5922
07596:  MOVF   01,W
07598:  ANDLW  7F
0759A:  MOVLB  9
0759C:  MOVWF  x0A
0759E:  MOVWF  x0F
075A0:  MOVLB  0
075A2:  CALL   598C
075A6:  MOVFF  01,276
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
*
05CC2:  MOVLW  01
05CC4:  MOVWF  00
05CC6:  RCALL  5922
05CC8:  MOVF   01,W
05CCA:  ANDLW  3F
05CCC:  MOVLB  9
05CCE:  MOVWF  x0A
05CD0:  MOVWF  x0F
05CD2:  MOVLB  0
05CD4:  RCALL  598C
05CD6:  MOVFF  01,270
*
06A8A:  MOVLW  01
06A8C:  MOVWF  00
06A8E:  CALL   5922
06A92:  MOVF   01,W
06A94:  ANDLW  3F
06A96:  MOVLB  9
06A98:  MOVWF  x0A
06A9A:  MOVWF  x0F
06A9C:  MOVLB  0
06A9E:  CALL   598C
06AA2:  MOVFF  01,270
*
075AA:  MOVLW  01
075AC:  MOVWF  00
075AE:  CALL   5922
075B2:  MOVF   01,W
075B4:  ANDLW  3F
075B6:  MOVLB  9
075B8:  MOVWF  x0A
075BA:  MOVWF  x0F
075BC:  MOVLB  0
075BE:  CALL   598C
075C2:  MOVFF  01,270
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
*
05CDA:  MOVLW  01
05CDC:  MOVWF  00
05CDE:  RCALL  5922
05CE0:  MOVF   01,W
05CE2:  ANDLW  1F
05CE4:  MOVLB  9
05CE6:  MOVWF  x0A
05CE8:  MOVWF  x0F
05CEA:  MOVLB  0
05CEC:  RCALL  598C
05CEE:  MOVFF  01,271
*
06AA6:  MOVLW  01
06AA8:  MOVWF  00
06AAA:  CALL   5922
06AAE:  MOVF   01,W
06AB0:  ANDLW  1F
06AB2:  MOVLB  9
06AB4:  MOVWF  x0A
06AB6:  MOVWF  x0F
06AB8:  MOVLB  0
06ABA:  CALL   598C
06ABE:  MOVFF  01,271
*
075C6:  MOVLW  01
075C8:  MOVWF  00
075CA:  CALL   5922
075CE:  MOVF   01,W
075D0:  ANDLW  1F
075D2:  MOVLB  9
075D4:  MOVWF  x0A
075D6:  MOVWF  x0F
075D8:  MOVLB  0
075DA:  CALL   598C
075DE:  MOVFF  01,271
....................   year = bcd2bin(i2c_read(0));            // REG 6  
*
05CF2:  CLRF   00
05CF4:  RCALL  5922
05CF6:  MOVFF  01,90A
05CFA:  MOVFF  01,90F
05CFE:  RCALL  598C
05D00:  MOVFF  01,272
*
06AC2:  CLRF   00
06AC4:  CALL   5922
06AC8:  MOVFF  01,90A
06ACC:  MOVFF  01,90F
06AD0:  CALL   598C
06AD4:  MOVFF  01,272
*
075E2:  CLRF   00
075E4:  CALL   5922
075E8:  MOVFF  01,90A
075EC:  MOVFF  01,90F
075F0:  CALL   598C
075F4:  MOVFF  01,272
....................   i2c_stop();  
*
05D04:  BCF    F95.6
05D06:  NOP   
05D08:  BSF    F96.1
05D0A:  BTFSS  F84.1
05D0C:  BRA    5D0A
05D0E:  MOVLW  0E
05D10:  MOVWF  00
05D12:  DECFSZ 00,F
05D14:  BRA    5D12
05D16:  BRA    5D18
05D18:  NOP   
05D1A:  BSF    F95.6
05D1C:  MOVLW  0E
05D1E:  MOVWF  00
05D20:  DECFSZ 00,F
05D22:  BRA    5D20
*
06AD8:  BCF    F95.6
06ADA:  NOP   
06ADC:  BSF    F96.1
06ADE:  BTFSS  F84.1
06AE0:  BRA    6ADE
06AE2:  MOVLW  0E
06AE4:  MOVWF  00
06AE6:  DECFSZ 00,F
06AE8:  BRA    6AE6
06AEA:  BRA    6AEC
06AEC:  NOP   
06AEE:  BSF    F95.6
06AF0:  MOVLW  0E
06AF2:  MOVWF  00
06AF4:  DECFSZ 00,F
06AF6:  BRA    6AF4
*
075F8:  BCF    F95.6
075FA:  NOP   
075FC:  BSF    F96.1
075FE:  BTFSS  F84.1
07600:  BRA    75FE
07602:  MOVLW  0E
07604:  MOVWF  00
07606:  DECFSZ 00,F
07608:  BRA    7606
0760A:  BRA    760C
0760C:  NOP   
0760E:  BSF    F95.6
07610:  MOVLW  0E
07612:  MOVWF  00
07614:  DECFSZ 00,F
07616:  BRA    7614
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
05D24:  BSF    F95.6
05D26:  MOVLW  0E
05D28:  MOVWF  00
05D2A:  DECFSZ 00,F
05D2C:  BRA    5D2A
05D2E:  BSF    F96.1
05D30:  MOVLW  0E
05D32:  MOVWF  00
05D34:  DECFSZ 00,F
05D36:  BRA    5D34
05D38:  BCF    F8C.6
05D3A:  BCF    F95.6
05D3C:  MOVLW  0E
05D3E:  MOVWF  00
05D40:  DECFSZ 00,F
05D42:  BRA    5D40
05D44:  BCF    F8D.1
05D46:  BCF    F96.1
*
06AF8:  BSF    F95.6
06AFA:  MOVLW  0E
06AFC:  MOVWF  00
06AFE:  DECFSZ 00,F
06B00:  BRA    6AFE
06B02:  BSF    F96.1
06B04:  MOVLW  0E
06B06:  MOVWF  00
06B08:  DECFSZ 00,F
06B0A:  BRA    6B08
06B0C:  BCF    F8C.6
06B0E:  BCF    F95.6
06B10:  MOVLW  0E
06B12:  MOVWF  00
06B14:  DECFSZ 00,F
06B16:  BRA    6B14
06B18:  BCF    F8D.1
06B1A:  BCF    F96.1
*
0743E:  BSF    F95.6
07440:  MOVLW  0E
07442:  MOVWF  00
07444:  DECFSZ 00,F
07446:  BRA    7444
07448:  BSF    F96.1
0744A:  MOVLW  0E
0744C:  MOVWF  00
0744E:  DECFSZ 00,F
07450:  BRA    744E
07452:  BCF    F8C.6
07454:  BCF    F95.6
07456:  MOVLW  0E
07458:  MOVWF  00
0745A:  DECFSZ 00,F
0745C:  BRA    745A
0745E:  BCF    F8D.1
07460:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05D48:  MOVLW  D0
05D4A:  MOVLB  9
05D4C:  MOVWF  x0E
05D4E:  MOVLB  0
05D50:  RCALL  58AC
*
06B1C:  MOVLW  D0
06B1E:  MOVLB  9
06B20:  MOVWF  x0E
06B22:  MOVLB  0
06B24:  CALL   58AC
*
07462:  MOVLW  D0
07464:  MOVLB  9
07466:  MOVWF  x0E
07468:  MOVLB  0
0746A:  CALL   58AC
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
*
05D52:  MOVLB  9
05D54:  CLRF   x0E
05D56:  MOVLB  0
05D58:  RCALL  58AC
*
06B28:  MOVLB  9
06B2A:  CLRF   x0E
06B2C:  MOVLB  0
06B2E:  CALL   58AC
*
0746E:  MOVLB  9
07470:  CLRF   x0E
07472:  MOVLB  0
07474:  CALL   58AC
....................   i2c_start();  
*
05D5A:  BSF    F95.6
05D5C:  MOVLW  0E
05D5E:  MOVWF  00
05D60:  DECFSZ 00,F
05D62:  BRA    5D60
05D64:  BSF    F96.1
05D66:  MOVLW  0E
05D68:  MOVWF  00
05D6A:  DECFSZ 00,F
05D6C:  BRA    5D6A
05D6E:  BTFSS  F84.1
05D70:  BRA    5D6E
05D72:  BCF    F8C.6
05D74:  BCF    F95.6
05D76:  MOVLW  0E
05D78:  MOVWF  00
05D7A:  DECFSZ 00,F
05D7C:  BRA    5D7A
05D7E:  BCF    F8D.1
05D80:  BCF    F96.1
*
06B32:  BSF    F95.6
06B34:  MOVLW  0E
06B36:  MOVWF  00
06B38:  DECFSZ 00,F
06B3A:  BRA    6B38
06B3C:  BSF    F96.1
06B3E:  MOVLW  0E
06B40:  MOVWF  00
06B42:  DECFSZ 00,F
06B44:  BRA    6B42
06B46:  BTFSS  F84.1
06B48:  BRA    6B46
06B4A:  BCF    F8C.6
06B4C:  BCF    F95.6
06B4E:  MOVLW  0E
06B50:  MOVWF  00
06B52:  DECFSZ 00,F
06B54:  BRA    6B52
06B56:  BCF    F8D.1
06B58:  BCF    F96.1
*
07478:  BSF    F95.6
0747A:  MOVLW  0E
0747C:  MOVWF  00
0747E:  DECFSZ 00,F
07480:  BRA    747E
07482:  BSF    F96.1
07484:  MOVLW  0E
07486:  MOVWF  00
07488:  DECFSZ 00,F
0748A:  BRA    7488
0748C:  BTFSS  F84.1
0748E:  BRA    748C
07490:  BCF    F8C.6
07492:  BCF    F95.6
07494:  MOVLW  0E
07496:  MOVWF  00
07498:  DECFSZ 00,F
0749A:  BRA    7498
0749C:  BCF    F8D.1
0749E:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05D82:  MOVLW  D1
05D84:  MOVLB  9
05D86:  MOVWF  x0E
05D88:  MOVLB  0
05D8A:  RCALL  58AC
*
06B5A:  MOVLW  D1
06B5C:  MOVLB  9
06B5E:  MOVWF  x0E
06B60:  MOVLB  0
06B62:  CALL   58AC
*
074A0:  MOVLW  D1
074A2:  MOVLB  9
074A4:  MOVWF  x0E
074A6:  MOVLB  0
074A8:  CALL   58AC
....................   sec = bcd2bin(i2c_read() & 0x7f);  
*
05D8C:  MOVLW  01
05D8E:  MOVWF  00
05D90:  RCALL  5922
05D92:  MOVF   01,W
05D94:  ANDLW  7F
05D96:  MOVLB  9
05D98:  MOVWF  x0A
05D9A:  MOVWF  x0F
05D9C:  MOVLB  0
05D9E:  RCALL  598C
05DA0:  MOVFF  01,275
*
06B66:  MOVLW  01
06B68:  MOVWF  00
06B6A:  CALL   5922
06B6E:  MOVF   01,W
06B70:  ANDLW  7F
06B72:  MOVLB  9
06B74:  MOVWF  x0A
06B76:  MOVWF  x0F
06B78:  MOVLB  0
06B7A:  CALL   598C
06B7E:  MOVFF  01,275
*
074AC:  MOVLW  01
074AE:  MOVWF  00
074B0:  CALL   5922
074B4:  MOVF   01,W
074B6:  ANDLW  7F
074B8:  MOVLB  9
074BA:  MOVWF  x0A
074BC:  MOVWF  x0F
074BE:  MOVLB  0
074C0:  CALL   598C
074C4:  MOVFF  01,275
....................   min = bcd2bin(i2c_read() & 0x7f);  
*
05DA4:  MOVLW  01
05DA6:  MOVWF  00
05DA8:  RCALL  5922
05DAA:  MOVF   01,W
05DAC:  ANDLW  7F
05DAE:  MOVLB  9
05DB0:  MOVWF  x0A
05DB2:  MOVWF  x0F
05DB4:  MOVLB  0
05DB6:  RCALL  598C
05DB8:  MOVFF  01,274
*
06B82:  MOVLW  01
06B84:  MOVWF  00
06B86:  CALL   5922
06B8A:  MOVF   01,W
06B8C:  ANDLW  7F
06B8E:  MOVLB  9
06B90:  MOVWF  x0A
06B92:  MOVWF  x0F
06B94:  MOVLB  0
06B96:  CALL   598C
06B9A:  MOVFF  01,274
*
074C8:  MOVLW  01
074CA:  MOVWF  00
074CC:  CALL   5922
074D0:  MOVF   01,W
074D2:  ANDLW  7F
074D4:  MOVLB  9
074D6:  MOVWF  x0A
074D8:  MOVWF  x0F
074DA:  MOVLB  0
074DC:  CALL   598C
074E0:  MOVFF  01,274
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
*
05DBC:  CLRF   00
05DBE:  RCALL  5922
05DC0:  MOVF   01,W
05DC2:  ANDLW  3F
05DC4:  MOVLB  9
05DC6:  MOVWF  x0A
05DC8:  MOVWF  x0F
05DCA:  MOVLB  0
05DCC:  RCALL  598C
05DCE:  MOVFF  01,273
*
06B9E:  CLRF   00
06BA0:  CALL   5922
06BA4:  MOVF   01,W
06BA6:  ANDLW  3F
06BA8:  MOVLB  9
06BAA:  MOVWF  x0A
06BAC:  MOVWF  x0F
06BAE:  MOVLB  0
06BB0:  CALL   598C
06BB4:  MOVFF  01,273
*
074E4:  CLRF   00
074E6:  CALL   5922
074EA:  MOVF   01,W
074EC:  ANDLW  3F
074EE:  MOVLB  9
074F0:  MOVWF  x0A
074F2:  MOVWF  x0F
074F4:  MOVLB  0
074F6:  CALL   598C
074FA:  MOVFF  01,273
....................   i2c_stop();  
*
05DD2:  BCF    F95.6
05DD4:  NOP   
05DD6:  BSF    F96.1
05DD8:  BTFSS  F84.1
05DDA:  BRA    5DD8
05DDC:  MOVLW  0E
05DDE:  MOVWF  00
05DE0:  DECFSZ 00,F
05DE2:  BRA    5DE0
05DE4:  BRA    5DE6
05DE6:  NOP   
05DE8:  BSF    F95.6
05DEA:  MOVLW  0E
05DEC:  MOVWF  00
05DEE:  DECFSZ 00,F
05DF0:  BRA    5DEE
*
06BB8:  BCF    F95.6
06BBA:  NOP   
06BBC:  BSF    F96.1
06BBE:  BTFSS  F84.1
06BC0:  BRA    6BBE
06BC2:  MOVLW  0E
06BC4:  MOVWF  00
06BC6:  DECFSZ 00,F
06BC8:  BRA    6BC6
06BCA:  BRA    6BCC
06BCC:  NOP   
06BCE:  BSF    F95.6
06BD0:  MOVLW  0E
06BD2:  MOVWF  00
06BD4:  DECFSZ 00,F
06BD6:  BRA    6BD4
*
074FE:  BCF    F95.6
07500:  NOP   
07502:  BSF    F96.1
07504:  BTFSS  F84.1
07506:  BRA    7504
07508:  MOVLW  0E
0750A:  MOVWF  00
0750C:  DECFSZ 00,F
0750E:  BRA    750C
07510:  BRA    7512
07512:  NOP   
07514:  BSF    F95.6
07516:  MOVLW  0E
07518:  MOVWF  00
0751A:  DECFSZ 00,F
0751C:  BRA    751A
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
0644A:  MOVFF  90D,90E
....................   retval = 0;  
0644E:  MOVLB  9
06450:  CLRF   x0F
....................  
....................   while(TRUE)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
06452:  MOVF   x0E,W
06454:  SUBLW  09
06456:  BC    6462
....................     {  
....................       temp -= 10;  
06458:  MOVLW  0A
0645A:  SUBWF  x0E,F
....................       retval += 0x10;  
0645C:  MOVLW  10
0645E:  ADDWF  x0F,F
....................     }  
06460:  BRA    6468
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
06462:  MOVF   x0E,W
06464:  ADDWF  x0F,F
....................       break;  
06466:  BRA    646A
....................     }  
06468:  BRA    6452
....................   }  
....................  
....................   return(retval);  
0646A:  MOVFF  90F,01
0646E:  MOVLB  0
06470:  RETURN 0
.................... }  
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
0598C:  MOVFF  90F,910
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
05990:  BCF    FD8.0
05992:  MOVLB  9
05994:  RRCF   x10,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
05996:  MOVLW  78
05998:  ANDWF  x10,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
0599A:  RRCF   x10,W
0599C:  MOVWF  00
0599E:  RRCF   00,F
059A0:  MOVLW  3F
059A2:  ANDWF  00,F
059A4:  MOVF   00,W
059A6:  ADDWF  x10,W
059A8:  MOVWF  x11
059AA:  MOVF   x0F,W
059AC:  ANDLW  0F
059AE:  ADDWF  x11,W
059B0:  MOVWF  01
059B2:  MOVLB  0
059B4:  RETURN 0
.................... } 
....................  
.................... // Entradas. 
.................... #define entrada01 PIN_D4// 
.................... #define entrada02 PIN_B0//DATA1  
.................... #define entrada03 PIN_B1//DATA0 
.................... #define entrada04 PIN_D0// 
.................... #define entrada05 PIN_D1//SENSOR BARRERA 
....................  
.................... // Salidas. 
.................... #define salida01 PIN_A5//abre entrada 
.................... #define salida02 PIN_E0//abre entrada 
.................... #define salida03 PIN_D2//abre salida 
.................... #define salida04 PIN_D3//indicador de cupo lleno 
.................... #define salida05 PIN_D7// 
.................... #define salida06 PIN_C2//indicador de conexion 
.................... // Macros de entrada: 
.................... char texto1[12]= "BOLETO_FOL";// 
.................... char texto2[12]= "BORRARTODO";// 
.................... char texto3[12]= "BORRAR_TAG";// 
.................... char texto4[12]= "ABRIR_ENTR";// 
.................... char texto5[12]= "CUPO_LLENO";//CANCELA BOLETOS 
.................... char texto6[12]= "CUPO_DISPO";//ACTIVA BOLETOS 
.................... char texto7[12]= "MENSAJEEN1";// 
.................... char texto8[12]= "          ";// 
.................... char texto9[12]= "CONSULTA01";// 
.................... char texto10[12]="CONFIGDATE";// 
.................... char texto11[12]="CONFIGURAB";// 
.................... char texto12[12]="BORRA_CON1";// 
.................... char texto13[12]="FOLIORESET";//REINICIAR FOLIOS 
.................... char texto14[12]="PAGADO0000";// 
.................... char boleto[]= "BOLETO"; // 
.................... char barrera[] ="BARRERAABIERTAE1"; 
.................... int fmensaje; 
.................... int16 time_lcd; 
.................... //int en5,flag_pluma; 
....................  
....................  
.................... // Define el stack usado: ENC28J60. 
.................... #define STACK_USE_CCS_PICENS   1 
.................... // Utilizamos el stack para el protocolo ICPM. 
.................... #define STACK_USE_ICMP  1 
.................... // Utilizamos el stack para el protocolo ARP. 
.................... #define STACK_USE_ARP 1 
.................... // Utilizamos el stack para el protocolo TCP. 
.................... #define STACK_USE_TCP 1 
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... // Definimos los pines utilizados. 
.................... #define  PIN_ENC_MAC_SO    PIN_C4 
.................... #define  PIN_ENC_MAC_SI    PIN_C5 
.................... #define  PIN_ENC_MAC_CLK   PIN_C3 
....................  
.................... #define  PIN_ENC_MAC_CS    PIN_C1 
.................... #define  PIN_ENC_MAC_RST   PIN_C0 
.................... #define  PIN_ENC_MAC_INT   PIN_D2 
.................... #define  PIN_ENC_MAC_WOL   PIN_D3 
....................  
.................... // Incluimos las definiciones necesarias para utilizar el stack TCP/IP. 
.................... #include "tcpip/stacktsk.c"  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_C0 
....................       #define PIN_ENC_MAC_RST PIN_C1 
....................       #define PIN_ENC_MAC_INT PIN_C6 
....................       #define PIN_ENC_MAC_WOL PIN_C7 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................       
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_MCPENC 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
.................... */ 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     35 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05636:  MOVFF  90C,90E
0563A:  MOVFF  90B,90D
0563E:  MOVFF  90E,03
05642:  MOVLB  9
05644:  MOVFF  90D,FE9
05648:  MOVFF  90E,FEA
0564C:  MOVF   FEF,F
0564E:  BZ    565C
05650:  INCF   x0D,F
05652:  BTFSC  FD8.2
05654:  INCF   x0E,F
05656:  MOVLB  0
05658:  BRA    563E
0565A:  MOVLB  9
....................    return(sc - s); 
0565C:  MOVF   x0B,W
0565E:  SUBWF  x0D,W
05660:  MOVWF  00
05662:  MOVF   x0C,W
05664:  SUBWFB x0E,W
05666:  MOVWF  03
05668:  MOVFF  00,01
0566C:  MOVWF  02
0566E:  MOVLB  0
05670:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
010E0:  MOVFF  386,8FC
010E4:  MOVFF  385,8FB
010E8:  MOVFF  384,8FA
010EC:  MOVFF  383,8F9
010F0:  MOVLW  41
010F2:  MOVLB  9
010F4:  MOVWF  x00
010F6:  MOVLW  C6
010F8:  MOVLB  8
010FA:  MOVWF  xFF
010FC:  MOVLW  4E
010FE:  MOVWF  xFE
01100:  MOVLW  6D
01102:  MOVWF  xFD
01104:  MOVLB  0
01106:  BRA    103C
01108:  MOVLW  39
0110A:  MOVLB  8
0110C:  ADDWF  00,W
0110E:  MOVLB  3
01110:  MOVWF  x83
01112:  MOVLW  30
01114:  MOVLB  8
01116:  ADDWFC 01,W
01118:  MOVLB  3
0111A:  MOVWF  x84
0111C:  MOVLW  00
0111E:  MOVLB  8
01120:  ADDWFC 02,W
01122:  MOVLB  3
01124:  MOVWF  x85
01126:  MOVLW  00
01128:  MOVLB  8
0112A:  ADDWFC 03,W
0112C:  MOVLB  3
0112E:  MOVWF  x86
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
01130:  MOVFF  385,00
01134:  MOVFF  386,01
01138:  CLRF   02
0113A:  CLRF   03
0113C:  MOVFF  386,8FB
01140:  MOVFF  385,8FA
01144:  MOVFF  386,909
01148:  MOVFF  385,908
0114C:  MOVLW  7F
0114E:  MOVLB  9
01150:  MOVWF  x0B
01152:  SETF   x0A
01154:  MOVLB  0
01156:  RCALL  109A
01158:  MOVFF  00,01
0115C:  MOVFF  03,02
01160:  GOTO   127E (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01028:  MOVFF  8FC,386
0102C:  MOVFF  8FB,385
01030:  MOVFF  8FA,384
01034:  MOVFF  8F9,383
01038:  GOTO   127C (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
017D4:  MOVFF  9A2,9A3
....................     new.v[1]=v.v[0]; 
017D8:  MOVFF  9A1,9A4
....................  
....................     return(new.Val); 
017DC:  MOVLB  9
017DE:  MOVFF  9A3,01
017E2:  MOVFF  9A4,02
017E6:  MOVLB  0
017E8:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
02714:  MOVFF  98D,98E
....................     new.v[1]=v.v[2]; 
02718:  MOVFF  98C,98F
....................     new.v[2]=v.v[1]; 
0271C:  MOVFF  98B,990
....................     new.v[3]=v.v[0]; 
02720:  MOVFF  98A,991
....................  
....................     return(new.Val); 
02724:  MOVFF  98E,00
02728:  MOVFF  98F,01
0272C:  MOVFF  990,02
02730:  MOVFF  991,03
02734:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
0247E:  MOVLB  9
02480:  CLRF   x93
02482:  CLRF   x92
02484:  CLRF   x91
02486:  CLRF   x90
....................  
....................    i = count >> 1; 
02488:  BCF    FD8.0
0248A:  RRCF   x87,W
0248C:  MOVWF  x89
0248E:  RRCF   x86,W
02490:  MOVWF  x88
....................    val = (WORD *)buffer; 
02492:  MOVFF  985,98B
02496:  MOVFF  984,98A
....................  
....................    while( i-- ) 
0249A:  MOVFF  989,03
0249E:  MOVF   x88,W
024A0:  BTFSC  FD8.2
024A2:  DECF   x89,F
024A4:  DECF   x88,F
024A6:  IORWF  03,W
024A8:  BZ    24D8
....................       sum.Val += *val++; 
024AA:  MOVFF  98B,03
024AE:  MOVFF  98A,00
024B2:  MOVLW  02
024B4:  ADDWF  x8A,F
024B6:  BTFSC  FD8.0
024B8:  INCF   x8B,F
024BA:  MOVFF  00,FE9
024BE:  MOVFF  03,FEA
024C2:  MOVFF  FEC,03
024C6:  MOVF   FED,F
024C8:  MOVF   FEF,W
024CA:  ADDWF  x90,F
024CC:  MOVF   03,W
024CE:  ADDWFC x91,F
024D0:  MOVLW  00
024D2:  ADDWFC x92,F
024D4:  ADDWFC x93,F
024D6:  BRA    249A
....................  
....................    if ( count & 1 ) 
024D8:  MOVF   x86,W
024DA:  ANDLW  01
024DC:  MOVWF  00
024DE:  CLRF   03
024E0:  MOVF   00,W
024E2:  IORWF  03,W
024E4:  BZ    24FA
....................       sum.Val += *(BYTE *)val; 
024E6:  MOVFF  98A,FE9
024EA:  MOVFF  98B,FEA
024EE:  MOVF   FEF,W
024F0:  ADDWF  x90,F
024F2:  MOVLW  00
024F4:  ADDWFC x91,F
024F6:  ADDWFC x92,F
024F8:  ADDWFC x93,F
....................  
....................    tempSum.Val = sum.Val; 
024FA:  MOVFF  993,98F
024FE:  MOVFF  992,98E
02502:  MOVFF  991,98D
02506:  MOVFF  990,98C
....................    i = tempSum.words.MSB.Val; 
0250A:  MOVFF  98F,989
0250E:  MOVFF  98E,988
....................  
....................    while( i != 0u ) 
02512:  MOVF   x88,F
02514:  BNZ   251A
02516:  MOVF   x89,F
02518:  BZ    2560
....................    { 
....................       sum.words.MSB.Val = 0; 
0251A:  CLRF   x93
0251C:  CLRF   x92
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
0251E:  CLRF   x97
02520:  CLRF   x96
02522:  MOVFF  991,995
02526:  MOVFF  990,994
0252A:  CLRF   02
0252C:  CLRF   03
0252E:  MOVF   x88,W
02530:  ADDWF  x90,W
02532:  MOVWF  x90
02534:  MOVF   x89,W
02536:  ADDWFC x91,W
02538:  MOVWF  x91
0253A:  MOVF   02,W
0253C:  ADDWFC x96,W
0253E:  MOVWF  x92
02540:  MOVF   03,W
02542:  ADDWFC x97,W
02544:  MOVWF  x93
....................       tempSum.Val = sum.Val; 
02546:  MOVFF  993,98F
0254A:  MOVFF  992,98E
0254E:  MOVFF  991,98D
02552:  MOVFF  990,98C
....................       i = tempSum.words.MSB.Val; 
02556:  MOVFF  98F,989
0255A:  MOVFF  98E,988
0255E:  BRA    2512
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
02560:  MOVFF  991,03
02564:  COMF   03,F
02566:  MOVF   x90,W
02568:  XORLW  FF
0256A:  MOVWF  01
0256C:  MOVFF  03,02
02570:  MOVLB  0
02572:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
00AE8:  MOVLW  83
00AEA:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
00AEC:  MOVLW  34
00AEE:  MOVWF  FD7
00AF0:  MOVLW  8C
00AF2:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
00AF4:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
00AF6:  MOVLW  C0
00AF8:  IORWF  FF2,F
00AFA:  GOTO   12BE (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
02B16:  BCF    FF2.5
....................     ret=TickCount; 
02B18:  MOVFF  389,949
02B1C:  MOVFF  388,948
....................     enable_interrupts(INT_TIMER0); 
02B20:  BSF    FF2.5
....................     return ret; 
02B22:  MOVLB  9
02B24:  MOVFF  948,01
02B28:  MOVFF  949,02
02B2C:  MOVLB  0
02B2E:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00124:  MOVLB  3
00126:  INCF   x88,F
00128:  BTFSC  FD8.2
0012A:  INCF   x89,F
....................  
....................         second_counter_intermediate++; 
0012C:  INCF   x8B,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
0012E:  MOVF   x8B,W
00130:  SUBLW  0B
00132:  BC    0138
....................             second_counter++; //increment this ever 1s 
00134:  INCF   x8A,F
....................             second_counter_intermediate=0; 
00136:  CLRF   x8B
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
00138:  MOVLW  34
0013A:  MOVWF  FD7
0013C:  MOVLW  8C
0013E:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
.................... /* 
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
.................... */  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
00140:  BCF    FF2.2
00142:  MOVLB  0
00144:  GOTO   0084
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
00AFE:  BCF    F94.3
00B00:  BCF    F8B.3
....................    output_float(PIN_ENC_MAC_SO); 
00B02:  BSF    F94.4
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
00B04:  BCF    F94.1
00B06:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00B08:  BCF    F94.0
00B0A:  BSF    F8B.0
00B0C:  GOTO   0E16 (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
00B10:  MOVLB  9
00B12:  CLRF   xAD
00B14:  MOVF   xAD,W
00B16:  SUBLW  07
00B18:  BNC   0B42
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
00B1A:  BCF    FD8.0
00B1C:  RLCF   xAC,F
00B1E:  BC    0B24
00B20:  BCF    F8B.5
00B22:  BRA    0B26
00B24:  BSF    F8B.5
00B26:  BCF    F94.5
....................       output_high(PIN_ENC_MAC_CLK); 
00B28:  BCF    F94.3
00B2A:  BSF    F8B.3
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
00B2C:  BSF    F94.4
00B2E:  BTFSC  F82.4
00B30:  BRA    0B36
00B32:  BCF    FD8.0
00B34:  BRA    0B38
00B36:  BSF    FD8.0
00B38:  RLCF   xAE,F
....................       output_low(PIN_ENC_MAC_CLK); 
00B3A:  BCF    F94.3
00B3C:  BCF    F8B.3
00B3E:  INCF   xAD,F
00B40:  BRA    0B14
....................    } 
....................    return(in); 
00B42:  MOVFF  9AE,01
....................  #endif 
00B46:  MOVLB  0
00B48:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
00E14:  BRA    0AFE
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
00E16:  MOVLW  1D
00E18:  MOVLB  9
00E1A:  MOVWF  xA1
00E1C:  MOVLB  0
00E1E:  RCALL  0B4A
00E20:  MOVFF  01,8F6
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00E24:  MOVLB  8
00E26:  BTFSS  xF6.3
00E28:  BRA    0E2E
00E2A:  MOVLB  0
00E2C:  BRA    0E16
00E2E:  MOVF   xF6,W
00E30:  XORLW  FF
00E32:  ANDLW  01
00E34:  BTFSC  FD8.2
00E36:  BRA    0E3C
00E38:  MOVLB  0
00E3A:  BRA    0E16
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
00E3C:  MOVLB  0
00E3E:  BRA    0B74
....................     delay_ms(1); 
00E40:  MOVLW  01
00E42:  MOVLB  9
00E44:  MOVWF  x00
00E46:  MOVLB  0
00E48:  CALL   0600
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
00E4C:  MOVLB  3
00E4E:  CLRF   x87
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
00E50:  BSF    x90.0
....................    NextPacketLocation.Val = RXSTART; 
00E52:  CLRF   x8D
00E54:  CLRF   x8C
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
00E56:  MOVLW  08
00E58:  MOVLB  9
00E5A:  MOVWF  xA7
00E5C:  CLRF   xA8
00E5E:  MOVLB  0
00E60:  RCALL  0B88
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
00E62:  MOVLW  09
00E64:  MOVLB  9
00E66:  MOVWF  xA7
00E68:  CLRF   xA8
00E6A:  MOVLB  0
00E6C:  RCALL  0B88
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
00E6E:  MOVLW  0C
00E70:  MOVLB  9
00E72:  MOVWF  xA7
00E74:  MOVLW  F7
00E76:  MOVWF  xA8
00E78:  MOVLB  0
00E7A:  RCALL  0B88
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00E7C:  MOVLW  0D
00E7E:  MOVLB  9
00E80:  MOVWF  xA7
00E82:  MOVLW  1B
00E84:  MOVWF  xA8
00E86:  MOVLB  0
00E88:  RCALL  0B88
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
00E8A:  MOVLW  0A
00E8C:  MOVLB  9
00E8E:  MOVWF  xA7
00E90:  MOVLW  F7
00E92:  MOVWF  xA8
00E94:  MOVLB  0
00E96:  RCALL  0B88
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
00E98:  MOVLW  0B
00E9A:  MOVLB  9
00E9C:  MOVWF  xA7
00E9E:  MOVLW  1B
00EA0:  MOVWF  xA8
00EA2:  MOVLB  0
00EA4:  RCALL  0B88
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
00EA6:  MOVLW  04
00EA8:  MOVLB  9
00EAA:  MOVWF  xA7
00EAC:  MOVLW  F8
00EAE:  MOVWF  xA8
00EB0:  MOVLB  0
00EB2:  RCALL  0B88
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
00EB4:  MOVLW  05
00EB6:  MOVLB  9
00EB8:  MOVWF  xA7
00EBA:  MOVLW  1B
00EBC:  MOVWF  xA8
00EBE:  MOVLB  0
00EC0:  RCALL  0B88
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
00EC2:  MOVLW  02
00EC4:  MOVLB  9
00EC6:  MOVWF  xA5
00EC8:  CLRF   xA4
00ECA:  MOVLB  0
00ECC:  RCALL  0BE2
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00ECE:  MOVLB  9
00ED0:  CLRF   xA7
00ED2:  MOVLW  0D
00ED4:  MOVWF  xA8
00ED6:  MOVLB  0
00ED8:  RCALL  0B88
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00EDA:  MOVLW  02
00EDC:  MOVLB  9
00EDE:  MOVWF  xA7
00EE0:  MOVLW  32
00EE2:  MOVWF  xA8
00EE4:  MOVLB  0
00EE6:  RCALL  0B88
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00EE8:  MOVLW  03
00EEA:  MOVLB  9
00EEC:  MOVWF  xA7
00EEE:  MOVLW  40
00EF0:  MOVWF  xA8
00EF2:  MOVLB  0
00EF4:  RCALL  0B88
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00EF6:  MOVLW  09
00EF8:  MOVLB  9
00EFA:  MOVWF  xA7
00EFC:  MOVLW  3F
00EFE:  MOVWF  xA8
00F00:  MOVLB  0
00F02:  RCALL  0B88
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
00F04:  MOVLW  06
00F06:  MOVLB  9
00F08:  MOVWF  xA7
00F0A:  MOVLW  12
00F0C:  MOVWF  xA8
00F0E:  MOVLB  0
00F10:  RCALL  0B88
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
00F12:  MOVLW  07
00F14:  MOVLB  9
00F16:  MOVWF  xA7
00F18:  MOVLW  0C
00F1A:  MOVWF  xA8
00F1C:  MOVLB  0
00F1E:  RCALL  0B88
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
00F20:  MOVLW  0A
00F22:  MOVLB  9
00F24:  MOVWF  xA7
00F26:  MOVLW  EE
00F28:  MOVWF  xA8
00F2A:  MOVLB  0
00F2C:  RCALL  0B88
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
00F2E:  MOVLW  0B
00F30:  MOVLB  9
00F32:  MOVWF  xA7
00F34:  MOVLW  05
00F36:  MOVWF  xA8
00F38:  MOVLB  0
00F3A:  RCALL  0B88
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
00F3C:  MOVLW  03
00F3E:  MOVLB  9
00F40:  MOVWF  xA5
00F42:  MOVLW  04
00F44:  MOVWF  xA4
00F46:  MOVLB  0
00F48:  RCALL  0BE2
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00F4A:  MOVLW  04
00F4C:  MOVLB  9
00F4E:  MOVWF  xA7
00F50:  MOVFF  354,9A8
00F54:  MOVLB  0
00F56:  RCALL  0B88
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00F58:  MOVLW  05
00F5A:  MOVLB  9
00F5C:  MOVWF  xA7
00F5E:  MOVFF  355,9A8
00F62:  MOVLB  0
00F64:  RCALL  0B88
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00F66:  MOVLW  02
00F68:  MOVLB  9
00F6A:  MOVWF  xA7
00F6C:  MOVFF  356,9A8
00F70:  MOVLB  0
00F72:  RCALL  0B88
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00F74:  MOVLW  03
00F76:  MOVLB  9
00F78:  MOVWF  xA7
00F7A:  MOVFF  357,9A8
00F7E:  MOVLB  0
00F80:  RCALL  0B88
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00F82:  MOVLB  9
00F84:  CLRF   xA7
00F86:  MOVFF  358,9A8
00F8A:  MOVLB  0
00F8C:  RCALL  0B88
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00F8E:  MOVLW  01
00F90:  MOVLB  9
00F92:  MOVWF  xA7
00F94:  MOVFF  359,9A8
00F98:  MOVLB  0
00F9A:  RCALL  0B88
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00F9C:  MOVLW  12
00F9E:  MOVLB  9
00FA0:  MOVWF  xA1
00FA2:  MOVLB  0
00FA4:  RCALL  0B4A
00FA6:  MOVFF  01,391
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00FAA:  MOVLW  10
00FAC:  MOVLB  8
00FAE:  MOVWF  xFB
00FB0:  MOVLW  01
00FB2:  MOVWF  xFD
00FB4:  CLRF   xFC
00FB6:  MOVLB  0
00FB8:  RCALL  0C46
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
00FBA:  MOVLW  14
00FBC:  MOVLB  8
00FBE:  MOVWF  xFB
00FC0:  MOVLW  04
00FC2:  MOVWF  xFD
00FC4:  MOVLW  72
00FC6:  MOVWF  xFC
00FC8:  MOVLB  0
00FCA:  RCALL  0C46
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
00FCC:  MOVLB  8
00FCE:  CLRF   xF7
00FD0:  MOVLB  0
00FD2:  BRA    0D72
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
00FD4:  MOVLW  1F
00FD6:  MOVLB  9
00FD8:  MOVWF  xA9
00FDA:  MOVLW  04
00FDC:  MOVWF  xAA
00FDE:  MOVLB  0
00FE0:  RCALL  0BC4
00FE2:  GOTO   12C0 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
06CB8:  MOVLW  01
06CBA:  MOVLB  8
06CBC:  MOVWF  xFB
06CBE:  MOVLB  0
06CC0:  CALL   0CD6
06CC4:  MOVFF  01,8F6
06CC8:  MOVLW  00
06CCA:  MOVLB  8
06CCC:  BTFSC  01.2
06CCE:  MOVLW  01
06CD0:  MOVWF  01
06CD2:  MOVLB  0
06CD4:  GOTO   7876 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
02C2E:  MOVLW  1F
02C30:  MOVLB  9
02C32:  MOVWF  xA1
02C34:  MOVLB  0
02C36:  CALL   0B4A
02C3A:  MOVFF  01,983
02C3E:  MOVLW  00
02C40:  MOVLB  9
02C42:  BTFSC  01.3
02C44:  MOVLW  01
02C46:  XORLW  00
02C48:  BZ    2C4E
02C4A:  MOVLW  00
02C4C:  BRA    2C50
02C4E:  MOVLW  01
02C50:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
02C52:  MOVLB  0
02C54:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
01AEC:  MOVLW  1F
01AEE:  MOVLB  9
01AF0:  MOVWF  xA1
01AF2:  MOVLB  0
01AF4:  CALL   0B4A
01AF8:  MOVFF  01,983
01AFC:  MOVLW  00
01AFE:  MOVLB  9
01B00:  BTFSC  01.3
01B02:  MOVLW  01
01B04:  XORLW  00
01B06:  BNZ   1B0C
01B08:  MOVLW  00
01B0A:  BRA    1B0E
01B0C:  MOVLW  FF
01B0E:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
01B10:  MOVLB  0
01B12:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
016FA:  MOVLB  3
016FC:  BTFSS  x90.0
016FE:  BRA    1702
....................       return; 
01700:  BRA    176C
....................    WasDiscarded = TRUE; 
01702:  BSF    x90.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
01704:  MOVLW  01
01706:  SUBWF  x8C,W
01708:  MOVLB  9
0170A:  MOVWF  x48
0170C:  MOVLW  00
0170E:  MOVLB  3
01710:  SUBWFB x8D,W
01712:  MOVLB  9
01714:  MOVWF  x49
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
01716:  MOVF   x49,W
01718:  SUBLW  1A
0171A:  BC    172E
0171C:  XORLW  FF
0171E:  BNZ   1726
01720:  MOVF   x48,W
01722:  SUBLW  F7
01724:  BC    172E
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
01726:  MOVLW  1B
01728:  MOVWF  x49
0172A:  MOVLW  F7
0172C:  MOVWF  x48
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
0172E:  MOVLW  1E
01730:  MOVWF  xA9
01732:  MOVLW  40
01734:  MOVWF  xAA
01736:  MOVLB  0
01738:  CALL   0BC4
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
0173C:  MOVLB  9
0173E:  CLRF   xA5
01740:  MOVLW  0C
01742:  MOVWF  xA4
01744:  MOVLB  0
01746:  CALL   0BE2
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
0174A:  MOVLW  0C
0174C:  MOVLB  9
0174E:  MOVWF  xA7
01750:  MOVFF  948,9A8
01754:  MOVLB  0
01756:  CALL   0B88
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
0175A:  MOVLW  0D
0175C:  MOVLB  9
0175E:  MOVWF  xA7
01760:  MOVFF  949,9A8
01764:  MOVLB  0
01766:  CALL   0B88
0176A:  MOVLB  3
0176C:  MOVLB  0
0176E:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
02C56:  MOVLW  01
02C58:  MOVLB  9
02C5A:  MOVWF  xA5
02C5C:  MOVLW  19
02C5E:  MOVWF  xA4
02C60:  MOVLB  0
02C62:  CALL   0BE2
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
02C66:  MOVLW  19
02C68:  MOVLB  9
02C6A:  MOVWF  xA1
02C6C:  MOVLB  0
02C6E:  CALL   0B4A
02C72:  MOVFF  01,982
....................  
....................       BankSel(ERXWRPTL); 
02C76:  MOVLB  9
02C78:  CLRF   xA5
02C7A:  MOVLW  0E
02C7C:  MOVWF  xA4
02C7E:  MOVLB  0
02C80:  CALL   0BE2
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
02C84:  MOVLW  0E
02C86:  MOVLB  9
02C88:  MOVWF  xA1
02C8A:  MOVLB  0
02C8C:  CALL   0B4A
02C90:  MOVFF  01,984
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
02C94:  MOVLW  0F
02C96:  MOVLB  9
02C98:  MOVWF  xA1
02C9A:  MOVLB  0
02C9C:  CALL   0B4A
02CA0:  MOVFF  01,985
....................  
....................       BankSel(EPKTCNT); 
02CA4:  MOVLW  01
02CA6:  MOVLB  9
02CA8:  MOVWF  xA5
02CAA:  MOVLW  19
02CAC:  MOVWF  xA4
02CAE:  MOVLB  0
02CB0:  CALL   0BE2
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
02CB4:  MOVLW  19
02CB6:  MOVLB  9
02CB8:  MOVWF  xA1
02CBA:  MOVLB  0
02CBC:  CALL   0B4A
02CC0:  MOVFF  01,986
02CC4:  MOVLB  9
02CC6:  MOVF   x82,W
02CC8:  SUBWF  01,W
02CCA:  BTFSC  FD8.2
02CCC:  BRA    2CD2
02CCE:  MOVLB  0
02CD0:  BRA    2C66
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
02CD2:  CLRF   xA5
02CD4:  MOVLW  0C
02CD6:  MOVWF  xA4
02CD8:  MOVLB  0
02CDA:  CALL   0BE2
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
02CDE:  MOVLW  0C
02CE0:  MOVLB  9
02CE2:  MOVWF  xA1
02CE4:  MOVLB  0
02CE6:  CALL   0B4A
02CEA:  MOVFF  01,982
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
02CEE:  MOVLW  0D
02CF0:  MOVLB  9
02CF2:  MOVWF  xA1
02CF4:  MOVLB  0
02CF6:  CALL   0B4A
02CFA:  MOVFF  01,983
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
02CFE:  MOVLB  9
02D00:  MOVF   x83,W
02D02:  SUBWF  x85,W
02D04:  BNC   2D32
02D06:  BNZ   2D0E
02D08:  MOVF   x84,W
02D0A:  SUBWF  x82,W
02D0C:  BC    2D32
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
02D0E:  MOVF   x82,W
02D10:  SUBWF  x84,W
02D12:  MOVWF  00
02D14:  MOVF   x83,W
02D16:  SUBWFB x85,W
02D18:  MOVWF  03
02D1A:  MOVF   00,W
02D1C:  XORLW  FF
02D1E:  ADDLW  F8
02D20:  MOVWF  00
02D22:  MOVLW  1B
02D24:  SUBFWB 03,F
02D26:  MOVFF  00,01
02D2A:  MOVFF  03,02
02D2E:  BRA    2D68
....................    } 
02D30:  BRA    2D68
....................    else if ( WritePT.Val == ReadPT.Val ) 
02D32:  MOVF   x82,W
02D34:  SUBWF  x84,W
02D36:  BNZ   2D4A
02D38:  MOVF   x83,W
02D3A:  SUBWF  x85,W
02D3C:  BNZ   2D4A
....................    { 
....................       return RXSIZE - 1; 
02D3E:  MOVLW  F7
02D40:  MOVWF  01
02D42:  MOVLW  1B
02D44:  MOVWF  02
02D46:  BRA    2D68
....................    } 
02D48:  BRA    2D68
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
02D4A:  MOVF   x84,W
02D4C:  SUBWF  x82,W
02D4E:  MOVWF  x86
02D50:  MOVF   x85,W
02D52:  SUBWFB x83,W
02D54:  MOVWF  x87
02D56:  MOVLW  01
02D58:  SUBWF  x86,W
02D5A:  MOVWF  00
02D5C:  MOVLW  00
02D5E:  SUBWFB x87,W
02D60:  MOVWF  03
02D62:  MOVFF  00,01
02D66:  MOVWF  02
....................    } 
02D68:  MOVLB  0
02D6A:  GOTO   2FEC (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
017EA:  MOVLW  01
017EC:  MOVLB  9
017EE:  MOVWF  xA5
017F0:  MOVLW  19
017F2:  MOVWF  xA4
017F4:  MOVLB  0
017F6:  CALL   0BE2
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
017FA:  MOVLW  19
017FC:  MOVLB  9
017FE:  MOVWF  xA1
01800:  MOVLB  0
01802:  CALL   0B4A
01806:  MOVFF  01,914
0180A:  MOVLB  9
0180C:  MOVF   x14,F
0180E:  BNZ   1816
....................       return FALSE; 
01810:  MOVLW  00
01812:  MOVWF  01
01814:  BRA    1932
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
01816:  MOVLB  3
01818:  BTFSC  x90.0
0181A:  BRA    182A
....................    { 
....................       MACDiscardRx(); 
0181C:  MOVLB  0
0181E:  RCALL  16FA
....................       return FALSE; 
01820:  MOVLW  00
01822:  MOVWF  01
01824:  MOVLB  9
01826:  BRA    1932
01828:  MOVLB  3
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
0182A:  MOVFF  38D,38F
0182E:  MOVFF  38C,38E
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
01832:  MOVLB  9
01834:  CLRF   xA5
01836:  CLRF   xA4
01838:  MOVLB  0
0183A:  CALL   0BE2
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
0183E:  MOVLB  9
01840:  CLRF   xA7
01842:  MOVFF  38C,9A8
01846:  MOVLB  0
01848:  CALL   0B88
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
0184C:  MOVLW  01
0184E:  MOVLB  9
01850:  MOVWF  xA7
01852:  MOVFF  38D,9A8
01856:  MOVLB  0
01858:  CALL   0B88
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
0185C:  MOVLW  09
0185E:  MOVLB  9
01860:  MOVWF  x15
01862:  CLRF   x14
01864:  MOVWF  x91
01866:  MOVFF  914,990
0186A:  CLRF   x93
0186C:  MOVLW  14
0186E:  MOVWF  x92
01870:  MOVLB  0
01872:  RCALL  1770
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
01874:  MOVFF  913,9A2
01878:  MOVFF  912,9A1
0187C:  RCALL  17D4
0187E:  MOVFF  02,913
01882:  MOVFF  01,912
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
01886:  MOVLB  9
01888:  MOVF   x01,W
0188A:  SUBLW  1A
0188C:  BC    1898
0188E:  XORLW  FF
01890:  BNZ   18C2
01892:  MOVF   x00,W
01894:  SUBLW  F7
01896:  BNC   18C2
01898:  MOVLW  09
0189A:  CLRF   x14
0189C:  MOVFF  914,FE9
018A0:  MOVWF  FEA
018A2:  BTFSC  FEF.0
018A4:  BRA    18C2
018A6:  BTFSC  x05.7
018A8:  BRA    18C2
018AA:  BTFSC  x04.4
018AC:  BRA    18C2
018AE:  MOVF   x03,W
018B0:  SUBLW  04
018B2:  BC    18BE
018B4:  XORLW  FF
018B6:  BNZ   18C2
018B8:  MOVF   x02,W
018BA:  SUBLW  EE
018BC:  BNC   18C2
018BE:  BTFSC  x04.7
018C0:  BRA    18C4
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
018C2:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
018C4:  MOVFF  901,38D
018C8:  MOVFF  900,38C
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
018CC:  MOVFF  8FD,03
018D0:  MOVFF  8FC,914
018D4:  MOVLB  9
018D6:  MOVFF  8FD,915
018DA:  MOVFF  8FD,FEA
018DE:  MOVFF  8FC,FE9
018E2:  MOVLW  09
018E4:  MOVWF  FE2
018E6:  MOVLW  0C
018E8:  MOVWF  FE1
018EA:  MOVLW  06
018EC:  MOVWF  01
018EE:  MOVFF  FE6,FEE
018F2:  DECFSZ 01,F
018F4:  BRA    18EE
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
018F6:  MOVFF  8FF,03
018FA:  MOVLB  8
018FC:  MOVFF  8FE,FE9
01900:  MOVFF  03,FEA
01904:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
01906:  MOVLB  9
01908:  MOVF   x13,W
0190A:  SUBLW  08
0190C:  BNZ   1928
0190E:  MOVF   x12,F
01910:  BZ    1918
01912:  MOVF   x12,W
01914:  SUBLW  06
01916:  BNZ   1928
....................     { 
....................        *type = header.Type.v[0]; 
01918:  MOVLB  8
0191A:  MOVFF  8FE,FE9
0191E:  MOVFF  8FF,FEA
01922:  MOVFF  912,FEF
01926:  MOVLB  9
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
01928:  MOVLB  3
0192A:  BCF    x90.0
....................    return TRUE; 
0192C:  MOVLW  01
0192E:  MOVWF  01
01930:  MOVLB  9
01932:  MOVLB  0
01934:  GOTO   44C0 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
01C1A:  MOVLB  9
01C1C:  CLRF   xA5
01C1E:  MOVLW  02
01C20:  MOVWF  xA4
01C22:  MOVLB  0
01C24:  CALL   0BE2
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
01C28:  MOVLW  02
01C2A:  MOVLB  9
01C2C:  MOVWF  xA7
01C2E:  MOVLW  F8
01C30:  MOVWF  xA8
01C32:  MOVLB  0
01C34:  CALL   0B88
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
01C38:  MOVLW  03
01C3A:  MOVLB  9
01C3C:  MOVWF  xA7
01C3E:  MOVLW  1B
01C40:  MOVWF  xA8
01C42:  MOVLB  0
01C44:  CALL   0B88
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C48:  MOVLW  06
01C4A:  MOVLB  9
01C4C:  ADDWF  xA2,F
01C4E:  MOVLW  1C
01C50:  ADDWFC xA3,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C52:  MOVLW  09
01C54:  MOVWF  xA5
01C56:  MOVLW  A2
01C58:  MOVWF  xA4
01C5A:  MOVWF  FE9
01C5C:  MOVFF  9A5,FEA
01C60:  MOVFF  FEF,9A8
01C64:  MOVLW  06
01C66:  MOVWF  xA7
01C68:  MOVLB  0
01C6A:  CALL   0B88
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01C6E:  MOVLW  09
01C70:  MOVLB  9
01C72:  MOVWF  xA5
01C74:  MOVLW  A2
01C76:  MOVWF  xA4
01C78:  MOVLW  01
01C7A:  ADDWF  xA4,W
01C7C:  MOVWF  FE9
01C7E:  MOVLW  00
01C80:  ADDWFC xA5,W
01C82:  MOVWF  FEA
01C84:  MOVFF  FEF,9A8
01C88:  MOVLW  07
01C8A:  MOVWF  xA7
01C8C:  MOVLB  0
01C8E:  CALL   0B88
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
01C92:  MOVLB  9
01C94:  CLRF   xA5
01C96:  MOVLB  0
01C98:  RCALL  1BB2
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01C9A:  MOVFF  9A0,9A7
01C9E:  MOVFF  99F,9A6
01CA2:  MOVLB  9
01CA4:  CLRF   xA9
01CA6:  MOVLW  06
01CA8:  MOVWF  xA8
01CAA:  MOVLB  0
01CAC:  RCALL  1BD0
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01CAE:  MOVLW  03
01CB0:  MOVLB  9
01CB2:  MOVWF  xA5
01CB4:  MOVLW  54
01CB6:  MOVWF  xA4
01CB8:  MOVFF  9A5,9A7
01CBC:  MOVWF  xA6
01CBE:  CLRF   xA9
01CC0:  MOVLW  06
01CC2:  MOVWF  xA8
01CC4:  MOVLB  0
01CC6:  RCALL  1BD0
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01CC8:  MOVLW  08
01CCA:  MOVLB  9
01CCC:  MOVWF  xA5
01CCE:  MOVLB  0
01CD0:  RCALL  1BB2
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01CD2:  MOVLB  9
01CD4:  MOVF   xA1,F
01CD6:  BNZ   1CDC
01CD8:  MOVLW  00
01CDA:  BRA    1CDE
01CDC:  MOVLW  06
01CDE:  MOVWF  xA4
01CE0:  MOVWF  xA5
01CE2:  MOVLB  0
01CE4:  RCALL  1BB2
01CE6:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
01CE8:  MOVLW  1C
01CEA:  MOVLB  9
01CEC:  MOVWF  xA1
01CEE:  MOVLB  0
01CF0:  CALL   0B4A
01CF4:  MOVFF  01,98E
01CF8:  MOVLW  00
01CFA:  MOVLB  9
01CFC:  BTFSC  01.1
01CFE:  MOVLW  01
01D00:  XORLW  00
01D02:  BZ    1D24
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
01D04:  MOVLW  1F
01D06:  MOVWF  xA9
01D08:  MOVLW  80
01D0A:  MOVWF  xAA
01D0C:  MOVLB  0
01D0E:  CALL   0BC4
....................       BFCReg(ECON1, ECON1_TXRST); 
01D12:  MOVLW  1F
01D14:  MOVLB  9
01D16:  MOVWF  xA6
01D18:  MOVLW  80
01D1A:  MOVWF  xA7
01D1C:  MOVLB  0
01D1E:  CALL   0BA6
01D22:  MOVLB  9
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01D24:  MOVLW  1C
01D26:  MOVWF  xA6
01D28:  MOVLW  0A
01D2A:  MOVWF  xA7
01D2C:  MOVLB  0
01D2E:  CALL   0BA6
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
01D32:  MOVLW  1F
01D34:  MOVLB  9
01D36:  MOVWF  xA9
01D38:  MOVLW  08
01D3A:  MOVWF  xAA
01D3C:  MOVLB  0
01D3E:  CALL   0BC4
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
01D42:  MOVLB  3
01D44:  MOVF   x91,W
01D46:  SUBLW  05
01D48:  BTFSS  FD8.2
01D4A:  BRA    1F14
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01D4C:  MOVLW  1C
01D4E:  MOVLB  9
01D50:  MOVWF  xA1
01D52:  MOVLB  0
01D54:  CALL   0B4A
01D58:  MOVFF  01,98E
01D5C:  MOVLB  9
01D5E:  MOVF   01,W
01D60:  ANDLW  0A
01D62:  BTFSS  FD8.2
01D64:  BRA    1D6A
01D66:  MOVLB  3
01D68:  BRA    1D4C
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
01D6A:  MOVLW  1C
01D6C:  MOVWF  xA1
01D6E:  MOVLB  0
01D70:  CALL   0B4A
01D74:  MOVFF  01,98E
01D78:  MOVLW  00
01D7A:  MOVLB  9
01D7C:  BTFSC  01.1
01D7E:  MOVLW  01
01D80:  XORLW  00
01D82:  BTFSC  FD8.2
01D84:  BRA    1F12
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
01D86:  MOVLW  1F
01D88:  MOVWF  xA6
01D8A:  MOVLW  08
01D8C:  MOVWF  xA7
01D8E:  MOVLB  0
01D90:  CALL   0BA6
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
01D94:  MOVLB  9
01D96:  CLRF   xA5
01D98:  CLRF   xA4
01D9A:  MOVLB  0
01D9C:  CALL   0BE2
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01DA0:  MOVLB  9
01DA2:  CLRF   xA1
01DA4:  MOVLB  0
01DA6:  CALL   0B4A
01DAA:  MOVFF  01,982
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01DAE:  MOVLW  01
01DB0:  MOVLB  9
01DB2:  MOVWF  xA1
01DB4:  MOVLB  0
01DB6:  CALL   0B4A
01DBA:  MOVFF  01,983
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01DBE:  MOVLW  06
01DC0:  MOVLB  9
01DC2:  MOVWF  xA1
01DC4:  MOVLB  0
01DC6:  CALL   0B4A
01DCA:  MOVFF  01,984
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01DCE:  MOVLW  07
01DD0:  MOVLB  9
01DD2:  MOVWF  xA1
01DD4:  MOVLB  0
01DD6:  CALL   0B4A
01DDA:  MOVFF  01,985
....................          TXEnd.Val++; 
01DDE:  MOVLB  9
01DE0:  INCF   x84,F
01DE2:  BTFSC  FD8.2
01DE4:  INCF   x85,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
01DE6:  CLRF   xA7
01DE8:  MOVFF  984,9A8
01DEC:  MOVLB  0
01DEE:  CALL   0B88
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
01DF2:  MOVLW  01
01DF4:  MOVLB  9
01DF6:  MOVWF  xA7
01DF8:  MOVFF  985,9A8
01DFC:  MOVLB  0
01DFE:  CALL   0B88
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01E02:  MOVLW  09
01E04:  MOVLB  9
01E06:  MOVWF  x8F
01E08:  MOVLW  86
01E0A:  MOVWF  x8E
01E0C:  MOVFF  98F,991
01E10:  MOVWF  x90
01E12:  CLRF   x93
01E14:  MOVLW  07
01E16:  MOVWF  x92
01E18:  MOVLB  0
01E1A:  RCALL  1770
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
01E1C:  MOVLB  9
01E1E:  CLRF   x8D
01E20:  MOVF   x8D,W
01E22:  SUBLW  0F
01E24:  BNC   1EF4
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01E26:  MOVLW  1C
01E28:  MOVWF  xA1
01E2A:  MOVLB  0
01E2C:  CALL   0B4A
01E30:  MOVFF  01,98E
01E34:  MOVLW  00
01E36:  MOVLB  9
01E38:  BTFSC  01.1
01E3A:  MOVLW  01
01E3C:  XORLW  00
01E3E:  BZ    1EEA
01E40:  BTFSS  x89.5
01E42:  BRA    1EEA
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
01E44:  MOVLW  1F
01E46:  MOVWF  xA9
01E48:  MOVLW  80
01E4A:  MOVWF  xAA
01E4C:  MOVLB  0
01E4E:  CALL   0BC4
....................                BFCReg(ECON1, ECON1_TXRST); 
01E52:  MOVLW  1F
01E54:  MOVLB  9
01E56:  MOVWF  xA6
01E58:  MOVLW  80
01E5A:  MOVWF  xA7
01E5C:  MOVLB  0
01E5E:  CALL   0BA6
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01E62:  MOVLW  1C
01E64:  MOVLB  9
01E66:  MOVWF  xA6
01E68:  MOVLW  0A
01E6A:  MOVWF  xA7
01E6C:  MOVLB  0
01E6E:  CALL   0BA6
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
01E72:  MOVLW  1F
01E74:  MOVLB  9
01E76:  MOVWF  xA9
01E78:  MOVLW  08
01E7A:  MOVWF  xAA
01E7C:  MOVLB  0
01E7E:  CALL   0BC4
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01E82:  MOVLW  1C
01E84:  MOVLB  9
01E86:  MOVWF  xA1
01E88:  MOVLB  0
01E8A:  CALL   0B4A
01E8E:  MOVFF  01,98E
01E92:  MOVLB  9
01E94:  MOVF   01,W
01E96:  ANDLW  0A
01E98:  BTFSS  FD8.2
01E9A:  BRA    1EA0
01E9C:  MOVLB  0
01E9E:  BRA    1E82
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
01EA0:  MOVLW  1F
01EA2:  MOVWF  xA6
01EA4:  MOVLW  08
01EA6:  MOVWF  xA7
01EA8:  MOVLB  0
01EAA:  CALL   0BA6
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
01EAE:  MOVLB  9
01EB0:  CLRF   xA7
01EB2:  MOVFF  984,9A8
01EB6:  MOVLB  0
01EB8:  CALL   0B88
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
01EBC:  MOVLW  01
01EBE:  MOVLB  9
01EC0:  MOVWF  xA7
01EC2:  MOVFF  985,9A8
01EC6:  MOVLB  0
01EC8:  CALL   0B88
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01ECC:  MOVLW  09
01ECE:  MOVLB  9
01ED0:  MOVWF  x8F
01ED2:  MOVLW  86
01ED4:  MOVWF  x8E
01ED6:  MOVFF  98F,991
01EDA:  MOVWF  x90
01EDC:  CLRF   x93
01EDE:  MOVLW  07
01EE0:  MOVWF  x92
01EE2:  MOVLB  0
01EE4:  RCALL  1770
....................             } 
01EE6:  BRA    1EEE
01EE8:  MOVLB  9
....................             else 
....................             { 
....................                break; 
01EEA:  BRA    1EF4
01EEC:  MOVLB  0
....................             } 
01EEE:  MOVLB  9
01EF0:  INCF   x8D,F
01EF2:  BRA    1E20
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01EF4:  CLRF   xA7
01EF6:  MOVFF  982,9A8
01EFA:  MOVLB  0
01EFC:  CALL   0B88
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01F00:  MOVLW  01
01F02:  MOVLB  9
01F04:  MOVWF  xA7
01F06:  MOVFF  983,9A8
01F0A:  MOVLB  0
01F0C:  CALL   0B88
01F10:  MOVLB  9
01F12:  MOVLB  3
....................       } 
....................    } 
01F14:  MOVLB  0
01F16:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02248:  MOVLW  14
0224A:  MOVLB  3
0224C:  ADDWF  x8E,W
0224E:  MOVLB  9
02250:  MOVWF  x31
02252:  MOVLW  00
02254:  MOVLB  3
02256:  ADDWFC x8F,W
02258:  MOVLB  9
0225A:  MOVWF  x32
0225C:  MOVF   x2D,W
0225E:  ADDWF  x31,W
02260:  MOVWF  x2F
02262:  MOVF   x2E,W
02264:  ADDWFC x32,W
02266:  MOVWF  x30
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
02268:  MOVF   x30,W
0226A:  SUBLW  1A
0226C:  BC    2280
0226E:  XORLW  FF
02270:  BNZ   2278
02272:  MOVF   x2F,W
02274:  SUBLW  F7
02276:  BC    2280
....................       ReadPT.Val -= RXSIZE; 
02278:  MOVLW  F8
0227A:  SUBWF  x2F,F
0227C:  MOVLW  1B
0227E:  SUBWFB x30,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
02280:  CLRF   xA5
02282:  CLRF   xA4
02284:  MOVLB  0
02286:  CALL   0BE2
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
0228A:  MOVLB  9
0228C:  CLRF   xA7
0228E:  MOVFF  92F,9A8
02292:  MOVLB  0
02294:  CALL   0B88
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
02298:  MOVLW  01
0229A:  MOVLB  9
0229C:  MOVWF  xA7
0229E:  MOVFF  930,9A8
022A2:  MOVLB  0
022A4:  CALL   0B88
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
022A8:  MOVLW  02
022AA:  MOVLB  9
022AC:  MOVWF  xA7
022AE:  MOVFF  92F,9A8
022B2:  MOVLB  0
022B4:  CALL   0B88
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
022B8:  MOVLW  03
022BA:  MOVLB  9
022BC:  MOVWF  xA7
022BE:  MOVFF  930,9A8
022C2:  MOVLB  0
022C4:  CALL   0B88
022C8:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01B14:  MOVFF  99B,387
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
01B18:  MOVLW  07
01B1A:  MOVLB  9
01B1C:  ADDWF  x9C,F
01B1E:  MOVLW  1C
01B20:  ADDWFC x9D,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
01B22:  CLRF   xA5
01B24:  MOVLW  02
01B26:  MOVWF  xA4
01B28:  MOVLB  0
01B2A:  CALL   0BE2
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01B2E:  MOVLW  09
01B30:  MOVLB  9
01B32:  MOVWF  x9F
01B34:  MOVLW  9C
01B36:  MOVWF  x9E
01B38:  MOVWF  FE9
01B3A:  MOVFF  99F,FEA
01B3E:  MOVFF  FEF,9A8
01B42:  CLRF   xA7
01B44:  MOVLB  0
01B46:  CALL   0B88
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
01B4A:  MOVLW  09
01B4C:  MOVLB  9
01B4E:  MOVWF  x9F
01B50:  MOVLW  9C
01B52:  MOVWF  x9E
01B54:  MOVLW  01
01B56:  ADDWF  x9E,W
01B58:  MOVWF  FE9
01B5A:  MOVLW  00
01B5C:  ADDWFC x9F,W
01B5E:  MOVWF  FEA
01B60:  MOVFF  FEF,9A8
01B64:  MOVLW  01
01B66:  MOVWF  xA7
01B68:  MOVLB  0
01B6A:  CALL   0B88
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01B6E:  MOVLW  09
01B70:  MOVLB  9
01B72:  MOVWF  x9F
01B74:  MOVLW  9C
01B76:  MOVWF  x9E
01B78:  MOVWF  FE9
01B7A:  MOVFF  99F,FEA
01B7E:  MOVFF  FEF,9A8
01B82:  MOVLW  02
01B84:  MOVWF  xA7
01B86:  MOVLB  0
01B88:  CALL   0B88
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
01B8C:  MOVLW  09
01B8E:  MOVLB  9
01B90:  MOVWF  x9F
01B92:  MOVLW  9C
01B94:  MOVWF  x9E
01B96:  MOVLW  01
01B98:  ADDWF  x9E,W
01B9A:  MOVWF  FE9
01B9C:  MOVLW  00
01B9E:  ADDWFC x9F,W
01BA0:  MOVWF  FEA
01BA2:  MOVFF  FEF,9A8
01BA6:  MOVLW  03
01BA8:  MOVWF  xA7
01BAA:  MOVLB  0
01BAC:  CALL   0B88
01BB0:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
0213A:  MOVLW  14
0213C:  MOVLB  3
0213E:  ADDWF  x8E,W
02140:  MOVLB  9
02142:  MOVWF  x5D
02144:  MOVLW  00
02146:  MOVLB  3
02148:  ADDWFC x8F,W
0214A:  MOVLB  9
0214C:  MOVWF  x5E
0214E:  MOVF   x57,W
02150:  ADDWF  x5D,W
02152:  MOVWF  x5B
02154:  MOVF   x58,W
02156:  ADDWFC x5E,W
02158:  MOVWF  x5C
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
0215A:  MOVF   x5C,W
0215C:  SUBLW  1A
0215E:  BC    2172
02160:  XORLW  FF
02162:  BNZ   216A
02164:  MOVF   x5B,W
02166:  SUBLW  F7
02168:  BC    2172
....................    { 
....................       temp.Val -= RXSIZE; 
0216A:  MOVLW  F8
0216C:  SUBWF  x5B,F
0216E:  MOVLW  1B
02170:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
02172:  CLRF   xA5
02174:  MOVLW  10
02176:  MOVWF  xA4
02178:  MOVLB  0
0217A:  CALL   0BE2
....................    WriteReg(EDMASTL, temp.v[0]); 
0217E:  MOVLW  10
02180:  MOVLB  9
02182:  MOVWF  xA7
02184:  MOVFF  95B,9A8
02188:  MOVLB  0
0218A:  CALL   0B88
....................    WriteReg(EDMASTH, temp.v[1]); 
0218E:  MOVLW  11
02190:  MOVLB  9
02192:  MOVWF  xA7
02194:  MOVFF  95C,9A8
02198:  MOVLB  0
0219A:  CALL   0B88
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
0219E:  MOVLW  01
021A0:  MOVLB  9
021A2:  SUBWF  x59,W
021A4:  MOVWF  00
021A6:  MOVLW  00
021A8:  SUBWFB x5A,W
021AA:  MOVWF  03
021AC:  MOVF   00,W
021AE:  ADDWF  x5B,F
021B0:  MOVF   03,W
021B2:  ADDWFC x5C,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
021B4:  MOVF   x5C,W
021B6:  SUBLW  1A
021B8:  BC    21CC
021BA:  XORLW  FF
021BC:  BNZ   21C4
021BE:  MOVF   x5B,W
021C0:  SUBLW  F7
021C2:  BC    21CC
....................    { 
....................       temp.Val -= RXSIZE; 
021C4:  MOVLW  F8
021C6:  SUBWF  x5B,F
021C8:  MOVLW  1B
021CA:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
021CC:  MOVLW  12
021CE:  MOVWF  xA7
021D0:  MOVFF  95B,9A8
021D4:  MOVLB  0
021D6:  CALL   0B88
....................    WriteReg(EDMANDH, temp.v[1]); 
021DA:  MOVLW  13
021DC:  MOVLB  9
021DE:  MOVWF  xA7
021E0:  MOVFF  95C,9A8
021E4:  MOVLB  0
021E6:  CALL   0B88
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
021EA:  MOVLW  1F
021EC:  MOVLB  9
021EE:  MOVWF  xA9
021F0:  MOVLW  30
021F2:  MOVWF  xAA
021F4:  MOVLB  0
021F6:  CALL   0BC4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
021FA:  MOVLW  1F
021FC:  MOVLB  9
021FE:  MOVWF  xA1
02200:  MOVLB  0
02202:  CALL   0B4A
02206:  MOVFF  01,95D
0220A:  MOVLW  00
0220C:  MOVLB  9
0220E:  BTFSC  01.5
02210:  MOVLW  01
02212:  XORLW  00
02214:  BTFSC  FD8.2
02216:  BRA    221C
02218:  MOVLB  0
0221A:  BRA    21FA
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
0221C:  MOVLW  16
0221E:  MOVWF  xA1
02220:  MOVLB  0
02222:  CALL   0B4A
02226:  MOVFF  01,95C
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
0222A:  MOVLW  17
0222C:  MOVLB  9
0222E:  MOVWF  xA1
02230:  MOVLB  0
02232:  CALL   0B4A
02236:  MOVFF  01,95B
....................    return temp.Val; 
0223A:  MOVLB  9
0223C:  MOVFF  95B,01
02240:  MOVFF  95C,02
02244:  MOVLB  0
02246:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
02D6E:  MOVLW  06
02D70:  MOVLB  9
02D72:  ADDWF  x9B,W
02D74:  MOVWF  xA1
02D76:  MOVLW  1C
02D78:  ADDWFC x9C,W
02D7A:  MOVWF  xA2
02D7C:  MOVLW  01
02D7E:  ADDWF  xA1,W
02D80:  MOVWF  x9F
02D82:  MOVLW  00
02D84:  ADDWFC xA2,W
02D86:  MOVWF  xA0
.................... #endif 
....................    BankSel(EDMASTL); 
02D88:  CLRF   xA5
02D8A:  MOVLW  10
02D8C:  MOVWF  xA4
02D8E:  MOVLB  0
02D90:  CALL   0BE2
....................    WriteReg(EDMASTL, temp.v[0]); 
02D94:  MOVLW  10
02D96:  MOVLB  9
02D98:  MOVWF  xA7
02D9A:  MOVFF  99F,9A8
02D9E:  MOVLB  0
02DA0:  CALL   0B88
....................    WriteReg(EDMASTH, temp.v[1]); 
02DA4:  MOVLW  11
02DA6:  MOVLB  9
02DA8:  MOVWF  xA7
02DAA:  MOVFF  9A0,9A8
02DAE:  MOVLB  0
02DB0:  CALL   0B88
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
02DB4:  MOVLW  01
02DB6:  MOVLB  9
02DB8:  SUBWF  x9D,W
02DBA:  MOVWF  00
02DBC:  MOVLW  00
02DBE:  SUBWFB x9E,W
02DC0:  MOVWF  03
02DC2:  MOVF   00,W
02DC4:  ADDWF  x9F,F
02DC6:  MOVF   03,W
02DC8:  ADDWFC xA0,F
....................    WriteReg(EDMANDL, temp.v[0]); 
02DCA:  MOVLW  12
02DCC:  MOVWF  xA7
02DCE:  MOVFF  99F,9A8
02DD2:  MOVLB  0
02DD4:  CALL   0B88
....................    WriteReg(EDMANDH, temp.v[1]); 
02DD8:  MOVLW  13
02DDA:  MOVLB  9
02DDC:  MOVWF  xA7
02DDE:  MOVFF  9A0,9A8
02DE2:  MOVLB  0
02DE4:  CALL   0B88
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02DE8:  MOVLW  1F
02DEA:  MOVLB  9
02DEC:  MOVWF  xA9
02DEE:  MOVLW  30
02DF0:  MOVWF  xAA
02DF2:  MOVLB  0
02DF4:  CALL   0BC4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02DF8:  MOVLW  1F
02DFA:  MOVLB  9
02DFC:  MOVWF  xA1
02DFE:  MOVLB  0
02E00:  CALL   0B4A
02E04:  MOVFF  01,9A1
02E08:  MOVLW  00
02E0A:  MOVLB  9
02E0C:  BTFSC  01.5
02E0E:  MOVLW  01
02E10:  XORLW  00
02E12:  BTFSC  FD8.2
02E14:  BRA    2E1A
02E16:  MOVLB  0
02E18:  BRA    2DF8
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02E1A:  MOVLW  16
02E1C:  MOVWF  xA1
02E1E:  MOVLB  0
02E20:  CALL   0B4A
02E24:  MOVFF  01,9A0
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02E28:  MOVLW  17
02E2A:  MOVLB  9
02E2C:  MOVWF  xA1
02E2E:  MOVLB  0
02E30:  CALL   0B4A
02E34:  MOVFF  01,99F
....................    return temp.Val; 
02E38:  MOVLB  9
02E3A:  MOVFF  99F,01
02E3E:  MOVFF  9A0,02
02E42:  MOVLB  0
02E44:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
025A0:  MOVLB  9
025A2:  MOVF   x82,F
025A4:  BNZ   25B4
025A6:  MOVF   x83,F
025A8:  BNZ   25B4
....................    { 
....................       return 0xFFFF; 
025AA:  MOVLW  FF
025AC:  MOVWF  01
025AE:  MOVWF  02
025B0:  BRA    26F4
....................    } 
025B2:  BRA    25E2
....................    else if(len == 1u) 
025B4:  DECFSZ x82,W
025B6:  BRA    25E2
025B8:  MOVF   x83,F
025BA:  BNZ   25E2
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
025BC:  MOVLB  0
025BE:  RCALL  2574
025C0:  MOVLB  9
025C2:  CLRF   x87
025C4:  MOVFF  01,986
025C8:  MOVFF  01,03
025CC:  MOVLW  00
025CE:  CLRF   00
025D0:  DECF   00,F
025D2:  XORWF  00,F
025D4:  MOVLW  FF
025D6:  XORWF  03,F
025D8:  MOVFF  00,01
025DC:  MOVFF  03,02
025E0:  BRA    26F4
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
025E2:  CLRF   xA5
025E4:  CLRF   xA4
025E6:  MOVLB  0
025E8:  CALL   0BE2
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
025EC:  MOVLB  9
025EE:  CLRF   xA1
025F0:  MOVLB  0
025F2:  CALL   0B4A
025F6:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
025FA:  MOVLW  01
025FC:  MOVLB  9
025FE:  MOVWF  xA1
02600:  MOVLB  0
02602:  CALL   0B4A
02606:  MOVFF  01,985
....................    WriteReg(EDMASTL, temp.v[0]); 
0260A:  MOVLW  10
0260C:  MOVLB  9
0260E:  MOVWF  xA7
02610:  MOVFF  984,9A8
02614:  MOVLB  0
02616:  CALL   0B88
....................    WriteReg(EDMASTH, temp.v[1]); 
0261A:  MOVLW  11
0261C:  MOVLB  9
0261E:  MOVWF  xA7
02620:  MOVFF  985,9A8
02624:  MOVLB  0
02626:  CALL   0B88
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
0262A:  MOVLB  9
0262C:  MOVF   x85,W
0262E:  SUBLW  1B
02630:  BNC   2668
02632:  BNZ   263A
02634:  MOVF   x84,W
02636:  SUBLW  F7
02638:  BNC   2668
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
0263A:  MOVLW  01
0263C:  SUBWF  x82,W
0263E:  MOVWF  00
02640:  MOVLW  00
02642:  SUBWFB x83,W
02644:  MOVWF  03
02646:  MOVF   00,W
02648:  ADDWF  x84,F
0264A:  MOVF   03,W
0264C:  ADDWFC x85,F
....................       if(temp.Val > RXSTOP) 
0264E:  MOVF   x85,W
02650:  SUBLW  1A
02652:  BC    2666
02654:  XORLW  FF
02656:  BNZ   265E
02658:  MOVF   x84,W
0265A:  SUBLW  F7
0265C:  BC    2666
....................       { 
....................          temp.Val -= RXSIZE; 
0265E:  MOVLW  F8
02660:  SUBWF  x84,F
02662:  MOVLW  1B
02664:  SUBWFB x85,F
....................       } 
....................    } 
02666:  BRA    267C
....................    else 
....................    { 
....................       temp.Val += len-1; 
02668:  MOVLW  01
0266A:  SUBWF  x82,W
0266C:  MOVWF  00
0266E:  MOVLW  00
02670:  SUBWFB x83,W
02672:  MOVWF  03
02674:  MOVF   00,W
02676:  ADDWF  x84,F
02678:  MOVF   03,W
0267A:  ADDWFC x85,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
0267C:  MOVLW  12
0267E:  MOVWF  xA7
02680:  MOVFF  984,9A8
02684:  MOVLB  0
02686:  CALL   0B88
....................    WriteReg(EDMANDH, temp.v[1]); 
0268A:  MOVLW  13
0268C:  MOVLB  9
0268E:  MOVWF  xA7
02690:  MOVFF  985,9A8
02694:  MOVLB  0
02696:  CALL   0B88
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
0269A:  MOVLW  1F
0269C:  MOVLB  9
0269E:  MOVWF  xA9
026A0:  MOVLW  30
026A2:  MOVWF  xAA
026A4:  MOVLB  0
026A6:  CALL   0BC4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
026AA:  MOVLW  1F
026AC:  MOVLB  9
026AE:  MOVWF  xA1
026B0:  MOVLB  0
026B2:  CALL   0B4A
026B6:  MOVFF  01,986
026BA:  MOVLW  00
026BC:  MOVLB  9
026BE:  BTFSC  01.5
026C0:  MOVLW  01
026C2:  XORLW  00
026C4:  BTFSC  FD8.2
026C6:  BRA    26CC
026C8:  MOVLB  0
026CA:  BRA    26AA
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
026CC:  MOVLW  16
026CE:  MOVWF  xA1
026D0:  MOVLB  0
026D2:  CALL   0B4A
026D6:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
026DA:  MOVLW  17
026DC:  MOVLB  9
026DE:  MOVWF  xA1
026E0:  MOVLB  0
026E2:  CALL   0B4A
026E6:  MOVFF  01,985
....................    return temp.Val; 
026EA:  MOVLB  9
026EC:  MOVFF  984,01
026F0:  MOVFF  985,02
026F4:  MOVLB  0
026F6:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
02574:  BCF    F94.1
02576:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
02578:  MOVLW  3A
0257A:  MOVLB  9
0257C:  MOVWF  xAC
0257E:  MOVLB  0
02580:  CALL   0B10
....................    c=ENCSPIXfer(0); 
02584:  MOVLB  9
02586:  CLRF   xAC
02588:  MOVLB  0
0258A:  CALL   0B10
0258E:  MOVFF  01,986
....................    SPIUnselectEthernet(); 
02592:  BCF    F94.1
02594:  BSF    F8B.1
....................    return(c); 
02596:  MOVLB  9
02598:  MOVFF  986,01
0259C:  MOVLB  0
0259E:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
01770:  MOVLB  9
01772:  CLRF   x95
01774:  CLRF   x94
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
01776:  BCF    F94.1
01778:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
0177A:  MOVLW  3A
0177C:  MOVWF  xAC
0177E:  MOVLB  0
01780:  CALL   0B10
....................    while(i<len) 
01784:  MOVLB  9
01786:  MOVF   x95,W
01788:  SUBWF  x93,W
0178A:  BNC   17C4
0178C:  BNZ   1794
0178E:  MOVF   x92,W
01790:  SUBWF  x94,W
01792:  BC    17C4
....................    { 
....................       *val=ENCSPIXfer(0); 
01794:  MOVFF  991,03
01798:  MOVFF  990,996
0179C:  MOVFF  991,997
017A0:  CLRF   xAC
017A2:  MOVLB  0
017A4:  CALL   0B10
017A8:  MOVFF  997,FEA
017AC:  MOVFF  996,FE9
017B0:  MOVFF  01,FEF
....................       val++; 
017B4:  MOVLB  9
017B6:  INCF   x90,F
017B8:  BTFSC  FD8.2
017BA:  INCF   x91,F
....................       i++; 
017BC:  INCF   x94,F
017BE:  BTFSC  FD8.2
017C0:  INCF   x95,F
017C2:  BRA    1786
....................    } 
....................    SPIUnselectEthernet(); 
017C4:  BCF    F94.1
017C6:  BSF    F8B.1
....................  
....................    return(i); 
017C8:  MOVFF  994,01
017CC:  MOVFF  995,02
017D0:  MOVLB  0
017D2:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01BB2:  BCF    F94.1
01BB4:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BB6:  MOVLW  7A
01BB8:  MOVLB  9
01BBA:  MOVWF  xAC
01BBC:  MOVLB  0
01BBE:  CALL   0B10
....................    ENCSPIXfer(val); 
01BC2:  MOVFF  9A5,9AC
01BC6:  CALL   0B10
....................    SPIUnselectEthernet(); 
01BCA:  BCF    F94.1
01BCC:  BSF    F8B.1
01BCE:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01BD0:  BCF    F94.1
01BD2:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BD4:  MOVLW  7A
01BD6:  MOVLB  9
01BD8:  MOVWF  xAC
01BDA:  MOVLB  0
01BDC:  CALL   0B10
....................    while(len--) 
01BE0:  MOVLB  9
01BE2:  MOVFF  9A9,03
01BE6:  MOVF   xA8,W
01BE8:  BTFSC  FD8.2
01BEA:  DECF   xA9,F
01BEC:  DECF   xA8,F
01BEE:  IORWF  03,W
01BF0:  BZ    1C12
....................    { 
....................       ENCSPIXfer(*val); 
01BF2:  MOVFF  9A7,03
01BF6:  MOVFF  9A6,FE9
01BFA:  MOVFF  9A7,FEA
01BFE:  MOVFF  FEF,9AC
01C02:  MOVLB  0
01C04:  CALL   0B10
....................       val++; 
01C08:  MOVLB  9
01C0A:  INCF   xA6,F
01C0C:  BTFSC  FD8.2
01C0E:  INCF   xA7,F
01C10:  BRA    1BE2
....................    } 
....................    SPIUnselectEthernet(); 
01C12:  BCF    F94.1
01C14:  BSF    F8B.1
01C16:  MOVLB  0
01C18:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B74:  BCF    F94.1
00B76:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
00B78:  MOVLB  9
00B7A:  SETF   xAC
00B7C:  MOVLB  0
00B7E:  RCALL  0B10
....................    SPIUnselectEthernet(); 
00B80:  BCF    F94.1
00B82:  BSF    F8B.1
00B84:  GOTO   0E40 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
00B4A:  BCF    F94.1
00B4C:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
00B4E:  MOVFF  9A1,9A3
00B52:  MOVFF  9A1,9AC
00B56:  MOVLB  0
00B58:  RCALL  0B10
....................    c=ENCSPIXfer(0); 
00B5A:  MOVLB  9
00B5C:  CLRF   xAC
00B5E:  MOVLB  0
00B60:  RCALL  0B10
00B62:  MOVFF  01,9A2
....................    SPIUnselectEthernet(); 
00B66:  BCF    F94.1
00B68:  BSF    F8B.1
....................    return(c); 
00B6A:  MOVLB  9
00B6C:  MOVFF  9A2,01
00B70:  MOVLB  0
00B72:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
00C14:  BCF    F94.1
00C16:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
00C18:  MOVFF  8FE,900
00C1C:  MOVFF  8FE,9AC
00C20:  MOVLB  0
00C22:  RCALL  0B10
....................    ENCSPIXfer(0); 
00C24:  MOVLB  9
00C26:  CLRF   xAC
00C28:  MOVLB  0
00C2A:  RCALL  0B10
....................    c=ENCSPIXfer(0); 
00C2C:  MOVLB  9
00C2E:  CLRF   xAC
00C30:  MOVLB  0
00C32:  RCALL  0B10
00C34:  MOVFF  01,8FF
....................  
....................    SPIUnselectEthernet(); 
00C38:  BCF    F94.1
00C3A:  BSF    F8B.1
....................  
....................    return(c); 
00C3C:  MOVLB  8
00C3E:  MOVFF  8FF,01
00C42:  MOVLB  0
00C44:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
00CD6:  MOVLW  02
00CD8:  MOVLB  9
00CDA:  MOVWF  xA5
00CDC:  MOVLW  14
00CDE:  MOVWF  xA4
00CE0:  MOVLB  0
00CE2:  RCALL  0BE2
....................    WriteReg(MIREGADR, Register); 
00CE4:  MOVLW  14
00CE6:  MOVLB  9
00CE8:  MOVWF  xA7
00CEA:  MOVFF  8FB,9A8
00CEE:  MOVLB  0
00CF0:  RCALL  0B88
....................    WriteReg(MICMD, MICMD_MIIRD); 
00CF2:  MOVLW  12
00CF4:  MOVLB  9
00CF6:  MOVWF  xA7
00CF8:  MOVLW  01
00CFA:  MOVWF  xA8
00CFC:  MOVLB  0
00CFE:  RCALL  0B88
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
00D00:  MOVLW  03
00D02:  MOVLB  9
00D04:  MOVWF  xA5
00D06:  MOVLW  0A
00D08:  MOVWF  xA4
00D0A:  MOVLB  0
00D0C:  RCALL  0BE2
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00D0E:  MOVLW  0A
00D10:  MOVLB  8
00D12:  MOVWF  xFE
00D14:  MOVLB  0
00D16:  RCALL  0C14
00D18:  MOVFF  01,8FE
00D1C:  MOVLW  00
00D1E:  MOVLB  8
00D20:  BTFSC  01.0
00D22:  MOVLW  01
00D24:  XORLW  00
00D26:  BTFSC  FD8.2
00D28:  BRA    0D2E
00D2A:  MOVLB  0
00D2C:  BRA    0D0E
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
00D2E:  MOVLW  02
00D30:  MOVLB  9
00D32:  MOVWF  xA5
00D34:  MOVLW  14
00D36:  MOVWF  xA4
00D38:  MOVLB  0
00D3A:  RCALL  0BE2
....................    WriteReg(MICMD, 0x00); 
00D3C:  MOVLW  12
00D3E:  MOVLB  9
00D40:  MOVWF  xA7
00D42:  CLRF   xA8
00D44:  MOVLB  0
00D46:  RCALL  0B88
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
00D48:  MOVLW  18
00D4A:  MOVLB  8
00D4C:  MOVWF  xFE
00D4E:  MOVLB  0
00D50:  RCALL  0C14
00D52:  MOVFF  01,8FC
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
00D56:  MOVLW  19
00D58:  MOVLB  8
00D5A:  MOVWF  xFE
00D5C:  MOVLB  0
00D5E:  RCALL  0C14
00D60:  MOVFF  01,8FD
....................    return Result; 
00D64:  MOVLB  8
00D66:  MOVFF  8FC,01
00D6A:  MOVFF  8FD,02
00D6E:  MOVLB  0
00D70:  RETURN 0
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B88:  BCF    F94.1
00B8A:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
00B8C:  MOVLB  9
00B8E:  MOVF   xA7,W
00B90:  IORLW  40
00B92:  MOVWF  xA9
00B94:  MOVWF  xAC
00B96:  MOVLB  0
00B98:  RCALL  0B10
....................    ENCSPIXfer(Data); 
00B9A:  MOVFF  9A8,9AC
00B9E:  RCALL  0B10
....................    SPIUnselectEthernet(); 
00BA0:  BCF    F94.1
00BA2:  BSF    F8B.1
00BA4:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00BA6:  BCF    F94.1
00BA8:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
00BAA:  MOVLB  9
00BAC:  MOVF   xA6,W
00BAE:  IORLW  A0
00BB0:  MOVWF  xA8
00BB2:  MOVWF  xAC
00BB4:  MOVLB  0
00BB6:  RCALL  0B10
....................    ENCSPIXfer(Data); 
00BB8:  MOVFF  9A7,9AC
00BBC:  RCALL  0B10
....................    SPIUnselectEthernet(); 
00BBE:  BCF    F94.1
00BC0:  BSF    F8B.1
00BC2:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00BC4:  BCF    F94.1
00BC6:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
00BC8:  MOVLB  9
00BCA:  MOVF   xA9,W
00BCC:  IORLW  80
00BCE:  MOVWF  xAB
00BD0:  MOVWF  xAC
00BD2:  MOVLB  0
00BD4:  RCALL  0B10
....................    ENCSPIXfer(Data); 
00BD6:  MOVFF  9AA,9AC
00BDA:  RCALL  0B10
....................    SPIUnselectEthernet(); 
00BDC:  BCF    F94.1
00BDE:  BSF    F8B.1
00BE0:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
00C46:  MOVLW  02
00C48:  MOVLB  9
00C4A:  MOVWF  xA5
00C4C:  MOVLW  14
00C4E:  MOVWF  xA4
00C50:  MOVLB  0
00C52:  RCALL  0BE2
....................    WriteReg(MIREGADR, Register); 
00C54:  MOVLW  14
00C56:  MOVLB  9
00C58:  MOVWF  xA7
00C5A:  MOVFF  8FB,9A8
00C5E:  MOVLB  0
00C60:  RCALL  0B88
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00C62:  MOVLW  08
00C64:  MOVLB  8
00C66:  MOVWF  xFF
00C68:  MOVLW  FC
00C6A:  MOVWF  xFE
00C6C:  MOVWF  FE9
00C6E:  MOVFF  8FF,FEA
00C72:  MOVFF  FEF,9A8
00C76:  MOVLW  16
00C78:  MOVLB  9
00C7A:  MOVWF  xA7
00C7C:  MOVLB  0
00C7E:  RCALL  0B88
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00C80:  MOVLW  08
00C82:  MOVLB  8
00C84:  MOVWF  xFF
00C86:  MOVLW  FC
00C88:  MOVWF  xFE
00C8A:  MOVLW  01
00C8C:  ADDWF  xFE,W
00C8E:  MOVWF  FE9
00C90:  MOVLW  00
00C92:  ADDWFC xFF,W
00C94:  MOVWF  FEA
00C96:  MOVFF  FEF,9A8
00C9A:  MOVLW  17
00C9C:  MOVLB  9
00C9E:  MOVWF  xA7
00CA0:  MOVLB  0
00CA2:  RCALL  0B88
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
00CA4:  MOVLW  03
00CA6:  MOVLB  9
00CA8:  MOVWF  xA5
00CAA:  MOVLW  0A
00CAC:  MOVWF  xA4
00CAE:  MOVLB  0
00CB0:  RCALL  0BE2
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00CB2:  MOVLW  0A
00CB4:  MOVLB  8
00CB6:  MOVWF  xFE
00CB8:  MOVLB  0
00CBA:  RCALL  0C14
00CBC:  MOVFF  01,8FE
00CC0:  MOVLW  00
00CC2:  MOVLB  8
00CC4:  BTFSC  01.0
00CC6:  MOVLW  01
00CC8:  XORLW  00
00CCA:  BTFSC  FD8.2
00CCC:  BRA    0CD2
00CCE:  MOVLB  0
00CD0:  BRA    0CB2
00CD2:  MOVLB  0
00CD4:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
00BE2:  MOVLW  1F
00BE4:  MOVLB  9
00BE6:  MOVWF  xA6
00BE8:  MOVLW  03
00BEA:  MOVWF  xA7
00BEC:  MOVLB  0
00BEE:  RCALL  0BA6
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00BF0:  MOVLW  09
00BF2:  MOVLB  9
00BF4:  MOVWF  xA7
00BF6:  MOVLW  A4
00BF8:  MOVWF  xA6
00BFA:  MOVLW  01
00BFC:  ADDWF  xA6,W
00BFE:  MOVWF  FE9
00C00:  MOVLW  00
00C02:  ADDWFC xA7,W
00C04:  MOVWF  FEA
00C06:  MOVFF  FEF,9AA
00C0A:  MOVLW  1F
00C0C:  MOVWF  xA9
00C0E:  MOVLB  0
00C10:  RCALL  0BC4
00C12:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
00D72:  MOVLW  1F
00D74:  MOVLB  9
00D76:  MOVWF  xA6
00D78:  MOVLW  0C
00D7A:  MOVWF  xA7
00D7C:  MOVLB  0
00D7E:  RCALL  0BA6
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
00D80:  MOVLB  8
00D82:  CLRF   xFB
00D84:  MOVLB  0
00D86:  RCALL  0CD6
00D88:  MOVFF  02,8FA
00D8C:  MOVFF  01,8F9
....................    if(DuplexState == USE_PHY) 
00D90:  MOVLB  8
00D92:  MOVF   xF7,W
00D94:  SUBLW  02
00D96:  BNZ   0DA0
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
00D98:  CLRF   xF7
00D9A:  BTFSC  xFA.0
00D9C:  INCF   xF7,F
....................    } 
00D9E:  BRA    0DB6
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
00DA0:  BCF    xFA.0
00DA2:  BTFSC  xF7.0
00DA4:  BSF    xFA.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
00DA6:  CLRF   xFB
00DA8:  MOVFF  8FA,8FD
00DAC:  MOVFF  8F9,8FC
00DB0:  MOVLB  0
00DB2:  RCALL  0C46
00DB4:  MOVLB  8
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
00DB6:  MOVLW  02
00DB8:  MOVLB  9
00DBA:  MOVWF  xA5
00DBC:  MOVWF  xA4
00DBE:  MOVLB  0
00DC0:  RCALL  0BE2
....................    Register = ReadMACReg(MACON3); 
00DC2:  MOVLW  02
00DC4:  MOVLB  8
00DC6:  MOVWF  xFE
00DC8:  MOVLB  0
00DCA:  RCALL  0C14
00DCC:  MOVFF  01,8F8
....................    Register.MACON3bits.FULDPX = DuplexState; 
00DD0:  MOVLB  8
00DD2:  BCF    xF8.0
00DD4:  BTFSC  xF7.0
00DD6:  BSF    xF8.0
....................    WriteReg(MACON3, Register.Val); 
00DD8:  MOVLW  02
00DDA:  MOVLB  9
00DDC:  MOVWF  xA7
00DDE:  MOVFF  8F8,9A8
00DE2:  MOVLB  0
00DE4:  RCALL  0B88
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
00DE6:  MOVLB  8
00DE8:  MOVF   xF7,F
00DEA:  BZ    0DF0
00DEC:  MOVLW  15
00DEE:  BRA    0DF2
00DF0:  MOVLW  12
00DF2:  MOVWF  xFB
00DF4:  MOVLW  04
00DF6:  MOVLB  9
00DF8:  MOVWF  xA7
00DFA:  MOVFF  8FB,9A8
00DFE:  MOVLB  0
00E00:  RCALL  0B88
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
00E02:  MOVLW  1F
00E04:  MOVLB  9
00E06:  MOVWF  xA9
00E08:  MOVLW  04
00E0A:  MOVWF  xAA
00E0C:  MOVLB  0
00E0E:  RCALL  0BC4
00E10:  GOTO   0FD4 (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
02392:  MOVLW  09
02394:  MOVLB  9
02396:  MOVWF  x1B
02398:  MOVLW  06
0239A:  MOVWF  x1A
0239C:  MOVFF  91B,991
023A0:  MOVWF  x90
023A2:  CLRF   x93
023A4:  MOVLW  14
023A6:  MOVWF  x92
023A8:  MOVLB  0
023AA:  CALL   1770
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
023AE:  MOVLB  9
023B0:  MOVF   x06,W
023B2:  ANDLW  F0
023B4:  SUBLW  40
023B6:  BZ    23BE
....................     	return FALSE; 
023B8:  MOVLW  00
023BA:  MOVWF  01
023BC:  BRA    2478
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
023BE:  MOVF   x06,W
023C0:  ANDLW  0F
023C2:  MOVWF  00
023C4:  RLCF   00,W
023C6:  MOVLB  3
023C8:  MOVWF  x94
023CA:  RLCF   x94,F
023CC:  MOVLW  FC
023CE:  ANDWF  x94,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
023D0:  MOVLB  9
023D2:  CLRF   x58
023D4:  CLRF   x57
023D6:  CLRF   x5A
023D8:  MOVFF  394,959
023DC:  MOVLB  0
023DE:  RCALL  213A
023E0:  MOVFF  02,905
023E4:  MOVFF  01,904
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
023E8:  MOVLB  9
023EA:  CLRF   x2E
023EC:  MOVFF  394,92D
023F0:  MOVLB  0
023F2:  RCALL  2248
....................  
....................     if(CalcChecksum.Val) 
023F4:  MOVLB  9
023F6:  MOVF   x04,W
023F8:  IORWF  x05,W
023FA:  BZ    2402
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
023FC:  MOVLW  00
023FE:  MOVWF  01
02400:  BRA    2478
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
02402:  MOVLW  09
02404:  MOVWF  x9C
02406:  MOVLW  06
02408:  MOVWF  x9B
0240A:  MOVLB  0
0240C:  RCALL  22CA
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
0240E:  MOVLB  8
02410:  MOVF   xFC,W
02412:  IORWF  xFD,W
02414:  BZ    242E
....................         localIP->Val    = header.DestAddress.Val; 
02416:  MOVFF  8FC,FE9
0241A:  MOVFF  8FD,FEA
0241E:  MOVFF  916,FEF
02422:  MOVFF  917,FEC
02426:  MOVFF  918,FEC
0242A:  MOVFF  919,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
0242E:  MOVLW  06
02430:  ADDWF  xFE,W
02432:  MOVWF  FE9
02434:  MOVLW  00
02436:  ADDWFC xFF,W
02438:  MOVWF  FEA
0243A:  MOVFF  912,FEF
0243E:  MOVFF  913,FEC
02442:  MOVFF  914,FEC
02446:  MOVFF  915,FEC
....................     *protocol           = header.Protocol; 
0244A:  MOVLB  9
0244C:  MOVFF  900,FE9
02450:  MOVFF  901,FEA
02454:  MOVFF  90F,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
02458:  MOVFF  902,FE9
0245C:  MOVFF  903,FEA
02460:  MOVLB  3
02462:  MOVF   x94,W
02464:  MOVLB  9
02466:  SUBWF  x08,W
02468:  MOVWF  00
0246A:  MOVLW  00
0246C:  SUBWFB x09,W
0246E:  MOVFF  00,FEF
02472:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
02474:  MOVLW  01
02476:  MOVWF  01
02478:  MOVLB  0
0247A:  GOTO   452A (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02E46:  MOVLW  14
02E48:  MOVLB  3
02E4A:  MOVWF  x94
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
02E4C:  MOVLW  45
02E4E:  MOVLB  9
02E50:  MOVWF  x87
....................     header.TypeOfService    = IP_SERVICE; 
02E52:  CLRF   x88
....................     header.TotalLength      = sizeof(header) + len; 
02E54:  MOVLW  14
02E56:  ADDWF  x85,W
02E58:  MOVWF  x89
02E5A:  MOVLW  00
02E5C:  ADDWFC x86,W
02E5E:  MOVWF  x8A
....................     header.Identification   = ++_Identifier; 
02E60:  MOVLB  3
02E62:  INCF   x92,F
02E64:  BTFSC  FD8.2
02E66:  INCF   x93,F
02E68:  MOVFF  393,98C
02E6C:  MOVFF  392,98B
....................     header.FragmentInfo     = 0; 
02E70:  MOVLB  9
02E72:  CLRF   x8E
02E74:  CLRF   x8D
....................     header.TimeToLive       = MY_IP_TTL; 
02E76:  MOVLW  64
02E78:  MOVWF  x8F
....................     header.Protocol         = protocol; 
02E7A:  MOVFF  984,990
....................     header.HeaderChecksum   = 0; 
02E7E:  CLRF   x92
02E80:  CLRF   x91
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
02E82:  MOVFF  353,996
02E86:  MOVFF  352,995
02E8A:  MOVFF  351,994
02E8E:  MOVFF  350,993
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02E92:  MOVLW  06
02E94:  ADDWF  x82,W
02E96:  MOVWF  FE9
02E98:  MOVLW  00
02E9A:  ADDWFC x83,W
02E9C:  MOVWF  FEA
02E9E:  MOVFF  FEF,997
02EA2:  MOVFF  FEC,998
02EA6:  MOVFF  FEC,999
02EAA:  MOVFF  FEC,99A
....................  
....................     SwapIPHeader(&header); 
02EAE:  MOVLW  09
02EB0:  MOVWF  x9C
02EB2:  MOVLW  87
02EB4:  MOVWF  x9B
02EB6:  MOVLB  0
02EB8:  CALL   22CA
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
02EBC:  MOVLB  9
02EBE:  MOVFF  982,01
02EC2:  MOVFF  983,03
02EC6:  MOVFF  982,99B
02ECA:  MOVFF  983,99C
02ECE:  MOVLW  14
02ED0:  ADDWF  x85,W
02ED2:  MOVWF  x9D
02ED4:  MOVLW  00
02ED6:  ADDWFC x86,W
02ED8:  MOVWF  x9E
02EDA:  MOVFF  983,9A0
02EDE:  MOVFF  982,99F
02EE2:  CLRF   xA1
02EE4:  MOVWF  xA3
02EE6:  MOVFF  99D,9A2
02EEA:  MOVLB  0
02EEC:  CALL   1C1A
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
02EF0:  MOVLW  09
02EF2:  MOVLB  9
02EF4:  MOVWF  x9C
02EF6:  MOVLW  87
02EF8:  MOVWF  x9B
02EFA:  MOVFF  99C,9A7
02EFE:  MOVWF  xA6
02F00:  CLRF   xA9
02F02:  MOVLW  14
02F04:  MOVWF  xA8
02F06:  MOVLB  0
02F08:  CALL   1BD0
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
02F0C:  MOVLB  9
02F0E:  CLRF   x9C
02F10:  CLRF   x9B
02F12:  CLRF   x9E
02F14:  MOVLW  14
02F16:  MOVWF  x9D
02F18:  MOVLB  0
02F1A:  RCALL  2D6E
02F1C:  MOVFF  02,992
02F20:  MOVFF  01,991
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
02F24:  MOVFF  387,99B
02F28:  MOVLB  9
02F2A:  CLRF   x9D
02F2C:  MOVLW  0A
02F2E:  MOVWF  x9C
02F30:  MOVLB  0
02F32:  CALL   1B14
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02F36:  MOVLW  09
02F38:  MOVLB  9
02F3A:  MOVWF  x9C
02F3C:  MOVLW  91
02F3E:  MOVWF  x9B
02F40:  MOVFF  99C,9A7
02F44:  MOVWF  xA6
02F46:  CLRF   xA9
02F48:  MOVLW  02
02F4A:  MOVWF  xA8
02F4C:  MOVLB  0
02F4E:  CALL   1BD0
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
02F52:  MOVFF  387,99B
02F56:  MOVLB  9
02F58:  CLRF   x9D
02F5A:  MOVLW  14
02F5C:  MOVWF  x9C
02F5E:  MOVLB  0
02F60:  CALL   1B14
.................... #endif 
....................  
....................     return 0x0; 
02F64:  MOVLW  00
02F66:  MOVWF  01
02F68:  MOVWF  02
02F6A:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
026F8:  MOVLB  3
026FA:  MOVF   x94,W
026FC:  MOVLB  9
026FE:  ADDWF  x29,W
02700:  MOVWF  x2B
02702:  MOVLW  00
02704:  ADDWFC x2A,W
02706:  MOVWF  x2C
02708:  MOVWF  x2E
0270A:  MOVFF  92B,92D
0270E:  MOVLB  0
02710:  RCALL  2248
02712:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
022CA:  MOVLW  02
022CC:  MOVLB  9
022CE:  ADDWF  x9B,W
022D0:  MOVWF  01
022D2:  MOVLW  00
022D4:  ADDWFC x9C,W
022D6:  MOVWF  03
022D8:  MOVFF  01,99D
022DC:  MOVWF  x9E
022DE:  MOVLW  02
022E0:  ADDWF  x9B,W
022E2:  MOVWF  FE9
022E4:  MOVLW  00
022E6:  ADDWFC x9C,W
022E8:  MOVWF  FEA
022EA:  MOVFF  FEC,9A2
022EE:  MOVF   FED,F
022F0:  MOVFF  FEF,9A1
022F4:  MOVLB  0
022F6:  CALL   17D4
022FA:  MOVFF  99E,FEA
022FE:  MOVFF  99D,FE9
02302:  MOVFF  02,FEC
02306:  MOVF   FED,F
02308:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
0230C:  MOVLW  04
0230E:  MOVLB  9
02310:  ADDWF  x9B,W
02312:  MOVWF  01
02314:  MOVLW  00
02316:  ADDWFC x9C,W
02318:  MOVWF  03
0231A:  MOVFF  01,99D
0231E:  MOVWF  x9E
02320:  MOVLW  04
02322:  ADDWF  x9B,W
02324:  MOVWF  FE9
02326:  MOVLW  00
02328:  ADDWFC x9C,W
0232A:  MOVWF  FEA
0232C:  MOVFF  FEC,9A2
02330:  MOVF   FED,F
02332:  MOVFF  FEF,9A1
02336:  MOVLB  0
02338:  CALL   17D4
0233C:  MOVFF  99E,FEA
02340:  MOVFF  99D,FE9
02344:  MOVFF  02,FEC
02348:  MOVF   FED,F
0234A:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
0234E:  MOVLW  0A
02350:  MOVLB  9
02352:  ADDWF  x9B,W
02354:  MOVWF  01
02356:  MOVLW  00
02358:  ADDWFC x9C,W
0235A:  MOVWF  03
0235C:  MOVFF  01,99D
02360:  MOVWF  x9E
02362:  MOVLW  0A
02364:  ADDWF  x9B,W
02366:  MOVWF  FE9
02368:  MOVLW  00
0236A:  ADDWFC x9C,W
0236C:  MOVWF  FEA
0236E:  MOVFF  FEC,9A2
02372:  MOVF   FED,F
02374:  MOVFF  FEF,9A1
02378:  MOVLB  0
0237A:  CALL   17D4
0237E:  MOVFF  99E,FEA
02382:  MOVFF  99D,FE9
02386:  MOVFF  02,FEC
0238A:  MOVF   FED,F
0238C:  MOVFF  01,FEF
02390:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
01164:  MOVLB  8
01166:  CLRF   xF6
01168:  MOVF   xF6,W
0116A:  SUBLW  22
0116C:  BNC   124C
....................     { 
....................         ps = &TCB[s]; 
0116E:  MOVLB  9
01170:  CLRF   x47
01172:  MOVFF  8F6,946
01176:  CLRF   x49
01178:  MOVLW  24
0117A:  MOVWF  x48
0117C:  MOVLB  0
0117E:  RCALL  1006
01180:  MOVFF  02,03
01184:  MOVF   01,W
01186:  ADDLW  97
01188:  MOVWF  01
0118A:  MOVLW  03
0118C:  ADDWFC 03,F
0118E:  MOVFF  01,8F7
01192:  MOVLB  8
01194:  MOVFF  03,8F8
....................  
....................         ps->smState             = TCP_CLOSED; 
01198:  MOVFF  8F7,FE9
0119C:  MOVFF  8F8,FEA
011A0:  MOVLW  0A
011A2:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
011A4:  MOVLW  23
011A6:  ADDWF  xF7,W
011A8:  MOVWF  FE9
011AA:  MOVLW  00
011AC:  ADDWFC xF8,W
011AE:  MOVWF  FEA
011B0:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
011B2:  MOVLW  23
011B4:  ADDWF  xF7,W
011B6:  MOVWF  FE9
011B8:  MOVLW  00
011BA:  ADDWFC xF8,W
011BC:  MOVWF  FEA
011BE:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
011C0:  MOVLW  23
011C2:  ADDWF  xF7,W
011C4:  MOVWF  FE9
011C6:  MOVLW  00
011C8:  ADDWFC xF8,W
011CA:  MOVWF  FEA
011CC:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
011CE:  MOVLW  23
011D0:  ADDWF  xF7,W
011D2:  MOVWF  FE9
011D4:  MOVLW  00
011D6:  ADDWFC xF8,W
011D8:  MOVWF  FEA
011DA:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
011DC:  MOVLW  23
011DE:  ADDWF  xF7,W
011E0:  MOVWF  FE9
011E2:  MOVLW  00
011E4:  ADDWFC xF8,W
011E6:  MOVWF  FEA
011E8:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
011EA:  MOVLW  0F
011EC:  ADDWF  xF7,W
011EE:  MOVWF  FE9
011F0:  MOVLW  00
011F2:  ADDWFC xF8,W
011F4:  MOVWF  FEA
011F6:  INCFSZ FEF,W
011F8:  BRA    11FC
011FA:  BRA    1222
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
011FC:  MOVLW  0F
011FE:  ADDWF  xF7,W
01200:  MOVWF  FE9
01202:  MOVLW  00
01204:  ADDWFC xF8,W
01206:  MOVWF  FEA
01208:  MOVFF  FEF,949
0120C:  MOVLB  0
0120E:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
01212:  MOVLW  0F
01214:  MOVLB  8
01216:  ADDWF  xF7,W
01218:  MOVWF  FE9
0121A:  MOVLW  00
0121C:  ADDWFC xF8,W
0121E:  MOVWF  FEA
01220:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
01222:  MOVLW  21
01224:  ADDWF  xF7,W
01226:  MOVWF  FE9
01228:  MOVLW  00
0122A:  ADDWFC xF8,W
0122C:  MOVWF  FEA
0122E:  CLRF   FEC
01230:  MOVF   FED,F
01232:  MOVLW  24
01234:  MOVWF  FEF
....................       ps->TxCount            = 0; 
01236:  MOVLW  10
01238:  ADDWF  xF7,W
0123A:  MOVWF  FE9
0123C:  MOVLW  00
0123E:  ADDWFC xF8,W
01240:  MOVWF  FEA
01242:  CLRF   FEC
01244:  MOVF   FED,F
01246:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
01248:  INCF   xF6,F
0124A:  BRA    1168
....................     TCPInit_RandSeed+=get_timer0(); 
0124C:  MOVF   FD6,W
0124E:  ADDWF  x83,F
01250:  MOVF   FD7,W
01252:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
01254:  MOVF   FCE,W
01256:  ADDWF  x83,F
01258:  MOVF   FCF,W
0125A:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
0125C:  MOVF   FCC,W
0125E:  ADDWF  x83,F
01260:  MOVLW  00
01262:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
01264:  MOVF   FB2,W
01266:  ADDWF  x83,F
01268:  MOVF   FB3,W
0126A:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
0126C:  CLRF   xFC
0126E:  CLRF   xFB
01270:  MOVFF  884,8FA
01274:  MOVFF  883,8F9
01278:  MOVLB  0
0127A:  BRA    1028
....................     _NextPort=rand(); 
0127C:  BRA    10E0
0127E:  MOVFF  02,396
01282:  MOVFF  01,395
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
01286:  MOVLW  04
01288:  MOVLB  3
0128A:  ADDWF  x96,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
0128C:  MOVF   x96,W
0128E:  SUBLW  12
01290:  BC    12A6
01292:  XORLW  FF
01294:  BNZ   129C
01296:  MOVF   x95,W
01298:  SUBLW  87
0129A:  BC    12A6
0129C:  MOVLW  88
0129E:  SUBWF  x95,F
012A0:  MOVLW  13
012A2:  SUBWFB x96,F
012A4:  BRA    128C
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
012A6:  MOVF   x96,W
012A8:  SUBLW  03
012AA:  BNC   12B0
012AC:  MOVLW  04
012AE:  ADDWF  x96,F
012B0:  MOVLB  0
012B2:  GOTO   12C4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
0472A:  MOVLB  9
0472C:  BCF    x00.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0472E:  MOVLB  8
04730:  CLRF   xFD
04732:  MOVF   xFD,W
04734:  SUBLW  22
04736:  BNC   477E
....................    { 
....................       ps = &TCB[s]; 
04738:  MOVLB  9
0473A:  CLRF   x47
0473C:  MOVFF  8FD,946
04740:  CLRF   x49
04742:  MOVLW  24
04744:  MOVWF  x48
04746:  MOVLB  0
04748:  CALL   1006
0474C:  MOVFF  02,03
04750:  MOVF   01,W
04752:  ADDLW  97
04754:  MOVWF  01
04756:  MOVLW  03
04758:  ADDWFC 03,F
0475A:  MOVFF  01,8FE
0475E:  MOVLB  8
04760:  MOVFF  03,8FF
....................       if(ps->smState == TCP_CLOSED) 
04764:  MOVFF  8FE,FE9
04768:  MOVFF  8FF,FEA
0476C:  MOVF   FEF,W
0476E:  SUBLW  0A
04770:  BNZ   477A
....................       { 
....................          lbFound = TRUE; 
04772:  MOVLB  9
04774:  BSF    x00.0
....................          break; 
04776:  MOVLB  8
04778:  BRA    477E
....................       } 
0477A:  INCF   xFD,F
0477C:  BRA    4732
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
0477E:  MOVLB  9
04780:  BTFSC  x00.0
04782:  BRA    478A
....................       return INVALID_SOCKET; 
04784:  MOVLW  FE
04786:  MOVWF  01
04788:  BRA    493A
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
0478A:  MOVLW  0B
0478C:  MOVLB  8
0478E:  ADDWF  xFE,W
04790:  MOVWF  FE9
04792:  MOVLW  00
04794:  ADDWFC xFF,W
04796:  MOVWF  FEA
04798:  MOVLB  3
0479A:  INCF   x95,F
0479C:  BTFSC  FD8.2
0479E:  INCF   x96,F
047A0:  MOVFF  396,FEC
047A4:  MOVF   FED,F
047A6:  MOVFF  395,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
047AA:  MOVF   x96,W
047AC:  SUBLW  12
047AE:  BC    47C0
047B0:  XORLW  FF
047B2:  BNZ   47BA
047B4:  MOVF   x95,W
047B6:  SUBLW  87
047B8:  BC    47C0
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
047BA:  MOVLW  03
047BC:  MOVWF  x96
047BE:  SETF   x95
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
047C0:  MOVLW  23
047C2:  MOVLB  8
047C4:  ADDWF  xFE,W
047C6:  MOVWF  FE9
047C8:  MOVLW  00
047CA:  ADDWFC xFF,W
047CC:  MOVWF  FEA
047CE:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
047D0:  MOVLW  0D
047D2:  ADDWF  xFE,W
047D4:  MOVWF  FE9
047D6:  MOVLW  00
047D8:  ADDWFC xFF,W
047DA:  MOVWF  FEA
047DC:  MOVFF  8FC,FEC
047E0:  MOVF   FED,F
047E2:  MOVFF  8FB,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
047E6:  MOVLW  16
047E8:  ADDWF  xFE,W
047EA:  MOVWF  FE9
047EC:  MOVLW  00
047EE:  ADDWFC xFF,W
047F0:  MOVWF  FEA
047F2:  MOVLW  01
047F4:  ADDWF  FEE,F
047F6:  MOVLW  00
047F8:  ADDWFC FEE,F
047FA:  ADDWFC FEE,F
047FC:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
047FE:  MOVLW  1A
04800:  ADDWF  xFE,W
04802:  MOVWF  FE9
04804:  MOVLW  00
04806:  ADDWFC xFF,W
04808:  MOVWF  FEA
0480A:  MOVF   FEE,F
0480C:  MOVF   FEE,F
0480E:  CLRF   FEC
04810:  MOVF   FED,F
04812:  CLRF   FEF
04814:  MOVF   FED,F
04816:  CLRF   FEF
04818:  MOVF   FED,F
0481A:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
0481C:  MOVLW  01
0481E:  ADDWF  xFE,W
04820:  MOVWF  01
04822:  MOVLW  00
04824:  ADDWFC xFF,W
04826:  MOVWF  03
04828:  MOVFF  01,901
0482C:  MOVLB  9
0482E:  MOVWF  x02
04830:  MOVWF  FEA
04832:  MOVFF  01,FE9
04836:  MOVFF  8FA,FE2
0483A:  MOVFF  8F9,FE1
0483E:  MOVLW  0A
04840:  MOVWF  01
04842:  MOVFF  FE6,FEE
04846:  DECFSZ 01,F
04848:  BRA    4842
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
0484A:  MOVLW  01
0484C:  MOVLB  8
0484E:  ADDWF  xFE,W
04850:  MOVWF  01
04852:  MOVLW  00
04854:  ADDWFC xFF,W
04856:  MOVWF  03
04858:  MOVFF  01,901
0485C:  MOVLB  9
0485E:  MOVWF  x02
04860:  MOVLW  0B
04862:  MOVLB  8
04864:  ADDWF  xFE,W
04866:  MOVWF  FE9
04868:  MOVLW  00
0486A:  ADDWFC xFF,W
0486C:  MOVWF  FEA
0486E:  MOVFF  FEC,94D
04872:  MOVF   FED,F
04874:  MOVFF  FEF,94C
04878:  MOVLW  0D
0487A:  ADDWF  xFE,W
0487C:  MOVWF  FE9
0487E:  MOVLW  00
04880:  ADDWFC xFF,W
04882:  MOVWF  FEA
04884:  MOVFF  FEC,94F
04888:  MOVF   FED,F
0488A:  MOVFF  FEF,94E
0488E:  MOVLW  16
04890:  ADDWF  xFE,W
04892:  MOVWF  FE9
04894:  MOVLW  00
04896:  ADDWFC xFF,W
04898:  MOVWF  FEA
0489A:  MOVFF  FEF,950
0489E:  MOVFF  FEC,951
048A2:  MOVFF  FEC,952
048A6:  MOVFF  FEC,953
048AA:  MOVLW  1A
048AC:  ADDWF  xFE,W
048AE:  MOVWF  FE9
048B0:  MOVLW  00
048B2:  ADDWFC xFF,W
048B4:  MOVWF  FEA
048B6:  MOVFF  FEF,954
048BA:  MOVFF  FEC,955
048BE:  MOVFF  FEC,956
048C2:  MOVFF  FEC,957
048C6:  MOVFF  03,94B
048CA:  MOVFF  01,94A
048CE:  MOVLW  02
048D0:  MOVLB  9
048D2:  MOVWF  x58
048D4:  SETF   x59
048D6:  CLRF   x5B
048D8:  CLRF   x5A
048DA:  MOVLB  0
048DC:  CALL   2F6C
....................  
....................    ps->smState = TCP_SYN_SENT; 
048E0:  MOVLB  8
048E2:  MOVFF  8FE,FE9
048E6:  MOVFF  8FF,FEA
048EA:  MOVLW  01
048EC:  MOVWF  FEF
....................    ps->SND_SEQ++; 
048EE:  MOVLW  16
048F0:  ADDWF  xFE,W
048F2:  MOVWF  FE9
048F4:  MOVLW  00
048F6:  ADDWFC xFF,W
048F8:  MOVWF  FEA
048FA:  MOVLW  01
048FC:  ADDWF  FEE,F
048FE:  MOVLW  00
04900:  ADDWFC FEE,F
04902:  ADDWFC FEE,F
04904:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
04906:  MOVLW  1F
04908:  ADDWF  xFE,W
0490A:  MOVWF  01
0490C:  MOVLW  00
0490E:  ADDWFC xFF,W
04910:  MOVWF  03
04912:  MOVFF  01,901
04916:  MOVLB  9
04918:  MOVWF  x02
0491A:  MOVLB  0
0491C:  CALL   2B16
04920:  MOVFF  902,FEA
04924:  MOVFF  901,FE9
04928:  MOVFF  02,FEC
0492C:  MOVF   FED,F
0492E:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
04932:  MOVLB  8
04934:  MOVFF  8FD,01
04938:  MOVLB  9
0493A:  MOVLB  0
0493C:  GOTO   5416 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
04940:  MOVLB  9
04942:  CLRF   x47
04944:  MOVFF  8F9,946
04948:  CLRF   x49
0494A:  MOVLW  24
0494C:  MOVWF  x48
0494E:  MOVLB  0
04950:  CALL   1006
04954:  MOVFF  02,8FB
04958:  MOVFF  01,8FA
0495C:  MOVLW  97
0495E:  MOVLB  8
04960:  ADDWF  01,W
04962:  MOVWF  FE9
04964:  MOVLW  03
04966:  ADDWFC 02,W
04968:  MOVWF  FEA
0496A:  MOVF   FEF,W
0496C:  SUBLW  03
0496E:  BZ    4974
04970:  MOVLW  00
04972:  BRA    4976
04974:  MOVLW  01
04976:  MOVWF  01
04978:  MOVLB  0
0497A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0509A:  MOVLB  9
0509C:  CLRF   x47
0509E:  MOVFF  8FB,946
050A2:  CLRF   x49
050A4:  MOVLW  24
050A6:  MOVWF  x48
050A8:  MOVLB  0
050AA:  CALL   1006
050AE:  MOVFF  02,03
050B2:  MOVF   01,W
050B4:  ADDLW  97
050B6:  MOVWF  01
050B8:  MOVLW  03
050BA:  ADDWFC 03,F
050BC:  MOVFF  01,8FC
050C0:  MOVLB  8
050C2:  MOVFF  03,8FD
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
050C6:  MOVFF  8FC,FE9
050CA:  MOVFF  8FD,FEA
050CE:  MOVF   FEF,W
050D0:  SUBLW  03
050D2:  BZ    50F4
050D4:  MOVFF  8FC,FE9
050D8:  MOVFF  8FD,FEA
050DC:  MOVF   FEF,W
050DE:  SUBLW  02
050E0:  BZ    50F4
....................    { 
....................       CloseSocket(ps); 
050E2:  MOVFF  8FD,947
050E6:  MOVFF  8FC,946
050EA:  MOVLB  0
050EC:  CALL   2B30
....................       return; 
050F0:  BRA    51BA
050F2:  MOVLB  8
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
050F4:  MOVFF  8FB,903
050F8:  MOVLB  0
050FA:  BRA    5038
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
050FC:  MOVLW  01
050FE:  MOVLB  8
05100:  ADDWF  xFC,W
05102:  MOVWF  01
05104:  MOVLW  00
05106:  ADDWFC xFD,W
05108:  MOVWF  03
0510A:  MOVFF  01,900
0510E:  MOVLB  9
05110:  MOVWF  x01
05112:  MOVLW  0B
05114:  MOVLB  8
05116:  ADDWF  xFC,W
05118:  MOVWF  FE9
0511A:  MOVLW  00
0511C:  ADDWFC xFD,W
0511E:  MOVWF  FEA
05120:  MOVFF  FEC,94D
05124:  MOVF   FED,F
05126:  MOVFF  FEF,94C
0512A:  MOVLW  0D
0512C:  ADDWF  xFC,W
0512E:  MOVWF  FE9
05130:  MOVLW  00
05132:  ADDWFC xFD,W
05134:  MOVWF  FEA
05136:  MOVFF  FEC,94F
0513A:  MOVF   FED,F
0513C:  MOVFF  FEF,94E
05140:  MOVLW  16
05142:  ADDWF  xFC,W
05144:  MOVWF  FE9
05146:  MOVLW  00
05148:  ADDWFC xFD,W
0514A:  MOVWF  FEA
0514C:  MOVFF  FEF,950
05150:  MOVFF  FEC,951
05154:  MOVFF  FEC,952
05158:  MOVFF  FEC,953
0515C:  MOVLW  1A
0515E:  ADDWF  xFC,W
05160:  MOVWF  FE9
05162:  MOVLW  00
05164:  ADDWFC xFD,W
05166:  MOVWF  FEA
05168:  MOVFF  FEF,954
0516C:  MOVFF  FEC,955
05170:  MOVFF  FEC,956
05174:  MOVFF  FEC,957
05178:  MOVFF  03,94B
0517C:  MOVFF  01,94A
05180:  MOVLW  11
05182:  MOVLB  9
05184:  MOVWF  x58
05186:  SETF   x59
05188:  CLRF   x5B
0518A:  CLRF   x5A
0518C:  MOVLB  0
0518E:  CALL   2F6C
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
05192:  MOVLW  16
05194:  MOVLB  8
05196:  ADDWF  xFC,W
05198:  MOVWF  FE9
0519A:  MOVLW  00
0519C:  ADDWFC xFD,W
0519E:  MOVWF  FEA
051A0:  MOVLW  01
051A2:  ADDWF  FEE,F
051A4:  MOVLW  00
051A6:  ADDWFC FEE,F
051A8:  ADDWFC FEE,F
051AA:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
051AC:  MOVFF  8FC,FE9
051B0:  MOVFF  8FD,FEA
051B4:  MOVLW  04
051B6:  MOVWF  FEF
051B8:  MOVLB  0
....................  
....................    return; 
051BA:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
04CB4:  MOVLB  9
04CB6:  CLRF   x47
04CB8:  MOVFF  904,946
04CBC:  CLRF   x49
04CBE:  MOVLW  24
04CC0:  MOVWF  x48
04CC2:  MOVLB  0
04CC4:  CALL   1006
04CC8:  MOVFF  02,03
04CCC:  MOVF   01,W
04CCE:  ADDLW  97
04CD0:  MOVWF  01
04CD2:  MOVLW  03
04CD4:  ADDWFC 03,F
04CD6:  MOVFF  01,905
04CDA:  MOVLB  9
04CDC:  MOVFF  03,906
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
04CE0:  MOVLW  0F
04CE2:  ADDWF  x05,W
04CE4:  MOVWF  FE9
04CE6:  MOVLW  00
04CE8:  ADDWFC x06,W
04CEA:  MOVWF  FEA
04CEC:  INCFSZ FEF,W
04CEE:  BRA    4CF6
....................       return FALSE; 
04CF0:  MOVLW  00
04CF2:  MOVWF  01
04CF4:  BRA    4E50
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
04CF6:  MOVLW  23
04CF8:  ADDWF  x05,W
04CFA:  MOVWF  FE9
04CFC:  MOVLW  00
04CFE:  ADDWFC x06,W
04D00:  MOVWF  FEA
04D02:  MOVFF  FEF,00
04D06:  RRCF   00,W
04D08:  ANDLW  01
04D0A:  BNZ   4D12
....................       return FALSE; 
04D0C:  MOVLW  00
04D0E:  MOVWF  01
04D10:  BRA    4E50
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
04D12:  MOVLW  01
04D14:  ADDWF  x05,W
04D16:  MOVWF  01
04D18:  MOVLW  00
04D1A:  ADDWFC x06,W
04D1C:  MOVWF  03
04D1E:  MOVFF  01,907
04D22:  MOVWF  x08
04D24:  MOVLW  0B
04D26:  ADDWF  x05,W
04D28:  MOVWF  FE9
04D2A:  MOVLW  00
04D2C:  ADDWFC x06,W
04D2E:  MOVWF  FEA
04D30:  MOVFF  FEC,94D
04D34:  MOVF   FED,F
04D36:  MOVFF  FEF,94C
04D3A:  MOVLW  0D
04D3C:  ADDWF  x05,W
04D3E:  MOVWF  FE9
04D40:  MOVLW  00
04D42:  ADDWFC x06,W
04D44:  MOVWF  FEA
04D46:  MOVFF  FEC,94F
04D4A:  MOVF   FED,F
04D4C:  MOVFF  FEF,94E
04D50:  MOVLW  16
04D52:  ADDWF  x05,W
04D54:  MOVWF  FE9
04D56:  MOVLW  00
04D58:  ADDWFC x06,W
04D5A:  MOVWF  FEA
04D5C:  MOVFF  FEF,950
04D60:  MOVFF  FEC,951
04D64:  MOVFF  FEC,952
04D68:  MOVFF  FEC,953
04D6C:  MOVLW  1A
04D6E:  ADDWF  x05,W
04D70:  MOVWF  FE9
04D72:  MOVLW  00
04D74:  ADDWFC x06,W
04D76:  MOVWF  FEA
04D78:  MOVFF  FEF,954
04D7C:  MOVFF  FEC,955
04D80:  MOVFF  FEC,956
04D84:  MOVFF  FEC,957
04D88:  MOVLW  0F
04D8A:  ADDWF  x05,W
04D8C:  MOVWF  FE9
04D8E:  MOVLW  00
04D90:  ADDWFC x06,W
04D92:  MOVWF  FEA
04D94:  MOVFF  FEF,959
04D98:  MOVLW  10
04D9A:  ADDWF  x05,W
04D9C:  MOVWF  FE9
04D9E:  MOVLW  00
04DA0:  ADDWFC x06,W
04DA2:  MOVWF  FEA
04DA4:  MOVFF  FEC,95B
04DA8:  MOVF   FED,F
04DAA:  MOVFF  FEF,95A
04DAE:  MOVFF  03,94B
04DB2:  MOVFF  01,94A
04DB6:  MOVLW  18
04DB8:  MOVWF  x58
04DBA:  MOVLB  0
04DBC:  CALL   2F6C
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
04DC0:  MOVLW  16
04DC2:  MOVLB  9
04DC4:  ADDWF  x05,W
04DC6:  MOVWF  01
04DC8:  MOVLW  00
04DCA:  ADDWFC x06,W
04DCC:  MOVWF  03
04DCE:  MOVFF  01,907
04DD2:  MOVWF  x08
04DD4:  MOVWF  FEA
04DD6:  MOVFF  01,FE9
04DDA:  MOVFF  FEF,909
04DDE:  MOVFF  FEC,90A
04DE2:  MOVFF  FEC,90B
04DE6:  MOVFF  FEC,90C
04DEA:  MOVLW  10
04DEC:  ADDWF  x05,W
04DEE:  MOVWF  FE9
04DF0:  MOVLW  00
04DF2:  ADDWFC x06,W
04DF4:  MOVWF  FEA
04DF6:  MOVFF  FEC,03
04DFA:  MOVF   FED,F
04DFC:  MOVFF  FEF,00
04E00:  MOVFF  03,01
04E04:  CLRF   02
04E06:  CLRF   03
04E08:  MOVF   x09,W
04E0A:  ADDWF  00,F
04E0C:  MOVF   x0A,W
04E0E:  ADDWFC 01,F
04E10:  MOVF   x0B,W
04E12:  ADDWFC 02,F
04E14:  MOVF   x0C,W
04E16:  ADDWFC 03,F
04E18:  MOVFF  908,FEA
04E1C:  MOVFF  907,FE9
04E20:  MOVFF  00,FEF
04E24:  MOVFF  01,FEC
04E28:  MOVFF  02,FEC
04E2C:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
04E30:  MOVLW  23
04E32:  ADDWF  x05,W
04E34:  MOVWF  FE9
04E36:  MOVLW  00
04E38:  ADDWFC x06,W
04E3A:  MOVWF  FEA
04E3C:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
04E3E:  MOVLW  23
04E40:  ADDWF  x05,W
04E42:  MOVWF  FE9
04E44:  MOVLW  00
04E46:  ADDWFC x06,W
04E48:  MOVWF  FEA
04E4A:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
04E4C:  MOVLW  01
04E4E:  MOVWF  01
04E50:  MOVLB  0
04E52:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
04AA8:  MOVLB  9
04AAA:  CLRF   x47
04AAC:  MOVFF  909,946
04AB0:  CLRF   x49
04AB2:  MOVLW  24
04AB4:  MOVWF  x48
04AB6:  MOVLB  0
04AB8:  CALL   1006
04ABC:  MOVFF  01,90A
04AC0:  MOVLW  14
04AC2:  MOVLB  9
04AC4:  ADDWF  01,W
04AC6:  MOVWF  01
04AC8:  MOVLW  00
04ACA:  ADDWFC 02,W
04ACC:  MOVWF  03
04ACE:  MOVF   01,W
04AD0:  ADDLW  97
04AD2:  MOVWF  FE9
04AD4:  MOVLW  03
04AD6:  ADDWFC 03,W
04AD8:  MOVWF  FEA
04ADA:  MOVFF  FEC,90B
04ADE:  MOVF   FED,F
04AE0:  MOVFF  FEF,90A
04AE4:  MOVF   x0A,F
04AE6:  BNZ   4AF2
04AE8:  MOVF   x0B,F
04AEA:  BNZ   4AF2
....................       return FALSE; 
04AEC:  MOVLW  00
04AEE:  MOVWF  01
04AF0:  BRA    4B72
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04AF2:  CLRF   x47
04AF4:  MOVFF  909,946
04AF8:  CLRF   x49
04AFA:  MOVLW  24
04AFC:  MOVWF  x48
04AFE:  MOVLB  0
04B00:  CALL   1006
04B04:  MOVFF  02,90B
04B08:  MOVFF  01,90A
04B0C:  MOVLW  0F
04B0E:  MOVLB  9
04B10:  ADDWF  01,W
04B12:  MOVWF  01
04B14:  MOVLW  00
04B16:  ADDWFC 02,W
04B18:  MOVWF  03
04B1A:  MOVF   01,W
04B1C:  ADDLW  97
04B1E:  MOVWF  FE9
04B20:  MOVLW  03
04B22:  ADDWFC 03,W
04B24:  MOVWF  FEA
04B26:  INCFSZ FEF,W
04B28:  BRA    4B3A
....................       return IPIsTxReady(FALSE); 
04B2A:  CLRF   x82
04B2C:  MOVLB  0
04B2E:  CALL   2C2E
04B32:  MOVF   01,W
04B34:  MOVLB  9
04B36:  BRA    4B72
04B38:  BRA    4B72
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
04B3A:  CLRF   x47
04B3C:  MOVFF  909,946
04B40:  CLRF   x49
04B42:  MOVLW  24
04B44:  MOVWF  x48
04B46:  MOVLB  0
04B48:  CALL   1006
04B4C:  MOVFF  02,90B
04B50:  MOVFF  01,90A
04B54:  MOVLW  23
04B56:  MOVLB  9
04B58:  ADDWF  x0A,F
04B5A:  MOVLW  00
04B5C:  ADDWFC x0B,F
04B5E:  MOVLW  97
04B60:  ADDWF  x0A,W
04B62:  MOVWF  FE9
04B64:  MOVLW  03
04B66:  ADDWFC x0B,W
04B68:  MOVWF  FEA
04B6A:  MOVLW  00
04B6C:  BTFSC  FEF.1
04B6E:  MOVLW  01
04B70:  MOVWF  01
04B72:  MOVLB  0
04B74:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
04B76:  MOVFF  904,909
04B7A:  RCALL  4AA8
04B7C:  MOVF   01,F
04B7E:  BNZ   4B88
....................       return(0); 
04B80:  MOVLW  00
04B82:  MOVWF  01
04B84:  MOVWF  02
04B86:  BRA    4CAE
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04B88:  MOVLB  9
04B8A:  CLRF   x47
04B8C:  MOVFF  904,946
04B90:  CLRF   x49
04B92:  MOVLW  24
04B94:  MOVWF  x48
04B96:  MOVLB  0
04B98:  CALL   1006
04B9C:  MOVFF  02,90A
04BA0:  MOVFF  01,909
04BA4:  MOVLW  0F
04BA6:  MOVLB  9
04BA8:  ADDWF  01,W
04BAA:  MOVWF  01
04BAC:  MOVLW  00
04BAE:  ADDWFC 02,W
04BB0:  MOVWF  03
04BB2:  MOVF   01,W
04BB4:  ADDLW  97
04BB6:  MOVWF  FE9
04BB8:  MOVLW  03
04BBA:  ADDWFC 03,W
04BBC:  MOVWF  FEA
04BBE:  INCFSZ FEF,W
04BC0:  BRA    4BC8
....................       txCount = 0; 
04BC2:  CLRF   x06
04BC4:  CLRF   x05
04BC6:  BRA    4C02
....................    else 
....................       txCount = TCB[s].TxCount; 
04BC8:  CLRF   x47
04BCA:  MOVFF  904,946
04BCE:  CLRF   x49
04BD0:  MOVLW  24
04BD2:  MOVWF  x48
04BD4:  MOVLB  0
04BD6:  CALL   1006
04BDA:  MOVFF  01,909
04BDE:  MOVLW  10
04BE0:  MOVLB  9
04BE2:  ADDWF  01,W
04BE4:  MOVWF  01
04BE6:  MOVLW  00
04BE8:  ADDWFC 02,W
04BEA:  MOVWF  03
04BEC:  MOVF   01,W
04BEE:  ADDLW  97
04BF0:  MOVWF  FE9
04BF2:  MOVLW  03
04BF4:  ADDWFC 03,W
04BF6:  MOVWF  FEA
04BF8:  MOVFF  FEC,906
04BFC:  MOVF   FED,F
04BFE:  MOVFF  FEF,905
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
04C02:  MOVLW  CA
04C04:  BSF    FD8.0
04C06:  SUBFWB x05,W
04C08:  MOVWF  x07
04C0A:  MOVLW  03
04C0C:  SUBFWB x06,W
04C0E:  MOVWF  x08
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
04C10:  CLRF   x47
04C12:  MOVFF  904,946
04C16:  CLRF   x49
04C18:  MOVLW  24
04C1A:  MOVWF  x48
04C1C:  MOVLB  0
04C1E:  CALL   1006
04C22:  MOVFF  02,90A
04C26:  MOVFF  01,909
04C2A:  MOVLW  14
04C2C:  MOVLB  9
04C2E:  ADDWF  01,W
04C30:  MOVWF  01
04C32:  MOVLW  00
04C34:  ADDWFC 02,W
04C36:  MOVWF  03
04C38:  MOVF   01,W
04C3A:  ADDLW  97
04C3C:  MOVWF  FE9
04C3E:  MOVLW  03
04C40:  ADDWFC 03,W
04C42:  MOVWF  FEA
04C44:  MOVFF  FEC,03
04C48:  MOVF   FED,F
04C4A:  MOVFF  FEF,01
04C4E:  MOVF   03,W
04C50:  SUBWF  x08,W
04C52:  BNC   4C9A
04C54:  BNZ   4C5C
04C56:  MOVF   x07,W
04C58:  SUBWF  01,W
04C5A:  BC    4C9A
04C5C:  CLRF   x47
04C5E:  MOVFF  904,946
04C62:  CLRF   x49
04C64:  MOVLW  24
04C66:  MOVWF  x48
04C68:  MOVLB  0
04C6A:  CALL   1006
04C6E:  MOVFF  02,90A
04C72:  MOVFF  01,909
04C76:  MOVLW  14
04C78:  MOVLB  9
04C7A:  ADDWF  01,W
04C7C:  MOVWF  01
04C7E:  MOVLW  00
04C80:  ADDWFC 02,W
04C82:  MOVWF  03
04C84:  MOVF   01,W
04C86:  ADDLW  97
04C88:  MOVWF  FE9
04C8A:  MOVLW  03
04C8C:  ADDWFC 03,W
04C8E:  MOVWF  FEA
04C90:  MOVFF  FEC,03
04C94:  MOVF   FED,F
04C96:  MOVF   FEF,W
04C98:  BRA    4CA0
04C9A:  MOVFF  908,03
04C9E:  MOVF   x07,W
04CA0:  MOVWF  x07
04CA2:  MOVFF  03,908
....................  
....................    return(txAvail); 
04CA6:  MOVFF  907,01
04CAA:  MOVFF  908,02
04CAE:  MOVLB  0
04CB0:  GOTO   4F2E (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
04E54:  MOVLB  9
04E56:  CLRF   x47
04E58:  MOVFF  8FB,946
04E5C:  CLRF   x49
04E5E:  MOVLW  24
04E60:  MOVWF  x48
04E62:  MOVLB  0
04E64:  CALL   1006
04E68:  MOVFF  02,03
04E6C:  MOVF   01,W
04E6E:  ADDLW  97
04E70:  MOVWF  01
04E72:  MOVLW  03
04E74:  ADDWFC 03,F
04E76:  MOVFF  01,900
04E7A:  MOVLB  9
04E7C:  MOVFF  03,901
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
04E80:  MOVLW  14
04E82:  ADDWF  x00,W
04E84:  MOVWF  FE9
04E86:  MOVLW  00
04E88:  ADDWFC x01,W
04E8A:  MOVWF  FEA
04E8C:  MOVFF  FEC,905
04E90:  MOVF   FED,F
04E92:  MOVFF  FEF,904
04E96:  MOVF   x04,F
04E98:  BNZ   4EA6
04E9A:  MOVF   x05,F
04E9C:  BNZ   4EA6
....................       return 0; 
04E9E:  MOVLW  00
04EA0:  MOVWF  01
04EA2:  MOVWF  02
04EA4:  BRA    5032
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
04EA6:  MOVLW  0F
04EA8:  ADDWF  x00,W
04EAA:  MOVWF  FE9
04EAC:  MOVLW  00
04EAE:  ADDWFC x01,W
04EB0:  MOVWF  FEA
04EB2:  INCFSZ FEF,W
04EB4:  BRA    4F26
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
04EB6:  MOVLW  0F
04EB8:  ADDWF  x00,W
04EBA:  MOVWF  01
04EBC:  MOVLW  00
04EBE:  ADDWFC x01,W
04EC0:  MOVWF  03
04EC2:  MOVFF  01,904
04EC6:  MOVWF  x05
04EC8:  CLRF   x82
04ECA:  MOVLB  0
04ECC:  CALL   1AEC
04ED0:  MOVFF  905,FEA
04ED4:  MOVFF  904,FE9
04ED8:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
04EDC:  MOVLW  0F
04EDE:  MOVLB  9
04EE0:  ADDWF  x00,W
04EE2:  MOVWF  FE9
04EE4:  MOVLW  00
04EE6:  ADDWFC x01,W
04EE8:  MOVWF  FEA
04EEA:  INCFSZ FEF,W
04EEC:  BRA    4EF6
....................          return 0; 
04EEE:  MOVLW  00
04EF0:  MOVWF  01
04EF2:  MOVWF  02
04EF4:  BRA    5032
....................  
....................       ps->TxCount = 0; 
04EF6:  MOVLW  10
04EF8:  ADDWF  x00,W
04EFA:  MOVWF  FE9
04EFC:  MOVLW  00
04EFE:  ADDWFC x01,W
04F00:  MOVWF  FEA
04F02:  CLRF   FEC
04F04:  MOVF   FED,F
04F06:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
04F08:  MOVLW  0F
04F0A:  ADDWF  x00,W
04F0C:  MOVWF  FE9
04F0E:  MOVLW  00
04F10:  ADDWFC x01,W
04F12:  MOVWF  FEA
04F14:  MOVFF  FEF,99B
04F18:  CLRF   x9D
04F1A:  MOVLW  28
04F1C:  MOVWF  x9C
04F1E:  MOVLB  0
04F20:  CALL   1B14
04F24:  MOVLB  9
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
04F26:  MOVFF  8FB,904
04F2A:  MOVLB  0
04F2C:  BRA    4B76
04F2E:  MOVFF  02,903
04F32:  MOVFF  01,902
....................     
....................    len = n < len ? n : len; 
04F36:  MOVLB  9
04F38:  MOVF   x03,W
04F3A:  MOVLB  8
04F3C:  SUBWF  xFF,W
04F3E:  BNC   4F5C
04F40:  BNZ   4F50
04F42:  MOVF   xFE,W
04F44:  MOVLB  9
04F46:  SUBWF  x02,W
04F48:  BTFSS  FD8.0
04F4A:  BRA    4F50
04F4C:  MOVLB  8
04F4E:  BRA    4F5C
04F50:  MOVFF  903,03
04F54:  MOVLB  9
04F56:  MOVF   x02,W
04F58:  BRA    4F62
04F5A:  MOVLB  8
04F5C:  MOVFF  8FF,03
04F60:  MOVF   xFE,W
04F62:  MOVLB  8
04F64:  MOVWF  xFE
04F66:  MOVFF  03,8FF
....................    n = len; 
04F6A:  MOVFF  8FF,903
04F6E:  MOVFF  8FE,902
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
04F72:  MOVLW  23
04F74:  MOVLB  9
04F76:  ADDWF  x00,W
04F78:  MOVWF  FE9
04F7A:  MOVLW  00
04F7C:  ADDWFC x01,W
04F7E:  MOVWF  FEA
04F80:  BSF    FEF.4
....................  
....................    while (n--) 
04F82:  MOVFF  903,03
04F86:  MOVF   x02,W
04F88:  BTFSC  FD8.2
04F8A:  DECF   x03,F
04F8C:  DECF   x02,F
04F8E:  IORWF  03,W
04F90:  BZ    4FF6
....................    { 
....................       MACPut(*ptr++); 
04F92:  MOVLB  8
04F94:  MOVFF  8FD,03
04F98:  MOVF   xFC,W
04F9A:  INCF   xFC,F
04F9C:  BTFSC  FD8.2
04F9E:  INCF   xFD,F
04FA0:  MOVWF  FE9
04FA2:  MOVFF  03,FEA
04FA6:  MOVFF  FEF,9A5
04FAA:  MOVLB  0
04FAC:  CALL   1BB2
....................       ps->RemoteWindow -= 1; 
04FB0:  MOVLW  14
04FB2:  MOVLB  9
04FB4:  ADDWF  x00,W
04FB6:  MOVWF  FE9
04FB8:  MOVLW  00
04FBA:  ADDWFC x01,W
04FBC:  MOVWF  FEA
04FBE:  MOVLW  01
04FC0:  SUBWF  FEF,W
04FC2:  MOVWF  00
04FC4:  MOVLW  00
04FC6:  SUBWFB FEC,W
04FC8:  MOVWF  03
04FCA:  MOVF   00,W
04FCC:  MOVF   FED,F
04FCE:  MOVWF  FEF
04FD0:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
04FD4:  MOVLW  10
04FD6:  ADDWF  x00,W
04FD8:  MOVWF  FE9
04FDA:  MOVLW  00
04FDC:  ADDWFC x01,W
04FDE:  MOVWF  FEA
04FE0:  MOVLW  01
04FE2:  ADDWF  FEF,W
04FE4:  MOVWF  01
04FE6:  MOVLW  00
04FE8:  ADDWFC FEC,W
04FEA:  MOVWF  03
04FEC:  MOVF   FED,F
04FEE:  MOVFF  01,FEF
04FF2:  MOVWF  FEC
04FF4:  BRA    4F82
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
04FF6:  MOVLW  10
04FF8:  ADDWF  x00,W
04FFA:  MOVWF  FE9
04FFC:  MOVLW  00
04FFE:  ADDWFC x01,W
05000:  MOVWF  FEA
05002:  MOVFF  FEC,905
05006:  MOVF   FED,F
05008:  MOVFF  FEF,904
0500C:  MOVF   x05,W
0500E:  SUBLW  02
05010:  BC    5026
05012:  XORLW  FF
05014:  BNZ   501C
05016:  MOVF   x04,W
05018:  SUBLW  C9
0501A:  BC    5026
....................       TCPFlush(s); 
0501C:  MOVFF  8FB,904
05020:  MOVLB  0
05022:  RCALL  4CB4
05024:  MOVLB  9
....................  
....................    return(len); 
05026:  MOVLB  8
05028:  MOVFF  8FE,01
0502C:  MOVFF  8FF,02
05030:  MOVLB  9
05032:  MOVLB  0
05034:  GOTO   5282 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
05038:  MOVLB  9
0503A:  CLRF   x47
0503C:  MOVFF  903,946
05040:  CLRF   x49
05042:  MOVLW  24
05044:  MOVWF  x48
05046:  MOVLB  0
05048:  CALL   1006
0504C:  MOVFF  02,03
05050:  MOVF   01,W
05052:  ADDLW  97
05054:  MOVWF  01
05056:  MOVLW  03
05058:  ADDWFC 03,F
0505A:  MOVFF  01,904
0505E:  MOVLB  9
05060:  MOVFF  03,905
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
05064:  MOVLW  23
05066:  ADDWF  x04,W
05068:  MOVWF  FE9
0506A:  MOVLW  00
0506C:  ADDWFC x05,W
0506E:  MOVWF  FEA
05070:  BTFSC  FEF.3
05072:  BRA    507A
....................         return FALSE; 
05074:  MOVLW  00
05076:  MOVWF  01
05078:  BRA    5094
....................  
....................     MACDiscardRx(); 
0507A:  MOVLB  0
0507C:  CALL   16FA
....................     ps->Flags.bIsGetReady = FALSE; 
05080:  MOVLW  23
05082:  MOVLB  9
05084:  ADDWF  x04,W
05086:  MOVWF  FE9
05088:  MOVLW  00
0508A:  ADDWFC x05,W
0508C:  MOVWF  FEA
0508E:  BCF    FEF.3
....................  
....................     return TRUE; 
05090:  MOVLW  01
05092:  MOVWF  01
05094:  MOVLB  0
05096:  GOTO   50FC (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
049BC:  MOVLB  9
049BE:  CLRF   x47
049C0:  MOVFF  8FB,946
049C4:  CLRF   x49
049C6:  MOVLW  24
049C8:  MOVWF  x48
049CA:  MOVLB  0
049CC:  CALL   1006
049D0:  MOVFF  02,03
049D4:  MOVF   01,W
049D6:  ADDLW  97
049D8:  MOVWF  01
049DA:  MOVLW  03
049DC:  ADDWFC 03,F
049DE:  MOVFF  01,8FE
049E2:  MOVLB  8
049E4:  MOVFF  03,8FF
....................  
....................     if ( ps->Flags.bIsGetReady ) 
049E8:  MOVLW  23
049EA:  ADDWF  xFE,W
049EC:  MOVWF  FE9
049EE:  MOVLW  00
049F0:  ADDWFC xFF,W
049F2:  MOVWF  FEA
049F4:  BTFSS  FEF.3
049F6:  BRA    4A9E
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
049F8:  MOVLW  23
049FA:  ADDWF  xFE,W
049FC:  MOVWF  FE9
049FE:  MOVLW  00
04A00:  ADDWFC xFF,W
04A02:  MOVWF  FEA
04A04:  BTFSS  FEF.2
04A06:  BRA    4A26
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
04A08:  MOVLB  9
04A0A:  CLRF   x2A
04A0C:  MOVLW  14
04A0E:  MOVWF  x29
04A10:  MOVLB  0
04A12:  CALL   26F8
....................  
....................             ps->Flags.bFirstRead = FALSE; 
04A16:  MOVLW  23
04A18:  MOVLB  8
04A1A:  ADDWF  xFE,W
04A1C:  MOVWF  FE9
04A1E:  MOVLW  00
04A20:  ADDWFC xFF,W
04A22:  MOVWF  FEA
04A24:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
04A26:  MOVLW  12
04A28:  ADDWF  xFE,W
04A2A:  MOVWF  FE9
04A2C:  MOVLW  00
04A2E:  ADDWFC xFF,W
04A30:  MOVWF  FEA
04A32:  MOVFF  FEC,901
04A36:  MOVF   FED,F
04A38:  MOVFF  FEF,900
04A3C:  MOVLB  9
04A3E:  MOVF   x00,F
04A40:  BNZ   4A64
04A42:  MOVF   x01,F
04A44:  BNZ   4A64
....................         { 
....................             MACDiscardRx(); 
04A46:  MOVLB  0
04A48:  CALL   16FA
....................             ps->Flags.bIsGetReady = FALSE; 
04A4C:  MOVLW  23
04A4E:  MOVLB  8
04A50:  ADDWF  xFE,W
04A52:  MOVWF  FE9
04A54:  MOVLW  00
04A56:  ADDWFC xFF,W
04A58:  MOVWF  FEA
04A5A:  BCF    FEF.3
....................             return FALSE; 
04A5C:  MOVLW  00
04A5E:  MOVWF  01
04A60:  BRA    4AA2
04A62:  MOVLB  9
....................         } 
....................  
....................          ps->RxCount--; 
04A64:  MOVLW  12
04A66:  MOVLB  8
04A68:  ADDWF  xFE,W
04A6A:  MOVWF  FE9
04A6C:  MOVLW  00
04A6E:  ADDWFC xFF,W
04A70:  MOVWF  FEA
04A72:  MOVLW  FF
04A74:  ADDWF  FEF,F
04A76:  BC    4A7C
04A78:  MOVF   FEE,F
04A7A:  DECF   FED,F
....................          *data = MACGet(); 
04A7C:  MOVFF  8FD,901
04A80:  MOVFF  8FC,900
04A84:  MOVLB  0
04A86:  CALL   2574
04A8A:  MOVFF  901,FEA
04A8E:  MOVFF  900,FE9
04A92:  MOVFF  01,FEF
....................         return TRUE; 
04A96:  MOVLW  01
04A98:  MOVWF  01
04A9A:  MOVLB  8
04A9C:  BRA    4AA2
....................     } 
....................     return FALSE; 
04A9E:  MOVLW  00
04AA0:  MOVWF  01
04AA2:  MOVLB  0
04AA4:  GOTO   51E4 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
0497C:  MOVLB  9
0497E:  CLRF   x47
04980:  MOVFF  8FB,946
04984:  CLRF   x49
04986:  MOVLW  24
04988:  MOVWF  x48
0498A:  MOVLB  0
0498C:  CALL   1006
04990:  MOVFF  02,8FD
04994:  MOVFF  01,8FC
04998:  MOVLW  23
0499A:  MOVLB  8
0499C:  ADDWF  xFC,F
0499E:  MOVLW  00
049A0:  ADDWFC xFD,F
049A2:  MOVLW  97
049A4:  ADDWF  xFC,W
049A6:  MOVWF  FE9
049A8:  MOVLW  03
049AA:  ADDWFC xFD,W
049AC:  MOVWF  FEA
049AE:  MOVLW  00
049B0:  BTFSC  FEF.3
049B2:  MOVLW  01
049B4:  MOVWF  01
049B6:  MOVLB  0
049B8:  GOTO   51C4 (RETURN)
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
03FE6:  MOVLB  9
03FE8:  CLRF   x07
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
03FEA:  MOVLB  8
03FEC:  CLRF   xFC
03FEE:  MOVF   xFC,W
03FF0:  SUBLW  22
03FF2:  BTFSS  FD8.0
03FF4:  BRA    4460
....................    { 
....................       ps = &TCB[s]; 
03FF6:  MOVLB  9
03FF8:  CLRF   x47
03FFA:  MOVFF  8FC,946
03FFE:  CLRF   x49
04000:  MOVLW  24
04002:  MOVWF  x48
04004:  MOVLB  0
04006:  CALL   1006
0400A:  MOVFF  02,03
0400E:  MOVF   01,W
04010:  ADDLW  97
04012:  MOVWF  01
04014:  MOVLW  03
04016:  ADDWFC 03,F
04018:  MOVFF  01,901
0401C:  MOVLB  9
0401E:  MOVFF  03,902
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
04022:  MOVLW  23
04024:  ADDWF  x01,W
04026:  MOVWF  FE9
04028:  MOVLW  00
0402A:  ADDWFC x02,W
0402C:  MOVWF  FEA
0402E:  BTFSC  FEF.3
04030:  BRA    4042
04032:  MOVLW  23
04034:  ADDWF  x01,W
04036:  MOVWF  FE9
04038:  MOVLW  00
0403A:  ADDWFC x02,W
0403C:  MOVWF  FEA
0403E:  BTFSS  FEF.4
04040:  BRA    4044
....................          continue; 
04042:  BRA    445A
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
04044:  MOVFF  901,FE9
04048:  MOVFF  902,FEA
0404C:  MOVF   FEF,W
0404E:  SUBLW  0A
04050:  BZ    4072
04052:  MOVFF  901,FE9
04056:  MOVFF  902,FEA
0405A:  MOVF   FEF,F
0405C:  BNZ   4074
0405E:  MOVLW  23
04060:  ADDWF  x01,W
04062:  MOVWF  FE9
04064:  MOVLW  00
04066:  ADDWFC x02,W
04068:  MOVWF  FEA
0406A:  MOVF   FEF,W
0406C:  ANDLW  01
0406E:  SUBLW  01
04070:  BNZ   4074
....................          continue; 
04072:  BRA    445A
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
04074:  MOVFF  901,FE9
04078:  MOVFF  902,FEA
0407C:  MOVF   FEF,W
0407E:  SUBLW  03
04080:  BNZ   4098
04082:  MOVLW  23
04084:  ADDWF  x01,W
04086:  MOVWF  FE9
04088:  MOVLW  00
0408A:  ADDWFC x02,W
0408C:  MOVWF  FEA
0408E:  MOVF   FEF,W
04090:  ANDLW  01
04092:  SUBLW  01
04094:  BNZ   4098
....................          continue; 
04096:  BRA    445A
....................  
....................  
....................       tick = TickGet(); 
04098:  MOVLB  0
0409A:  CALL   2B16
0409E:  MOVFF  02,900
040A2:  MOVFF  01,8FF
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
040A6:  MOVLW  1F
040A8:  MOVLB  9
040AA:  ADDWF  x01,W
040AC:  MOVWF  FE9
040AE:  MOVLW  00
040B0:  ADDWFC x02,W
040B2:  MOVWF  FEA
040B4:  MOVFF  FEC,03
040B8:  MOVF   FED,F
040BA:  MOVFF  FEF,01
040BE:  MOVF   x00,W
040C0:  SUBWF  03,W
040C2:  BNC   40D6
040C4:  BNZ   40DA
040C6:  MOVF   01,W
040C8:  MOVLB  8
040CA:  SUBWF  xFF,W
040CC:  BTFSC  FD8.0
040CE:  BRA    40D4
040D0:  MOVLB  9
040D2:  BRA    40DA
040D4:  MOVLB  9
040D6:  MOVLW  00
040D8:  BRA    40DC
040DA:  MOVLW  01
040DC:  CLRF   03
040DE:  IORWF  03,W
040E0:  BZ    411C
040E2:  MOVLW  1F
040E4:  ADDWF  x01,W
040E6:  MOVWF  FE9
040E8:  MOVLW  00
040EA:  ADDWFC x02,W
040EC:  MOVWF  FEA
040EE:  MOVFF  FEC,03
040F2:  MOVF   FED,F
040F4:  MOVF   FEF,W
040F6:  SUBLW  FF
040F8:  MOVWF  x08
040FA:  MOVLW  FF
040FC:  SUBFWB 03,W
040FE:  MOVWF  x09
04100:  MOVLB  8
04102:  MOVF   xFF,W
04104:  MOVLB  9
04106:  ADDWF  x08,F
04108:  MOVF   x00,W
0410A:  ADDWFC x09,F
0410C:  MOVLW  01
0410E:  ADDWF  x08,W
04110:  MOVWF  01
04112:  MOVLW  00
04114:  ADDWFC x09,W
04116:  MOVWF  03
04118:  MOVF   01,W
0411A:  BRA    4140
0411C:  MOVLW  1F
0411E:  ADDWF  x01,W
04120:  MOVWF  FE9
04122:  MOVLW  00
04124:  ADDWFC x02,W
04126:  MOVWF  FEA
04128:  MOVFF  FEC,03
0412C:  MOVF   FED,F
0412E:  MOVF   FEF,W
04130:  MOVLB  8
04132:  SUBWF  xFF,W
04134:  MOVWF  00
04136:  MOVF   03,W
04138:  MOVLB  9
0413A:  SUBWFB x00,W
0413C:  MOVWF  03
0413E:  MOVF   00,W
04140:  MOVLB  8
04142:  MOVWF  xFD
04144:  MOVFF  03,8FE
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
04148:  MOVLW  21
0414A:  MOVLB  9
0414C:  ADDWF  x01,W
0414E:  MOVWF  FE9
04150:  MOVLW  00
04152:  ADDWFC x02,W
04154:  MOVWF  FEA
04156:  MOVFF  FEC,03
0415A:  MOVF   FED,F
0415C:  MOVFF  FEF,01
04160:  MOVLB  8
04162:  MOVF   xFE,W
04164:  SUBWF  03,W
04166:  BNC   4176
04168:  BNZ   4170
0416A:  MOVF   xFD,W
0416C:  SUBWF  01,W
0416E:  BNC   4176
....................          continue; 
04170:  MOVLB  9
04172:  BRA    445A
04174:  MOVLB  8
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
04176:  MOVLW  01
04178:  MOVLB  9
0417A:  MOVWF  x82
0417C:  MOVLB  0
0417E:  CALL   2C2E
04182:  MOVF   01,F
04184:  BNZ   4188
....................          return; 
04186:  BRA    4460
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
04188:  MOVLW  1F
0418A:  MOVLB  9
0418C:  ADDWF  x01,W
0418E:  MOVWF  01
04190:  MOVLW  00
04192:  ADDWFC x02,W
04194:  MOVWF  03
04196:  MOVFF  01,908
0419A:  MOVWF  x09
0419C:  MOVLB  0
0419E:  CALL   2B16
041A2:  MOVFF  909,FEA
041A6:  MOVFF  908,FE9
041AA:  MOVFF  02,FEC
041AE:  MOVF   FED,F
041B0:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
041B4:  MOVLW  21
041B6:  MOVLB  9
041B8:  ADDWF  x01,W
041BA:  MOVWF  FE9
041BC:  MOVLW  00
041BE:  ADDWFC x02,W
041C0:  MOVWF  FEA
041C2:  BCF    FD8.0
041C4:  RLCF   FEF,W
041C6:  MOVWF  02
041C8:  RLCF   FEC,W
041CA:  MOVWF  03
041CC:  MOVF   02,W
041CE:  MOVF   FED,F
041D0:  MOVWF  FEF
041D2:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
041D6:  MOVLW  1E
041D8:  ADDWF  x01,W
041DA:  MOVWF  FE9
041DC:  MOVLW  00
041DE:  ADDWFC x02,W
041E0:  MOVWF  FEA
041E2:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
041E4:  MOVFF  901,FE9
041E8:  MOVFF  902,FEA
041EC:  MOVLW  01
041EE:  SUBWF  FEF,W
041F0:  ADDLW  F7
041F2:  BTFSC  FD8.0
041F4:  BRA    437C
041F6:  ADDLW  09
041F8:  MOVLB  0
041FA:  GOTO   4466
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
041FE:  MOVLW  02
04200:  MOVLB  9
04202:  MOVWF  x07
....................          break; 
04204:  BRA    437C
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04206:  MOVLW  1E
04208:  MOVLB  9
0420A:  ADDWF  x01,W
0420C:  MOVWF  FE9
0420E:  MOVLW  00
04210:  ADDWFC x02,W
04212:  MOVWF  FEA
04214:  MOVF   FEF,W
04216:  SUBLW  03
04218:  BNC   4220
....................          { 
....................             flags = SYN | ACK; 
0421A:  MOVLW  12
0421C:  MOVWF  x07
....................          } 
0421E:  BRA    424C
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
04220:  MOVLW  23
04222:  ADDWF  x01,W
04224:  MOVWF  FE9
04226:  MOVLW  00
04228:  ADDWFC x02,W
0422A:  MOVWF  FEA
0422C:  BTFSS  FEF.0
0422E:  BRA    423C
....................             { 
....................                ps->smState = TCP_LISTEN; 
04230:  MOVFF  901,FE9
04234:  MOVFF  902,FEA
04238:  CLRF   FEF
....................             } 
0423A:  BRA    424C
....................             else 
....................             { 
....................                flags = SYN; 
0423C:  MOVLW  02
0423E:  MOVWF  x07
....................                ps->smState = TCP_SYN_SENT; 
04240:  MOVFF  901,FE9
04244:  MOVFF  902,FEA
04248:  MOVLW  01
0424A:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
0424C:  BRA    437C
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0424E:  MOVLW  1E
04250:  MOVLB  9
04252:  ADDWF  x01,W
04254:  MOVWF  FE9
04256:  MOVLW  00
04258:  ADDWFC x02,W
0425A:  MOVWF  FEA
0425C:  MOVF   FEF,W
0425E:  SUBLW  03
04260:  BNC   42A0
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04262:  MOVLW  0F
04264:  ADDWF  x01,W
04266:  MOVWF  FE9
04268:  MOVLW  00
0426A:  ADDWFC x02,W
0426C:  MOVWF  FEA
0426E:  INCFSZ FEF,W
04270:  BRA    4274
04272:  BRA    4296
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
04274:  MOVLW  0F
04276:  ADDWF  x01,W
04278:  MOVWF  FE9
0427A:  MOVLW  00
0427C:  ADDWFC x02,W
0427E:  MOVWF  FEA
04280:  MOVFF  FEF,99B
04284:  CLRF   x9D
04286:  CLRF   x9C
04288:  MOVLB  0
0428A:  CALL   1B14
....................                MACFlush(); 
0428E:  CALL   1CE8
....................             } 
04292:  BRA    429C
04294:  MOVLB  9
....................             else 
....................                flags = ACK; 
04296:  MOVLW  10
04298:  MOVWF  x07
0429A:  MOVLB  0
....................          } 
0429C:  BRA    42EA
0429E:  MOVLB  9
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
042A0:  MOVLW  0F
042A2:  ADDWF  x01,W
042A4:  MOVWF  FE9
042A6:  MOVLW  00
042A8:  ADDWFC x02,W
042AA:  MOVWF  FEA
042AC:  INCFSZ FEF,W
042AE:  BRA    42B2
042B0:  BRA    42D8
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
042B2:  MOVLW  0F
042B4:  ADDWF  x01,W
042B6:  MOVWF  FE9
042B8:  MOVLW  00
042BA:  ADDWFC x02,W
042BC:  MOVWF  FEA
042BE:  MOVFF  FEF,949
042C2:  MOVLB  0
042C4:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
042C8:  MOVLW  0F
042CA:  MOVLB  9
042CC:  ADDWF  x01,W
042CE:  MOVWF  FE9
042D0:  MOVLW  00
042D2:  ADDWFC x02,W
042D4:  MOVWF  FEA
042D6:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
042D8:  MOVLW  11
042DA:  MOVWF  x07
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
042DC:  MOVFF  901,FE9
042E0:  MOVFF  902,FEA
042E4:  MOVLW  04
042E6:  MOVWF  FEF
042E8:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
042EA:  MOVLB  9
042EC:  BRA    437C
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
042EE:  MOVLW  1E
042F0:  MOVLB  9
042F2:  ADDWF  x01,W
042F4:  MOVWF  FE9
042F6:  MOVLW  00
042F8:  ADDWFC x02,W
042FA:  MOVWF  FEA
042FC:  MOVF   FEF,W
042FE:  SUBLW  03
04300:  BNC   4308
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
04302:  MOVLW  01
04304:  MOVWF  x07
....................          } 
04306:  BRA    4318
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
04308:  MOVFF  902,947
0430C:  MOVFF  901,946
04310:  MOVLB  0
04312:  CALL   2B30
04316:  MOVLB  9
....................          } 
....................          break; 
04318:  BRA    437C
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
0431A:  MOVFF  902,947
0431E:  MOVFF  901,946
04322:  CALL   2B30
....................          break; 
04326:  MOVLB  9
04328:  BRA    437C
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
0432A:  MOVFF  902,947
0432E:  MOVFF  901,946
04332:  CALL   2B30
....................          break; 
04336:  MOVLB  9
04338:  BRA    437C
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
0433A:  MOVLW  01
0433C:  MOVLB  9
0433E:  MOVWF  x07
....................          ps->smState = TCP_LAST_ACK; 
04340:  MOVFF  901,FE9
04344:  MOVFF  902,FEA
04348:  MOVLW  09
0434A:  MOVWF  FEF
....................          break; 
0434C:  BRA    437C
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0434E:  MOVLW  1E
04350:  MOVLB  9
04352:  ADDWF  x01,W
04354:  MOVWF  FE9
04356:  MOVLW  00
04358:  ADDWFC x02,W
0435A:  MOVWF  FEA
0435C:  MOVF   FEF,W
0435E:  SUBLW  03
04360:  BNC   4368
....................             flags = FIN; 
04362:  MOVLW  01
04364:  MOVWF  x07
04366:  BRA    4378
....................          else 
....................             CloseSocket(ps); 
04368:  MOVFF  902,947
0436C:  MOVFF  901,946
04370:  MOVLB  0
04372:  CALL   2B30
04376:  MOVLB  9
....................          break; 
04378:  BRA    437C
0437A:  MOVLB  9
....................       } 
....................  
....................  
....................       if(flags) 
0437C:  MOVF   x07,F
0437E:  BZ    445A
....................       { 
....................          if(flags & ACK) 
04380:  BTFSS  x07.4
04382:  BRA    43A2
....................             seq = ps->SND_SEQ; 
04384:  MOVLW  16
04386:  ADDWF  x01,W
04388:  MOVWF  FE9
0438A:  MOVLW  00
0438C:  ADDWFC x02,W
0438E:  MOVWF  FEA
04390:  MOVFF  FEF,903
04394:  MOVFF  FEC,904
04398:  MOVFF  FEC,905
0439C:  MOVFF  FEC,906
043A0:  BRA    43D6
....................          else 
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
043A2:  MOVLW  16
043A4:  ADDWF  x01,W
043A6:  MOVWF  FE9
043A8:  MOVLW  00
043AA:  ADDWFC x02,W
043AC:  MOVWF  FEA
043AE:  MOVFF  FEF,903
043B2:  MOVFF  FEC,904
043B6:  MOVFF  FEC,905
043BA:  MOVFF  FEC,906
....................             ps->SND_SEQ++; 
043BE:  MOVLW  16
043C0:  ADDWF  x01,W
043C2:  MOVWF  FE9
043C4:  MOVLW  00
043C6:  ADDWFC x02,W
043C8:  MOVWF  FEA
043CA:  MOVLW  01
043CC:  ADDWF  FEE,F
043CE:  MOVLW  00
043D0:  ADDWFC FEE,F
043D2:  ADDWFC FEE,F
043D4:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
043D6:  MOVLW  01
043D8:  ADDWF  x01,W
043DA:  MOVWF  01
043DC:  MOVLW  00
043DE:  ADDWFC x02,W
043E0:  MOVWF  03
043E2:  MOVFF  01,908
043E6:  MOVWF  x09
043E8:  MOVLW  0B
043EA:  ADDWF  x01,W
043EC:  MOVWF  FE9
043EE:  MOVLW  00
043F0:  ADDWFC x02,W
043F2:  MOVWF  FEA
043F4:  MOVFF  FEC,94D
043F8:  MOVF   FED,F
043FA:  MOVFF  FEF,94C
043FE:  MOVLW  0D
04400:  ADDWF  x01,W
04402:  MOVWF  FE9
04404:  MOVLW  00
04406:  ADDWFC x02,W
04408:  MOVWF  FEA
0440A:  MOVFF  FEC,94F
0440E:  MOVF   FED,F
04410:  MOVFF  FEF,94E
04414:  MOVLW  1A
04416:  ADDWF  x01,W
04418:  MOVWF  FE9
0441A:  MOVLW  00
0441C:  ADDWFC x02,W
0441E:  MOVWF  FEA
04420:  MOVFF  FEF,954
04424:  MOVFF  FEC,955
04428:  MOVFF  FEC,956
0442C:  MOVFF  FEC,957
04430:  MOVFF  03,94B
04434:  MOVFF  01,94A
04438:  MOVFF  906,953
0443C:  MOVFF  905,952
04440:  MOVFF  904,951
04444:  MOVFF  903,950
04448:  MOVFF  907,958
0444C:  SETF   x59
0444E:  CLRF   x5B
04450:  CLRF   x5A
04452:  MOVLB  0
04454:  CALL   2F6C
04458:  MOVLB  9
....................       } 
0445A:  MOVLB  8
0445C:  INCF   xFC,F
0445E:  BRA    3FEE
04460:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
04462:  GOTO   4644 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
03BA6:  MOVLW  06
03BA8:  MOVLB  8
03BAA:  ADDWF  xFC,W
03BAC:  MOVWF  FE9
03BAE:  MOVLW  00
03BB0:  ADDWFC xFD,W
03BB2:  MOVWF  FEA
03BB4:  MOVFF  FEF,916
03BB8:  MOVFF  FEC,917
03BBC:  MOVFF  FEC,918
03BC0:  MOVFF  FEC,919
....................    pseudoHeader.DestAddress        = *localIP; 
03BC4:  MOVFF  8FE,FE9
03BC8:  MOVFF  8FF,FEA
03BCC:  MOVFF  FEF,91A
03BD0:  MOVFF  FEC,91B
03BD4:  MOVFF  FEC,91C
03BD8:  MOVFF  FEC,91D
....................    pseudoHeader.Zero               = 0x0; 
03BDC:  MOVLB  9
03BDE:  CLRF   x1E
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
03BE0:  MOVLW  06
03BE2:  MOVWF  x1F
....................    pseudoHeader.TCPLength          = len; 
03BE4:  MOVFF  901,921
03BE8:  MOVFF  900,920
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03BEC:  MOVFF  921,9A2
03BF0:  MOVFF  920,9A1
03BF4:  MOVLB  0
03BF6:  CALL   17D4
03BFA:  MOVFF  02,921
03BFE:  MOVFF  01,920
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03C02:  MOVLW  09
03C04:  MOVLB  9
03C06:  MOVWF  x29
03C08:  MOVLW  16
03C0A:  MOVWF  x28
03C0C:  MOVFF  929,985
03C10:  MOVWF  x84
03C12:  CLRF   x87
03C14:  MOVLW  0C
03C16:  MOVWF  x86
03C18:  MOVLB  0
03C1A:  CALL   247E
03C1E:  MOVFF  01,923
03C22:  MOVLB  9
03C24:  COMF   x23,F
03C26:  MOVFF  02,924
03C2A:  COMF   x24,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
03C2C:  MOVFF  901,983
03C30:  MOVFF  900,982
03C34:  MOVLB  0
03C36:  CALL   25A0
03C3A:  MOVFF  02,926
03C3E:  MOVFF  01,925
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
03C42:  MOVLB  9
03C44:  MOVF   x26,W
03C46:  SUBWF  x23,W
03C48:  BNZ   3C50
03C4A:  MOVF   x25,W
03C4C:  SUBWF  x24,W
03C4E:  BZ    3C5E
....................    { 
....................       MACDiscardRx(); 
03C50:  MOVLB  0
03C52:  CALL   16FA
....................       return TRUE; 
03C56:  MOVLW  01
03C58:  MOVWF  01
03C5A:  BRA    3D32
03C5C:  MOVLB  9
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
03C5E:  CLRF   x2A
03C60:  CLRF   x29
03C62:  MOVLB  0
03C64:  CALL   26F8
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
03C68:  MOVLW  09
03C6A:  MOVLB  9
03C6C:  MOVWF  x29
03C6E:  MOVLW  02
03C70:  MOVWF  x28
03C72:  MOVFF  929,991
03C76:  MOVWF  x90
03C78:  CLRF   x93
03C7A:  MOVLW  14
03C7C:  MOVWF  x92
03C7E:  MOVLB  0
03C80:  CALL   1770
....................    SwapTCPHeader(&TCPHeader); 
03C84:  MOVLW  09
03C86:  MOVLB  9
03C88:  MOVWF  x83
03C8A:  MOVLW  02
03C8C:  MOVWF  x82
03C8E:  MOVLB  0
03C90:  CALL   2736
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
03C94:  MOVLB  9
03C96:  SWAPF  x0E,W
03C98:  ANDLW  0F
03C9A:  MOVWF  00
03C9C:  RLCF   00,F
03C9E:  RLCF   00,F
03CA0:  MOVLW  FC
03CA2:  ANDWF  00,F
03CA4:  MOVF   00,W
03CA6:  ADDLW  EC
03CA8:  MOVWF  x27
....................    len = len - optionsSize - sizeof(TCPHeader); 
03CAA:  MOVF   x27,W
03CAC:  SUBWF  x00,W
03CAE:  MOVWF  x28
03CB0:  MOVLW  00
03CB2:  SUBWFB x01,W
03CB4:  MOVWF  x29
03CB6:  MOVLW  14
03CB8:  SUBWF  x28,W
03CBA:  MOVWF  x00
03CBC:  MOVLW  00
03CBE:  SUBWFB x29,W
03CC0:  MOVWF  x01
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
03CC2:  SWAPF  x0E,W
03CC4:  ANDLW  0F
03CC6:  MOVWF  00
03CC8:  RLCF   00,W
03CCA:  MOVWF  x28
03CCC:  RLCF   x28,F
03CCE:  MOVLW  FC
03CD0:  ANDWF  x28,F
03CD2:  CLRF   x2A
03CD4:  MOVFF  928,929
03CD8:  MOVLB  0
03CDA:  CALL   26F8
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
03CDE:  MOVLW  09
03CE0:  MOVLB  9
03CE2:  MOVWF  x29
03CE4:  MOVLW  02
03CE6:  MOVWF  x28
03CE8:  MOVFF  8FD,92B
03CEC:  MOVFF  8FC,92A
03CF0:  MOVLB  0
03CF2:  GOTO   2914
03CF6:  MOVFF  01,922
....................    if(socket != INVALID_SOCKET) 
03CFA:  MOVLB  9
03CFC:  MOVF   x22,W
03CFE:  SUBLW  FE
03D00:  BZ    3D28
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
03D02:  MOVFF  922,928
03D06:  MOVFF  8FD,92A
03D0A:  MOVFF  8FC,929
03D0E:  MOVLW  09
03D10:  MOVWF  x2C
03D12:  MOVLW  02
03D14:  MOVWF  x2B
03D16:  MOVFF  901,92E
03D1A:  MOVFF  900,92D
03D1E:  MOVLB  0
03D20:  GOTO   3190
....................    } 
03D24:  BRA    3D2E
03D26:  MOVLB  9
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
03D28:  MOVLB  0
03D2A:  CALL   16FA
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
03D2E:  MOVLW  01
03D30:  MOVWF  01
03D32:  GOTO   4582 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
02F6C:  MOVLW  01
02F6E:  MOVLB  9
02F70:  MOVWF  x82
02F72:  MOVLB  0
02F74:  RCALL  2C2E
02F76:  MOVF   01,F
02F78:  BZ    2F6C
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
02F7A:  MOVLB  9
02F7C:  INCFSZ x59,W
02F7E:  BRA    2F90
....................       buff = MACGetTxBuffer(TRUE); 
02F80:  MOVLW  01
02F82:  MOVWF  x82
02F84:  MOVLB  0
02F86:  CALL   1AEC
02F8A:  MOVFF  01,959
02F8E:  MOVLB  9
....................  
....................    if(buff == INVALID_BUFFER) 
02F90:  INCFSZ x59,W
02F92:  BRA    2F96
....................       return; 
02F94:  BRA    318C
....................  
....................    IPSetTxBuffer(buff, 0); 
02F96:  MOVFF  959,99B
02F9A:  CLRF   x9D
02F9C:  MOVLW  14
02F9E:  MOVWF  x9C
02FA0:  MOVLB  0
02FA2:  CALL   1B14
....................  
....................    header.SourcePort           = localPort; 
02FA6:  MOVFF  94D,95F
02FAA:  MOVFF  94C,95E
....................    header.DestPort             = remotePort; 
02FAE:  MOVFF  94F,961
02FB2:  MOVFF  94E,960
....................    header.SeqNumber            = tseq; 
02FB6:  MOVFF  953,965
02FBA:  MOVFF  952,964
02FBE:  MOVFF  951,963
02FC2:  MOVFF  950,962
....................    header.AckNumber            = tack; 
02FC6:  MOVFF  957,969
02FCA:  MOVFF  956,968
02FCE:  MOVFF  955,967
02FD2:  MOVFF  954,966
....................    header.Flags.bits.Reserved2 = 0; 
02FD6:  MOVLW  3F
02FD8:  MOVLB  9
02FDA:  ANDWF  x6B,W
02FDC:  MOVWF  x6B
....................    header.DataOffset.Reserved3 = 0; 
02FDE:  MOVLW  F0
02FE0:  ANDWF  x6A,W
02FE2:  MOVWF  x6A
....................    header.Flags.b              = flags; 
02FE4:  MOVFF  958,96B
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
02FE8:  MOVLB  0
02FEA:  BRA    2C56
02FEC:  MOVFF  02,96D
02FF0:  MOVFF  01,96C
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
02FF4:  MOVLB  9
02FF6:  MOVF   x6D,F
02FF8:  BNZ   3000
02FFA:  MOVF   x6C,W
02FFC:  SUBLW  28
02FFE:  BC    300A
....................    { 
....................       header.Window -= 40; 
03000:  MOVLW  28
03002:  SUBWF  x6C,F
03004:  MOVLW  00
03006:  SUBWFB x6D,F
....................    } 
03008:  BRA    300E
....................    else 
....................       header.Window = 0; 
0300A:  CLRF   x6D
0300C:  CLRF   x6C
.................... #endif 
....................  
....................    header.Checksum             = 0; 
0300E:  CLRF   x6F
03010:  CLRF   x6E
....................    header.UrgentPointer        = 0; 
03012:  CLRF   x71
03014:  CLRF   x70
....................  
....................    SwapTCPHeader(&header); 
03016:  MOVLW  09
03018:  MOVWF  x83
0301A:  MOVLW  5E
0301C:  MOVWF  x82
0301E:  MOVLB  0
03020:  CALL   2736
....................  
....................    len += sizeof(header); 
03024:  MOVLW  14
03026:  MOVLB  9
03028:  ADDWF  x5A,F
0302A:  MOVLW  00
0302C:  ADDWFC x5B,F
....................  
....................    if ( flags & SYN ) 
0302E:  BTFSS  x58.1
03030:  BRA    3050
....................    { 
....................       len += sizeof(options); 
03032:  MOVLW  04
03034:  ADDWF  x5A,F
03036:  MOVLW  00
03038:  ADDWFC x5B,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
0303A:  MOVLW  02
0303C:  MOVWF  x72
....................       options.Length = 0x04; 
0303E:  MOVLW  04
03040:  MOVWF  x73
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
03042:  MOVWF  x74
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
03044:  CLRF   x75
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
03046:  MOVLW  0F
03048:  ANDWF  x6A,W
0304A:  IORLW  60
0304C:  MOVWF  x6A
....................    } 
0304E:  BRA    3058
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
03050:  MOVLW  0F
03052:  ANDWF  x6A,W
03054:  IORLW  50
03056:  MOVWF  x6A
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03058:  MOVFF  353,979
0305C:  MOVFF  352,978
03060:  MOVFF  351,977
03064:  MOVFF  350,976
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
03068:  MOVLW  06
0306A:  ADDWF  x4A,W
0306C:  MOVWF  FE9
0306E:  MOVLW  00
03070:  ADDWFC x4B,W
03072:  MOVWF  FEA
03074:  MOVFF  FEF,97A
03078:  MOVFF  FEC,97B
0307C:  MOVFF  FEC,97C
03080:  MOVFF  FEC,97D
....................    pseudoHeader.Zero           = 0x0; 
03084:  CLRF   x7E
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
03086:  MOVLW  06
03088:  MOVWF  x7F
....................    pseudoHeader.TCPLength      = len; 
0308A:  MOVFF  95B,981
0308E:  MOVFF  95A,980
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03092:  MOVFF  981,9A2
03096:  MOVFF  980,9A1
0309A:  MOVLB  0
0309C:  CALL   17D4
030A0:  MOVFF  02,981
030A4:  MOVFF  01,980
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
030A8:  MOVLW  09
030AA:  MOVLB  9
030AC:  MOVWF  x83
030AE:  MOVLW  76
030B0:  MOVWF  x82
030B2:  MOVFF  983,985
030B6:  MOVWF  x84
030B8:  CLRF   x87
030BA:  MOVLW  0C
030BC:  MOVWF  x86
030BE:  MOVLB  0
030C0:  CALL   247E
030C4:  MOVFF  01,96E
030C8:  MOVLB  9
030CA:  COMF   x6E,F
030CC:  MOVFF  02,96F
030D0:  COMF   x6F,F
....................    checkSum.Val = header.Checksum; 
030D2:  MOVFF  96F,95D
030D6:  MOVFF  96E,95C
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
030DA:  MOVFF  94B,983
030DE:  MOVFF  94A,982
030E2:  MOVLW  06
030E4:  MOVWF  x84
030E6:  MOVFF  95B,986
030EA:  MOVFF  95A,985
030EE:  MOVLB  0
030F0:  RCALL  2E46
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
030F2:  MOVLW  09
030F4:  MOVLB  9
030F6:  MOVWF  x83
030F8:  MOVLW  5E
030FA:  MOVWF  x82
030FC:  MOVFF  983,9A7
03100:  MOVWF  xA6
03102:  CLRF   xA9
03104:  MOVLW  14
03106:  MOVWF  xA8
03108:  MOVLB  0
0310A:  CALL   1BD0
....................  
....................    if ( flags & SYN ) 
0310E:  MOVLB  9
03110:  BTFSS  x58.1
03112:  BRA    3130
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
03114:  MOVLW  09
03116:  MOVWF  x83
03118:  MOVLW  72
0311A:  MOVWF  x82
0311C:  MOVFF  983,9A7
03120:  MOVWF  xA6
03122:  CLRF   xA9
03124:  MOVLW  04
03126:  MOVWF  xA8
03128:  MOVLB  0
0312A:  CALL   1BD0
0312E:  MOVLB  9
....................  
....................    IPSetTxBuffer(buff, 0); 
03130:  MOVFF  959,99B
03134:  CLRF   x9D
03136:  MOVLW  14
03138:  MOVWF  x9C
0313A:  MOVLB  0
0313C:  CALL   1B14
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
03140:  MOVFF  95B,983
03144:  MOVFF  95A,982
03148:  CALL   25A0
0314C:  MOVFF  02,95D
03150:  MOVFF  01,95C
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
03154:  MOVFF  959,99B
03158:  MOVLB  9
0315A:  CLRF   x9D
0315C:  MOVLW  24
0315E:  MOVWF  x9C
03160:  MOVLB  0
03162:  CALL   1B14
....................    MACPut(checkSum.v[1]); 
03166:  MOVFF  95D,9A5
0316A:  CALL   1BB2
....................    MACPut(checkSum.v[0]); 
0316E:  MOVFF  95C,9A5
03172:  CALL   1BB2
....................    MACSetTxBuffer(buff, 0); 
03176:  MOVFF  959,99B
0317A:  MOVLB  9
0317C:  CLRF   x9D
0317E:  CLRF   x9C
03180:  MOVLB  0
03182:  CALL   1B14
....................  
....................    MACFlush(); 
03186:  CALL   1CE8
0318A:  MOVLB  9
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
0318C:  MOVLB  0
0318E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
02914:  MOVLW  FE
02916:  MOVLB  9
02918:  MOVWF  x2F
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
0291A:  CLRF   x2E
0291C:  MOVF   x2E,W
0291E:  SUBLW  22
02920:  BTFSS  FD8.0
02922:  BRA    2A2A
....................    { 
....................       ps = &TCB[s]; 
02924:  CLRF   x47
02926:  MOVFF  92E,946
0292A:  CLRF   x49
0292C:  MOVLW  24
0292E:  MOVWF  x48
02930:  MOVLB  0
02932:  CALL   1006
02936:  MOVFF  02,03
0293A:  MOVF   01,W
0293C:  ADDLW  97
0293E:  MOVWF  01
02940:  MOVLW  03
02942:  ADDWFC 03,F
02944:  MOVFF  01,92C
02948:  MOVLB  9
0294A:  MOVFF  03,92D
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
0294E:  MOVFF  92C,FE9
02952:  MOVFF  92D,FEA
02956:  MOVF   FEF,W
02958:  SUBLW  0A
0295A:  BZ    2A26
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
0295C:  MOVLW  0B
0295E:  ADDWF  x2C,W
02960:  MOVWF  FE9
02962:  MOVLW  00
02964:  ADDWFC x2D,W
02966:  MOVWF  FEA
02968:  MOVFF  FEC,931
0296C:  MOVF   FED,F
0296E:  MOVFF  FEF,930
02972:  MOVLW  02
02974:  ADDWF  x28,W
02976:  MOVWF  FE9
02978:  MOVLW  00
0297A:  ADDWFC x29,W
0297C:  MOVWF  FEA
0297E:  MOVFF  FEC,03
02982:  MOVF   FED,F
02984:  MOVF   FEF,W
02986:  SUBWF  x30,W
02988:  BNZ   2A26
0298A:  MOVF   03,W
0298C:  SUBWF  x31,W
0298E:  BNZ   2A26
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
02990:  MOVFF  92C,FE9
02994:  MOVFF  92D,FEA
02998:  MOVF   FEF,F
0299A:  BNZ   29A0
....................                partialMatch = s; 
0299C:  MOVFF  92E,92F
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
029A0:  MOVLW  0D
029A2:  ADDWF  x2C,W
029A4:  MOVWF  FE9
029A6:  MOVLW  00
029A8:  ADDWFC x2D,W
029AA:  MOVWF  FEA
029AC:  MOVFF  FEC,931
029B0:  MOVF   FED,F
029B2:  MOVFF  FEF,930
029B6:  MOVFF  928,FE9
029BA:  MOVFF  929,FEA
029BE:  MOVFF  FEC,03
029C2:  MOVF   FED,F
029C4:  MOVF   FEF,W
029C6:  SUBWF  x30,W
029C8:  BNZ   2A26
029CA:  MOVF   03,W
029CC:  SUBWF  x31,W
029CE:  BNZ   2A26
029D0:  MOVLW  07
029D2:  ADDWF  x2C,W
029D4:  MOVWF  FE9
029D6:  MOVLW  00
029D8:  ADDWFC x2D,W
029DA:  MOVWF  FEA
029DC:  MOVFF  FEF,930
029E0:  MOVFF  FEC,931
029E4:  MOVFF  FEC,932
029E8:  MOVFF  FEC,933
029EC:  MOVLW  06
029EE:  ADDWF  x2A,W
029F0:  MOVWF  FE9
029F2:  MOVLW  00
029F4:  ADDWFC x2B,W
029F6:  MOVWF  FEA
029F8:  MOVFF  FEF,00
029FC:  MOVFF  FEC,01
02A00:  MOVFF  FEC,02
02A04:  MOVFF  FEC,03
02A08:  MOVF   00,W
02A0A:  SUBWF  x30,W
02A0C:  BNZ   2A26
02A0E:  MOVF   01,W
02A10:  SUBWF  x31,W
02A12:  BNZ   2A26
02A14:  MOVF   02,W
02A16:  SUBWF  x32,W
02A18:  BNZ   2A26
02A1A:  MOVF   03,W
02A1C:  SUBWF  x33,W
02A1E:  BNZ   2A26
....................             { 
....................                return s; 
02A20:  MOVFF  92E,01
02A24:  BRA    2B10
....................             } 
....................          } 
....................       } 
02A26:  INCF   x2E,F
02A28:  BRA    291C
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
02A2A:  MOVF   x2F,W
02A2C:  SUBLW  FE
02A2E:  BNZ   2A36
....................       return INVALID_SOCKET; 
02A30:  MOVLW  FE
02A32:  MOVWF  01
02A34:  BRA    2B10
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
02A36:  CLRF   x47
02A38:  MOVFF  92F,946
02A3C:  CLRF   x49
02A3E:  MOVLW  24
02A40:  MOVWF  x48
02A42:  MOVLB  0
02A44:  CALL   1006
02A48:  MOVFF  02,03
02A4C:  MOVF   01,W
02A4E:  ADDLW  97
02A50:  MOVWF  01
02A52:  MOVLW  03
02A54:  ADDWFC 03,F
02A56:  MOVFF  01,92C
02A5A:  MOVLB  9
02A5C:  MOVFF  03,92D
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
02A60:  MOVLW  01
02A62:  ADDWF  x2C,W
02A64:  MOVWF  01
02A66:  MOVLW  00
02A68:  ADDWFC x2D,W
02A6A:  MOVWF  03
02A6C:  MOVFF  01,930
02A70:  MOVWF  x31
02A72:  MOVWF  FEA
02A74:  MOVFF  01,FE9
02A78:  MOVFF  92B,FE2
02A7C:  MOVFF  92A,FE1
02A80:  MOVLW  0A
02A82:  MOVWF  01
02A84:  MOVFF  FE6,FEE
02A88:  DECFSZ 01,F
02A8A:  BRA    2A84
....................    ps->remotePort          = h->SourcePort; 
02A8C:  MOVLW  0D
02A8E:  ADDWF  x2C,W
02A90:  MOVWF  01
02A92:  MOVLW  00
02A94:  ADDWFC x2D,W
02A96:  MOVFF  928,FE9
02A9A:  MOVFF  929,FEA
02A9E:  MOVFF  FEC,03
02AA2:  MOVF   FED,F
02AA4:  MOVFF  FEF,932
02AA8:  MOVWF  FEA
02AAA:  MOVFF  01,FE9
02AAE:  MOVFF  03,FEC
02AB2:  MOVF   FED,F
02AB4:  MOVFF  932,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
02AB8:  MOVLW  23
02ABA:  ADDWF  x2C,W
02ABC:  MOVWF  FE9
02ABE:  MOVLW  00
02AC0:  ADDWFC x2D,W
02AC2:  MOVWF  FEA
02AC4:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
02AC6:  MOVLW  0F
02AC8:  ADDWF  x2C,W
02ACA:  MOVWF  FE9
02ACC:  MOVLW  00
02ACE:  ADDWFC x2D,W
02AD0:  MOVWF  FEA
02AD2:  INCFSZ FEF,W
02AD4:  BRA    2AD8
02AD6:  BRA    2AFE
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
02AD8:  MOVLW  0F
02ADA:  ADDWF  x2C,W
02ADC:  MOVWF  FE9
02ADE:  MOVLW  00
02AE0:  ADDWFC x2D,W
02AE2:  MOVWF  FEA
02AE4:  MOVFF  FEF,949
02AE8:  MOVLB  0
02AEA:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
02AEE:  MOVLW  0F
02AF0:  MOVLB  9
02AF2:  ADDWF  x2C,W
02AF4:  MOVWF  FE9
02AF6:  MOVLW  00
02AF8:  ADDWFC x2D,W
02AFA:  MOVWF  FEA
02AFC:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
02AFE:  MOVLW  23
02B00:  ADDWF  x2C,W
02B02:  MOVWF  FE9
02B04:  MOVLW  00
02B06:  ADDWFC x2D,W
02B08:  MOVWF  FEA
02B0A:  BSF    FEF.1
....................  
....................    return partialMatch; 
02B0C:  MOVFF  92F,01
02B10:  MOVLB  0
02B12:  GOTO   3CF6 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
02736:  MOVLB  9
02738:  MOVFF  982,01
0273C:  MOVFF  983,03
02740:  MOVFF  982,984
02744:  MOVFF  983,985
02748:  MOVFF  982,FE9
0274C:  MOVFF  983,FEA
02750:  MOVFF  FEC,9A2
02754:  MOVF   FED,F
02756:  MOVFF  FEF,9A1
0275A:  MOVLB  0
0275C:  CALL   17D4
02760:  MOVFF  985,FEA
02764:  MOVFF  984,FE9
02768:  MOVFF  02,FEC
0276C:  MOVF   FED,F
0276E:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
02772:  MOVLW  02
02774:  MOVLB  9
02776:  ADDWF  x82,W
02778:  MOVWF  01
0277A:  MOVLW  00
0277C:  ADDWFC x83,W
0277E:  MOVWF  03
02780:  MOVFF  01,984
02784:  MOVWF  x85
02786:  MOVLW  02
02788:  ADDWF  x82,W
0278A:  MOVWF  FE9
0278C:  MOVLW  00
0278E:  ADDWFC x83,W
02790:  MOVWF  FEA
02792:  MOVFF  FEC,9A2
02796:  MOVF   FED,F
02798:  MOVFF  FEF,9A1
0279C:  MOVLB  0
0279E:  CALL   17D4
027A2:  MOVFF  985,FEA
027A6:  MOVFF  984,FE9
027AA:  MOVFF  02,FEC
027AE:  MOVF   FED,F
027B0:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
027B4:  MOVLW  04
027B6:  MOVLB  9
027B8:  ADDWF  x82,W
027BA:  MOVWF  01
027BC:  MOVLW  00
027BE:  ADDWFC x83,W
027C0:  MOVWF  03
027C2:  MOVFF  01,984
027C6:  MOVWF  x85
027C8:  MOVLW  04
027CA:  ADDWF  x82,W
027CC:  MOVWF  FE9
027CE:  MOVLW  00
027D0:  ADDWFC x83,W
027D2:  MOVWF  FEA
027D4:  MOVFF  FEF,98A
027D8:  MOVFF  FEC,98B
027DC:  MOVFF  FEC,98C
027E0:  MOVFF  FEC,98D
027E4:  MOVLB  0
027E6:  RCALL  2714
027E8:  MOVFF  985,FEA
027EC:  MOVFF  984,FE9
027F0:  MOVFF  00,FEF
027F4:  MOVFF  01,FEC
027F8:  MOVFF  02,FEC
027FC:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
02800:  MOVLW  08
02802:  MOVLB  9
02804:  ADDWF  x82,W
02806:  MOVWF  01
02808:  MOVLW  00
0280A:  ADDWFC x83,W
0280C:  MOVWF  03
0280E:  MOVFF  01,984
02812:  MOVWF  x85
02814:  MOVLW  08
02816:  ADDWF  x82,W
02818:  MOVWF  FE9
0281A:  MOVLW  00
0281C:  ADDWFC x83,W
0281E:  MOVWF  FEA
02820:  MOVFF  FEF,98A
02824:  MOVFF  FEC,98B
02828:  MOVFF  FEC,98C
0282C:  MOVFF  FEC,98D
02830:  MOVLB  0
02832:  RCALL  2714
02834:  MOVFF  985,FEA
02838:  MOVFF  984,FE9
0283C:  MOVFF  00,FEF
02840:  MOVFF  01,FEC
02844:  MOVFF  02,FEC
02848:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
0284C:  MOVLW  0E
0284E:  MOVLB  9
02850:  ADDWF  x82,W
02852:  MOVWF  01
02854:  MOVLW  00
02856:  ADDWFC x83,W
02858:  MOVWF  03
0285A:  MOVFF  01,984
0285E:  MOVWF  x85
02860:  MOVLW  0E
02862:  ADDWF  x82,W
02864:  MOVWF  FE9
02866:  MOVLW  00
02868:  ADDWFC x83,W
0286A:  MOVWF  FEA
0286C:  MOVFF  FEC,9A2
02870:  MOVF   FED,F
02872:  MOVFF  FEF,9A1
02876:  MOVLB  0
02878:  CALL   17D4
0287C:  MOVFF  985,FEA
02880:  MOVFF  984,FE9
02884:  MOVFF  02,FEC
02888:  MOVF   FED,F
0288A:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
0288E:  MOVLW  10
02890:  MOVLB  9
02892:  ADDWF  x82,W
02894:  MOVWF  01
02896:  MOVLW  00
02898:  ADDWFC x83,W
0289A:  MOVWF  03
0289C:  MOVFF  01,984
028A0:  MOVWF  x85
028A2:  MOVLW  10
028A4:  ADDWF  x82,W
028A6:  MOVWF  FE9
028A8:  MOVLW  00
028AA:  ADDWFC x83,W
028AC:  MOVWF  FEA
028AE:  MOVFF  FEC,9A2
028B2:  MOVF   FED,F
028B4:  MOVFF  FEF,9A1
028B8:  MOVLB  0
028BA:  CALL   17D4
028BE:  MOVFF  985,FEA
028C2:  MOVFF  984,FE9
028C6:  MOVFF  02,FEC
028CA:  MOVF   FED,F
028CC:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
028D0:  MOVLW  12
028D2:  MOVLB  9
028D4:  ADDWF  x82,W
028D6:  MOVWF  01
028D8:  MOVLW  00
028DA:  ADDWFC x83,W
028DC:  MOVWF  03
028DE:  MOVFF  01,984
028E2:  MOVWF  x85
028E4:  MOVLW  12
028E6:  ADDWF  x82,W
028E8:  MOVWF  FE9
028EA:  MOVLW  00
028EC:  ADDWFC x83,W
028EE:  MOVWF  FEA
028F0:  MOVFF  FEC,9A2
028F4:  MOVF   FED,F
028F6:  MOVFF  FEF,9A1
028FA:  MOVLB  0
028FC:  CALL   17D4
02900:  MOVFF  985,FEA
02904:  MOVFF  984,FE9
02908:  MOVFF  02,FEC
0290C:  MOVF   FED,F
0290E:  MOVFF  01,FEF
02912:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
02B30:  MOVLW  0F
02B32:  MOVLB  9
02B34:  ADDWF  x46,W
02B36:  MOVWF  FE9
02B38:  MOVLW  00
02B3A:  ADDWFC x47,W
02B3C:  MOVWF  FEA
02B3E:  INCFSZ FEF,W
02B40:  BRA    2B44
02B42:  BRA    2B78
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
02B44:  MOVLW  0F
02B46:  ADDWF  x46,W
02B48:  MOVWF  FE9
02B4A:  MOVLW  00
02B4C:  ADDWFC x47,W
02B4E:  MOVWF  FEA
02B50:  MOVFF  FEF,949
02B54:  MOVLB  0
02B56:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
02B5A:  MOVLW  0F
02B5C:  MOVLB  9
02B5E:  ADDWF  x46,W
02B60:  MOVWF  FE9
02B62:  MOVLW  00
02B64:  ADDWFC x47,W
02B66:  MOVWF  FEA
02B68:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
02B6A:  MOVLW  23
02B6C:  ADDWF  x46,W
02B6E:  MOVWF  FE9
02B70:  MOVLW  00
02B72:  ADDWFC x47,W
02B74:  MOVWF  FEA
02B76:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
02B78:  MOVLW  07
02B7A:  ADDWF  x46,W
02B7C:  MOVWF  FE9
02B7E:  MOVLW  00
02B80:  ADDWFC x47,W
02B82:  MOVWF  FEA
02B84:  MOVF   FEE,F
02B86:  MOVF   FEE,F
02B88:  CLRF   FEC
02B8A:  MOVF   FED,F
02B8C:  CLRF   FEF
02B8E:  MOVF   FED,F
02B90:  CLRF   FEF
02B92:  MOVF   FED,F
02B94:  CLRF   FEF
....................     ps->remotePort = 0x00; 
02B96:  MOVLW  0D
02B98:  ADDWF  x46,W
02B9A:  MOVWF  FE9
02B9C:  MOVLW  00
02B9E:  ADDWFC x47,W
02BA0:  MOVWF  FEA
02BA2:  CLRF   FEC
02BA4:  MOVF   FED,F
02BA6:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
02BA8:  MOVLW  23
02BAA:  ADDWF  x46,W
02BAC:  MOVWF  FE9
02BAE:  MOVLW  00
02BB0:  ADDWFC x47,W
02BB2:  MOVWF  FEA
02BB4:  BTFSS  FEF.3
02BB6:  BRA    2BC0
....................     { 
....................         MACDiscardRx(); 
02BB8:  MOVLB  0
02BBA:  CALL   16FA
02BBE:  MOVLB  9
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
02BC0:  MOVLW  23
02BC2:  ADDWF  x46,W
02BC4:  MOVWF  FE9
02BC6:  MOVLW  00
02BC8:  ADDWFC x47,W
02BCA:  MOVWF  FEA
02BCC:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
02BCE:  MOVLW  21
02BD0:  ADDWF  x46,W
02BD2:  MOVWF  FE9
02BD4:  MOVLW  00
02BD6:  ADDWFC x47,W
02BD8:  MOVWF  FEA
02BDA:  CLRF   FEC
02BDC:  MOVF   FED,F
02BDE:  MOVLW  24
02BE0:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
02BE2:  MOVLW  23
02BE4:  ADDWF  x46,W
02BE6:  MOVWF  FE9
02BE8:  MOVLW  00
02BEA:  ADDWFC x47,W
02BEC:  MOVWF  FEA
02BEE:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
02BF0:  MOVLW  23
02BF2:  ADDWF  x46,W
02BF4:  MOVWF  FE9
02BF6:  MOVLW  00
02BF8:  ADDWFC x47,W
02BFA:  MOVWF  FEA
02BFC:  BTFSS  FEF.0
02BFE:  BRA    2C0C
....................     { 
....................         ps->smState = TCP_LISTEN; 
02C00:  MOVFF  946,FE9
02C04:  MOVFF  947,FEA
02C08:  CLRF   FEF
....................     } 
02C0A:  BRA    2C18
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
02C0C:  MOVFF  946,FE9
02C10:  MOVFF  947,FEA
02C14:  MOVLW  0A
02C16:  MOVWF  FEF
....................     } 
....................     //ps->smState = TCP_CLOSED; 
....................  
....................    ps->TxCount = 0; 
02C18:  MOVLW  10
02C1A:  ADDWF  x46,W
02C1C:  MOVWF  FE9
02C1E:  MOVLW  00
02C20:  ADDWFC x47,W
02C22:  MOVWF  FEA
02C24:  CLRF   FEC
02C26:  MOVF   FED,F
02C28:  CLRF   FEF
....................  
....................     return; 
02C2A:  MOVLB  0
02C2C:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
03190:  MOVLB  9
03192:  CLRF   x47
03194:  MOVFF  928,946
03198:  CLRF   x49
0319A:  MOVLW  24
0319C:  MOVWF  x48
0319E:  MOVLB  0
031A0:  CALL   1006
031A4:  MOVFF  02,03
031A8:  MOVF   01,W
031AA:  ADDLW  97
031AC:  MOVWF  01
031AE:  MOVLW  03
031B0:  ADDWFC 03,F
031B2:  MOVFF  01,93F
031B6:  MOVLB  9
031B8:  MOVFF  03,940
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
031BC:  CLRF   x41
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
031BE:  MOVLW  1E
031C0:  ADDWF  x3F,W
031C2:  MOVWF  FE9
031C4:  MOVLW  00
031C6:  ADDWFC x40,W
031C8:  MOVWF  FEA
031CA:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
031CC:  MOVLW  1F
031CE:  ADDWF  x3F,W
031D0:  MOVWF  01
031D2:  MOVLW  00
031D4:  ADDWFC x40,W
031D6:  MOVWF  03
031D8:  MOVFF  01,946
031DC:  MOVWF  x47
031DE:  MOVLB  0
031E0:  RCALL  2B16
031E2:  MOVFF  947,FEA
031E6:  MOVFF  946,FE9
031EA:  MOVFF  02,FEC
031EE:  MOVF   FED,F
031F0:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
031F4:  MOVLW  21
031F6:  MOVLB  9
031F8:  ADDWF  x3F,W
031FA:  MOVWF  FE9
031FC:  MOVLW  00
031FE:  ADDWFC x40,W
03200:  MOVWF  FEA
03202:  CLRF   FEC
03204:  MOVF   FED,F
03206:  MOVLW  24
03208:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
0320A:  MOVLW  0D
0320C:  ADDWF  x2B,W
0320E:  MOVWF  FE9
03210:  MOVLW  00
03212:  ADDWFC x2C,W
03214:  MOVWF  FEA
03216:  BTFSS  FEF.2
03218:  BRA    3256
....................    { 
....................       MACDiscardRx(); 
0321A:  MOVLB  0
0321C:  CALL   16FA
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
03220:  MOVLB  9
03222:  MOVFF  93F,01
03226:  MOVFF  940,03
0322A:  MOVFF  93F,946
0322E:  MOVFF  940,947
03232:  MOVLW  23
03234:  ADDWF  x3F,W
03236:  MOVWF  FE9
03238:  MOVLW  00
0323A:  ADDWFC x40,W
0323C:  MOVWF  FEA
0323E:  BTFSS  FEF.0
03240:  BRA    3246
03242:  MOVLW  00
03244:  BRA    3248
03246:  MOVLW  01
03248:  MOVFF  947,FEA
0324C:  MOVFF  946,FE9
03250:  MOVWF  FEF
....................       return; 
03252:  GOTO   3BA0
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
03256:  MOVLW  16
03258:  ADDWF  x3F,W
0325A:  MOVWF  FE9
0325C:  MOVLW  00
0325E:  ADDWFC x40,W
03260:  MOVWF  FEA
03262:  MOVFF  FEF,933
03266:  MOVFF  FEC,934
0326A:  MOVFF  FEC,935
0326E:  MOVFF  FEC,936
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
03272:  MOVLW  0E
03274:  ADDWF  x2B,W
03276:  MOVWF  FE9
03278:  MOVLW  00
0327A:  ADDWFC x2C,W
0327C:  MOVWF  FEA
0327E:  MOVFF  FEC,947
03282:  MOVF   FED,F
03284:  MOVFF  FEF,946
03288:  CLRF   x48
0328A:  CLRF   x49
0328C:  MOVLW  08
0328E:  ADDWF  x2B,W
03290:  MOVWF  FE9
03292:  MOVLW  00
03294:  ADDWFC x2C,W
03296:  MOVWF  FEA
03298:  MOVFF  FEF,00
0329C:  MOVFF  FEC,01
032A0:  MOVFF  FEC,02
032A4:  MOVFF  FEC,03
032A8:  MOVF   00,W
032AA:  SUBWF  x33,W
032AC:  MOVWF  00
032AE:  MOVF   01,W
032B0:  SUBWFB x34,W
032B2:  MOVWF  01
032B4:  MOVF   02,W
032B6:  SUBWFB x35,W
032B8:  MOVWF  02
032BA:  MOVF   03,W
032BC:  SUBWFB x36,W
032BE:  MOVWF  03
032C0:  MOVF   00,W
032C2:  SUBWF  x46,F
032C4:  MOVF   01,W
032C6:  SUBWFB x47,F
032C8:  MOVF   02,W
032CA:  SUBWFB x48,F
032CC:  MOVF   03,W
032CE:  SUBWFB x49,F
032D0:  MOVLW  10
032D2:  ADDWF  x3F,W
032D4:  MOVWF  FE9
032D6:  MOVLW  00
032D8:  ADDWFC x40,W
032DA:  MOVWF  FEA
032DC:  MOVFF  FEC,03
032E0:  MOVF   FED,F
032E2:  MOVFF  FEF,00
032E6:  MOVFF  03,01
032EA:  CLRF   02
032EC:  CLRF   03
032EE:  MOVF   00,W
032F0:  SUBWF  x46,W
032F2:  MOVWF  x42
032F4:  MOVF   01,W
032F6:  SUBWFB x47,W
032F8:  MOVWF  x43
032FA:  MOVF   02,W
032FC:  SUBWFB x48,W
032FE:  MOVWF  x44
03300:  MOVF   03,W
03302:  SUBWFB x49,W
03304:  MOVWF  x45
....................    if(temp < 0) 
03306:  BTFSS  x45.7
03308:  BRA    331E
....................    { 
....................       ps->RemoteWindow = 0; 
0330A:  MOVLW  14
0330C:  ADDWF  x3F,W
0330E:  MOVWF  FE9
03310:  MOVLW  00
03312:  ADDWFC x40,W
03314:  MOVWF  FEA
03316:  CLRF   FEC
03318:  MOVF   FED,F
0331A:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
0331C:  BRA    3332
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
0331E:  MOVLW  14
03320:  ADDWF  x3F,W
03322:  MOVWF  FE9
03324:  MOVLW  00
03326:  ADDWFC x40,W
03328:  MOVWF  FEA
0332A:  MOVFF  92F,FEF
0332E:  MOVFF  930,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
03332:  MOVFF  93F,FE9
03336:  MOVFF  940,FEA
0333A:  DECFSZ FEF,W
0333C:  BRA    34A8
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
0333E:  MOVLW  0D
03340:  ADDWF  x2B,W
03342:  MOVWF  FE9
03344:  MOVLW  00
03346:  ADDWFC x2C,W
03348:  MOVWF  FEA
0334A:  BTFSC  FEF.1
0334C:  BRA    3372
....................       { 
....................          MACDiscardRx(); 
0334E:  MOVLB  0
03350:  CALL   16FA
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
03354:  MOVLW  0D
03356:  MOVLB  9
03358:  ADDWF  x2B,W
0335A:  MOVWF  FE9
0335C:  MOVLW  00
0335E:  ADDWFC x2C,W
03360:  MOVWF  FEA
03362:  BTFSS  FEF.4
03364:  BRA    336E
....................           { 
....................             flags = RST; 
03366:  MOVLW  04
03368:  MOVWF  x41
....................             goto SendTCPControlPacket; 
0336A:  GOTO   3B3A
....................            } 
....................  
....................          return; 
0336E:  GOTO   3BA0
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
03372:  MOVLW  1A
03374:  ADDWF  x3F,W
03376:  MOVWF  01
03378:  MOVLW  00
0337A:  ADDWFC x40,W
0337C:  MOVFF  01,946
03380:  MOVWF  x47
03382:  MOVLW  04
03384:  ADDWF  x2B,W
03386:  MOVWF  FE9
03388:  MOVLW  00
0338A:  ADDWFC x2C,W
0338C:  MOVWF  FEA
0338E:  MOVFF  FEF,948
03392:  MOVFF  FEC,949
03396:  MOVFF  FEC,94A
0339A:  MOVFF  FEC,94B
0339E:  MOVF   x2D,W
033A0:  ADDWF  x48,F
033A2:  MOVF   x2E,W
033A4:  ADDWFC x49,F
033A6:  MOVLW  00
033A8:  ADDWFC x4A,F
033AA:  ADDWFC x4B,F
033AC:  MOVLW  01
033AE:  ADDWF  x48,W
033B0:  MOVWF  00
033B2:  MOVLW  00
033B4:  ADDWFC x49,W
033B6:  MOVWF  01
033B8:  MOVLW  00
033BA:  ADDWFC x4A,W
033BC:  MOVWF  02
033BE:  MOVLW  00
033C0:  ADDWFC x4B,W
033C2:  MOVFF  947,FEA
033C6:  MOVFF  946,FE9
033CA:  MOVFF  00,FEF
033CE:  MOVFF  01,FEC
033D2:  MOVFF  02,FEC
033D6:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
033D8:  MOVLW  1A
033DA:  ADDWF  x3F,W
033DC:  MOVWF  FE9
033DE:  MOVLW  00
033E0:  ADDWFC x40,W
033E2:  MOVWF  FEA
033E4:  MOVFF  FEF,92F
033E8:  MOVFF  FEC,930
033EC:  MOVFF  FEC,931
033F0:  MOVFF  FEC,932
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
033F4:  MOVLW  0D
033F6:  ADDWF  x2B,W
033F8:  MOVWF  FE9
033FA:  MOVLW  00
033FC:  ADDWFC x2C,W
033FE:  MOVWF  FEA
03400:  BTFSC  FEF.4
03402:  BRA    341E
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
03404:  MOVFF  93F,FE9
03408:  MOVFF  940,FEA
0340C:  MOVLW  02
0340E:  MOVWF  FEF
....................          MACDiscardRx(); 
03410:  MOVLB  0
03412:  CALL   16FA
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
03416:  MOVLW  12
03418:  MOVLB  9
0341A:  MOVWF  x41
....................          goto SendTCPControlPacket; 
0341C:  BRA    3B3A
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
0341E:  MOVFF  93F,FE9
03422:  MOVFF  940,FEA
03426:  MOVLW  03
03428:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
0342A:  MOVLW  10
0342C:  MOVWF  x41
....................  
....................       ps->RemoteWindow = h->Window; 
0342E:  MOVLW  14
03430:  ADDWF  x3F,W
03432:  MOVWF  01
03434:  MOVLW  00
03436:  ADDWFC x40,W
03438:  MOVWF  03
0343A:  MOVWF  x47
0343C:  MOVLW  0E
0343E:  ADDWF  x2B,W
03440:  MOVWF  FE9
03442:  MOVLW  00
03444:  ADDWFC x2C,W
03446:  MOVWF  FEA
03448:  MOVFF  FEC,03
0344C:  MOVF   FED,F
0344E:  MOVFF  FEF,948
03452:  MOVFF  947,FEA
03456:  MOVFF  01,FE9
0345A:  MOVFF  03,FEC
0345E:  MOVF   FED,F
03460:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
03464:  MOVF   x2D,W
03466:  IORWF  x2E,W
03468:  BZ    349E
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
0346A:  MOVLW  23
0346C:  ADDWF  x3F,W
0346E:  MOVWF  FE9
03470:  MOVLW  00
03472:  ADDWFC x40,W
03474:  MOVWF  FEA
03476:  BSF    FEF.3
....................          ps->RxCount             = len; 
03478:  MOVLW  12
0347A:  ADDWF  x3F,W
0347C:  MOVWF  FE9
0347E:  MOVLW  00
03480:  ADDWFC x40,W
03482:  MOVWF  FEA
03484:  MOVFF  92E,FEC
03488:  MOVF   FED,F
0348A:  MOVFF  92D,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
0348E:  MOVLW  23
03490:  ADDWF  x3F,W
03492:  MOVWF  FE9
03494:  MOVLW  00
03496:  ADDWFC x40,W
03498:  MOVWF  FEA
0349A:  BSF    FEF.2
....................       } 
0349C:  BRA    34A6
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
0349E:  MOVLB  0
034A0:  CALL   16FA
034A4:  MOVLB  9
....................       } 
....................       goto SendTCPControlPacket; 
034A6:  BRA    3B3A
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
034A8:  MOVFF  93F,FE9
034AC:  MOVFF  940,FEA
034B0:  MOVF   FEF,F
034B2:  BTFSS  FD8.2
034B4:  BRA    362A
....................    { 
....................       MACDiscardRx(); 
034B6:  MOVLB  0
034B8:  CALL   16FA
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
034BC:  MOVLW  0D
034BE:  MOVLB  9
034C0:  ADDWF  x2B,W
034C2:  MOVWF  FE9
034C4:  MOVLW  00
034C6:  ADDWFC x2C,W
034C8:  MOVWF  FEA
034CA:  BTFSC  FEF.1
034CC:  BRA    34D4
....................       { 
....................          flags = RST; 
034CE:  MOVLW  04
034D0:  MOVWF  x41
....................          goto SendTCPControlPacket; 
034D2:  BRA    3B3A
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
034D4:  MOVLW  1A
034D6:  ADDWF  x3F,W
034D8:  MOVWF  01
034DA:  MOVLW  00
034DC:  ADDWFC x40,W
034DE:  MOVFF  01,946
034E2:  MOVWF  x47
034E4:  MOVLW  04
034E6:  ADDWF  x2B,W
034E8:  MOVWF  FE9
034EA:  MOVLW  00
034EC:  ADDWFC x2C,W
034EE:  MOVWF  FEA
034F0:  MOVFF  FEF,948
034F4:  MOVFF  FEC,949
034F8:  MOVFF  FEC,94A
034FC:  MOVFF  FEC,94B
03500:  MOVF   x2D,W
03502:  ADDWF  x48,F
03504:  MOVF   x2E,W
03506:  ADDWFC x49,F
03508:  MOVLW  00
0350A:  ADDWFC x4A,F
0350C:  ADDWFC x4B,F
0350E:  MOVLW  01
03510:  ADDWF  x48,W
03512:  MOVWF  00
03514:  MOVLW  00
03516:  ADDWFC x49,W
03518:  MOVWF  01
0351A:  MOVLW  00
0351C:  ADDWFC x4A,W
0351E:  MOVWF  02
03520:  MOVLW  00
03522:  ADDWFC x4B,W
03524:  MOVFF  947,FEA
03528:  MOVFF  946,FE9
0352C:  MOVFF  00,FEF
03530:  MOVFF  01,FEC
03534:  MOVFF  02,FEC
03538:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
0353A:  MOVLW  14
0353C:  ADDWF  x3F,W
0353E:  MOVWF  01
03540:  MOVLW  00
03542:  ADDWFC x40,W
03544:  MOVWF  03
03546:  MOVWF  x47
03548:  MOVLW  0E
0354A:  ADDWF  x2B,W
0354C:  MOVWF  FE9
0354E:  MOVLW  00
03550:  ADDWFC x2C,W
03552:  MOVWF  FEA
03554:  MOVFF  FEC,03
03558:  MOVF   FED,F
0355A:  MOVFF  FEF,948
0355E:  MOVFF  947,FEA
03562:  MOVFF  01,FE9
03566:  MOVFF  03,FEC
0356A:  MOVF   FED,F
0356C:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
03570:  MOVLW  01
03572:  ADDWF  x3F,W
03574:  MOVWF  01
03576:  MOVLW  00
03578:  ADDWFC x40,W
0357A:  MOVWF  03
0357C:  MOVFF  01,946
03580:  MOVWF  x47
03582:  MOVWF  FEA
03584:  MOVFF  01,FE9
03588:  MOVFF  92A,FE2
0358C:  MOVFF  929,FE1
03590:  MOVLW  0A
03592:  MOVWF  01
03594:  MOVFF  FE6,FEE
03598:  DECFSZ 01,F
0359A:  BRA    3594
....................       ps->remotePort = h->SourcePort; 
0359C:  MOVLW  0D
0359E:  ADDWF  x3F,W
035A0:  MOVWF  01
035A2:  MOVLW  00
035A4:  ADDWFC x40,W
035A6:  MOVFF  92B,FE9
035AA:  MOVFF  92C,FEA
035AE:  MOVFF  FEC,03
035B2:  MOVF   FED,F
035B4:  MOVFF  FEF,948
035B8:  MOVWF  FEA
035BA:  MOVFF  01,FE9
035BE:  MOVFF  03,FEC
035C2:  MOVF   FED,F
035C4:  MOVFF  948,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
035C8:  MOVFF  93F,FE9
035CC:  MOVFF  940,FEA
035D0:  MOVLW  02
035D2:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
035D4:  MOVLW  16
035D6:  ADDWF  x3F,W
035D8:  MOVWF  FE9
035DA:  MOVLW  00
035DC:  ADDWFC x40,W
035DE:  MOVWF  FEA
035E0:  MOVFF  FEF,933
035E4:  MOVFF  FEC,934
035E8:  MOVFF  FEC,935
035EC:  MOVFF  FEC,936
....................       ps->SND_SEQ++; 
035F0:  MOVLW  16
035F2:  ADDWF  x3F,W
035F4:  MOVWF  FE9
035F6:  MOVLW  00
035F8:  ADDWFC x40,W
035FA:  MOVWF  FEA
035FC:  MOVLW  01
035FE:  ADDWF  FEE,F
03600:  MOVLW  00
03602:  ADDWFC FEE,F
03604:  ADDWFC FEE,F
03606:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
03608:  MOVLW  1A
0360A:  ADDWF  x3F,W
0360C:  MOVWF  FE9
0360E:  MOVLW  00
03610:  ADDWFC x40,W
03612:  MOVWF  FEA
03614:  MOVFF  FEF,92F
03618:  MOVFF  FEC,930
0361C:  MOVFF  FEC,931
03620:  MOVFF  FEC,932
....................       flags = SYN | ACK; 
03624:  MOVLW  12
03626:  MOVWF  x41
....................       goto SendTCPControlPacket; 
03628:  BRA    3B3A
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
0362A:  MOVLW  1A
0362C:  ADDWF  x3F,W
0362E:  MOVWF  FE9
03630:  MOVLW  00
03632:  ADDWFC x40,W
03634:  MOVWF  FEA
03636:  MOVFF  FEF,937
0363A:  MOVFF  FEC,938
0363E:  MOVFF  FEC,939
03642:  MOVFF  FEC,93A
....................    prevSeq = ps->SND_SEQ; 
03646:  MOVLW  16
03648:  ADDWF  x3F,W
0364A:  MOVWF  FE9
0364C:  MOVLW  00
0364E:  ADDWFC x40,W
03650:  MOVWF  FEA
03652:  MOVFF  FEF,93B
03656:  MOVFF  FEC,93C
0365A:  MOVFF  FEC,93D
0365E:  MOVFF  FEC,93E
....................  
....................    ack = h->SeqNumber; 
03662:  MOVLW  04
03664:  ADDWF  x2B,W
03666:  MOVWF  FE9
03668:  MOVLW  00
0366A:  ADDWFC x2C,W
0366C:  MOVWF  FEA
0366E:  MOVFF  FEF,92F
03672:  MOVFF  FEC,930
03676:  MOVFF  FEC,931
0367A:  MOVFF  FEC,932
....................    ack += (DWORD)len; 
0367E:  CLRF   02
03680:  CLRF   03
03682:  MOVF   x2D,W
03684:  ADDWF  x2F,F
03686:  MOVF   x2E,W
03688:  ADDWFC x30,F
0368A:  MOVF   02,W
0368C:  ADDWFC x31,F
0368E:  MOVF   03,W
03690:  ADDWFC x32,F
....................    seq = ps->SND_SEQ; 
03692:  MOVLW  16
03694:  ADDWF  x3F,W
03696:  MOVWF  FE9
03698:  MOVLW  00
0369A:  ADDWFC x40,W
0369C:  MOVWF  FEA
0369E:  MOVFF  FEF,933
036A2:  MOVFF  FEC,934
036A6:  MOVFF  FEC,935
036AA:  MOVFF  FEC,936
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
036AE:  MOVLW  04
036B0:  ADDWF  x2B,W
036B2:  MOVWF  FE9
036B4:  MOVLW  00
036B6:  ADDWFC x2C,W
036B8:  MOVWF  FEA
036BA:  MOVFF  FEF,946
036BE:  MOVFF  FEC,947
036C2:  MOVFF  FEC,948
036C6:  MOVFF  FEC,949
036CA:  MOVF   x37,W
036CC:  SUBWF  x46,W
036CE:  BTFSS  FD8.2
036D0:  BRA    3B1E
036D2:  MOVF   x38,W
036D4:  SUBWF  x47,W
036D6:  BTFSS  FD8.2
036D8:  BRA    3B1E
036DA:  MOVF   x39,W
036DC:  SUBWF  x48,W
036DE:  BTFSS  FD8.2
036E0:  BRA    3B1E
036E2:  MOVF   x3A,W
036E4:  SUBWF  x49,W
036E6:  BTFSS  FD8.2
036E8:  BRA    3B1E
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
036EA:  MOVFF  93F,FE9
036EE:  MOVFF  940,FEA
036F2:  MOVF   FEF,W
036F4:  SUBLW  02
036F6:  BNZ   377E
....................          { 
....................             if(h->Flags.bits.flagACK) 
036F8:  MOVLW  0D
036FA:  ADDWF  x2B,W
036FC:  MOVWF  FE9
036FE:  MOVLW  00
03700:  ADDWFC x2C,W
03702:  MOVWF  FEA
03704:  BTFSS  FEF.4
03706:  BRA    3774
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
03708:  MOVLW  1A
0370A:  ADDWF  x3F,W
0370C:  MOVWF  FE9
0370E:  MOVLW  00
03710:  ADDWFC x40,W
03712:  MOVWF  FEA
03714:  MOVFF  92F,FEF
03718:  MOVFF  930,FEC
0371C:  MOVFF  931,FEC
03720:  MOVFF  932,FEC
....................                ps->smState = TCP_ESTABLISHED; 
03724:  MOVFF  93F,FE9
03728:  MOVFF  940,FEA
0372C:  MOVLW  03
0372E:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
03730:  MOVF   x2D,W
03732:  IORWF  x2E,W
03734:  BZ    376A
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
03736:  MOVLW  23
03738:  ADDWF  x3F,W
0373A:  MOVWF  FE9
0373C:  MOVLW  00
0373E:  ADDWFC x40,W
03740:  MOVWF  FEA
03742:  BSF    FEF.3
....................                   ps->RxCount             = len; 
03744:  MOVLW  12
03746:  ADDWF  x3F,W
03748:  MOVWF  FE9
0374A:  MOVLW  00
0374C:  ADDWFC x40,W
0374E:  MOVWF  FEA
03750:  MOVFF  92E,FEC
03754:  MOVF   FED,F
03756:  MOVFF  92D,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
0375A:  MOVLW  23
0375C:  ADDWF  x3F,W
0375E:  MOVWF  FE9
03760:  MOVLW  00
03762:  ADDWFC x40,W
03764:  MOVWF  FEA
03766:  BSF    FEF.2
....................                } 
03768:  BRA    3772
....................                else 
....................                   MACDiscardRx(); 
0376A:  MOVLB  0
0376C:  CALL   16FA
03770:  MOVLB  9
....................             } 
03772:  BRA    377C
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
03774:  MOVLB  0
03776:  CALL   16FA
0377A:  MOVLB  9
....................             } 
....................          } 
0377C:  BRA    3B1C
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
0377E:  MOVLW  1A
03780:  ADDWF  x3F,W
03782:  MOVWF  FE9
03784:  MOVLW  00
03786:  ADDWFC x40,W
03788:  MOVWF  FEA
0378A:  MOVFF  92F,FEF
0378E:  MOVFF  930,FEC
03792:  MOVFF  931,FEC
03796:  MOVFF  932,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
0379A:  MOVFF  93F,FE9
0379E:  MOVFF  940,FEA
037A2:  MOVF   FEF,W
037A4:  SUBLW  03
037A6:  BTFSS  FD8.2
037A8:  BRA    394E
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
037AA:  MOVLW  0D
037AC:  ADDWF  x2B,W
037AE:  MOVWF  FE9
037B0:  MOVLW  00
037B2:  ADDWFC x2C,W
037B4:  MOVWF  FEA
037B6:  BTFSS  FEF.4
037B8:  BRA    3810
037BA:  MOVLW  23
037BC:  ADDWF  x3F,W
037BE:  MOVWF  FE9
037C0:  MOVLW  00
037C2:  ADDWFC x40,W
037C4:  MOVWF  FEA
037C6:  BTFSC  FEF.1
037C8:  BRA    3810
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
037CA:  MOVLW  0F
037CC:  ADDWF  x3F,W
037CE:  MOVWF  FE9
037D0:  MOVLW  00
037D2:  ADDWFC x40,W
037D4:  MOVWF  FEA
037D6:  INCFSZ FEF,W
037D8:  BRA    37DC
037DA:  BRA    3810
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
037DC:  MOVLW  0F
037DE:  ADDWF  x3F,W
037E0:  MOVWF  FE9
037E2:  MOVLW  00
037E4:  ADDWFC x40,W
037E6:  MOVWF  FEA
037E8:  MOVFF  FEF,949
037EC:  MOVLB  0
037EE:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
037F2:  MOVLW  0F
037F4:  MOVLB  9
037F6:  ADDWF  x3F,W
037F8:  MOVWF  FE9
037FA:  MOVLW  00
037FC:  ADDWFC x40,W
037FE:  MOVWF  FEA
03800:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
03802:  MOVLW  23
03804:  ADDWF  x3F,W
03806:  MOVWF  FE9
03808:  MOVLW  00
0380A:  ADDWFC x40,W
0380C:  MOVWF  FEA
0380E:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
03810:  MOVLW  0D
03812:  ADDWF  x2B,W
03814:  MOVWF  FE9
03816:  MOVLW  00
03818:  ADDWFC x2C,W
0381A:  MOVWF  FEA
0381C:  BTFSS  FEF.0
0381E:  BRA    38B6
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
03820:  MOVLW  11
03822:  MOVWF  x41
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
03824:  MOVLW  16
03826:  ADDWF  x3F,W
03828:  MOVWF  FE9
0382A:  MOVLW  00
0382C:  ADDWFC x40,W
0382E:  MOVWF  FEA
03830:  MOVFF  FEF,933
03834:  MOVFF  FEC,934
03838:  MOVFF  FEC,935
0383C:  MOVFF  FEC,936
....................                   ps->SND_SEQ++; 
03840:  MOVLW  16
03842:  ADDWF  x3F,W
03844:  MOVWF  FE9
03846:  MOVLW  00
03848:  ADDWFC x40,W
0384A:  MOVWF  FEA
0384C:  MOVLW  01
0384E:  ADDWF  FEE,F
03850:  MOVLW  00
03852:  ADDWFC FEE,F
03854:  ADDWFC FEE,F
03856:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03858:  MOVLW  1A
0385A:  ADDWF  x3F,W
0385C:  MOVWF  FE9
0385E:  MOVLW  00
03860:  ADDWFC x40,W
03862:  MOVWF  FEA
03864:  MOVLW  01
03866:  ADDWF  FEF,W
03868:  MOVWF  00
0386A:  MOVLW  00
0386C:  ADDWFC FEC,W
0386E:  MOVWF  01
03870:  MOVLW  00
03872:  ADDWFC FEC,W
03874:  MOVWF  02
03876:  MOVLW  00
03878:  ADDWFC FEC,W
0387A:  MOVF   FED,F
0387C:  MOVF   FED,F
0387E:  MOVF   FED,F
03880:  MOVFF  00,FEF
03884:  MOVFF  01,FEC
03888:  MOVFF  02,FEC
0388C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
0388E:  MOVLW  1A
03890:  ADDWF  x3F,W
03892:  MOVWF  FE9
03894:  MOVLW  00
03896:  ADDWFC x40,W
03898:  MOVWF  FEA
0389A:  MOVFF  FEF,92F
0389E:  MOVFF  FEC,930
038A2:  MOVFF  FEC,931
038A6:  MOVFF  FEC,932
....................                   ps->smState = TCP_LAST_ACK; 
038AA:  MOVFF  93F,FE9
038AE:  MOVFF  940,FEA
038B2:  MOVLW  09
038B4:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
038B6:  MOVF   x2D,W
038B8:  IORWF  x2E,W
038BA:  BZ    3944
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
038BC:  MOVLW  23
038BE:  ADDWF  x3F,W
038C0:  MOVWF  FE9
038C2:  MOVLW  00
038C4:  ADDWFC x40,W
038C6:  MOVWF  FEA
038C8:  BTFSC  FEF.3
038CA:  BRA    3902
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
038CC:  MOVLW  23
038CE:  ADDWF  x3F,W
038D0:  MOVWF  FE9
038D2:  MOVLW  00
038D4:  ADDWFC x40,W
038D6:  MOVWF  FEA
038D8:  BSF    FEF.3
....................                      ps->RxCount             = len; 
038DA:  MOVLW  12
038DC:  ADDWF  x3F,W
038DE:  MOVWF  FE9
038E0:  MOVLW  00
038E2:  ADDWFC x40,W
038E4:  MOVWF  FEA
038E6:  MOVFF  92E,FEC
038EA:  MOVF   FED,F
038EC:  MOVFF  92D,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
038F0:  MOVLW  23
038F2:  ADDWF  x3F,W
038F4:  MOVWF  FE9
038F6:  MOVLW  00
038F8:  ADDWFC x40,W
038FA:  MOVWF  FEA
038FC:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
038FE:  BSF    x41.4
....................                   } 
03900:  BRA    3942
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
03902:  MOVLW  16
03904:  ADDWF  x3F,W
03906:  MOVWF  FE9
03908:  MOVLW  00
0390A:  ADDWFC x40,W
0390C:  MOVWF  FEA
0390E:  MOVFF  93B,FEF
03912:  MOVFF  93C,FEC
03916:  MOVFF  93D,FEC
0391A:  MOVFF  93E,FEC
....................                      ps->SND_ACK = prevAck; 
0391E:  MOVLW  1A
03920:  ADDWF  x3F,W
03922:  MOVWF  FE9
03924:  MOVLW  00
03926:  ADDWFC x40,W
03928:  MOVWF  FEA
0392A:  MOVFF  937,FEF
0392E:  MOVFF  938,FEC
03932:  MOVFF  939,FEC
03936:  MOVFF  93A,FEC
....................  
....................                      MACDiscardRx(); 
0393A:  MOVLB  0
0393C:  CALL   16FA
03940:  MOVLB  9
....................                   } 
....................                } 
03942:  BRA    394C
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
03944:  MOVLB  0
03946:  CALL   16FA
0394A:  MOVLB  9
....................                } 
....................             } 
0394C:  BRA    3B1C
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
0394E:  MOVFF  93F,FE9
03952:  MOVFF  940,FEA
03956:  MOVF   FEF,W
03958:  SUBLW  09
0395A:  BNZ   3986
....................             { 
....................                MACDiscardRx(); 
0395C:  MOVLB  0
0395E:  CALL   16FA
....................  
....................                if(h->Flags.bits.flagACK) 
03962:  MOVLW  0D
03964:  MOVLB  9
03966:  ADDWF  x2B,W
03968:  MOVWF  FE9
0396A:  MOVLW  00
0396C:  ADDWFC x2C,W
0396E:  MOVWF  FEA
03970:  BTFSS  FEF.4
03972:  BRA    3984
....................                { 
....................                   CloseSocket(ps); 
03974:  MOVFF  940,947
03978:  MOVFF  93F,946
0397C:  MOVLB  0
0397E:  CALL   2B30
03982:  MOVLB  9
....................                } 
....................             } 
03984:  BRA    3B1C
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
03986:  MOVFF  93F,FE9
0398A:  MOVFF  940,FEA
0398E:  MOVF   FEF,W
03990:  SUBLW  04
03992:  BNZ   3A58
....................             { 
....................                MACDiscardRx(); 
03994:  MOVLB  0
03996:  CALL   16FA
....................  
....................                if(h->Flags.bits.flagFIN) 
0399A:  MOVLW  0D
0399C:  MOVLB  9
0399E:  ADDWF  x2B,W
039A0:  MOVWF  FE9
039A2:  MOVLW  00
039A4:  ADDWFC x2C,W
039A6:  MOVWF  FEA
039A8:  BTFSS  FEF.0
039AA:  BRA    3A36
....................                { 
....................                   flags = ACK; 
039AC:  MOVLW  10
039AE:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
039B0:  MOVLW  1A
039B2:  ADDWF  x3F,W
039B4:  MOVWF  FE9
039B6:  MOVLW  00
039B8:  ADDWFC x40,W
039BA:  MOVWF  FEA
039BC:  MOVLW  01
039BE:  ADDWF  FEF,W
039C0:  MOVWF  00
039C2:  MOVLW  00
039C4:  ADDWFC FEC,W
039C6:  MOVWF  01
039C8:  MOVLW  00
039CA:  ADDWFC FEC,W
039CC:  MOVWF  02
039CE:  MOVLW  00
039D0:  ADDWFC FEC,W
039D2:  MOVF   FED,F
039D4:  MOVF   FED,F
039D6:  MOVF   FED,F
039D8:  MOVFF  00,FEF
039DC:  MOVFF  01,FEC
039E0:  MOVFF  02,FEC
039E4:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
039E6:  MOVLW  1A
039E8:  ADDWF  x3F,W
039EA:  MOVWF  FE9
039EC:  MOVLW  00
039EE:  ADDWFC x40,W
039F0:  MOVWF  FEA
039F2:  MOVFF  FEF,92F
039F6:  MOVFF  FEC,930
039FA:  MOVFF  FEC,931
039FE:  MOVFF  FEC,932
....................                   if(h->Flags.bits.flagACK) 
03A02:  MOVLW  0D
03A04:  ADDWF  x2B,W
03A06:  MOVWF  FE9
03A08:  MOVLW  00
03A0A:  ADDWFC x2C,W
03A0C:  MOVWF  FEA
03A0E:  BTFSS  FEF.4
03A10:  BRA    3A24
....................                   { 
....................                      CloseSocket(ps); 
03A12:  MOVFF  940,947
03A16:  MOVFF  93F,946
03A1A:  MOVLB  0
03A1C:  CALL   2B30
....................                   } 
03A20:  BRA    3A32
03A22:  MOVLB  9
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
03A24:  MOVFF  93F,FE9
03A28:  MOVFF  940,FEA
03A2C:  MOVLW  06
03A2E:  MOVWF  FEF
03A30:  MOVLB  0
....................                   } 
....................                } 
03A32:  BRA    3A54
03A34:  MOVLB  9
....................                else if(h->Flags.bits.flagACK) 
03A36:  MOVLW  0D
03A38:  ADDWF  x2B,W
03A3A:  MOVWF  FE9
03A3C:  MOVLW  00
03A3E:  ADDWFC x2C,W
03A40:  MOVWF  FEA
03A42:  BTFSS  FEF.4
03A44:  BRA    3A52
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
03A46:  MOVFF  93F,FE9
03A4A:  MOVFF  940,FEA
03A4E:  MOVLW  05
03A50:  MOVWF  FEF
03A52:  MOVLB  0
....................                } 
....................             } 
03A54:  BRA    3B1A
03A56:  MOVLB  9
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
03A58:  MOVFF  93F,FE9
03A5C:  MOVFF  940,FEA
03A60:  MOVF   FEF,W
03A62:  SUBLW  05
03A64:  BNZ   3AE6
....................             { 
....................                MACDiscardRx(); 
03A66:  MOVLB  0
03A68:  CALL   16FA
....................  
....................                if(h->Flags.bits.flagFIN) 
03A6C:  MOVLW  0D
03A6E:  MOVLB  9
03A70:  ADDWF  x2B,W
03A72:  MOVWF  FE9
03A74:  MOVLW  00
03A76:  ADDWFC x2C,W
03A78:  MOVWF  FEA
03A7A:  BTFSS  FEF.0
03A7C:  BRA    3AE4
....................                { 
....................                   flags = ACK; 
03A7E:  MOVLW  10
03A80:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03A82:  MOVLW  1A
03A84:  ADDWF  x3F,W
03A86:  MOVWF  FE9
03A88:  MOVLW  00
03A8A:  ADDWFC x40,W
03A8C:  MOVWF  FEA
03A8E:  MOVLW  01
03A90:  ADDWF  FEF,W
03A92:  MOVWF  00
03A94:  MOVLW  00
03A96:  ADDWFC FEC,W
03A98:  MOVWF  01
03A9A:  MOVLW  00
03A9C:  ADDWFC FEC,W
03A9E:  MOVWF  02
03AA0:  MOVLW  00
03AA2:  ADDWFC FEC,W
03AA4:  MOVF   FED,F
03AA6:  MOVF   FED,F
03AA8:  MOVF   FED,F
03AAA:  MOVFF  00,FEF
03AAE:  MOVFF  01,FEC
03AB2:  MOVFF  02,FEC
03AB6:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03AB8:  MOVLW  1A
03ABA:  ADDWF  x3F,W
03ABC:  MOVWF  FE9
03ABE:  MOVLW  00
03AC0:  ADDWFC x40,W
03AC2:  MOVWF  FEA
03AC4:  MOVFF  FEF,92F
03AC8:  MOVFF  FEC,930
03ACC:  MOVFF  FEC,931
03AD0:  MOVFF  FEC,932
....................                   CloseSocket(ps); 
03AD4:  MOVFF  940,947
03AD8:  MOVFF  93F,946
03ADC:  MOVLB  0
03ADE:  CALL   2B30
03AE2:  MOVLB  9
....................                } 
....................             } 
03AE4:  BRA    3B1C
....................             else if ( ps->smState == TCP_CLOSING ) 
03AE6:  MOVFF  93F,FE9
03AEA:  MOVFF  940,FEA
03AEE:  MOVF   FEF,W
03AF0:  SUBLW  06
03AF2:  BNZ   3B1C
....................             { 
....................                MACDiscardRx(); 
03AF4:  MOVLB  0
03AF6:  CALL   16FA
....................  
....................                if ( h->Flags.bits.flagACK ) 
03AFA:  MOVLW  0D
03AFC:  MOVLB  9
03AFE:  ADDWF  x2B,W
03B00:  MOVWF  FE9
03B02:  MOVLW  00
03B04:  ADDWFC x2C,W
03B06:  MOVWF  FEA
03B08:  BTFSS  FEF.4
03B0A:  BRA    3B1C
....................                { 
....................                   CloseSocket(ps); 
03B0C:  MOVFF  940,947
03B10:  MOVFF  93F,946
03B14:  MOVLB  0
03B16:  CALL   2B30
03B1A:  MOVLB  9
....................                } 
....................             } 
....................          } 
....................       } 
03B1C:  BRA    3B3A
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
03B1E:  MOVLB  0
03B20:  CALL   16FA
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
03B24:  MOVLW  10
03B26:  MOVLB  9
03B28:  MOVWF  x41
....................          ack = prevAck; 
03B2A:  MOVFF  93A,932
03B2E:  MOVFF  939,931
03B32:  MOVFF  938,930
03B36:  MOVFF  937,92F
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
03B3A:  MOVF   x41,F
03B3C:  BZ    3BA0
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
03B3E:  MOVLW  02
03B40:  ADDWF  x2B,W
03B42:  MOVWF  FE9
03B44:  MOVLW  00
03B46:  ADDWFC x2C,W
03B48:  MOVWF  FEA
03B4A:  MOVFF  FEC,94D
03B4E:  MOVF   FED,F
03B50:  MOVFF  FEF,94C
03B54:  MOVFF  92B,FE9
03B58:  MOVFF  92C,FEA
03B5C:  MOVFF  FEC,94F
03B60:  MOVF   FED,F
03B62:  MOVFF  FEF,94E
03B66:  MOVFF  92A,94B
03B6A:  MOVFF  929,94A
03B6E:  MOVFF  936,953
03B72:  MOVFF  935,952
03B76:  MOVFF  934,951
03B7A:  MOVFF  933,950
03B7E:  MOVFF  932,957
03B82:  MOVFF  931,956
03B86:  MOVFF  930,955
03B8A:  MOVFF  92F,954
03B8E:  MOVFF  941,958
03B92:  SETF   x59
03B94:  CLRF   x5B
03B96:  CLRF   x5A
03B98:  MOVLB  0
03B9A:  CALL   2F6C
03B9E:  MOVLB  9
....................    } 
03BA0:  MOVLB  0
03BA2:  GOTO   3D24 (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
03DFE:  MOVLW  09
03E00:  MOVLB  9
03E02:  MOVWF  x55
03E04:  MOVLW  08
03E06:  MOVWF  x54
03E08:  MOVFF  955,991
03E0C:  MOVWF  x90
03E0E:  CLRF   x93
03E10:  MOVWF  x92
03E12:  MOVLB  0
03E14:  CALL   1770
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
03E18:  MOVLB  9
03E1A:  CLRF   x53
03E1C:  CLRF   x52
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
03E1E:  MOVFF  903,03
03E22:  MOVFF  902,FE9
03E26:  MOVFF  903,FEA
03E2A:  MOVFF  FEF,959
03E2E:  CLRF   x58
03E30:  MOVLW  14
03E32:  MOVWF  x57
03E34:  CLRF   x5A
03E36:  MOVLB  0
03E38:  CALL   213A
03E3C:  MOVFF  02,951
03E40:  MOVFF  01,950
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
03E44:  MOVLB  9
03E46:  MOVFF  902,FE9
03E4A:  MOVFF  903,FEA
03E4E:  MOVLW  08
03E50:  SUBWF  FEF,W
03E52:  MOVWF  FEF
....................     MACGetArray(data, *len); 
03E54:  MOVFF  903,03
03E58:  MOVFF  902,FE9
03E5C:  MOVFF  903,FEA
03E60:  MOVFF  FEF,992
03E64:  MOVFF  901,991
03E68:  MOVFF  900,990
03E6C:  CLRF   x93
03E6E:  MOVLB  0
03E70:  CALL   1770
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
03E74:  MOVLW  09
03E76:  MOVLB  9
03E78:  MOVWF  x57
03E7A:  MOVLW  08
03E7C:  MOVWF  x56
03E7E:  MOVLB  0
03E80:  RCALL  3D36
....................  
....................     *code = packet.Type; 
03E82:  MOVLB  8
03E84:  MOVFF  8FE,FE9
03E88:  MOVFF  8FF,FEA
03E8C:  MOVFF  908,FEF
....................     *id = packet.Identifier; 
03E90:  MOVLB  9
03E92:  MOVFF  904,FE9
03E96:  MOVFF  905,FEA
03E9A:  MOVFF  90D,FEC
03E9E:  MOVF   FED,F
03EA0:  MOVFF  90C,FEF
....................     *seq = packet.SequenceNumber; 
03EA4:  MOVFF  906,FE9
03EA8:  MOVFF  907,FEA
03EAC:  MOVFF  90F,FEC
03EB0:  MOVF   FED,F
03EB2:  MOVFF  90E,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
03EB6:  MOVF   x52,W
03EB8:  SUBWF  x50,W
03EBA:  BNZ   3EC2
03EBC:  MOVF   x53,W
03EBE:  SUBWF  x51,W
03EC0:  BZ    3EC6
03EC2:  MOVLW  00
03EC4:  BRA    3EC8
03EC6:  MOVLW  01
03EC8:  MOVWF  01
03ECA:  MOVLB  0
03ECC:  GOTO   45D4 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
03ED0:  MOVLW  01
03ED2:  MOVLB  9
03ED4:  MOVWF  x82
03ED6:  MOVLB  0
03ED8:  CALL   1AEC
03EDC:  MOVFF  01,950
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
03EE0:  MOVLB  9
03EE2:  INCFSZ x50,W
03EE4:  BRA    3EE8
....................       return; 
03EE6:  BRA    3FE0
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
03EE8:  MOVFF  950,99B
03EEC:  CLRF   x9D
03EEE:  MOVLW  14
03EF0:  MOVWF  x9C
03EF2:  MOVLB  0
03EF4:  CALL   1B14
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
03EF8:  CLRF   03
03EFA:  MOVLB  9
03EFC:  MOVF   x01,W
03EFE:  ADDLW  08
03F00:  MOVWF  x4E
03F02:  MOVLW  00
03F04:  ADDWFC 03,W
03F06:  MOVWF  x4F
....................  
....................     packet.Code             = 0; 
03F08:  CLRF   x07
....................     packet.Type             = code; 
03F0A:  MOVFF  8FE,906
....................     packet.Checksum         = 0; 
03F0E:  CLRF   x09
03F10:  CLRF   x08
....................     packet.Identifier       = id; 
03F12:  MOVFF  903,90B
03F16:  MOVFF  902,90A
....................     packet.SequenceNumber   = seq; 
03F1A:  MOVFF  905,90D
03F1E:  MOVFF  904,90C
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
03F22:  MOVLW  09
03F24:  MOVWF  FEA
03F26:  MOVLW  0E
03F28:  MOVWF  FE9
03F2A:  MOVFF  900,FE2
03F2E:  MOVFF  8FF,FE1
03F32:  MOVF   x01,W
03F34:  MOVWF  01
03F36:  BZ    3F40
03F38:  MOVFF  FE6,FEE
03F3C:  DECFSZ 01,F
03F3E:  BRA    3F38
....................  
....................     SwapICMPPacket(&packet); 
03F40:  MOVLW  09
03F42:  MOVWF  x57
03F44:  MOVLW  06
03F46:  MOVWF  x56
03F48:  MOVLB  0
03F4A:  RCALL  3D36
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
03F4C:  MOVLW  08
03F4E:  MOVLB  9
03F50:  ADDWF  x01,W
03F52:  CLRF   x52
03F54:  MOVWF  x51
03F56:  MOVFF  8FD,983
03F5A:  MOVFF  8FC,982
03F5E:  MOVLW  01
03F60:  MOVWF  x84
03F62:  MOVFF  952,986
03F66:  MOVFF  951,985
03F6A:  MOVLB  0
03F6C:  CALL   2E46
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
03F70:  MOVLW  09
03F72:  MOVLB  9
03F74:  MOVWF  x52
03F76:  MOVLW  06
03F78:  MOVWF  x51
03F7A:  MOVFF  952,9A7
03F7E:  MOVWF  xA6
03F80:  MOVFF  94F,9A9
03F84:  MOVFF  94E,9A8
03F88:  MOVLB  0
03F8A:  CALL   1BD0
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
03F8E:  MOVLB  9
03F90:  CLRF   x9C
03F92:  MOVLW  14
03F94:  MOVWF  x9B
03F96:  MOVFF  94F,99E
03F9A:  MOVFF  94E,99D
03F9E:  MOVLB  0
03FA0:  CALL   2D6E
03FA4:  MOVFF  02,909
03FA8:  MOVFF  01,908
....................    IPSetTxBuffer(MyTxBuffer, 2); 
03FAC:  MOVFF  950,99B
03FB0:  MOVLB  9
03FB2:  CLRF   x9D
03FB4:  MOVLW  16
03FB6:  MOVWF  x9C
03FB8:  MOVLB  0
03FBA:  CALL   1B14
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
03FBE:  MOVLW  09
03FC0:  MOVLB  9
03FC2:  MOVWF  x52
03FC4:  MOVLW  08
03FC6:  MOVWF  x51
03FC8:  MOVFF  952,9A7
03FCC:  MOVWF  xA6
03FCE:  CLRF   xA9
03FD0:  MOVLW  02
03FD2:  MOVWF  xA8
03FD4:  MOVLB  0
03FD6:  CALL   1BD0
.................... #endif 
....................  
....................  
....................     MACFlush(); 
03FDA:  CALL   1CE8
03FDE:  MOVLB  9
03FE0:  MOVLB  0
03FE2:  GOTO   4630 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
03D36:  MOVLW  04
03D38:  MOVLB  9
03D3A:  ADDWF  x56,W
03D3C:  MOVWF  01
03D3E:  MOVLW  00
03D40:  ADDWFC x57,W
03D42:  MOVWF  03
03D44:  MOVFF  01,958
03D48:  MOVWF  x59
03D4A:  MOVLW  04
03D4C:  ADDWF  x56,W
03D4E:  MOVWF  FE9
03D50:  MOVLW  00
03D52:  ADDWFC x57,W
03D54:  MOVWF  FEA
03D56:  MOVFF  FEC,9A2
03D5A:  MOVF   FED,F
03D5C:  MOVFF  FEF,9A1
03D60:  MOVLB  0
03D62:  CALL   17D4
03D66:  MOVFF  959,FEA
03D6A:  MOVFF  958,FE9
03D6E:  MOVFF  02,FEC
03D72:  MOVF   FED,F
03D74:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
03D78:  MOVLW  06
03D7A:  MOVLB  9
03D7C:  ADDWF  x56,W
03D7E:  MOVWF  01
03D80:  MOVLW  00
03D82:  ADDWFC x57,W
03D84:  MOVWF  03
03D86:  MOVFF  01,958
03D8A:  MOVWF  x59
03D8C:  MOVLW  06
03D8E:  ADDWF  x56,W
03D90:  MOVWF  FE9
03D92:  MOVLW  00
03D94:  ADDWFC x57,W
03D96:  MOVWF  FEA
03D98:  MOVFF  FEC,9A2
03D9C:  MOVF   FED,F
03D9E:  MOVFF  FEF,9A1
03DA2:  MOVLB  0
03DA4:  CALL   17D4
03DA8:  MOVFF  959,FEA
03DAC:  MOVFF  958,FE9
03DB0:  MOVFF  02,FEC
03DB4:  MOVF   FED,F
03DB6:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
03DBA:  MOVLW  02
03DBC:  MOVLB  9
03DBE:  ADDWF  x56,W
03DC0:  MOVWF  01
03DC2:  MOVLW  00
03DC4:  ADDWFC x57,W
03DC6:  MOVWF  03
03DC8:  MOVFF  01,958
03DCC:  MOVWF  x59
03DCE:  MOVLW  02
03DD0:  ADDWF  x56,W
03DD2:  MOVWF  FE9
03DD4:  MOVLW  00
03DD6:  ADDWFC x57,W
03DD8:  MOVWF  FEA
03DDA:  MOVFF  FEC,9A2
03DDE:  MOVF   FED,F
03DE0:  MOVFF  FEF,9A1
03DE4:  MOVLB  0
03DE6:  CALL   17D4
03DEA:  MOVFF  959,FEA
03DEE:  MOVFF  958,FE9
03DF2:  MOVFF  02,FEC
03DF6:  MOVF   FED,F
03DF8:  MOVFF  01,FEF
03DFC:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
00FE6:  MOVLB  3
00FE8:  BCF    x90.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
00FEA:  MOVLB  8
00FEC:  SETF   x85
....................     Cache.MACAddr.v[1] = 0xff; 
00FEE:  SETF   x86
....................     Cache.MACAddr.v[2] = 0xff; 
00FF0:  SETF   x87
....................     Cache.MACAddr.v[3] = 0xff; 
00FF2:  SETF   x88
....................     Cache.MACAddr.v[4] = 0xff; 
00FF4:  SETF   x89
....................     Cache.MACAddr.v[5] = 0xff; 
00FF6:  SETF   x8A
....................  
....................     Cache.IPAddr.Val = 0x0; 
00FF8:  CLRF   x8E
00FFA:  CLRF   x8D
00FFC:  CLRF   x8C
00FFE:  CLRF   x8B
01000:  MOVLB  0
01002:  GOTO   12C2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
0209C:  MOVLW  00
0209E:  MOVLB  3
020A0:  BTFSC  x90.1
020A2:  MOVLW  01
020A4:  XORLW  00
020A6:  MOVLB  0
020A8:  BZ    20AC
020AA:  BRA    210C
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
020AC:  MOVLW  08
020AE:  MOVLB  9
020B0:  MOVWF  x08
020B2:  MOVLW  FC
020B4:  MOVWF  x07
020B6:  MOVLW  09
020B8:  MOVWF  x0A
020BA:  MOVLW  06
020BC:  MOVWF  x09
020BE:  MOVLB  0
020C0:  BRA    19F4
020C2:  MOVF   01,F
020C4:  BNZ   20C8
....................             break; 
020C6:  BRA    2132
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
020C8:  CALL   16FA
....................  
....................         if ( opCode == ARP_REPLY ) 
020CC:  MOVLB  9
020CE:  MOVF   x06,F
020D0:  BNZ   2106
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
020D2:  MOVLW  08
020D4:  MOVWF  FEA
020D6:  MOVLW  85
020D8:  MOVWF  FE9
020DA:  MOVLW  08
020DC:  MOVWF  FE2
020DE:  MOVLW  FC
020E0:  MOVWF  FE1
020E2:  MOVLW  06
020E4:  MOVWF  01
020E6:  MOVFF  FE6,FEE
020EA:  DECFSZ 01,F
020EC:  BRA    20E6
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
020EE:  MOVFF  905,88E
020F2:  MOVFF  904,88D
020F6:  MOVFF  903,88C
020FA:  MOVFF  902,88B
....................             break; 
020FE:  MOVLB  0
02100:  BRA    2132
....................         } 
02102:  BRA    210C
02104:  MOVLB  9
....................         else 
....................             smARP = SM_ARP_REPLY; 
02106:  MOVLB  3
02108:  BSF    x90.1
0210A:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
0210C:  MOVLW  08
0210E:  MOVLB  9
02110:  MOVWF  x08
02112:  MOVLW  FC
02114:  MOVWF  x07
02116:  CLRF   x09
02118:  MOVLB  0
0211A:  RCALL  1F18
0211C:  MOVF   01,F
0211E:  BZ    2128
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
02120:  MOVLB  3
02122:  BCF    x90.1
.................... 		} 
02124:  BRA    2130
02126:  MOVLB  0
....................         else 
....................             return FALSE; 
02128:  MOVLW  00
0212A:  MOVWF  01
0212C:  BRA    2136
0212E:  MOVLB  3
....................         break; 
02130:  MOVLB  0
....................  
....................     } 
....................     return TRUE; 
02132:  MOVLW  01
02134:  MOVWF  01
02136:  GOTO   44F2 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
0466E:  MOVLB  8
04670:  MOVFF  8F9,FE9
04674:  MOVFF  8FA,FEA
04678:  MOVFF  FEF,901
0467C:  MOVFF  FEC,902
04680:  MOVFF  FEC,903
04684:  MOVFF  FEC,904
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
04688:  MOVLW  08
0468A:  MOVLB  9
0468C:  MOVWF  x08
0468E:  MOVLW  FB
04690:  MOVWF  x07
04692:  MOVLW  01
04694:  MOVWF  x09
04696:  MOVLB  0
04698:  CALL   1F18
0469C:  GOTO   5344 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
046A0:  MOVLB  8
046A2:  MOVFF  8F9,FE9
046A6:  MOVFF  8FA,FEA
046AA:  MOVFF  FEF,00
046AE:  MOVFF  FEC,01
046B2:  MOVFF  FEC,02
046B6:  MOVFF  FEC,03
046BA:  MOVF   00,W
046BC:  SUBWF  x8B,W
046BE:  BNZ   46D2
046C0:  MOVF   01,W
046C2:  SUBWF  x8C,W
046C4:  BNZ   46D2
046C6:  MOVF   02,W
046C8:  SUBWF  x8D,W
046CA:  BNZ   46D2
046CC:  MOVF   03,W
046CE:  SUBWF  x8E,W
046D0:  BZ    46FA
046D2:  MOVLB  3
046D4:  MOVF   x5E,W
046D6:  MOVLB  8
046D8:  SUBWF  x8B,W
046DA:  BNZ   4720
046DC:  MOVLB  3
046DE:  MOVF   x5F,W
046E0:  MOVLB  8
046E2:  SUBWF  x8C,W
046E4:  BNZ   4720
046E6:  MOVLB  3
046E8:  MOVF   x60,W
046EA:  MOVLB  8
046EC:  SUBWF  x8D,W
046EE:  BNZ   4720
046F0:  MOVLB  3
046F2:  MOVF   x61,W
046F4:  MOVLB  8
046F6:  SUBWF  x8E,W
046F8:  BNZ   4720
....................     { 
....................         *MACAddr = Cache.MACAddr; 
046FA:  MOVFF  8FC,03
046FE:  MOVFF  8FB,FE9
04702:  MOVFF  8FC,FEA
04706:  MOVLW  08
04708:  MOVWF  FE2
0470A:  MOVLW  85
0470C:  MOVWF  FE1
0470E:  MOVLW  06
04710:  MOVWF  01
04712:  MOVFF  FE6,FEE
04716:  DECFSZ 01,F
04718:  BRA    4712
....................         return TRUE; 
0471A:  MOVLW  01
0471C:  MOVWF  01
0471E:  BRA    4724
....................     } 
....................     return FALSE; 
04720:  MOVLW  00
04722:  MOVWF  01
04724:  MOVLB  0
04726:  GOTO   5370 (RETURN)
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
019F4:  MOVLW  09
019F6:  MOVLB  9
019F8:  MOVWF  x91
019FA:  MOVLW  0B
019FC:  MOVWF  x90
019FE:  CLRF   x93
01A00:  MOVLW  1C
01A02:  MOVWF  x92
01A04:  MOVLB  0
01A06:  RCALL  1770
....................  
....................     MACDiscardRx(); 
01A08:  RCALL  16FA
....................  
....................     SwapARPPacket(&packet); 
01A0A:  MOVLW  09
01A0C:  MOVLB  9
01A0E:  MOVWF  x28
01A10:  MOVLW  0B
01A12:  MOVWF  x27
01A14:  MOVLB  0
01A16:  RCALL  1938
....................  
....................    debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
01A18:  MOVLB  9
01A1A:  DECFSZ x0B,W
01A1C:  BRA    1A2E
01A1E:  MOVF   x0C,F
01A20:  BNZ   1A2E
01A22:  MOVF   x0F,W
01A24:  SUBLW  06
01A26:  BNZ   1A2E
01A28:  MOVF   x10,W
01A2A:  SUBLW  04
01A2C:  BZ    1A34
....................          return FALSE; 
01A2E:  MOVLW  00
01A30:  MOVWF  01
01A32:  BRA    1AE6
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
01A34:  MOVF   x11,W
01A36:  SUBLW  02
01A38:  BNZ   1A4E
01A3A:  MOVF   x12,F
01A3C:  BNZ   1A4E
....................         *opCode = ARP_REPLY; 
01A3E:  MOVFF  90A,03
01A42:  MOVFF  909,FE9
01A46:  MOVFF  90A,FEA
01A4A:  CLRF   FEF
01A4C:  BRA    1A7A
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
01A4E:  DECFSZ x11,W
01A50:  BRA    1A68
01A52:  MOVF   x12,F
01A54:  BNZ   1A68
....................         *opCode = ARP_REQUEST; 
01A56:  MOVFF  90A,03
01A5A:  MOVFF  909,FE9
01A5E:  MOVFF  90A,FEA
01A62:  MOVLW  01
01A64:  MOVWF  FEF
01A66:  BRA    1A7A
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
01A68:  MOVFF  909,FE9
01A6C:  MOVFF  90A,FEA
01A70:  MOVLW  02
01A72:  MOVWF  FEF
....................         return FALSE; 
01A74:  MOVLW  00
01A76:  MOVWF  01
01A78:  BRA    1AE6
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
01A7A:  MOVLB  3
01A7C:  MOVF   x50,W
01A7E:  MOVLB  9
01A80:  SUBWF  x23,W
01A82:  BNZ   1AE2
01A84:  MOVLB  3
01A86:  MOVF   x51,W
01A88:  MOVLB  9
01A8A:  SUBWF  x24,W
01A8C:  BNZ   1AE2
01A8E:  MOVLB  3
01A90:  MOVF   x52,W
01A92:  MOVLB  9
01A94:  SUBWF  x25,W
01A96:  BNZ   1AE2
01A98:  MOVLB  3
01A9A:  MOVF   x53,W
01A9C:  MOVLB  9
01A9E:  SUBWF  x26,W
01AA0:  BNZ   1AE2
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
01AA2:  MOVFF  907,FE9
01AA6:  MOVFF  908,FEA
01AAA:  MOVLW  09
01AAC:  MOVWF  FE2
01AAE:  MOVLW  13
01AB0:  MOVWF  FE1
01AB2:  MOVLW  06
01AB4:  MOVWF  01
01AB6:  MOVFF  FE6,FEE
01ABA:  DECFSZ 01,F
01ABC:  BRA    1AB6
....................         remote->IPAddr      = packet.SenderIPAddr; 
01ABE:  MOVLW  06
01AC0:  ADDWF  x07,W
01AC2:  MOVWF  FE9
01AC4:  MOVLW  00
01AC6:  ADDWFC x08,W
01AC8:  MOVWF  FEA
01ACA:  MOVFF  919,FEF
01ACE:  MOVFF  91A,FEC
01AD2:  MOVFF  91B,FEC
01AD6:  MOVFF  91C,FEC
....................         return TRUE; 
01ADA:  MOVLW  01
01ADC:  MOVWF  01
01ADE:  BRA    1AE6
....................     } 
01AE0:  BRA    1AE6
....................     else 
....................         return FALSE; 
01AE2:  MOVLW  00
01AE4:  MOVWF  01
01AE6:  MOVLB  0
01AE8:  GOTO   20C2 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
01F18:  MOVLW  01
01F1A:  MOVLB  9
01F1C:  MOVWF  x82
01F1E:  MOVLB  0
01F20:  RCALL  1AEC
01F22:  MOVFF  01,926
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
01F26:  MOVLB  9
01F28:  INCFSZ x26,W
01F2A:  BRA    1F32
....................       return FALSE; 
01F2C:  MOVLW  00
01F2E:  MOVWF  01
01F30:  BRA    2098
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
01F32:  MOVFF  926,99B
01F36:  CLRF   x9D
01F38:  CLRF   x9C
01F3A:  MOVLB  0
01F3C:  RCALL  1B14
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
01F3E:  MOVLB  9
01F40:  CLRF   x0B
01F42:  MOVLW  01
01F44:  MOVWF  x0A
....................     packet.Protocol                 = ARP_IP; 
01F46:  MOVLW  08
01F48:  MOVWF  x0D
01F4A:  CLRF   x0C
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
01F4C:  MOVLW  06
01F4E:  MOVWF  x0E
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
01F50:  MOVLW  04
01F52:  MOVWF  x0F
....................  
....................     if ( opCode == ARP_REQUEST ) 
01F54:  DECFSZ x09,W
01F56:  BRA    1F6C
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
01F58:  CLRF   x11
01F5A:  MOVLW  01
01F5C:  MOVWF  x10
....................         packet.TargetMACAddr.v[0]   = 0xff; 
01F5E:  SETF   x1C
....................         packet.TargetMACAddr.v[1]   = 0xff; 
01F60:  SETF   x1D
....................         packet.TargetMACAddr.v[2]   = 0xff; 
01F62:  SETF   x1E
....................         packet.TargetMACAddr.v[3]   = 0xff; 
01F64:  SETF   x1F
....................         packet.TargetMACAddr.v[4]   = 0xff; 
01F66:  SETF   x20
....................         packet.TargetMACAddr.v[5]   = 0xff; 
01F68:  SETF   x21
....................     } 
01F6A:  BRA    1F8E
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
01F6C:  CLRF   x11
01F6E:  MOVLW  02
01F70:  MOVWF  x10
....................         packet.TargetMACAddr        = remote->MACAddr; 
01F72:  MOVFF  907,FE1
01F76:  MOVFF  908,FE2
01F7A:  MOVLW  09
01F7C:  MOVWF  FEA
01F7E:  MOVLW  1C
01F80:  MOVWF  FE9
01F82:  MOVLW  06
01F84:  MOVWF  01
01F86:  MOVFF  FE6,FEE
01F8A:  DECFSZ 01,F
01F8C:  BRA    1F86
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
01F8E:  MOVLW  09
01F90:  MOVWF  FEA
01F92:  MOVLW  12
01F94:  MOVWF  FE9
01F96:  MOVLW  03
01F98:  MOVWF  FE2
01F9A:  MOVLW  54
01F9C:  MOVWF  FE1
01F9E:  MOVLW  06
01FA0:  MOVWF  01
01FA2:  MOVFF  FE6,FEE
01FA6:  DECFSZ 01,F
01FA8:  BRA    1FA2
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
01FAA:  MOVFF  353,91B
01FAE:  MOVFF  352,91A
01FB2:  MOVFF  351,919
01FB6:  MOVFF  350,918
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
01FBA:  MOVLW  06
01FBC:  ADDWF  x07,W
01FBE:  MOVWF  FE9
01FC0:  MOVLW  00
01FC2:  ADDWFC x08,W
01FC4:  MOVWF  FEA
01FC6:  MOVFF  FEF,00
01FCA:  MOVFF  FEC,01
01FCE:  MOVFF  FEC,02
01FD2:  MOVFF  FEC,03
01FD6:  MOVF   00,W
01FD8:  XORWF  x18,W
01FDA:  MOVWF  x27
01FDC:  MOVF   01,W
01FDE:  XORWF  x19,W
01FE0:  MOVWF  x28
01FE2:  MOVF   02,W
01FE4:  XORWF  x1A,W
01FE6:  MOVWF  x29
01FE8:  MOVF   03,W
01FEA:  XORWF  x1B,W
01FEC:  MOVWF  x2A
01FEE:  MOVF   x27,W
01FF0:  MOVLB  3
01FF2:  ANDWF  x5A,W
01FF4:  MOVWF  00
01FF6:  MOVLB  9
01FF8:  MOVF   x28,W
01FFA:  MOVLB  3
01FFC:  ANDWF  x5B,W
01FFE:  MOVWF  01
02000:  MOVLB  9
02002:  MOVF   x29,W
02004:  MOVLB  3
02006:  ANDWF  x5C,W
02008:  MOVWF  02
0200A:  MOVLB  9
0200C:  MOVF   x2A,W
0200E:  MOVLB  3
02010:  ANDWF  x5D,W
02012:  MOVWF  03
02014:  MOVF   00,F
02016:  BNZ   2024
02018:  MOVF   01,F
0201A:  BNZ   2024
0201C:  MOVF   02,F
0201E:  BNZ   2024
02020:  MOVF   03,F
02022:  BZ    2036
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
02024:  MOVFF  361,925
02028:  MOVFF  360,924
0202C:  MOVFF  35F,923
02030:  MOVFF  35E,922
....................     } 
02034:  BRA    2056
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
02036:  MOVLW  06
02038:  MOVLB  9
0203A:  ADDWF  x07,W
0203C:  MOVWF  FE9
0203E:  MOVLW  00
02040:  ADDWFC x08,W
02042:  MOVWF  FEA
02044:  MOVFF  FEF,922
02048:  MOVFF  FEC,923
0204C:  MOVFF  FEC,924
02050:  MOVFF  FEC,925
02054:  MOVLB  3
....................  
....................     SwapARPPacket(&packet); 
02056:  MOVLW  09
02058:  MOVLB  9
0205A:  MOVWF  x28
0205C:  MOVLW  0A
0205E:  MOVWF  x27
02060:  MOVLB  0
02062:  RCALL  1938
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
02064:  MOVLW  09
02066:  MOVLB  9
02068:  MOVWF  xA0
0206A:  MOVLW  1C
0206C:  MOVWF  x9F
0206E:  MOVLW  06
02070:  MOVWF  xA1
02072:  CLRF   xA3
02074:  MOVLW  1C
02076:  MOVWF  xA2
02078:  MOVLB  0
0207A:  RCALL  1C1A
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
0207C:  MOVLW  09
0207E:  MOVLB  9
02080:  MOVWF  xA7
02082:  MOVLW  0A
02084:  MOVWF  xA6
02086:  CLRF   xA9
02088:  MOVLW  1C
0208A:  MOVWF  xA8
0208C:  MOVLB  0
0208E:  RCALL  1BD0
....................  
....................     MACFlush(); 
02090:  RCALL  1CE8
....................     
....................    return TRUE; 
02092:  MOVLW  01
02094:  MOVWF  01
02096:  MOVLB  9
02098:  MOVLB  0
0209A:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
01938:  MOVLB  9
0193A:  MOVFF  927,01
0193E:  MOVFF  928,03
01942:  MOVFF  927,929
01946:  MOVFF  928,92A
0194A:  MOVFF  927,FE9
0194E:  MOVFF  928,FEA
01952:  MOVFF  FEC,9A2
01956:  MOVF   FED,F
01958:  MOVFF  FEF,9A1
0195C:  MOVLB  0
0195E:  RCALL  17D4
01960:  MOVFF  92A,FEA
01964:  MOVFF  929,FE9
01968:  MOVFF  02,FEC
0196C:  MOVF   FED,F
0196E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
01972:  MOVLW  02
01974:  MOVLB  9
01976:  ADDWF  x27,W
01978:  MOVWF  01
0197A:  MOVLW  00
0197C:  ADDWFC x28,W
0197E:  MOVWF  03
01980:  MOVFF  01,929
01984:  MOVWF  x2A
01986:  MOVLW  02
01988:  ADDWF  x27,W
0198A:  MOVWF  FE9
0198C:  MOVLW  00
0198E:  ADDWFC x28,W
01990:  MOVWF  FEA
01992:  MOVFF  FEC,9A2
01996:  MOVF   FED,F
01998:  MOVFF  FEF,9A1
0199C:  MOVLB  0
0199E:  RCALL  17D4
019A0:  MOVFF  92A,FEA
019A4:  MOVFF  929,FE9
019A8:  MOVFF  02,FEC
019AC:  MOVF   FED,F
019AE:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
019B2:  MOVLW  06
019B4:  MOVLB  9
019B6:  ADDWF  x27,W
019B8:  MOVWF  01
019BA:  MOVLW  00
019BC:  ADDWFC x28,W
019BE:  MOVWF  03
019C0:  MOVFF  01,929
019C4:  MOVWF  x2A
019C6:  MOVLW  06
019C8:  ADDWF  x27,W
019CA:  MOVWF  FE9
019CC:  MOVLW  00
019CE:  ADDWFC x28,W
019D0:  MOVWF  FEA
019D2:  MOVFF  FEC,9A2
019D6:  MOVF   FED,F
019D8:  MOVFF  FEF,9A1
019DC:  MOVLB  0
019DE:  RCALL  17D4
019E0:  MOVFF  92A,FEA
019E4:  MOVFF  929,FE9
019E8:  MOVFF  02,FEC
019EC:  MOVF   FED,F
019EE:  MOVFF  01,FEF
019F2:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
012B6:  MOVLB  8
012B8:  CLRF   x8F
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
012BA:  MOVLB  0
012BC:  BRA    0AE8
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
012BE:  BRA    0E14
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
012C0:  BRA    0FE6
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
012C2:  BRA    1164
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
012C4:  GOTO   6E8E (RETURN)
....................    TFTPInit(); 
.................... #endif 
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
04492:  MOVLB  8
04494:  BCF    xFB.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
04496:  BCF    xFB.0
....................         switch(smStack) 
04498:  MOVF   x8F,W
0449A:  ADDLW  F9
0449C:  BTFSC  FD8.0
0449E:  BRA    463C
044A0:  ADDLW  07
044A2:  MOVLB  0
044A4:  GOTO   4646
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
044A8:  MOVLW  08
044AA:  MOVLB  8
044AC:  MOVWF  xFD
044AE:  MOVLW  90
044B0:  MOVWF  xFC
044B2:  MOVLW  08
044B4:  MOVWF  xFF
044B6:  MOVLW  FA
044B8:  MOVWF  xFE
044BA:  MOVLB  0
044BC:  GOTO   17EA
044C0:  MOVF   01,F
044C2:  BNZ   44CA
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
044C4:  MOVLB  8
044C6:  BRA    463C
044C8:  MOVLB  0
....................             } 
....................  
....................             debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
044CA:  MOVLB  8
044CC:  BSF    xFB.0
....................             if ( type.MACFrameType == MAC_IP ) { 
044CE:  MOVF   xFA,F
044D0:  BNZ   44D8
....................                 smStack = SM_STACK_IP; 
044D2:  MOVLW  02
044D4:  MOVWF  x8F
....................                 debug_stack(debug_putc, "IP "); 
....................             } 
044D6:  BRA    44EC
....................             else if ( type.MACFrameType == MAC_ARP ) { 
044D8:  MOVF   xFA,W
044DA:  SUBLW  06
044DC:  BNZ   44E4
....................                 smStack = SM_STACK_ARP; 
044DE:  MOVLW  05
044E0:  MOVWF  x8F
....................                 debug_stack(debug_putc, "ARP "); 
....................             } 
044E2:  BRA    44EC
....................             else { 
....................                 MACDiscardRx(); 
044E4:  MOVLB  0
044E6:  CALL   16FA
044EA:  MOVLB  8
....................                 debug_stack(debug_putc, "DISCARD"); 
....................             } 
....................             break; 
044EC:  BRA    463C
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
044EE:  GOTO   209C
044F2:  MOVF   01,F
044F4:  BZ    44FC
....................                 smStack = SM_STACK_IDLE; 
044F6:  MOVLB  8
044F8:  CLRF   x8F
044FA:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
044FC:  MOVLB  8
044FE:  BRA    463C
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
04500:  MOVLW  08
04502:  MOVLB  8
04504:  MOVWF  xFD
04506:  MOVLW  F6
04508:  MOVWF  xFC
0450A:  MOVLW  08
0450C:  MOVWF  xFF
0450E:  MOVLW  90
04510:  MOVWF  xFE
04512:  MOVLW  08
04514:  MOVLB  9
04516:  MOVWF  x01
04518:  MOVLW  FA
0451A:  MOVWF  x00
0451C:  MOVLW  08
0451E:  MOVWF  x03
04520:  MOVLW  9A
04522:  MOVWF  x02
04524:  MOVLB  0
04526:  GOTO   2392
0452A:  MOVF   01,F
0452C:  BZ    4558
....................             { 
....................                 lbContinue = TRUE; 
0452E:  MOVLB  8
04530:  BSF    xFB.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
04532:  DECFSZ xFA,W
04534:  BRA    453C
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
04536:  MOVLW  03
04538:  MOVWF  x8F
....................                     debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
0453A:  BRA    4554
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
0453C:  MOVF   xFA,W
0453E:  SUBLW  06
04540:  BNZ   4548
....................                     smStack = SM_STACK_TCP; 
04542:  MOVLW  06
04544:  MOVWF  x8F
....................                     debug_stack(debug_putc, "TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
04546:  BRA    4554
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack(debug_putc, "UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
04548:  BCF    xFB.0
....................                     MACDiscardRx(); 
0454A:  MOVLB  0
0454C:  CALL   16FA
....................  
....................                     smStack = SM_STACK_IDLE; 
04550:  MOVLB  8
04552:  CLRF   x8F
....................                     debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................                 } 
....................             } 
04554:  BRA    4560
04556:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
04558:  CALL   16FA
....................                 smStack = SM_STACK_IDLE; 
0455C:  MOVLB  8
0455E:  CLRF   x8F
....................                 debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................             } 
....................             break; 
04560:  BRA    463C
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
04562:  MOVLW  08
04564:  MOVLB  8
04566:  MOVWF  xFD
04568:  MOVLW  90
0456A:  MOVWF  xFC
0456C:  MOVLW  08
0456E:  MOVWF  xFF
04570:  MOVLW  F6
04572:  MOVWF  xFE
04574:  MOVFF  89B,901
04578:  MOVFF  89A,900
0457C:  MOVLB  0
0457E:  GOTO   3BA6
04582:  MOVF   01,F
04584:  BZ    458C
....................             { 
....................                 debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
04586:  MOVLB  8
04588:  CLRF   x8F
0458A:  MOVLB  0
....................             } 
....................             break; 
0458C:  MOVLB  8
0458E:  BRA    463C
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
04590:  MOVLB  8
04592:  CLRF   x8F
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
04594:  MOVF   x9B,F
04596:  BNZ   45E6
04598:  MOVF   x9A,W
0459A:  SUBLW  48
0459C:  BNC   45E6
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
0459E:  MOVLW  08
045A0:  MOVWF  xFD
045A2:  MOVLW  9A
045A4:  MOVWF  xFC
045A6:  MOVLW  08
045A8:  MOVWF  xFF
045AA:  MOVLW  FA
045AC:  MOVWF  xFE
045AE:  MOVLW  08
045B0:  MOVLB  9
045B2:  MOVWF  x01
045B4:  MOVLW  9C
045B6:  MOVWF  x00
045B8:  MOVFF  8FD,903
045BC:  MOVFF  8FC,902
045C0:  MOVLW  08
045C2:  MOVWF  x05
045C4:  MOVLW  DC
045C6:  MOVWF  x04
045C8:  MOVLW  08
045CA:  MOVWF  x07
045CC:  MOVLW  DE
045CE:  MOVWF  x06
045D0:  MOVLB  0
045D2:  BRA    3DFE
045D4:  MOVF   01,F
045D6:  BZ    45E8
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
045D8:  MOVLB  8
045DA:  MOVF   xFA,W
045DC:  SUBLW  08
045DE:  BNZ   45E6
....................                     { 
....................                         debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
045E0:  BSF    xFB.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
045E2:  MOVLW  04
045E4:  MOVWF  x8F
045E6:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
045E8:  CALL   16FA
....................             break; 
045EC:  MOVLB  8
045EE:  BRA    463C
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
045F0:  MOVLW  01
045F2:  MOVLB  9
045F4:  MOVWF  x82
045F6:  MOVLB  0
045F8:  CALL   2C2E
045FC:  MOVF   01,F
045FE:  BZ    4636
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
04600:  MOVLW  08
04602:  MOVLB  8
04604:  MOVWF  xFD
04606:  MOVLW  90
04608:  MOVWF  xFC
0460A:  CLRF   xFE
0460C:  MOVLW  08
0460E:  MOVLB  9
04610:  MOVWF  x00
04612:  MOVLW  9C
04614:  MOVLB  8
04616:  MOVWF  xFF
04618:  MOVFF  89A,901
0461C:  MOVFF  8DD,903
04620:  MOVFF  8DC,902
04624:  MOVFF  8DF,905
04628:  MOVFF  8DE,904
0462C:  MOVLB  0
0462E:  BRA    3ED0
....................  
....................                 debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
04630:  MOVLB  8
04632:  CLRF   x8F
04634:  MOVLB  0
....................             } 
....................             break; 
04636:  MOVLB  8
04638:  BRA    463C
0463A:  MOVLB  8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
0463C:  BTFSC  xFB.0
0463E:  BRA    4496
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
04640:  MOVLB  0
04642:  BRA    3FE6
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
04644:  RETURN 0
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
....................  
....................  
.................... // Dirección IP de la PC (destino). 
.................... IP_ADDR server; 
.................... // Puerto TCP. 
.................... #define EXAMPLE_TCP_PORT   (int16)7654 
.................... //int reintento_envio; 
.................... // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX. 
....................  
.................... void MACAddrInit(void) 
.................... { 
....................    MY_MAC_BYTE1=0x00; 
*
00A86:  MOVLB  3
00A88:  CLRF   x54
....................    MY_MAC_BYTE2=0x04; 
00A8A:  MOVLW  04
00A8C:  MOVWF  x55
....................    MY_MAC_BYTE3=0xA3; 
00A8E:  MOVLW  A3
00A90:  MOVWF  x56
....................    MY_MAC_BYTE4=0x00; 
00A92:  CLRF   x57
....................    MY_MAC_BYTE5=0x00; 
00A94:  CLRF   x58
....................    MY_MAC_BYTE6=0x11; 
00A96:  MOVLW  11
00A98:  MOVWF  x59
00A9A:  MOVLB  0
00A9C:  GOTO   6E82 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    // IP del dispositivo. 
....................    MY_IP_BYTE1=192; 
00AA0:  MOVLW  C0
00AA2:  MOVLB  3
00AA4:  MOVWF  x50
....................    MY_IP_BYTE2=168; 
00AA6:  MOVLW  A8
00AA8:  MOVWF  x51
....................    MY_IP_BYTE3=16; 
00AAA:  MOVLW  10
00AAC:  MOVWF  x52
....................    MY_IP_BYTE4=111; 
00AAE:  MOVLW  6F
00AB0:  MOVWF  x53
....................  
....................    // Puerta de enlace. 
....................    MY_GATE_BYTE1=192; 
00AB2:  MOVLW  C0
00AB4:  MOVWF  x5E
....................    MY_GATE_BYTE2=168; 
00AB6:  MOVLW  A8
00AB8:  MOVWF  x5F
....................    MY_GATE_BYTE3=16; 
00ABA:  MOVLW  10
00ABC:  MOVWF  x60
....................    MY_GATE_BYTE4=1; 
00ABE:  MOVLW  01
00AC0:  MOVWF  x61
....................  
....................    // Máscara de Subred. 
....................    MY_MASK_BYTE1=255; 
00AC2:  SETF   x5A
....................    MY_MASK_BYTE2=255; 
00AC4:  SETF   x5B
....................    MY_MASK_BYTE3=255; 
00AC6:  SETF   x5C
....................    MY_MASK_BYTE4=0; 
00AC8:  CLRF   x5D
00ACA:  MOVLB  0
00ACC:  GOTO   6E86 (RETURN)
.................... } 
....................  
.................... void ServerAddrInit(void) { 
....................    // IP del servidor.. 
....................    server.v[0]=192; 
00AD0:  MOVLW  C0
00AD2:  MOVLB  8
00AD4:  MOVWF  xE0
....................    server.v[1]=168; 
00AD6:  MOVLW  A8
00AD8:  MOVWF  xE1
....................    server.v[2]=16; 
00ADA:  MOVLW  10
00ADC:  MOVWF  xE2
....................    server.v[3]=199; 
00ADE:  MOVLW  C7
00AE0:  MOVWF  xE3
00AE2:  MOVLB  0
00AE4:  GOTO   6E8A (RETURN)
.................... } 
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
....................  
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    //static int8 counter; 
....................    //char str[20]; 
....................    static int8 button1_held; 
....................     
....................    if (TCPIsGetReady(socket)) {//ESCUCHA PUERTO TCP 
*
051BC:  MOVFF  8F9,8FB
051C0:  GOTO   497C
051C4:  MOVF   01,F
051C6:  BZ    524C
....................       //fprintf(DEBUG,"\r\nLEE SOCKET"); 
.................... //   if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      lcd_putc("LEE SOCKET          ");         } 
....................       edo_str=1;//bandera de dato recibido en socket actual 
051C8:  MOVLW  01
051CA:  MOVWF  4E
....................       i=0; 
051CC:  CLRF   41
051CE:  CLRF   40
....................       while ( TCPGet(socket, &c) ) { 
051D0:  MOVFF  8F9,8FB
051D4:  MOVLW  08
051D6:  MOVLB  8
051D8:  MOVWF  xFD
051DA:  MOVLW  FA
051DC:  MOVWF  xFC
051DE:  MOVLB  0
051E0:  GOTO   49BC
051E4:  MOVF   01,F
051E6:  BZ    524C
....................          rxtcp[i++]=c; 
051E8:  MOVFF  41,03
051EC:  MOVF   40,W
051EE:  INCF   40,F
051F0:  BTFSC  FD8.2
051F2:  INCF   41,F
051F4:  MOVLB  8
051F6:  MOVWF  xFB
051F8:  MOVLW  60
051FA:  ADDWF  xFB,W
051FC:  MOVWF  FE9
051FE:  MOVLW  01
05200:  ADDWFC 03,W
05202:  MOVWF  FEA
05204:  MOVFF  8FA,FEF
....................          if (c=='@') { 
05208:  MOVF   xFA,W
0520A:  SUBLW  40
0520C:  BNZ   522A
....................             edo_str=0; 
0520E:  CLRF   4E
....................             lcd_gotoxy(20,4); 
05210:  MOVLW  14
05212:  MOVLB  9
05214:  MOVWF  x00
05216:  MOVLW  04
05218:  MOVWF  x01
0521A:  MOVLB  0
0521C:  CALL   0628
....................             printf(lcd_putc,"%c",c); 
05220:  MOVFF  8FA,8FF
05224:  CALL   067A
05228:  MOVLB  8
....................          } 
....................          if (i>port_size) {i=port_size;} 
0522A:  MOVF   41,F
0522C:  BNZ   5234
0522E:  MOVF   40,W
05230:  SUBLW  5A
05232:  BC    523A
05234:  CLRF   41
05236:  MOVLW  5A
05238:  MOVWF  40
....................          rxtcp[i]=0; 
0523A:  MOVLW  60
0523C:  ADDWF  40,W
0523E:  MOVWF  FE9
05240:  MOVLW  01
05242:  ADDWFC 41,W
05244:  MOVWF  FEA
05246:  CLRF   FEF
05248:  MOVLB  0
0524A:  BRA    51D0
....................       } 
....................    } 
....................  
.................... //send message over TCP 
....................    //if(envia_pc) fprintf(DEBUG,"envia_pc:%u !button1_held:%u TCPIsPutReady(socket):%u\r\n",envia_pc,button1_held, TCPIsPutReady(socket) ); 
....................    if (envia_pc && !button1_held && TCPIsPutReady(socket)) {//ENVIA MENSAJE POR TCP 
0524C:  MOVF   1A,F
0524E:  BZ    528E
05250:  MOVLB  8
05252:  MOVF   xE4,F
05254:  BTFSC  FD8.2
05256:  BRA    525C
05258:  MOVLB  0
0525A:  BRA    528E
0525C:  MOVFF  8F9,909
05260:  MOVLB  0
05262:  RCALL  4AA8
05264:  MOVF   01,F
05266:  BZ    528E
....................       button1_held=TRUE; 
05268:  MOVLW  01
0526A:  MOVLB  8
0526C:  MOVWF  xE4
....................       TCPPutArray(socket,txtcp,size_tx_tcp);//SOCKET,DATO,NO.BYTES 
0526E:  MOVFF  8F9,8FB
05272:  MOVWF  xFD
05274:  MOVLW  06
05276:  MOVWF  xFC
05278:  CLRF   xFF
0527A:  MOVFF  48,8FE
0527E:  MOVLB  0
05280:  BRA    4E54
....................       TCPFlush(socket); 
05282:  MOVFF  8F9,904
05286:  RCALL  4CB4
....................       reintento_envio=0; 
05288:  CLRF   4F
....................       envia_pc=0; 
0528A:  CLRF   1A
....................       //fprintf(DEBUG,"Envio:%s\r\n",txtcp); 
.................... //      if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      printf(lcd_putc,"Envio:%s       ",txtcp);} 
....................    }////////////////// 
0528C:  BRA    52B8
....................    else if (envia_pc && !button1_held && !TCPIsPutReady(socket)) {//SI NO PUEDE VACIAR DATOS ROMPE CONEXION 
0528E:  MOVF   1A,F
05290:  BZ    52B8
05292:  MOVLB  8
05294:  MOVF   xE4,F
05296:  BTFSC  FD8.2
05298:  BRA    529E
0529A:  MOVLB  0
0529C:  BRA    52B8
0529E:  MOVFF  8F9,909
052A2:  MOVLB  0
052A4:  RCALL  4AA8
052A6:  MOVF   01,F
052A8:  BNZ   52B8
....................       reintento_envio++; 
052AA:  INCF   4F,F
....................       if(reintento_envio>=10) TCPDisconnect(socket); 
052AC:  MOVF   4F,W
052AE:  SUBLW  09
052B0:  BC    52B8
052B2:  MOVFF  8F9,8FB
052B6:  RCALL  509A
....................    }/////////////////// 
....................     
....................    if (!envia_pc) { 
052B8:  MOVF   1A,F
052BA:  BNZ   52C2
....................       button1_held=FALSE; 
052BC:  MOVLB  8
052BE:  CLRF   xE4
052C0:  MOVLB  0
....................    } 
....................     
....................    //#if defined(ESTADO_entrada04)//CIERRA LAS CONEXIONES 
....................    //if (ESTADO_entrada04) { 
....................      // return(TRUE); 
....................    //} 
....................   //#endif 
....................  
....................    return(TRUE); 
052C2:  MOVLW  01
052C4:  MOVWF  01
052C6:  GOTO   5514 (RETURN)
.................... } 
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_ARP_REQ=1, MYTCP_STATE_ARP_WAIT=2, 
....................       MYTCP_STATE_CONNECT=3, MYTCP_STATE_CONNECT_WAIT=4, 
....................       MYTCP_STATE_CONNECTED=5, MYTCP_STATE_DISCONNECT=6, 
....................       MYTCP_STATE_FORCE_DISCONNECT=7 
....................    } state=0; 
....................    static NODE_INFO remote; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................  
....................    currTick=TickGet(); 
052CA:  CALL   2B16
052CE:  MOVFF  02,8F7
052D2:  MOVFF  01,8F6
....................  
....................    switch (state) { 
052D6:  MOVLB  8
052D8:  MOVF   xE8,W
052DA:  ADDLW  F8
052DC:  BTFSC  FD8.0
052DE:  BRA    5608
052E0:  ADDLW  08
052E2:  MOVLB  0
052E4:  GOTO   560C
....................       case MYTCP_STATE_NEW: 
....................          memcpy(&remote.IPAddr, &server, sizeof(IP_ADDR)); 
052E8:  MOVFF  8E0,8EF
052EC:  MOVFF  8E1,8F0
052F0:  MOVFF  8E2,8F1
052F4:  MOVFF  8E3,8F2
....................          //fprintf(DEBUG,"\n Solicitud ARP."); 
....................          if(!espera)   { 
052F8:  MOVLB  2
052FA:  MOVF   x7D,F
052FC:  BNZ   531C
....................          lcd_gotoxy(1,4); 
052FE:  MOVLW  01
05300:  MOVLB  9
05302:  MOVWF  x00
05304:  MOVLW  04
05306:  MOVWF  x01
05308:  MOVLB  0
0530A:  CALL   0628
....................          lcd_putc("Solicitud ARP.      ");} 
0530E:  MOVLW  48
05310:  MOVWF  FF6
05312:  MOVLW  01
05314:  MOVWF  FF7
05316:  CALL   06DE
0531A:  MOVLB  2
....................          state=MYTCP_STATE_ARP_REQ; 
0531C:  MOVLW  01
0531E:  MOVLB  8
05320:  MOVWF  xE8
05322:  MOVLB  0
....................  
....................       case MYTCP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
05324:  MOVLW  01
05326:  MOVLB  9
05328:  MOVWF  x82
0532A:  MOVLB  0
0532C:  CALL   2C2E
05330:  MOVF   01,F
05332:  BZ    5354
....................             ARPResolve(&remote.IPAddr); 
05334:  MOVLW  08
05336:  MOVLB  8
05338:  MOVWF  xFA
0533A:  MOVLW  EF
0533C:  MOVWF  xF9
0533E:  MOVLB  0
05340:  GOTO   466E
....................             lastTick=currTick; 
05344:  MOVFF  8F7,8E6
05348:  MOVFF  8F6,8E5
....................             state=MYTCP_STATE_ARP_WAIT; 
0534C:  MOVLW  02
0534E:  MOVLB  8
05350:  MOVWF  xE8
05352:  MOVLB  0
....................          } 
....................          break; 
05354:  MOVLB  8
05356:  BRA    5608
....................  
....................       case MYTCP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) { 
05358:  MOVLW  08
0535A:  MOVLB  8
0535C:  MOVWF  xFA
0535E:  MOVLW  EF
05360:  MOVWF  xF9
05362:  MOVLW  08
05364:  MOVWF  xFC
05366:  MOVLW  E9
05368:  MOVWF  xFB
0536A:  MOVLB  0
0536C:  GOTO   46A0
05370:  MOVF   01,F
05372:  BZ    53A0
....................             state=MYTCP_STATE_CONNECT; 
05374:  MOVLW  03
05376:  MOVLB  8
05378:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTANDO...      "); 
....................             if(!espera)   { 
0537A:  MOVLB  2
0537C:  MOVF   x7D,F
0537E:  BNZ   539E
....................             lcd_gotoxy(1,4); 
05380:  MOVLW  01
05382:  MOVLB  9
05384:  MOVWF  x00
05386:  MOVLW  04
05388:  MOVWF  x01
0538A:  MOVLB  0
0538C:  CALL   0628
....................             lcd_putc("CONECTANDO...       ");} 
05390:  MOVLW  5E
05392:  MOVWF  FF6
05394:  MOVLW  01
05396:  MOVWF  FF7
05398:  CALL   06DE
0539C:  MOVLB  2
....................          } 
0539E:  BRA    53FA
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) { 
053A0:  MOVLB  8
053A2:  MOVF   xF7,W
053A4:  SUBWF  xE6,W
053A6:  BNC   53B0
053A8:  BNZ   53B4
053AA:  MOVF   xE5,W
053AC:  SUBWF  xF6,W
053AE:  BNC   53B4
053B0:  MOVLW  00
053B2:  BRA    53B6
053B4:  MOVLW  01
053B6:  CLRF   03
053B8:  IORWF  03,W
053BA:  BZ    53E2
053BC:  MOVLW  FF
053BE:  BSF    FD8.0
053C0:  SUBFWB xE5,W
053C2:  MOVWF  xF9
053C4:  MOVLW  FF
053C6:  SUBFWB xE6,W
053C8:  MOVWF  xFA
053CA:  MOVF   xF6,W
053CC:  ADDWF  xF9,F
053CE:  MOVF   xF7,W
053D0:  ADDWFC xFA,F
053D2:  MOVLW  01
053D4:  ADDWF  xF9,W
053D6:  MOVWF  01
053D8:  MOVLW  00
053DA:  ADDWFC xFA,W
053DC:  MOVWF  03
053DE:  MOVF   01,W
053E0:  BRA    53F0
053E2:  MOVF   xE5,W
053E4:  SUBWF  xF6,W
053E6:  MOVWF  00
053E8:  MOVF   xE6,W
053EA:  SUBWFB xF7,W
053EC:  MOVWF  03
053EE:  MOVF   00,W
053F0:  SUBLW  18
053F2:  BC    53F8
....................             state=MYTCP_STATE_ARP_REQ; 
053F4:  MOVLW  01
053F6:  MOVWF  xE8
053F8:  MOVLB  2
....................          } 
....................          break; 
053FA:  MOVLB  8
053FC:  BRA    5608
....................  
....................       case MYTCP_STATE_CONNECT: 
....................          socket2=socket=TCPConnect(&remote, EXAMPLE_TCP_PORT); 
053FE:  MOVLW  08
05400:  MOVLB  8
05402:  MOVWF  xFA
05404:  MOVLW  E9
05406:  MOVWF  xF9
05408:  MOVLW  1D
0540A:  MOVWF  xFC
0540C:  MOVLW  E6
0540E:  MOVWF  xFB
05410:  MOVLB  0
05412:  GOTO   472A
05416:  MOVFF  01,8E7
0541A:  MOVFF  8E7,51
....................          if (socket!=INVALID_SOCKET) { 
0541E:  MOVLB  8
05420:  MOVF   xE7,W
05422:  SUBLW  FE
05424:  BZ    543C
....................             lastTick=TickGet(); 
05426:  MOVLB  0
05428:  CALL   2B16
0542C:  MOVFF  02,8E6
05430:  MOVFF  01,8E5
....................             state=MYTCP_STATE_CONNECT_WAIT; 
05434:  MOVLW  04
05436:  MOVLB  8
05438:  MOVWF  xE8
....................          } 
0543A:  BRA    5462
....................          else { 
....................             //fprintf(DEBUG,"\nError en el socket."); 
....................             if(!espera)   { 
0543C:  MOVLB  2
0543E:  MOVF   x7D,F
05440:  BNZ   5460
....................                lcd_gotoxy(1,4);  
05442:  MOVLW  01
05444:  MOVLB  9
05446:  MOVWF  x00
05448:  MOVLW  04
0544A:  MOVWF  x01
0544C:  MOVLB  0
0544E:  CALL   0628
....................                lcd_putc("Error en el socket. ");} 
05452:  MOVLW  74
05454:  MOVWF  FF6
05456:  MOVLW  01
05458:  MOVWF  FF7
0545A:  CALL   06DE
0545E:  MOVLB  2
05460:  MOVLB  8
....................          } 
....................          break; 
05462:  BRA    5608
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(socket)) { 
05464:  MOVFF  8E7,8F9
05468:  CALL   4940
0546C:  MOVF   01,F
0546E:  BZ    54A4
....................             state=MYTCP_STATE_CONNECTED; 
05470:  MOVLW  05
05472:  MOVLB  8
05474:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTADO! "); 
....................             if(!espera)   { 
05476:  MOVLB  2
05478:  MOVF   x7D,F
0547A:  BNZ   549A
....................                lcd_gotoxy(1,4); 
0547C:  MOVLW  01
0547E:  MOVLB  9
05480:  MOVWF  x00
05482:  MOVLW  04
05484:  MOVWF  x01
05486:  MOVLB  0
05488:  CALL   0628
....................                lcd_putc("CONECTADO           ");} 
0548C:  MOVLW  8A
0548E:  MOVWF  FF6
05490:  MOVLW  01
05492:  MOVWF  FF7
05494:  CALL   06DE
05498:  MOVLB  2
....................             output_high(salida06); 
0549A:  BCF    F94.2
0549C:  BSF    F8B.2
....................             inicializado=1; 
0549E:  MOVLW  01
054A0:  MOVWF  50
....................          } 
054A2:  BRA    54FE
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
054A4:  MOVLB  8
054A6:  MOVF   xF7,W
054A8:  SUBWF  xE6,W
054AA:  BNC   54B4
054AC:  BNZ   54B8
054AE:  MOVF   xE5,W
054B0:  SUBWF  xF6,W
054B2:  BNC   54B8
054B4:  MOVLW  00
054B6:  BRA    54BA
054B8:  MOVLW  01
054BA:  CLRF   03
054BC:  IORWF  03,W
054BE:  BZ    54E6
054C0:  MOVLW  FF
054C2:  BSF    FD8.0
054C4:  SUBFWB xE5,W
054C6:  MOVWF  xF9
054C8:  MOVLW  FF
054CA:  SUBFWB xE6,W
054CC:  MOVWF  xFA
054CE:  MOVF   xF6,W
054D0:  ADDWF  xF9,F
054D2:  MOVF   xF7,W
054D4:  ADDWFC xFA,F
054D6:  MOVLW  01
054D8:  ADDWF  xF9,W
054DA:  MOVWF  01
054DC:  MOVLW  00
054DE:  ADDWFC xFA,W
054E0:  MOVWF  03
054E2:  MOVF   01,W
054E4:  BRA    54F4
054E6:  MOVF   xE5,W
054E8:  SUBWF  xF6,W
054EA:  MOVWF  00
054EC:  MOVF   xE6,W
054EE:  SUBWFB xF7,W
054F0:  MOVWF  03
054F2:  MOVF   00,W
054F4:  SUBLW  78
054F6:  BC    54FC
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
054F8:  MOVLW  07
054FA:  MOVWF  xE8
054FC:  MOVLB  2
....................          } 
....................          break; 
054FE:  MOVLB  8
05500:  BRA    5608
....................  
....................       case MYTCP_STATE_CONNECTED: 
....................          if (TCPIsConnected(socket)) { 
05502:  MOVFF  8E7,8F9
05506:  CALL   4940
0550A:  MOVF   01,F
0550C:  BZ    552A
....................             dis=TCPConnectedTask(socket); 
0550E:  MOVFF  8E7,8F9
05512:  BRA    51BC
05514:  MOVFF  01,8F8
....................             //fprintf(DEBUG,"\ndis:%u ",dis); 
....................             if (dis) { 
05518:  MOVLB  8
0551A:  MOVF   xF8,F
0551C:  BZ    5526
....................                //state=MYTCP_STATE_DISCONNECT; 
....................                lastTick=currTick; 
0551E:  MOVFF  8F7,8E6
05522:  MOVFF  8F6,8E5
....................             } 
....................          } 
05526:  BRA    5530
05528:  MOVLB  0
....................          else { 
....................             //fprintf(DEBUG,"\nDESCONECTADO.   "); 
....................             //state=MYTCP_STATE_CONNECT; 
....................             state=MYTCP_STATE_DISCONNECT; 
0552A:  MOVLW  06
0552C:  MOVLB  8
0552E:  MOVWF  xE8
....................             //output_low(salida06); 
....................          } 
....................          break; 
05530:  BRA    5608
....................  
....................       case MYTCP_STATE_DISCONNECT: 
....................          //fprintf(DEBUG,"\nDESCONECTANDO.   "); 
....................          if(!espera)   { 
05532:  MOVLB  2
05534:  MOVF   x7D,F
05536:  BNZ   5556
....................             lcd_gotoxy(1,4); 
05538:  MOVLW  01
0553A:  MOVLB  9
0553C:  MOVWF  x00
0553E:  MOVLW  04
05540:  MOVWF  x01
05542:  MOVLB  0
05544:  CALL   0628
....................             lcd_putc("DESCONECTADO       ");} 
05548:  MOVLW  A0
0554A:  MOVWF  FF6
0554C:  MOVLW  01
0554E:  MOVWF  FF7
05550:  CALL   06DE
05554:  MOVLB  2
....................          output_low(salida06); 
05556:  BCF    F94.2
05558:  BCF    F8B.2
....................          inicializado=0; 
0555A:  CLRF   50
....................          if (TCPIsPutReady(socket)) { 
0555C:  MOVFF  8E7,909
05560:  MOVLB  0
05562:  CALL   4AA8
05566:  MOVF   01,F
05568:  BZ    5572
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
0556A:  MOVLW  07
0556C:  MOVLB  8
0556E:  MOVWF  xE8
....................          } 
05570:  BRA    55CA
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
05572:  MOVLB  8
05574:  MOVF   xF7,W
05576:  SUBWF  xE6,W
05578:  BNC   5582
0557A:  BNZ   5586
0557C:  MOVF   xE5,W
0557E:  SUBWF  xF6,W
05580:  BNC   5586
05582:  MOVLW  00
05584:  BRA    5588
05586:  MOVLW  01
05588:  CLRF   03
0558A:  IORWF  03,W
0558C:  BZ    55B4
0558E:  MOVLW  FF
05590:  BSF    FD8.0
05592:  SUBFWB xE5,W
05594:  MOVWF  xF9
05596:  MOVLW  FF
05598:  SUBFWB xE6,W
0559A:  MOVWF  xFA
0559C:  MOVF   xF6,W
0559E:  ADDWF  xF9,F
055A0:  MOVF   xF7,W
055A2:  ADDWFC xFA,F
055A4:  MOVLW  01
055A6:  ADDWF  xF9,W
055A8:  MOVWF  01
055AA:  MOVLW  00
055AC:  ADDWFC xFA,W
055AE:  MOVWF  03
055B0:  MOVF   01,W
055B2:  BRA    55C2
055B4:  MOVF   xE5,W
055B6:  SUBWF  xF6,W
055B8:  MOVWF  00
055BA:  MOVF   xE6,W
055BC:  SUBWFB xF7,W
055BE:  MOVWF  03
055C0:  MOVF   00,W
055C2:  SUBLW  78
055C4:  BC    55CA
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
055C6:  MOVLW  07
055C8:  MOVWF  xE8
....................          } 
....................          break; 
055CA:  BRA    5608
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
....................          TCPDisconnect(socket); 
055CC:  MOVFF  8E7,8FB
055D0:  RCALL  509A
....................          state=MYTCP_STATE_CONNECT; 
055D2:  MOVLW  03
055D4:  MOVLB  8
055D6:  MOVWF  xE8
....................          if(!espera)   { 
055D8:  MOVLB  2
055DA:  MOVF   x7D,F
055DC:  BNZ   55FC
....................             lcd_gotoxy(1,4); 
055DE:  MOVLW  01
055E0:  MOVLB  9
055E2:  MOVWF  x00
055E4:  MOVLW  04
055E6:  MOVWF  x01
055E8:  MOVLB  0
055EA:  CALL   0628
....................             lcd_putc("DESCONECTADO       ");} 
055EE:  MOVLW  B4
055F0:  MOVWF  FF6
055F2:  MOVLW  01
055F4:  MOVWF  FF7
055F6:  CALL   06DE
055FA:  MOVLB  2
....................          output_low(salida06); 
055FC:  BCF    F94.2
055FE:  BCF    F8B.2
....................          inicializado=0; 
05600:  CLRF   50
....................          break; 
05602:  MOVLB  8
05604:  BRA    5608
05606:  MOVLB  8
....................    } 
05608:  MOVLB  0
0560A:  RETURN 0
.................... } 
....................  
.................... ////wiegand/// 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... wiegand_cuenta++; 
*
001C8:  MOVLB  2
001CA:  INCF   x11,F
.................... time_relay1++; 
001CC:  INCF   1F,F
.................... time_boleto++; 
001CE:  INCF   x89,F
.................... cuenta++; 
001D0:  INCF   x7C,F
.................... cta_lcd++; 
001D2:  INCF   x8B,F
.................... set_timer1(3036); //50 ms 
001D4:  MOVLW  0B
001D6:  MOVWF  FCF
001D8:  MOVLW  DC
001DA:  MOVWF  FCE
.................... } 
....................  
001DC:  BCF    F9E.0
001DE:  MOVLB  0
001E0:  GOTO   0084
.................... #int_ext 
.................... void EXT_isr(void){//data1 
....................    while (!input(PIN_B0) ) {} 
001E4:  BSF    F93.0
001E6:  BTFSS  F81.0
001E8:  BRA    01E4
....................    wiegand_cuenta=0; 
001EA:  MOVLB  2
001EC:  CLRF   x11
....................    wieg=1; 
001EE:  MOVLW  01
001F0:  MOVWF  x0C
....................    data[sub_indice]=1; 
001F2:  CLRF   03
001F4:  MOVF   x0F,W
001F6:  ADDLW  16
001F8:  MOVWF  FE9
001FA:  MOVLW  02
001FC:  ADDWFC 03,W
001FE:  MOVWF  FEA
00200:  MOVLW  01
00202:  MOVWF  FEF
....................    sub_indice++; 
00204:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
00206:  MOVF   x0F,W
00208:  SUBLW  1A
0020A:  BNZ   0210
....................       wieg_full=1; 
0020C:  MOVLW  01
0020E:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
.................... } 
....................  
00210:  BCF    FF2.1
00212:  MOVLB  0
00214:  GOTO   0084
.................... #int_ext1 
.................... void EXT1_isr(void){//data0 
....................    while (!input(PIN_B1) ) {} 
00218:  BSF    F93.1
0021A:  BTFSS  F81.1
0021C:  BRA    0218
....................    wiegand_cuenta=0; 
0021E:  MOVLB  2
00220:  CLRF   x11
....................    wieg=1; 
00222:  MOVLW  01
00224:  MOVWF  x0C
....................    data[sub_indice]=0; 
00226:  CLRF   03
00228:  MOVF   x0F,W
0022A:  ADDLW  16
0022C:  MOVWF  FE9
0022E:  MOVLW  02
00230:  ADDWFC 03,W
00232:  MOVWF  FEA
00234:  CLRF   FEF
....................    sub_indice++; 
00236:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
00238:  MOVF   x0F,W
0023A:  SUBLW  1A
0023C:  BNZ   0242
....................       wieg_full=1; 
0023E:  MOVLW  01
00240:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
00242:  BCF    FF0.0
00244:  MOVLB  0
00246:  GOTO   0084
.................... } 
.................... /////////////////////// 
.................... //funciones extra 
.................... void wiegand_read_card(); 
.................... void enviar_tcp(); 
.................... /////////boleto//////////////////// 
.................... void encri(); 
.................... void barra1(); 
.................... void barra2(); 
.................... void CR(); 
.................... void LF(); 
.................... void ticket(); 
.................... void sensores(); 
.................... void llaves(); 
.................... void rd_eeprom(); 
.................... void zeller(); 
.................... void horario(); 
.................... void fecha(); 
....................  
.................... void main(void) { 
*
06CD8:  CLRF   FF8
06CDA:  BCF    FD0.7
06CDC:  BSF    07.7
06CDE:  CLRF   19
06CE0:  BCF    FB8.3
06CE2:  MOVLW  40
06CE4:  MOVWF  FAF
06CE6:  MOVLW  A6
06CE8:  MOVWF  FAC
06CEA:  MOVLW  90
06CEC:  MOVWF  FAB
06CEE:  MOVLB  2
06CF0:  CLRF   x0F
06CF2:  CLRF   x10
06CF4:  MOVLB  3
06CF6:  CLRF   x89
06CF8:  CLRF   x88
06CFA:  CLRF   x8A
06CFC:  CLRF   x8B
06CFE:  CLRF   x93
06D00:  CLRF   x92
06D02:  MOVLW  04
06D04:  MOVWF  x96
06D06:  CLRF   x95
06D08:  MOVLW  FE
06D0A:  MOVLB  8
06D0C:  MOVWF  xE7
06D0E:  CLRF   xE8
06D10:  CLRF   xF4
06D12:  CLRF   xF3
06D14:  MOVF   FC1,W
06D16:  ANDLW  C0
06D18:  IORLW  0F
06D1A:  MOVWF  FC1
06D1C:  MOVLW  07
06D1E:  MOVWF  FB4
06D20:  MOVLB  3
06D22:  BCF    x90.1
06D24:  BRA    6E1C
06D26:  DATA 0B,02
06D28:  DATA 8D,42
06D2A:  DATA 4F,4C
06D2C:  DATA 45,54
06D2E:  DATA 4F,5F
06D30:  DATA 46,4F
06D32:  DATA 4C,00
06D34:  DATA 0B,02
06D36:  DATA 99,42
06D38:  DATA 4F,52
06D3A:  DATA 52,41
06D3C:  DATA 52,54
06D3E:  DATA 4F,44
06D40:  DATA 4F,00
06D42:  DATA 0B,02
06D44:  DATA A5,42
06D46:  DATA 4F,52
06D48:  DATA 52,41
06D4A:  DATA 52,5F
06D4C:  DATA 54,41
06D4E:  DATA 47,00
06D50:  DATA 0B,02
06D52:  DATA B1,41
06D54:  DATA 42,52
06D56:  DATA 49,52
06D58:  DATA 5F,45
06D5A:  DATA 4E,54
06D5C:  DATA 52,00
06D5E:  DATA 0B,02
06D60:  DATA BD,43
06D62:  DATA 55,50
06D64:  DATA 4F,5F
06D66:  DATA 4C,4C
06D68:  DATA 45,4E
06D6A:  DATA 4F,00
06D6C:  DATA 0B,02
06D6E:  DATA C9,43
06D70:  DATA 55,50
06D72:  DATA 4F,5F
06D74:  DATA 44,49
06D76:  DATA 53,50
06D78:  DATA 4F,00
06D7A:  DATA 0B,02
06D7C:  DATA D5,4D
06D7E:  DATA 45,4E
06D80:  DATA 53,41
06D82:  DATA 4A,45
06D84:  DATA 45,4E
06D86:  DATA 31,00
06D88:  DATA 0A,42
06D8A:  DATA E1,20
06D8C:  DATA 01,80
06D8E:  DATA 00,0B
06D90:  DATA 02,ED
06D92:  DATA 43,4F
06D94:  DATA 4E,53
06D96:  DATA 55,4C
06D98:  DATA 54,41
06D9A:  DATA 30,31
06D9C:  DATA 00,0B
06D9E:  DATA 02,F9
06DA0:  DATA 43,4F
06DA2:  DATA 4E,46
06DA4:  DATA 49,47
06DA6:  DATA 44,41
06DA8:  DATA 54,45
06DAA:  DATA 00,0B
06DAC:  DATA 03,05
06DAE:  DATA 43,4F
06DB0:  DATA 4E,46
06DB2:  DATA 49,47
06DB4:  DATA 55,52
06DB6:  DATA 41,42
06DB8:  DATA 00,0B
06DBA:  DATA 03,11
06DBC:  DATA 42,4F
06DBE:  DATA 52,52
06DC0:  DATA 41,5F
06DC2:  DATA 43,4F
06DC4:  DATA 4E,31
06DC6:  DATA 00,0B
06DC8:  DATA 03,1D
06DCA:  DATA 46,4F
06DCC:  DATA 4C,49
06DCE:  DATA 4F,52
06DD0:  DATA 45,53
06DD2:  DATA 45,54
06DD4:  DATA 00,06
06DD6:  DATA 03,29
06DD8:  DATA 50,41
06DDA:  DATA 47,41
06DDC:  DATA 44,4F
06DDE:  DATA 04,C0
06DE0:  DATA 30,01
06DE2:  DATA 80,00
06DE4:  DATA 18,03
06DE6:  DATA 35,42
06DE8:  DATA 4F,4C
06DEA:  DATA 45,54
06DEC:  DATA 4F,00
06DEE:  DATA 42,41
06DF0:  DATA 52,52
06DF2:  DATA 45,52
06DF4:  DATA 41,41
06DF6:  DATA 42,49
06DF8:  DATA 45,52
06DFA:  DATA 54,41
06DFC:  DATA 45,31
06DFE:  DATA 00,02
06E00:  DATA 03,81
06E02:  DATA 00,00
06E04:  DATA 01,03
06E06:  DATA 94,00
06E08:  DATA 0A,48
06E0A:  DATA 85,00
06E0C:  DATA 46,48
06E0E:  DATA 9A,00
06E10:  DATA 03,08
06E12:  DATA E4,00
06E14:  DATA 00,00
06E16:  DATA 0A,48
06E18:  DATA E9,00
06E1A:  DATA 00,00
06E1C:  MOVLW  00
06E1E:  MOVWF  FF8
06E20:  MOVLW  6D
06E22:  MOVWF  FF7
06E24:  MOVLW  26
06E26:  MOVWF  FF6
06E28:  TBLRD*+
06E2A:  MOVF   FF5,W
06E2C:  MOVWF  00
06E2E:  XORLW  00
06E30:  BZ    6E58
06E32:  TBLRD*+
06E34:  MOVF   FF5,W
06E36:  MOVWF  01
06E38:  BTFSC  FE8.7
06E3A:  BRA    6E46
06E3C:  ANDLW  0F
06E3E:  MOVWF  FEA
06E40:  TBLRD*+
06E42:  MOVFF  FF5,FE9
06E46:  BTFSC  01.6
06E48:  TBLRD*+
06E4A:  BTFSS  01.6
06E4C:  TBLRD*+
06E4E:  MOVFF  FF5,FEE
06E52:  DCFSNZ 00,F
06E54:  BRA    6E28
06E56:  BRA    6E4A
06E58:  CLRF   FF8
....................    //fprintf(DEBUG,"\r\n\nCLIENTE TCP/IP\r\n"); 
....................    lcd_putc("\fINICIANDO"); 
06E5A:  MOVLW  4A
06E5C:  MOVWF  FF6
06E5E:  MOVLW  02
06E60:  MOVWF  FF7
06E62:  MOVLB  0
06E64:  CALL   06DE
....................    setup_adc_ports(NO_ANALOGS); 
06E68:  MOVF   FC1,W
06E6A:  ANDLW  C0
06E6C:  IORLW  0F
06E6E:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
06E70:  BCF    FC2.0
....................     
....................    init_ext_eeprom();//iniciar memoria 
06E72:  GOTO   06FE
....................    lcd_init();//iniciar LCD 
06E76:  GOTO   0706
....................    llaves(); 
06E7A:  GOTO   0782
....................     
....................    MACAddrInit(); 
06E7E:  GOTO   0A86
....................    IPAddrInit(); 
06E82:  GOTO   0AA0
....................    ServerAddrInit(); 
06E86:  GOTO   0AD0
....................    StackInit(); 
06E8A:  GOTO   12B6
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
06E8E:  MOVLW  B5
06E90:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);//Habilito interrupción particular del TIMER1 
06E92:  BSF    F9D.0
....................    set_timer1(3036);//Carga del TMR1 
06E94:  MOVLW  0B
06E96:  MOVWF  FCF
06E98:  MOVLW  DC
06E9A:  MOVWF  FCE
....................    ext_int_edge(0,L_TO_H);       //Asigno flancos de subida 
06E9C:  BSF    FF1.6
....................    ext_int_edge(1,L_TO_H);       //Asigno flancos de subida 
06E9E:  BSF    FF1.5
....................    enable_interrupts(INT_EXT1); 
06EA0:  BSF    FF0.3
....................    enable_interrupts(INT_EXT); 
06EA2:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);//Habilito interrupciones globales 
06EA4:  MOVLW  C0
06EA6:  IORWF  FF2,F
....................  
....................    envia_pc=0; 
06EA8:  CLRF   1A
....................    //int linked_out=0; 
....................    edo_str=envia_pc=0; 
06EAA:  CLRF   1A
06EAC:  MOVFF  1A,4E
....................    re_bol=0; 
06EB0:  MOVLB  2
06EB2:  CLRF   x8A
....................    //leyendo validacion de pago 
....................    int vigencia; 
....................    vigencia=read_ext_eeprom(10); 
06EB4:  MOVLB  9
06EB6:  CLRF   x07
06EB8:  MOVLW  0A
06EBA:  MOVWF  x06
06EBC:  MOVLB  0
06EBE:  CALL   13AA
06EC2:  MOVFF  01,8F5
....................    if(vigencia!=1) { 
06EC6:  MOVLB  8
06EC8:  DECFSZ xF5,W
06ECA:  BRA    6ECE
06ECC:  BRA    6F12
....................       write_ext_eeprom(10,1); 
06ECE:  MOVLB  9
06ED0:  CLRF   x07
06ED2:  MOVLW  0A
06ED4:  MOVWF  x06
06ED6:  MOVLW  01
06ED8:  MOVWF  x08
06EDA:  MOVLB  0
06EDC:  CALL   1452
....................       write_ext_eeprom(11,0); 
06EE0:  MOVLB  9
06EE2:  CLRF   x07
06EE4:  MOVLW  0B
06EE6:  MOVWF  x06
06EE8:  CLRF   x08
06EEA:  MOVLB  0
06EEC:  CALL   1452
....................       write_ext_eeprom(12,0); 
06EF0:  MOVLB  9
06EF2:  CLRF   x07
06EF4:  MOVLW  0C
06EF6:  MOVWF  x06
06EF8:  CLRF   x08
06EFA:  MOVLB  0
06EFC:  CALL   1452
....................       write_ext_eeprom(13,0); 
06F00:  MOVLB  9
06F02:  CLRF   x07
06F04:  MOVLW  0D
06F06:  MOVWF  x06
06F08:  CLRF   x08
06F0A:  MOVLB  0
06F0C:  CALL   1452
06F10:  MOVLB  8
....................    } 
....................    pago=read_ext_eeprom(11);// 
06F12:  MOVLB  9
06F14:  CLRF   x07
06F16:  MOVLW  0B
06F18:  MOVWF  x06
06F1A:  MOVLB  0
06F1C:  CALL   13AA
06F20:  MOVFF  01,27B
....................    dias_prueba=read_ext_eeprom(12);//dias de prueba 
06F24:  MOVLB  9
06F26:  CLRF   x07
06F28:  MOVLW  0C
06F2A:  MOVWF  x06
06F2C:  MOVLB  0
06F2E:  CALL   13AA
06F32:  MOVFF  01,279
....................    dia_temp=read_ext_eeprom(13);// 
06F36:  MOVLB  9
06F38:  CLRF   x07
06F3A:  MOVLW  0D
06F3C:  MOVWF  x06
06F3E:  MOVLB  0
06F40:  CALL   13AA
06F44:  MOVFF  01,27A
....................    lcd_gotoxy(1,1); 
06F48:  MOVLW  01
06F4A:  MOVLB  9
06F4C:  MOVWF  x00
06F4E:  MOVWF  x01
06F50:  MOVLB  0
06F52:  CALL   0628
....................    printf(lcd_putc,"Dias:%u PAGO:%d",dias_prueba,pago); 
06F56:  MOVLW  56
06F58:  MOVWF  FF6
06F5A:  MOVLW  02
06F5C:  MOVWF  FF7
06F5E:  MOVLW  05
06F60:  MOVLB  8
06F62:  MOVWF  xF7
06F64:  MOVLB  0
06F66:  CALL   1558
06F6A:  MOVFF  279,8F7
06F6E:  MOVLW  1B
06F70:  MOVLB  8
06F72:  MOVWF  xF8
06F74:  MOVLB  0
06F76:  CALL   15AE
06F7A:  MOVLW  5D
06F7C:  MOVWF  FF6
06F7E:  MOVLW  02
06F80:  MOVWF  FF7
06F82:  MOVLW  06
06F84:  MOVLB  8
06F86:  MOVWF  xF7
06F88:  MOVLB  0
06F8A:  CALL   1558
06F8E:  MOVFF  27B,8F6
06F92:  MOVLW  18
06F94:  MOVLB  8
06F96:  MOVWF  xF7
06F98:  MOVLB  0
06F9A:  GOTO   1630
....................    lcd_gotoxy(1,2); 
06F9E:  MOVLW  01
06FA0:  MOVLB  9
06FA2:  MOVWF  x00
06FA4:  MOVLW  02
06FA6:  MOVWF  x01
06FA8:  MOVLB  0
06FAA:  CALL   0628
....................    printf(lcd_putc,"Restan:%u ",(dia_limite-dias_prueba) ); 
06FAE:  MOVLW  5A
06FB0:  BSF    FD8.0
06FB2:  MOVLB  2
06FB4:  SUBFWB x79,W
06FB6:  MOVLB  8
06FB8:  MOVWF  xF6
06FBA:  MOVLW  66
06FBC:  MOVWF  FF6
06FBE:  MOVLW  02
06FC0:  MOVWF  FF7
06FC2:  MOVLW  07
06FC4:  MOVWF  xF7
06FC6:  MOVLB  0
06FC8:  CALL   1558
06FCC:  MOVFF  8F6,8F7
06FD0:  MOVLW  1B
06FD2:  MOVLB  8
06FD4:  MOVWF  xF8
06FD6:  MOVLB  0
06FD8:  CALL   15AE
06FDC:  MOVLW  20
06FDE:  MOVLB  8
06FE0:  MOVWF  xFF
06FE2:  MOVLB  0
06FE4:  CALL   067A
....................    delay_ms(1000); 
06FE8:  MOVLW  04
06FEA:  MOVLB  8
06FEC:  MOVWF  xF6
06FEE:  MOVLW  FA
06FF0:  MOVLB  9
06FF2:  MOVWF  x00
06FF4:  MOVLB  0
06FF6:  CALL   0600
06FFA:  MOVLB  8
06FFC:  DECFSZ xF6,F
06FFE:  BRA    6FEE
....................    ////////////////// 
....................    hrs2=espera=fmensaje=0; 
07000:  MOVLB  3
07002:  CLRF   x4D
07004:  MOVFF  34D,27D
07008:  MOVFF  27D,27E
....................    while(TRUE) { 
....................       StackTask(); 
0700C:  MOVLB  0
0700E:  CALL   4492
....................       MyTCPTask(); 
07012:  CALL   52CA
....................       if( (dias_prueba>dia_limite)&&(pago!=1) ){//pruebas 
07016:  MOVLB  2
07018:  MOVF   x79,W
0701A:  SUBLW  5A
0701C:  BC    70EA
0701E:  DECFSZ x7B,W
07020:  BRA    7024
07022:  BRA    70EA
....................          lcd_gotoxy(1,1); 
07024:  MOVLW  01
07026:  MOVLB  9
07028:  MOVWF  x00
0702A:  MOVWF  x01
0702C:  MOVLB  0
0702E:  CALL   0628
....................          lcd_putc("TIEMPO DE PRUEBA"); 
07032:  MOVLW  72
07034:  MOVWF  FF6
07036:  MOVLW  02
07038:  MOVWF  FF7
0703A:  CALL   06DE
....................          lcd_gotoxy(1,2); 
0703E:  MOVLW  01
07040:  MOVLB  9
07042:  MOVWF  x00
07044:  MOVLW  02
07046:  MOVWF  x01
07048:  MOVLB  0
0704A:  CALL   0628
....................          lcd_putc("  HA EXPIRADO   "); 
0704E:  MOVLW  84
07050:  MOVWF  FF6
07052:  MOVLW  02
07054:  MOVWF  FF7
07056:  CALL   06DE
....................          if(edo_str){ 
0705A:  MOVF   4E,F
0705C:  BZ    70E4
....................             edo_str=0; 
0705E:  CLRF   4E
....................             strcpy(XX,rxtcp); 
07060:  CLRF   FEA
07062:  MOVLW  52
07064:  MOVWF  FE9
07066:  MOVLW  01
07068:  MOVWF  FE2
0706A:  MOVLW  60
0706C:  MOVWF  FE1
0706E:  MOVF   FE7,F
07070:  MOVFF  FE6,FEE
07074:  BNZ   706E
....................             if( (XX[0]=='P')&&(XX[1]=='A')&&(XX[2]=='G')&&(XX[3]=='A')&&(XX[4]=='D')&&(XX[5]=='O') ){ 
07076:  MOVF   52,W
07078:  SUBLW  50
0707A:  BNZ   70E4
0707C:  MOVF   53,W
0707E:  SUBLW  41
07080:  BNZ   70E4
07082:  MOVF   54,W
07084:  SUBLW  47
07086:  BNZ   70E4
07088:  MOVF   55,W
0708A:  SUBLW  41
0708C:  BNZ   70E4
0708E:  MOVF   56,W
07090:  SUBLW  44
07092:  BNZ   70E4
07094:  MOVF   57,W
07096:  SUBLW  4F
07098:  BNZ   70E4
....................                pago=1; 
0709A:  MOVLW  01
0709C:  MOVLB  2
0709E:  MOVWF  x7B
....................                write_ext_eeprom(11,pago);// 
070A0:  MOVLB  9
070A2:  CLRF   x07
070A4:  MOVLW  0B
070A6:  MOVWF  x06
070A8:  MOVFF  27B,908
070AC:  MOVLB  0
070AE:  CALL   1452
....................                strcpy (txtcp, "BOLETERA_PAGADO"); 
070B2:  MOVLW  01
070B4:  MOVWF  FEA
070B6:  MOVLW  06
070B8:  MOVWF  FE9
070BA:  MOVLW  00
070BC:  CALL   00E6
070C0:  TBLRD*-
070C2:  TBLRD*+
070C4:  MOVF   FF5,W
070C6:  MOVWF  FEE
070C8:  IORLW  00
070CA:  BNZ   70C2
....................                size_tx_tcp=strlen(txtcp); 
070CC:  MOVLW  01
070CE:  MOVLB  9
070D0:  MOVWF  x0C
070D2:  MOVLW  06
070D4:  MOVWF  x0B
070D6:  MOVLB  0
070D8:  CALL   5636
070DC:  MOVFF  01,48
....................                enviar_tcp(); 
070E0:  CALL   5672
....................             } 
....................          } 
....................       } 
070E4:  GOTO   7872
070E8:  MOVLB  2
....................       else{ 
....................          wiegand_read_card(); 
070EA:  MOVLB  0
070EC:  GOTO   5728
....................          sensores(); 
070F0:  GOTO   6148
....................          if(edo_str){//bandera de dato recibido en socket actual 
070F4:  MOVF   4E,F
070F6:  BTFSC  FD8.2
070F8:  BRA    740E
....................             edo_str=0; 
070FA:  CLRF   4E
....................             //fprintf(DEBUG,"\r\nrxtcp:%s",rxtcp); 
....................             //printf(lcd_putc,"\frxtcp:%s",rxtcp); 
....................             strcpy(XX,rxtcp); 
070FC:  CLRF   FEA
070FE:  MOVLW  52
07100:  MOVWF  FE9
07102:  MOVLW  01
07104:  MOVWF  FE2
07106:  MOVLW  60
07108:  MOVWF  FE1
0710A:  MOVF   FE7,F
0710C:  MOVFF  FE6,FEE
07110:  BNZ   710A
....................             //fprintf(U1PRINTER,"\frxtcp:%s",XX); 
....................             rd_eeprom(); 
07112:  GOTO   61B8
....................             lcd_gotoxy(1,3); 
07116:  MOVLW  01
07118:  MOVLB  9
0711A:  MOVWF  x00
0711C:  MOVLW  03
0711E:  MOVWF  x01
07120:  MOVLB  0
07122:  CALL   0628
....................             printf(lcd_putc,"rxtcp:%s",rxtcp); 
07126:  MOVLW  96
07128:  MOVWF  FF6
0712A:  MOVLW  02
0712C:  MOVWF  FF7
0712E:  MOVLW  06
07130:  MOVLB  8
07132:  MOVWF  xF7
07134:  MOVLB  0
07136:  CALL   1558
0713A:  MOVLW  01
0713C:  MOVWF  FEA
0713E:  MOVLW  60
07140:  MOVWF  FE9
07142:  GOTO   6278
....................             lcd_gotoxy(1,4); 
07146:  MOVLW  01
07148:  MOVLB  9
0714A:  MOVWF  x00
0714C:  MOVLW  04
0714E:  MOVWF  x01
07150:  MOVLB  0
07152:  CALL   0628
....................             printf(lcd_putc,"b:%Ld                ",b); 
07156:  MOVLW  62
07158:  MOVLB  8
0715A:  MOVWF  xFF
0715C:  MOVLB  0
0715E:  CALL   067A
07162:  MOVLW  3A
07164:  MOVLB  8
07166:  MOVWF  xFF
07168:  MOVLB  0
0716A:  CALL   067A
0716E:  MOVLW  10
07170:  MOVWF  FE9
07172:  MOVFF  45,8F7
07176:  MOVFF  44,8F6
0717A:  GOTO   62A0
0717E:  MOVLW  A5
07180:  MOVWF  FF6
07182:  MOVLW  02
07184:  MOVWF  FF7
07186:  MOVLW  10
07188:  MOVLB  8
0718A:  MOVWF  xF7
0718C:  MOVLB  0
0718E:  CALL   1558
....................             switch (b) { 
07192:  MOVFF  44,00
07196:  MOVF   45,W
07198:  MOVWF  03
0719A:  BNZ   71A2
0719C:  MOVLW  01
0719E:  SUBWF  00,W
071A0:  BZ    722A
071A2:  MOVF   03,W
071A4:  BNZ   71AE
071A6:  MOVLW  02
071A8:  SUBWF  00,W
071AA:  BTFSC  FD8.2
071AC:  BRA    725C
071AE:  MOVF   03,W
071B0:  BNZ   71B8
071B2:  MOVLW  03
071B4:  SUBWF  00,W
071B6:  BZ    725E
071B8:  MOVF   03,W
071BA:  BNZ   71C2
071BC:  MOVLW  04
071BE:  SUBWF  00,W
071C0:  BZ    7260
071C2:  MOVF   03,W
071C4:  BNZ   71CC
071C6:  MOVLW  05
071C8:  SUBWF  00,W
071CA:  BZ    727A
071CC:  MOVF   03,W
071CE:  BNZ   71D6
071D0:  MOVLW  06
071D2:  SUBWF  00,W
071D4:  BZ    727C
071D6:  MOVF   03,W
071D8:  BNZ   71E0
071DA:  MOVLW  07
071DC:  SUBWF  00,W
071DE:  BZ    727E
071E0:  MOVF   03,W
071E2:  BNZ   71EC
071E4:  MOVLW  08
071E6:  SUBWF  00,W
071E8:  BTFSC  FD8.2
071EA:  BRA    73B6
071EC:  MOVF   03,W
071EE:  BNZ   71F8
071F0:  MOVLW  09
071F2:  SUBWF  00,W
071F4:  BTFSC  FD8.2
071F6:  BRA    73B8
071F8:  MOVF   03,W
071FA:  BNZ   7204
071FC:  MOVLW  0A
071FE:  SUBWF  00,W
07200:  BTFSC  FD8.2
07202:  BRA    73BA
07204:  MOVF   03,W
07206:  BNZ   7210
07208:  MOVLW  0B
0720A:  SUBWF  00,W
0720C:  BTFSC  FD8.2
0720E:  BRA    73C0
07210:  MOVF   03,W
07212:  BNZ   721C
07214:  MOVLW  0D
07216:  SUBWF  00,W
07218:  BTFSC  FD8.2
0721A:  BRA    73C2
0721C:  MOVF   03,W
0721E:  BNZ   7228
07220:  MOVLW  0E
07222:  SUBWF  00,W
07224:  BTFSC  FD8.2
07226:  BRA    73C4
07228:  BRA    740E
....................               case 1: {//IMPRIMIR BOLETO 
....................                   espera=1; 
0722A:  MOVLW  01
0722C:  MOVLB  2
0722E:  MOVWF  x7D
....................                   printf(lcd_putc,"\f TOME SU BOLETO \nY AVANCE POR FAVOR"); 
07230:  MOVLW  B6
07232:  MOVWF  FF6
07234:  MOVLW  02
07236:  MOVWF  FF7
07238:  MOVLB  0
0723A:  CALL   06DE
....................                   ticket(); 
0723E:  CALL   5C40
....................                   output_high(salida01);//abre entrada 
07242:  BCF    F92.5
07244:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07246:  BCF    F96.0
07248:  BSF    F8D.0
....................                   relay1=1; 
0724A:  MOVLW  01
0724C:  MOVWF  1D
....................                   time_relay1=0; 
0724E:  CLRF   1F
....................                   flag_pluma=1; 
07250:  MOVLB  2
07252:  MOVWF  x88
....................                   //sprintf(txtcp,barra_codi);//CONFIRMACION DE BOLETO IMPRESO 
....................                   //size_tx_tcp=strlen(txtcp); 
....................                   //enviar_tcp(); 
....................                   cta_lcd=0; 
07254:  CLRF   x8B
....................                   re_bol=1; 
07256:  MOVWF  x8A
....................                   break;} 
07258:  MOVLB  0
0725A:  BRA    740E
....................               case 2: {//VIGENCIA POR VENCER O VENCIDA 
....................                   break;} 
0725C:  BRA    740E
....................               case 3: {//no activa en entrada 
....................                   break;} 
0725E:  BRA    740E
....................               case 4: {//ABRIR ENTRADA 
....................                   //lcd_putc("\f\n     BIENVENIDO"); 
....................                   output_high(salida01);//abre entrada 
07260:  BCF    F92.5
07262:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07264:  BCF    F96.0
07266:  BSF    F8D.0
....................                   flag_pluma=1; 
07268:  MOVLW  01
0726A:  MOVLB  2
0726C:  MOVWF  x88
....................                   relay1=1; 
0726E:  MOVWF  1D
....................                   time_relay1=0; 
07270:  CLRF   1F
....................                   b=0; 
07272:  CLRF   45
07274:  CLRF   44
....................                   break;} 
07276:  MOVLB  0
07278:  BRA    740E
....................               case 5: {//CUPO LLENO 
....................                   break;} 
0727A:  BRA    740E
....................               case 6: {//ACTIVA BOLETOS 
....................                   break;} 
0727C:  BRA    740E
....................               case 7: {//MENSAJES DE LCD 
....................                      memset(lcd_men, 0, sizeof(lcd_men) ); 
0727E:  MOVLW  01
07280:  MOVWF  FEA
07282:  MOVLW  BA
07284:  MOVWF  FE9
07286:  CLRF   00
07288:  CLRF   02
0728A:  MOVLW  50
0728C:  MOVWF  01
0728E:  CALL   570E
....................                      for(i=0;i<strlen(XX);i++) lcd_men[i]=XX[instruccion_size+i]; 
07292:  CLRF   41
07294:  CLRF   40
07296:  MOVLB  9
07298:  CLRF   x0C
0729A:  MOVLW  52
0729C:  MOVWF  x0B
0729E:  MOVLB  0
072A0:  CALL   5636
072A4:  MOVFF  02,03
072A8:  MOVF   41,W
072AA:  SUBWF  02,W
072AC:  BNC   72F0
072AE:  BNZ   72B6
072B0:  MOVF   01,W
072B2:  SUBWF  40,W
072B4:  BC    72F0
072B6:  MOVLW  BA
072B8:  ADDWF  40,W
072BA:  MOVWF  01
072BC:  MOVLW  01
072BE:  ADDWFC 41,W
072C0:  MOVWF  03
072C2:  MOVFF  01,8F6
072C6:  MOVLB  8
072C8:  MOVWF  xF7
072CA:  MOVLW  5C
072CC:  ADDWF  40,W
072CE:  MOVWF  FE9
072D0:  MOVLW  00
072D2:  ADDWFC 41,W
072D4:  MOVWF  FEA
072D6:  MOVFF  FEF,8FA
072DA:  MOVFF  03,FEA
072DE:  MOVFF  01,FE9
072E2:  MOVFF  8FA,FEF
072E6:  INCF   40,F
072E8:  BTFSC  FD8.2
072EA:  INCF   41,F
072EC:  MOVLB  0
072EE:  BRA    7296
....................                      lcd_putc("\f"); 
072F0:  MOVLW  DC
072F2:  MOVWF  FF6
072F4:  MOVLW  02
072F6:  MOVWF  FF7
072F8:  CALL   06DE
....................                      for(i=0;i<strlen(lcd_men);i++){ 
072FC:  CLRF   41
072FE:  CLRF   40
07300:  MOVLW  01
07302:  MOVLB  9
07304:  MOVWF  x0C
07306:  MOVLW  BA
07308:  MOVWF  x0B
0730A:  MOVLB  0
0730C:  CALL   5636
07310:  MOVFF  02,03
07314:  MOVF   41,W
07316:  SUBWF  02,W
07318:  BNC   73AA
0731A:  BNZ   7322
0731C:  MOVF   01,W
0731E:  SUBWF  40,W
07320:  BC    73AA
....................                         if(i==0)lcd_gotoxy(1,1); 
07322:  MOVF   40,F
07324:  BTFSS  FD8.2
07326:  BRA    733C
07328:  MOVF   41,F
0732A:  BNZ   733C
0732C:  MOVLW  01
0732E:  MOVLB  9
07330:  MOVWF  x00
07332:  MOVWF  x01
07334:  MOVLB  0
07336:  CALL   0628
0733A:  BRA    738E
....................                         else if(i==20) lcd_gotoxy(1,2); 
0733C:  MOVF   40,W
0733E:  SUBLW  14
07340:  BNZ   7358
07342:  MOVF   41,F
07344:  BNZ   7358
07346:  MOVLW  01
07348:  MOVLB  9
0734A:  MOVWF  x00
0734C:  MOVLW  02
0734E:  MOVWF  x01
07350:  MOVLB  0
07352:  CALL   0628
07356:  BRA    738E
....................                         else if(i==40) lcd_gotoxy(1,3); 
07358:  MOVF   40,W
0735A:  SUBLW  28
0735C:  BNZ   7374
0735E:  MOVF   41,F
07360:  BNZ   7374
07362:  MOVLW  01
07364:  MOVLB  9
07366:  MOVWF  x00
07368:  MOVLW  03
0736A:  MOVWF  x01
0736C:  MOVLB  0
0736E:  CALL   0628
07372:  BRA    738E
....................                         else if(i==60) lcd_gotoxy(1,4); 
07374:  MOVF   40,W
07376:  SUBLW  3C
07378:  BNZ   738E
0737A:  MOVF   41,F
0737C:  BNZ   738E
0737E:  MOVLW  01
07380:  MOVLB  9
07382:  MOVWF  x00
07384:  MOVLW  04
07386:  MOVWF  x01
07388:  MOVLB  0
0738A:  CALL   0628
....................                         printf(lcd_putc,"%c",lcd_men[i]); 
0738E:  MOVLW  BA
07390:  ADDWF  40,W
07392:  MOVWF  FE9
07394:  MOVLW  01
07396:  ADDWFC 41,W
07398:  MOVWF  FEA
0739A:  MOVFF  FEF,8FF
0739E:  CALL   067A
073A2:  INCF   40,F
073A4:  BTFSC  FD8.2
073A6:  INCF   41,F
073A8:  BRA    7300
....................                      } 
....................                      espera=1; 
073AA:  MOVLW  01
073AC:  MOVLB  2
073AE:  MOVWF  x7D
....................                      cta_lcd=0; 
073B0:  CLRF   x8B
....................                      break;}// 
073B2:  MOVLB  0
073B4:  BRA    740E
....................               case 8: {//MOITOREO DESACTIVADO 
....................                      break;}// 
073B6:  BRA    740E
....................               case 9: {//CONSULTA ENTRADAS SIN CONEXION 
....................                   break;} 
073B8:  BRA    740E
....................               case 10:{//CONFIGURA FECHA Y HORA 
....................                   fecha(); 
073BA:  GOTO   662A
....................                   break;} 
073BE:  BRA    740E
....................               case 11:{//ultima conexion 
....................                   break;} 
073C0:  BRA    740E
....................               case 13:{//RESET DE FOLIOS 
....................                   break;} 
073C2:  BRA    740E
....................               case 14:{//PAGO EFECTUADO 
....................                   pago=1; 
073C4:  MOVLW  01
073C6:  MOVLB  2
073C8:  MOVWF  x7B
....................                   write_ext_eeprom(11,pago);// 
073CA:  MOVLB  9
073CC:  CLRF   x07
073CE:  MOVLW  0B
073D0:  MOVWF  x06
073D2:  MOVFF  27B,908
073D6:  MOVLB  0
073D8:  CALL   1452
....................                   strcpy (txtcp, "BOLETERA_PAGADO"); 
073DC:  MOVLW  01
073DE:  MOVWF  FEA
073E0:  MOVLW  06
073E2:  MOVWF  FE9
073E4:  MOVLW  00
073E6:  CALL   00E6
073EA:  TBLRD*-
073EC:  TBLRD*+
073EE:  MOVF   FF5,W
073F0:  MOVWF  FEE
073F2:  IORLW  00
073F4:  BNZ   73EC
....................                   size_tx_tcp=strlen(txtcp); 
073F6:  MOVLW  01
073F8:  MOVLB  9
073FA:  MOVWF  x0C
073FC:  MOVLW  06
073FE:  MOVWF  x0B
07400:  MOVLB  0
07402:  CALL   5636
07406:  MOVFF  01,48
....................                   enviar_tcp(); 
0740A:  CALL   5672
....................                   break;} 
....................             }//end switch 
....................          }//end dato recibido tcp 
....................          ////////////////////////////////////// 
....................          if( (relay1)&&(time_relay1>=7) ){ 
0740E:  MOVF   1D,F
07410:  BZ    7422
07412:  MOVF   1F,W
07414:  SUBLW  06
07416:  BC    7422
....................             relay1=0; 
07418:  CLRF   1D
....................             output_low(salida01); 
0741A:  BCF    F92.5
0741C:  BCF    F89.5
....................             output_low(salida02); 
0741E:  BCF    F96.0
07420:  BCF    F8D.0
....................          } 
....................          //if( (time_boleto>60)&&(re_bol) )  re_bol=0; 
....................           
....................          if( (espera)&&(cta_lcd>=100) ) espera=0; 
07422:  MOVLB  2
07424:  MOVF   x7D,F
07426:  BZ    7430
07428:  MOVF   x8B,W
0742A:  SUBLW  63
0742C:  BC    7430
0742E:  CLRF   x7D
....................           
....................          if( (cuenta>=20)&&(espera==0) ){//CADA 2 SEGUNDOS VERIFICA FECHA Y HORA 
07430:  MOVF   x7C,W
07432:  SUBLW  13
07434:  BTFSC  FD8.0
07436:  BRA    7870
07438:  MOVF   x7D,F
0743A:  BTFSS  FD8.2
0743C:  BRA    7870
....................              ds1307_get_time(hrs,min,sec); 
....................              ds1307_get_date(day,month,yr,dow); 
....................              if(hrs2!=hrs){ 
*
07618:  MOVLB  2
0761A:  MOVF   x73,W
0761C:  SUBWF  x7E,W
0761E:  BZ    7670
....................                dia=31;//ultimo dia del mes 
07620:  CLRF   x82
07622:  MOVLW  1F
07624:  MOVWF  x81
....................                mes2=10;//octubre, mes en el que cambia horario invierno 
07626:  CLRF   x80
07628:  MOVLW  0A
0762A:  MOVWF  x7F
....................                zeller(); 
0762C:  MOVLB  0
0762E:  GOTO   68E4
....................                hrs2=hrs; 
07632:  MOVFF  273,27E
....................                if( (dia_temp!=day)&&(pago!=1) ){ 
07636:  MOVLB  2
07638:  MOVF   x70,W
0763A:  SUBWF  x7A,W
0763C:  BZ    7670
0763E:  DECFSZ x7B,W
07640:  BRA    7644
07642:  BRA    7670
....................                   dia_temp=day; 
07644:  MOVFF  270,27A
....................                   dias_prueba++; 
07648:  INCF   x79,F
....................                   write_ext_eeprom(12,dias_prueba);//dias de prueba 
0764A:  MOVLB  9
0764C:  CLRF   x07
0764E:  MOVLW  0C
07650:  MOVWF  x06
07652:  MOVFF  279,908
07656:  MOVLB  0
07658:  CALL   1452
....................                   write_ext_eeprom(13,dia_temp);// 
0765C:  MOVLB  9
0765E:  CLRF   x07
07660:  MOVLW  0D
07662:  MOVWF  x06
07664:  MOVFF  27A,908
07668:  MOVLB  0
0766A:  CALL   1452
0766E:  MOVLB  2
....................                } 
....................              }//FIN CONFIGURA AUTMATICO FECHA Y HORA 
....................              //cuenta_lcd=0; 
....................              puntos=!puntos; 
07670:  MOVF   x77,F
07672:  BZ    7678
07674:  MOVLW  00
07676:  BRA    767A
07678:  MOVLW  01
0767A:  MOVWF  x77
....................              if( (!espera)&&(!en1) ){ 
0767C:  MOVF   x7D,F
0767E:  BTFSS  FD8.2
07680:  BRA    786E
07682:  MOVF   x83,F
07684:  BTFSS  FD8.2
07686:  BRA    786E
....................                lcd_gotoxy(1,1);//printf(lcd_putc,"  %02d %02d %02d %02d/%02d/%02d   ",hrs_e,min_e,sec_e,day_e,month,yr); 
07688:  MOVLW  01
0768A:  MOVLB  9
0768C:  MOVWF  x00
0768E:  MOVWF  x01
07690:  MOVLB  0
07692:  CALL   0628
....................                if(puntos==0)   printf(lcd_putc,"   %02d %02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
07696:  MOVLB  2
07698:  MOVF   x77,F
0769A:  BNZ   7748
0769C:  MOVLW  DE
0769E:  MOVWF  FF6
076A0:  MOVLW  02
076A2:  MOVWF  FF7
076A4:  MOVLW  03
076A6:  MOVLB  8
076A8:  MOVWF  xF7
076AA:  MOVLB  0
076AC:  CALL   1558
076B0:  MOVFF  273,8F6
076B4:  MOVLW  01
076B6:  MOVLB  8
076B8:  MOVWF  xF7
076BA:  MOVLB  0
076BC:  CALL   655E
076C0:  MOVLW  20
076C2:  MOVLB  8
076C4:  MOVWF  xFF
076C6:  MOVLB  0
076C8:  CALL   067A
076CC:  MOVFF  274,8F6
076D0:  MOVLW  01
076D2:  MOVLB  8
076D4:  MOVWF  xF7
076D6:  MOVLB  0
076D8:  CALL   655E
076DC:  MOVLW  20
076DE:  MOVLB  8
076E0:  MOVWF  xFF
076E2:  MOVLB  0
076E4:  CALL   067A
076E8:  MOVFF  270,8F6
076EC:  MOVLW  01
076EE:  MOVLB  8
076F0:  MOVWF  xF7
076F2:  MOVLB  0
076F4:  CALL   655E
076F8:  MOVLW  2F
076FA:  MOVLB  8
076FC:  MOVWF  xFF
076FE:  MOVLB  0
07700:  CALL   067A
07704:  MOVFF  271,8F6
07708:  MOVLW  01
0770A:  MOVLB  8
0770C:  MOVWF  xF7
0770E:  MOVLB  0
07710:  CALL   655E
07714:  MOVLW  2F
07716:  MOVLB  8
07718:  MOVWF  xFF
0771A:  MOVLB  0
0771C:  CALL   067A
07720:  MOVFF  272,8F6
07724:  MOVLW  01
07726:  MOVLB  8
07728:  MOVWF  xF7
0772A:  MOVLB  0
0772C:  CALL   655E
07730:  MOVLW  F9
07732:  MOVWF  FF6
07734:  MOVLW  02
07736:  MOVWF  FF7
07738:  MOVLW  04
0773A:  MOVLB  8
0773C:  MOVWF  xF7
0773E:  MOVLB  0
07740:  CALL   1558
07744:  BRA    77F0
07746:  MOVLB  2
....................                else   printf(lcd_putc,"   %02d:%02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
07748:  MOVLW  FE
0774A:  MOVWF  FF6
0774C:  MOVLW  02
0774E:  MOVWF  FF7
07750:  MOVLW  03
07752:  MOVLB  8
07754:  MOVWF  xF7
07756:  MOVLB  0
07758:  CALL   1558
0775C:  MOVFF  273,8F6
07760:  MOVLW  01
07762:  MOVLB  8
07764:  MOVWF  xF7
07766:  MOVLB  0
07768:  CALL   655E
0776C:  MOVLW  3A
0776E:  MOVLB  8
07770:  MOVWF  xFF
07772:  MOVLB  0
07774:  CALL   067A
07778:  MOVFF  274,8F6
0777C:  MOVLW  01
0777E:  MOVLB  8
07780:  MOVWF  xF7
07782:  MOVLB  0
07784:  CALL   655E
07788:  MOVLW  20
0778A:  MOVLB  8
0778C:  MOVWF  xFF
0778E:  MOVLB  0
07790:  CALL   067A
07794:  MOVFF  270,8F6
07798:  MOVLW  01
0779A:  MOVLB  8
0779C:  MOVWF  xF7
0779E:  MOVLB  0
077A0:  CALL   655E
077A4:  MOVLW  2F
077A6:  MOVLB  8
077A8:  MOVWF  xFF
077AA:  MOVLB  0
077AC:  CALL   067A
077B0:  MOVFF  271,8F6
077B4:  MOVLW  01
077B6:  MOVLB  8
077B8:  MOVWF  xF7
077BA:  MOVLB  0
077BC:  CALL   655E
077C0:  MOVLW  2F
077C2:  MOVLB  8
077C4:  MOVWF  xFF
077C6:  MOVLB  0
077C8:  CALL   067A
077CC:  MOVFF  272,8F6
077D0:  MOVLW  01
077D2:  MOVLB  8
077D4:  MOVWF  xF7
077D6:  MOVLB  0
077D8:  CALL   655E
077DC:  MOVLW  19
077DE:  MOVWF  FF6
077E0:  MOVLW  03
077E2:  MOVWF  FF7
077E4:  MOVLW  04
077E6:  MOVLB  8
077E8:  MOVWF  xF7
077EA:  MOVLB  0
077EC:  CALL   1558
....................                cambio_msj++; 
077F0:  MOVLB  2
077F2:  INCF   x78,F
....................                lcd_gotoxy(1,2); 
077F4:  MOVLW  01
077F6:  MOVLB  9
077F8:  MOVWF  x00
077FA:  MOVLW  02
077FC:  MOVWF  x01
077FE:  MOVLB  0
07800:  CALL   0628
....................                if(cambio_msj>=10) lcd_putc("   WWW.ACCESA.ME    ");//COMPLEJO CITY ANGELÓPOLIS   
07804:  MOVLB  2
07806:  MOVF   x78,W
07808:  SUBLW  09
0780A:  BC    781E
0780C:  MOVLW  1E
0780E:  MOVWF  FF6
07810:  MOVLW  03
07812:  MOVWF  FF7
07814:  MOVLB  0
07816:  CALL   06DE
0781A:  BRA    782C
0781C:  MOVLB  2
....................                else lcd_putc("       ACCESA       "); 
0781E:  MOVLW  34
07820:  MOVWF  FF6
07822:  MOVLW  03
07824:  MOVWF  FF7
07826:  MOVLB  0
07828:  CALL   06DE
....................                lcd_gotoxy(1,3); 
0782C:  MOVLW  01
0782E:  MOVLB  9
07830:  MOVWF  x00
07832:  MOVLW  03
07834:  MOVWF  x01
07836:  MOVLB  0
07838:  CALL   0628
....................                lcd_putc("                    "); 
0783C:  MOVLW  4A
0783E:  MOVWF  FF6
07840:  MOVLW  03
07842:  MOVWF  FF7
07844:  CALL   06DE
....................                lcd_gotoxy(1,4); 
07848:  MOVLW  01
0784A:  MOVLB  9
0784C:  MOVWF  x00
0784E:  MOVLW  04
07850:  MOVWF  x01
07852:  MOVLB  0
07854:  CALL   0628
....................                lcd_putc("                    "); 
07858:  MOVLW  60
0785A:  MOVWF  FF6
0785C:  MOVLW  03
0785E:  MOVWF  FF7
07860:  CALL   06DE
....................                if(cambio_msj>=20) cambio_msj=0; 
07864:  MOVLB  2
07866:  MOVF   x78,W
07868:  SUBLW  13
0786A:  BC    786E
0786C:  CLRF   x78
....................              } 
....................              cuenta=0; 
0786E:  CLRF   x7C
07870:  MOVLB  0
....................          }//END SEGUNDO 
....................       } 
....................       //if( (MACIsLinked()==0)&&(inicializado)&&(linked_out==0) ){//cable off 
....................       if( (MACIsLinked()==0)&&(inicializado) ){//cable off 
07872:  GOTO   6CB8
07876:  MOVF   01,F
07878:  BNZ   7886
0787A:  MOVF   50,F
0787C:  BZ    7886
....................          //linked_out=1; 
....................          TCPDisconnect(socket2); 
0787E:  MOVFF  51,8FB
07882:  CALL   509A
....................       } 
07886:  GOTO   700E
....................       ////////////////////////////////////// 
....................    }//end true 
.................... }//end main 
....................  
0788A:  SLEEP 
.................... int convertir_to_entero(char *cadena){ 
*
063A2:  MOVLB  8
063A4:  CLRF   xF9
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
063A6:  MOVF   xF7,W
063A8:  SUBLW  30
063AA:  BNZ   63B4
063AC:  MOVF   xF8,F
063AE:  BNZ   63B4
063B0:  CLRF   xF9
063B2:  BRA    6442
....................    else if(cadena=='1') valor=1; 
063B4:  MOVF   xF7,W
063B6:  SUBLW  31
063B8:  BNZ   63C4
063BA:  MOVF   xF8,F
063BC:  BNZ   63C4
063BE:  MOVLW  01
063C0:  MOVWF  xF9
063C2:  BRA    6442
....................    else if(cadena=='2') valor=2; 
063C4:  MOVF   xF7,W
063C6:  SUBLW  32
063C8:  BNZ   63D4
063CA:  MOVF   xF8,F
063CC:  BNZ   63D4
063CE:  MOVLW  02
063D0:  MOVWF  xF9
063D2:  BRA    6442
....................    else if(cadena=='3') valor=3; 
063D4:  MOVF   xF7,W
063D6:  SUBLW  33
063D8:  BNZ   63E4
063DA:  MOVF   xF8,F
063DC:  BNZ   63E4
063DE:  MOVLW  03
063E0:  MOVWF  xF9
063E2:  BRA    6442
....................    else if(cadena=='4') valor=4; 
063E4:  MOVF   xF7,W
063E6:  SUBLW  34
063E8:  BNZ   63F4
063EA:  MOVF   xF8,F
063EC:  BNZ   63F4
063EE:  MOVLW  04
063F0:  MOVWF  xF9
063F2:  BRA    6442
....................    else if(cadena=='5') valor=5; 
063F4:  MOVF   xF7,W
063F6:  SUBLW  35
063F8:  BNZ   6404
063FA:  MOVF   xF8,F
063FC:  BNZ   6404
063FE:  MOVLW  05
06400:  MOVWF  xF9
06402:  BRA    6442
....................    else if(cadena=='6') valor=6; 
06404:  MOVF   xF7,W
06406:  SUBLW  36
06408:  BNZ   6414
0640A:  MOVF   xF8,F
0640C:  BNZ   6414
0640E:  MOVLW  06
06410:  MOVWF  xF9
06412:  BRA    6442
....................    else if(cadena=='7') valor=7; 
06414:  MOVF   xF7,W
06416:  SUBLW  37
06418:  BNZ   6424
0641A:  MOVF   xF8,F
0641C:  BNZ   6424
0641E:  MOVLW  07
06420:  MOVWF  xF9
06422:  BRA    6442
....................    else if(cadena=='8') valor=8; 
06424:  MOVF   xF7,W
06426:  SUBLW  38
06428:  BNZ   6434
0642A:  MOVF   xF8,F
0642C:  BNZ   6434
0642E:  MOVLW  08
06430:  MOVWF  xF9
06432:  BRA    6442
....................    else if(cadena=='9') valor=9; 
06434:  MOVF   xF7,W
06436:  SUBLW  39
06438:  BNZ   6442
0643A:  MOVF   xF8,F
0643C:  BNZ   6442
0643E:  MOVLW  09
06440:  MOVWF  xF9
....................    return valor; 
06442:  MOVFF  8F9,01
06446:  MOVLB  0
06448:  RETURN 0
.................... } 
....................  
.................... void fecha(){//falta revisar si se deshabilitan las int globales 
....................    disable_interrupts(INT_RDA); 
*
0662A:  BCF    F9D.5
....................    //delay_ms(1000); 
....................    lcd_gotoxy(1,2); 
0662C:  MOVLW  01
0662E:  MOVLB  9
06630:  MOVWF  x00
06632:  MOVLW  02
06634:  MOVWF  x01
06636:  MOVLB  0
06638:  CALL   0628
....................    lcd_putc("\f     CONFIGURA      ");// 
0663C:  MOVLW  76
0663E:  MOVWF  FF6
06640:  MOVLW  03
06642:  MOVWF  FF7
06644:  CALL   06DE
....................    lcd_gotoxy(1,3); 
06648:  MOVLW  01
0664A:  MOVLB  9
0664C:  MOVWF  x00
0664E:  MOVLW  03
06650:  MOVWF  x01
06652:  MOVLB  0
06654:  CALL   0628
....................    lcd_putc("     FECHA/HORA     "); 
06658:  MOVLW  8C
0665A:  MOVWF  FF6
0665C:  MOVLW  03
0665E:  MOVWF  FF7
06660:  CALL   06DE
....................     
....................    setup_wdt(WDT_ON); 
06664:  BSF    FD1.0
....................    restart_wdt(); 
06666:  CLRWDT
....................     
....................    day=(convertir_to_entero(XX[instruccion_size])*10)+convertir_to_entero(XX[instruccion_size+1]); 
06668:  MOVLB  8
0666A:  CLRF   xF8
0666C:  MOVFF  5C,8F7
06670:  MOVLB  0
06672:  RCALL  63A2
06674:  MOVF   01,W
06676:  MULLW  0A
06678:  MOVFF  FF3,8F6
0667C:  MOVLB  8
0667E:  CLRF   xF8
06680:  MOVFF  5D,8F7
06684:  MOVLB  0
06686:  RCALL  63A2
06688:  MOVF   01,W
0668A:  MOVLB  8
0668C:  ADDWF  xF6,W
0668E:  MOVLB  2
06690:  MOVWF  x70
....................    hrs=(convertir_to_entero(XX[instruccion_size+7])*10)+convertir_to_entero(XX[instruccion_size+8]); 
06692:  MOVLB  8
06694:  CLRF   xF8
06696:  MOVFF  63,8F7
0669A:  MOVLB  0
0669C:  RCALL  63A2
0669E:  MOVF   01,W
066A0:  MULLW  0A
066A2:  MOVFF  FF3,8F6
066A6:  MOVLB  8
066A8:  CLRF   xF8
066AA:  MOVFF  64,8F7
066AE:  MOVLB  0
066B0:  RCALL  63A2
066B2:  MOVF   01,W
066B4:  MOVLB  8
066B6:  ADDWF  xF6,W
066B8:  MOVLB  2
066BA:  MOVWF  x73
....................    min=(convertir_to_entero(XX[instruccion_size+9])*10)+convertir_to_entero(XX[instruccion_size+10]); 
066BC:  MOVLB  8
066BE:  CLRF   xF8
066C0:  MOVFF  65,8F7
066C4:  MOVLB  0
066C6:  RCALL  63A2
066C8:  MOVF   01,W
066CA:  MULLW  0A
066CC:  MOVFF  FF3,8F6
066D0:  MOVLB  8
066D2:  CLRF   xF8
066D4:  MOVFF  66,8F7
066D8:  MOVLB  0
066DA:  RCALL  63A2
066DC:  MOVF   01,W
066DE:  MOVLB  8
066E0:  ADDWF  xF6,W
066E2:  MOVLB  2
066E4:  MOVWF  x74
....................    sec=(convertir_to_entero(XX[instruccion_size+11])*10)+convertir_to_entero(XX[instruccion_size+12]); 
066E6:  MOVLB  8
066E8:  CLRF   xF8
066EA:  MOVFF  67,8F7
066EE:  MOVLB  0
066F0:  RCALL  63A2
066F2:  MOVF   01,W
066F4:  MULLW  0A
066F6:  MOVFF  FF3,8F6
066FA:  MOVLB  8
066FC:  CLRF   xF8
066FE:  MOVFF  68,8F7
06702:  MOVLB  0
06704:  RCALL  63A2
06706:  MOVF   01,W
06708:  MOVLB  8
0670A:  ADDWF  xF6,W
0670C:  MOVLB  2
0670E:  MOVWF  x75
....................     
....................    month=(convertir_to_entero(XX[instruccion_size+2])*10)+convertir_to_entero(XX[instruccion_size+3]); 
06710:  MOVLB  8
06712:  CLRF   xF8
06714:  MOVFF  5E,8F7
06718:  MOVLB  0
0671A:  RCALL  63A2
0671C:  MOVF   01,W
0671E:  MULLW  0A
06720:  MOVFF  FF3,8F6
06724:  MOVLB  8
06726:  CLRF   xF8
06728:  MOVFF  5F,8F7
0672C:  MOVLB  0
0672E:  RCALL  63A2
06730:  MOVF   01,W
06732:  MOVLB  8
06734:  ADDWF  xF6,W
06736:  MOVLB  2
06738:  MOVWF  x71
....................    yr= (convertir_to_entero(XX[instruccion_size+4])*10)+convertir_to_entero(XX[instruccion_size+5]); 
0673A:  MOVLB  8
0673C:  CLRF   xF8
0673E:  MOVFF  60,8F7
06742:  MOVLB  0
06744:  RCALL  63A2
06746:  MOVF   01,W
06748:  MULLW  0A
0674A:  MOVFF  FF3,8F6
0674E:  MOVLB  8
06750:  CLRF   xF8
06752:  MOVFF  61,8F7
06756:  MOVLB  0
06758:  RCALL  63A2
0675A:  MOVF   01,W
0675C:  MOVLB  8
0675E:  ADDWF  xF6,W
06760:  MOVLB  2
06762:  MOVWF  x72
....................    dow= convertir_to_entero(XX[instruccion_size+6]); 
06764:  MOVLB  8
06766:  CLRF   xF8
06768:  MOVFF  62,8F7
0676C:  MOVLB  0
0676E:  RCALL  63A2
06770:  MOVFF  01,276
....................    ///////////////////// 
....................    ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos), ,hora,min,seg 
06774:  MOVFF  270,906
06778:  MOVFF  271,907
0677C:  MOVFF  272,908
06780:  MOVFF  276,909
06784:  MOVFF  273,90A
06788:  MOVFF  274,90B
0678C:  MOVFF  275,90C
06790:  RCALL  6472
....................    lcd_gotoxy(1,1); 
06792:  MOVLW  01
06794:  MOVLB  9
06796:  MOVWF  x00
06798:  MOVWF  x01
0679A:  MOVLB  0
0679C:  CALL   0628
....................    printf(lcd_putc,"      %02d:%02d:%02d      ",hrs,min,sec); 
067A0:  MOVLW  A2
067A2:  MOVWF  FF6
067A4:  MOVLW  03
067A6:  MOVWF  FF7
067A8:  MOVLW  06
067AA:  MOVLB  8
067AC:  MOVWF  xF7
067AE:  MOVLB  0
067B0:  CALL   1558
067B4:  MOVFF  273,8F6
067B8:  MOVLW  01
067BA:  MOVLB  8
067BC:  MOVWF  xF7
067BE:  MOVLB  0
067C0:  RCALL  655E
067C2:  MOVLW  3A
067C4:  MOVLB  8
067C6:  MOVWF  xFF
067C8:  MOVLB  0
067CA:  CALL   067A
067CE:  MOVFF  274,8F6
067D2:  MOVLW  01
067D4:  MOVLB  8
067D6:  MOVWF  xF7
067D8:  MOVLB  0
067DA:  RCALL  655E
067DC:  MOVLW  3A
067DE:  MOVLB  8
067E0:  MOVWF  xFF
067E2:  MOVLB  0
067E4:  CALL   067A
067E8:  MOVFF  275,8F6
067EC:  MOVLW  01
067EE:  MOVLB  8
067F0:  MOVWF  xF7
067F2:  MOVLB  0
067F4:  RCALL  655E
067F6:  MOVLW  B6
067F8:  MOVWF  FF6
067FA:  MOVLW  03
067FC:  MOVWF  FF7
067FE:  MOVLW  06
06800:  MOVLB  8
06802:  MOVWF  xF7
06804:  MOVLB  0
06806:  CALL   1558
....................    lcd_gotoxy(1,2); 
0680A:  MOVLW  01
0680C:  MOVLB  9
0680E:  MOVWF  x00
06810:  MOVLW  02
06812:  MOVWF  x01
06814:  MOVLB  0
06816:  CALL   0628
....................    printf (lcd_putc,"     %02d/%02d/2%03d     ",day,month,yr); 
0681A:  MOVLW  BE
0681C:  MOVWF  FF6
0681E:  MOVLW  03
06820:  MOVWF  FF7
06822:  MOVLW  05
06824:  MOVLB  8
06826:  MOVWF  xF7
06828:  MOVLB  0
0682A:  CALL   1558
0682E:  MOVFF  270,8F6
06832:  MOVLW  01
06834:  MOVLB  8
06836:  MOVWF  xF7
06838:  MOVLB  0
0683A:  RCALL  655E
0683C:  MOVLW  2F
0683E:  MOVLB  8
06840:  MOVWF  xFF
06842:  MOVLB  0
06844:  CALL   067A
06848:  MOVFF  271,8F6
0684C:  MOVLW  01
0684E:  MOVLB  8
06850:  MOVWF  xF7
06852:  MOVLB  0
06854:  RCALL  655E
06856:  MOVLW  2F
06858:  MOVLB  8
0685A:  MOVWF  xFF
0685C:  MOVLB  0
0685E:  CALL   067A
06862:  MOVLW  32
06864:  MOVLB  8
06866:  MOVWF  xFF
06868:  MOVLB  0
0686A:  CALL   067A
0686E:  MOVFF  272,8F6
06872:  MOVLW  03
06874:  MOVLB  8
06876:  MOVWF  xF7
06878:  MOVLB  0
0687A:  RCALL  655E
0687C:  MOVLW  D2
0687E:  MOVWF  FF6
06880:  MOVLW  03
06882:  MOVWF  FF7
06884:  MOVLW  05
06886:  MOVLB  8
06888:  MOVWF  xF7
0688A:  MOVLB  0
0688C:  CALL   1558
....................    lcd_gotoxy(1,3); 
06890:  MOVLW  01
06892:  MOVLB  9
06894:  MOVWF  x00
06896:  MOVLW  03
06898:  MOVWF  x01
0689A:  MOVLB  0
0689C:  CALL   0628
....................    lcd_putc("  DATOS GUARDADOS   "); 
068A0:  MOVLW  D8
068A2:  MOVWF  FF6
068A4:  MOVLW  03
068A6:  MOVWF  FF7
068A8:  CALL   06DE
....................    delay_ms(1500); 
068AC:  MOVLW  06
068AE:  MOVLB  8
068B0:  MOVWF  xF6
068B2:  MOVLW  FA
068B4:  MOVLB  9
068B6:  MOVWF  x00
068B8:  MOVLB  0
068BA:  CALL   0600
068BE:  MOVLB  8
068C0:  DECFSZ xF6,F
068C2:  BRA    68B2
....................    delay_ms(1000); 
068C4:  MOVLW  04
068C6:  MOVWF  xF6
068C8:  MOVLW  FA
068CA:  MOVLB  9
068CC:  MOVWF  x00
068CE:  MOVLB  0
068D0:  CALL   0600
068D4:  MOVLB  8
068D6:  DECFSZ xF6,F
068D8:  BRA    68C8
....................    restart_wdt(); 
068DA:  CLRWDT
....................    //if(demo==1) printf("\r\nXX:%s",XX); 
....................    enable_interrupts(INT_RDA); 
068DC:  BSF    F9D.5
068DE:  MOVLB  0
068E0:  GOTO   740E (RETURN)
.................... } 
....................  
.................... void wiegand_read_card(){ 
....................  if(wieg_full){ 
*
05728:  MOVLB  2
0572A:  MOVF   x10,F
0572C:  BTFSC  FD8.2
0572E:  BRA    585A
....................    //disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
....................    deci=0; 
05730:  CLRF   x15
05732:  CLRF   x14
05734:  CLRF   x13
05736:  CLRF   x12
....................    for(i=1;i<sub_indice-1;i++) deci = (deci<<1)|data[i]; 
05738:  CLRF   41
0573A:  MOVLW  01
0573C:  MOVWF  40
0573E:  MOVLW  01
05740:  SUBWF  x0F,W
05742:  MOVF   41,F
05744:  BNZ   5794
05746:  SUBWF  40,W
05748:  BC    5794
0574A:  BCF    FD8.0
0574C:  RLCF   x12,W
0574E:  MOVLB  8
05750:  MOVWF  xF7
05752:  MOVLB  2
05754:  RLCF   x13,W
05756:  MOVLB  8
05758:  MOVWF  xF8
0575A:  MOVLB  2
0575C:  RLCF   x14,W
0575E:  MOVLB  8
05760:  MOVWF  xF9
05762:  MOVLB  2
05764:  RLCF   x15,W
05766:  MOVLB  8
05768:  MOVWF  xFA
0576A:  MOVLW  16
0576C:  ADDWF  40,W
0576E:  MOVWF  FE9
05770:  MOVLW  02
05772:  ADDWFC 41,W
05774:  MOVWF  FEA
05776:  MOVF   FEF,W
05778:  IORWF  xF7,W
0577A:  MOVLB  2
0577C:  MOVWF  x12
0577E:  MOVFF  8F8,213
05782:  MOVFF  8F9,214
05786:  MOVFF  8FA,215
0578A:  MOVLB  2
0578C:  INCF   40,F
0578E:  BTFSC  FD8.2
05790:  INCF   41,F
05792:  BRA    573E
....................    sprintf(YY,"%08LX",deci);// imprime en un arreglo (printf en ram) 
05794:  MOVLB  8
05796:  CLRF   xF4
05798:  MOVLW  AC
0579A:  MOVWF  xF3
0579C:  MOVFF  215,8F6
057A0:  MOVLW  37
057A2:  MOVWF  xF7
057A4:  MOVLB  0
057A6:  RCALL  569E
057A8:  MOVFF  214,8F6
057AC:  MOVLW  37
057AE:  MOVLB  8
057B0:  MOVWF  xF7
057B2:  MOVLB  0
057B4:  RCALL  569E
057B6:  MOVFF  213,8F6
057BA:  MOVLW  37
057BC:  MOVLB  8
057BE:  MOVWF  xF7
057C0:  MOVLB  0
057C2:  RCALL  569E
057C4:  MOVFF  212,8F6
057C8:  MOVLW  37
057CA:  MOVLB  8
057CC:  MOVWF  xF7
057CE:  MOVLB  0
057D0:  RCALL  569E
....................    sprintf(txtcp,"EN1-%08LX",deci);// imprime en un arreglo (printf en ram) 
057D2:  MOVLW  01
057D4:  MOVLB  8
057D6:  MOVWF  xF4
057D8:  MOVLW  06
057DA:  MOVWF  xF3
057DC:  MOVLW  EE
057DE:  MOVWF  FF6
057E0:  MOVLW  03
057E2:  MOVWF  FF7
057E4:  MOVLW  04
057E6:  MOVWF  xF6
057E8:  MOVLB  0
057EA:  BRA    56E4
057EC:  MOVFF  215,8F6
057F0:  MOVLW  37
057F2:  MOVLB  8
057F4:  MOVWF  xF7
057F6:  MOVLB  0
057F8:  RCALL  569E
057FA:  MOVFF  214,8F6
057FE:  MOVLW  37
05800:  MOVLB  8
05802:  MOVWF  xF7
05804:  MOVLB  0
05806:  RCALL  569E
05808:  MOVFF  213,8F6
0580C:  MOVLW  37
0580E:  MOVLB  8
05810:  MOVWF  xF7
05812:  MOVLB  0
05814:  RCALL  569E
05816:  MOVFF  212,8F6
0581A:  MOVLW  37
0581C:  MOVLB  8
0581E:  MOVWF  xF7
05820:  MOVLB  0
05822:  RCALL  569E
....................    //fprintf(DEBUG,"TA:%s\r\n",txtcp); 
....................    //lcd_gotoxy(1,3); 
....................    //printf(lcd_putc,"TA:%s",txtcp); 
....................    size_tx_tcp=strlen(txtcp); 
05824:  MOVLW  01
05826:  MOVLB  9
05828:  MOVWF  x0C
0582A:  MOVLW  06
0582C:  MOVWF  x0B
0582E:  MOVLB  0
05830:  RCALL  5636
05832:  MOVFF  01,48
....................    enviar_tcp(); 
05836:  RCALL  5672
....................    //validar_tag_salida();//FUNCION PARA ABRIR AUTOMATICAMENTE Y GUARDAR ESTADO DE ANTIPASS 
....................    wieg_full=0; 
05838:  MOVLB  2
0583A:  CLRF   x10
....................    wieg=sub_indice=0; 
0583C:  CLRF   x0F
0583E:  MOVFF  20F,20C
....................    wiegand_cuenta=0; 
05842:  CLRF   x11
....................    memset(data, 0, sizeof(data) ); 
05844:  MOVLW  02
05846:  MOVWF  FEA
05848:  MOVLW  16
0584A:  MOVWF  FE9
0584C:  CLRF   00
0584E:  CLRF   02
05850:  MOVLW  1A
05852:  MOVWF  01
05854:  MOVLB  0
05856:  RCALL  570E
05858:  MOVLB  2
....................  }//END TARJETA LEIDA 
....................  if( (wieg==1)&&(wiegand_cuenta>=3) ) { 
0585A:  DECFSZ x0C,W
0585C:  BRA    58A6
0585E:  MOVF   x11,W
05860:  SUBLW  02
05862:  BC    58A6
....................       wigmal++; 
05864:  INCF   x0D,F
....................       //fprintf(DEBUG,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_gotoxy(1,4); 
....................       //printf(lcd_putc,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_putc("CAPTURA INCOMPLETA  "); 
....................       wieg_full=0; 
05866:  CLRF   x10
....................       deci=0; 
05868:  CLRF   x15
0586A:  CLRF   x14
0586C:  CLRF   x13
0586E:  CLRF   x12
....................       ///////////UNIFICANDO EL TAMAÑO DEL DATO LEIDO///////////////// 
....................       deteccion_nulo=0; 
05870:  CLRF   x0A
....................       pre_cuenta=0; 
05872:  CLRF   x0B
....................       ////////////////////// 
....................       wieg=sub_indice=i=0; 
05874:  CLRF   41
05876:  CLRF   40
05878:  MOVFF  40,20F
0587C:  MOVFF  20F,20C
....................       wiegand_cuenta=0; 
05880:  CLRF   x11
....................       for(i=0;i<wieg_size;i++) data[i]=0; 
05882:  CLRF   41
05884:  CLRF   40
05886:  MOVF   41,F
05888:  BNZ   58A6
0588A:  MOVF   40,W
0588C:  SUBLW  19
0588E:  BNC   58A6
05890:  MOVLW  16
05892:  ADDWF  40,W
05894:  MOVWF  FE9
05896:  MOVLW  02
05898:  ADDWFC 41,W
0589A:  MOVWF  FEA
0589C:  CLRF   FEF
0589E:  INCF   40,F
058A0:  BTFSC  FD8.2
058A2:  INCF   41,F
058A4:  BRA    5886
....................  } 
058A6:  MOVLB  0
058A8:  GOTO   70F0 (RETURN)
.................... } 
....................  
.................... void enviar_tcp(){ 
....................    envia_pc=1; 
*
05672:  MOVLW  01
05674:  MOVWF  1A
....................    StackTask(); 
05676:  CALL   4492
....................    MyTCPTask(); 
0567A:  RCALL  52CA
0567C:  RETURN 0
.................... } 
.................... //////////////////// 
.................... void zeller(){ 
.................... int16 dia_s1,dia_s2,dia_s3,diac,mesc,dia_fecha;//(day,month,yr,dow,hrs,min,sec 
....................    int siglo,asiglo,resultado,di2; 
....................    diac=31; 
*
068E4:  MOVLB  8
068E6:  CLRF   xFD
068E8:  MOVLW  1F
068EA:  MOVWF  xFC
....................    mesc=10; 
068EC:  CLRF   xFF
068EE:  MOVLW  0A
068F0:  MOVWF  xFE
....................    siglo=20; 
068F2:  MOVLW  14
068F4:  MOVLB  9
068F6:  MOVWF  x02
....................    asiglo=yr; 
068F8:  MOVFF  272,903
....................    //fprintf(U1PRINTER,"Dia:%Ld mes:%Ld año:%d siglo:%d asiglo:%d\r\n",diac,mesc,asiglo,siglo,asiglo); 
....................    if(mesc<3){ 
068FC:  MOVLB  8
068FE:  MOVF   xFF,F
06900:  BNZ   6916
06902:  MOVF   xFE,W
06904:  SUBLW  02
06906:  BNC   6916
....................       mesc+=12; 
06908:  MOVLW  0C
0690A:  ADDWF  xFE,F
0690C:  MOVLW  00
0690E:  ADDWFC xFF,F
....................       asiglo--; 
06910:  MOVLB  9
06912:  DECF   x03,F
06914:  MOVLB  8
....................    } 
....................    dia_s1=(siglo/4)+5*siglo; 
06916:  MOVLB  9
06918:  RRCF   x02,W
0691A:  MOVWF  x06
0691C:  RRCF   x06,F
0691E:  MOVLW  3F
06920:  ANDWF  x06,F
06922:  MOVF   x02,W
06924:  MULLW  05
06926:  MOVF   FF3,W
06928:  ADDWF  x06,W
0692A:  MOVLB  8
0692C:  MOVWF  xF6
0692E:  CLRF   xF7
....................    dia_s2=dia_s1+asiglo+(asiglo/4); 
06930:  MOVLB  9
06932:  MOVF   x03,W
06934:  MOVLB  8
06936:  ADDWF  xF6,W
06938:  MOVLB  9
0693A:  MOVWF  x06
0693C:  MOVLW  00
0693E:  MOVLB  8
06940:  ADDWFC xF7,W
06942:  MOVLB  9
06944:  MOVWF  x07
06946:  RRCF   x03,W
06948:  MOVWF  00
0694A:  RRCF   00,F
0694C:  MOVLW  3F
0694E:  ANDWF  00,F
06950:  MOVF   00,W
06952:  ADDWF  x06,W
06954:  MOVLB  8
06956:  MOVWF  xF8
06958:  MOVLW  00
0695A:  MOVLB  9
0695C:  ADDWFC x07,W
0695E:  MOVLB  8
06960:  MOVWF  xF9
....................    dia_s3=dia_s2+((mesc+1)*26)/10; 
06962:  MOVLW  01
06964:  ADDWF  xFE,W
06966:  MOVLB  9
06968:  MOVWF  x06
0696A:  MOVLW  00
0696C:  MOVLB  8
0696E:  ADDWFC xFF,W
06970:  MOVLB  9
06972:  MOVWF  x07
06974:  MOVWF  x47
06976:  MOVFF  906,946
0697A:  CLRF   x49
0697C:  MOVLW  1A
0697E:  MOVWF  x48
06980:  MOVLB  0
06982:  CALL   1006
06986:  MOVFF  02,907
0698A:  MOVFF  01,906
0698E:  MOVFF  02,909
06992:  MOVFF  01,908
06996:  MOVLB  9
06998:  CLRF   x0B
0699A:  MOVLW  0A
0699C:  MOVWF  x0A
0699E:  MOVLB  0
069A0:  CALL   109A
069A4:  MOVF   01,W
069A6:  MOVLB  8
069A8:  ADDWF  xF8,W
069AA:  MOVWF  xFA
069AC:  MOVF   02,W
069AE:  ADDWFC xF9,W
069B0:  MOVWF  xFB
....................    dia_fecha=(dia_s3+diac)%7;//dia de fin de mes 
069B2:  MOVF   xFC,W
069B4:  ADDWF  xFA,W
069B6:  MOVLB  9
069B8:  MOVWF  x06
069BA:  MOVLB  8
069BC:  MOVF   xFD,W
069BE:  ADDWFC xFB,W
069C0:  MOVLB  9
069C2:  MOVWF  x07
069C4:  MOVWF  x09
069C6:  MOVFF  906,908
069CA:  CLRF   x0B
069CC:  MOVLW  07
069CE:  MOVWF  x0A
069D0:  MOVLB  0
069D2:  CALL   109A
069D6:  MOVFF  00,900
069DA:  MOVLB  9
069DC:  MOVFF  03,901
....................    if(dia_fecha==0) dia_fecha=7; 
069E0:  MOVF   x00,F
069E2:  BNZ   69EE
069E4:  MOVF   x01,F
069E6:  BNZ   69EE
069E8:  CLRF   x01
069EA:  MOVLW  07
069EC:  MOVWF  x00
....................    //fprintf(U1PRINTER,"Dia:%Ld ",dia_fecha); 
....................    resultado=31-(dia_fecha-1); 
069EE:  MOVLW  01
069F0:  SUBWF  x00,W
069F2:  MOVWF  00
069F4:  MOVLW  00
069F6:  SUBWFB x01,W
069F8:  MOVF   00,W
069FA:  XORLW  FF
069FC:  ADDLW  20
069FE:  MOVWF  x04
....................    //fprintf(U1PRINTER,"Dia:%d ",resultado); 
.................... ///////////revisar cambio de horario//////////// 
.................... ds1307_get_date(day,month,yr,dow); 
.................... ds1307_get_time(hrs,min,sec); 
.................... di2=read_ext_eeprom(14); 
*
06BD8:  MOVLB  9
06BDA:  CLRF   x07
06BDC:  MOVLW  0E
06BDE:  MOVWF  x06
06BE0:  MOVLB  0
06BE2:  CALL   13AA
06BE6:  MOVFF  01,905
.................... if((month==4)&&(dow==1)&&(hrs>=2)&&(di2!=1)){//cambia a horario de verano 
06BEA:  MOVLB  2
06BEC:  MOVF   x71,W
06BEE:  SUBLW  04
06BF0:  BNZ   6C48
06BF2:  DECFSZ x76,W
06BF4:  BRA    6C48
06BF6:  MOVF   x73,W
06BF8:  SUBLW  01
06BFA:  BC    6C48
06BFC:  MOVLB  9
06BFE:  DECFSZ x05,W
06C00:  BRA    6C08
06C02:  MOVLB  2
06C04:  BRA    6C48
06C06:  MOVLB  9
....................  hrs=hrs+1; 
06C08:  MOVLW  01
06C0A:  MOVLB  2
06C0C:  ADDWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
06C0E:  MOVFF  270,906
06C12:  MOVFF  271,907
06C16:  MOVFF  272,908
06C1A:  MOVFF  276,909
06C1E:  MOVFF  273,90A
06C22:  MOVFF  274,90B
06C26:  MOVFF  275,90C
06C2A:  MOVLB  0
06C2C:  RCALL  6472
....................  di2=1; 
06C2E:  MOVLW  01
06C30:  MOVLB  9
06C32:  MOVWF  x05
....................  write_ext_eeprom(14,di2);//(1,0)horario de invierno 
06C34:  CLRF   x07
06C36:  MOVLW  0E
06C38:  MOVWF  x06
06C3A:  MOVFF  905,908
06C3E:  MOVLB  0
06C40:  CALL   1452
.................... } 
06C44:  BRA    6CB0
06C46:  MOVLB  2
.................... //if((month==10)&&(dow==1)&&(day==resultado)&&(hrs==3)&&(di2!=day)){//cambia a horario de invierno 
.................... else if((month==10)&&(day==resultado)&&(hrs>=3)&&(hrs<=5)&&(di2!=day)){//cambia a horario de invierno 
06C48:  MOVF   x71,W
06C4A:  SUBLW  0A
06C4C:  BNZ   6CB2
06C4E:  MOVLB  9
06C50:  MOVF   x04,W
06C52:  MOVLB  2
06C54:  SUBWF  x70,W
06C56:  BNZ   6CB2
06C58:  MOVF   x73,W
06C5A:  SUBLW  02
06C5C:  BC    6CB2
06C5E:  MOVF   x73,W
06C60:  SUBLW  05
06C62:  BNC   6CB2
06C64:  MOVF   x70,W
06C66:  MOVLB  9
06C68:  SUBWF  x05,W
06C6A:  BTFSS  FD8.2
06C6C:  BRA    6C72
06C6E:  MOVLB  2
06C70:  BRA    6CB2
....................  hrs=hrs-1; 
06C72:  MOVLW  01
06C74:  MOVLB  2
06C76:  SUBWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
06C78:  MOVFF  270,906
06C7C:  MOVFF  271,907
06C80:  MOVFF  272,908
06C84:  MOVFF  276,909
06C88:  MOVFF  273,90A
06C8C:  MOVFF  274,90B
06C90:  MOVFF  275,90C
06C94:  MOVLB  0
06C96:  CALL   6472
....................  di2=day; 
06C9A:  MOVFF  270,905
....................  write_ext_eeprom(14,di2); 
06C9E:  MOVLB  9
06CA0:  CLRF   x07
06CA2:  MOVLW  0E
06CA4:  MOVWF  x06
06CA6:  MOVFF  905,908
06CAA:  MOVLB  0
06CAC:  CALL   1452
06CB0:  MOVLB  2
....................  } 
06CB2:  MOVLB  0
06CB4:  GOTO   7632 (RETURN)
.................... } 
.................... //////////////////// 
.................... void sensores(){ 
.................... if(en1!=input(entrada01) ){//SENSOR 1 bobina DE ENTRADA 
*
06148:  BSF    F95.4
0614A:  MOVLW  00
0614C:  BTFSC  F83.4
0614E:  MOVLW  01
06150:  MOVLB  2
06152:  SUBWF  x83,W
06154:  BZ    6186
....................    delay_ms(200); 
06156:  MOVLW  C8
06158:  MOVLB  9
0615A:  MOVWF  x00
0615C:  MOVLB  0
0615E:  CALL   0600
....................    if(en1!=input(entrada01)){ 
06162:  BSF    F95.4
06164:  MOVLW  00
06166:  BTFSC  F83.4
06168:  MOVLW  01
0616A:  MOVLB  2
0616C:  SUBWF  x83,W
0616E:  BZ    6186
....................       en1=input(entrada01); 
06170:  BSF    F95.4
06172:  CLRF   x83
06174:  BTFSC  F83.4
06176:  INCF   x83,F
....................       //fen4=0; 
....................       if(en1==1){ 
06178:  DECFSZ x83,W
0617A:  BRA    6180
....................          //lcd_putc("\fEN1-ENTRADA"); 
....................          re_bol=0; 
0617C:  CLRF   x8A
....................          //strcpy(txtcp,"EN1-ENTRADA"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
0617E:  BRA    6186
....................       else { 
....................          output_low(salida04); 
06180:  BCF    F95.3
06182:  BCF    F8C.3
....................          re_bol=0; 
06184:  CLRF   x8A
....................          //lcd_putc("\fEN1-SINDETECCION"); 
....................          //strcpy(txtcp,"EN1-SINDETECCION"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................    } 
.................... }//end S1 
....................  
.................... if(en4!=input(entrada04) ){//BOTON DE TICKET 
06186:  BSF    F95.0
06188:  MOVLW  00
0618A:  BTFSC  F83.0
0618C:  MOVLW  01
0618E:  SUBWF  x86,W
06190:  BZ    61B2
....................    //delay_ms(10); 
....................    if(en4!=input(entrada04)){ 
06192:  BSF    F95.0
06194:  MOVLW  00
06196:  BTFSC  F83.0
06198:  MOVLW  01
0619A:  SUBWF  x86,W
0619C:  BZ    61B2
....................       en4=input(entrada04); 
0619E:  BSF    F95.0
061A0:  CLRF   x86
061A2:  BTFSC  F83.0
061A4:  INCF   x86,F
....................       //printf(lcd_putc,"\fbot:%d au:%d hbot:%d cpo:%d "en3,en1,fen3,cupo ); 
....................       //if( (en4)&&(en1)&&(fen4!=1)&&(cupo!=1) ){ 
....................       if(en4){ 
061A6:  MOVF   x86,F
061A8:  BZ    61B2
....................          time_boleto=0; 
061AA:  CLRF   x89
....................          ticket(); 
061AC:  MOVLB  0
061AE:  RCALL  5C40
061B0:  MOVLB  2
....................       } 
....................    }//verificacion boton 
.................... }//en boton ticket 
061B2:  MOVLB  0
061B4:  GOTO   70F4 (RETURN)
.................... ///////////////////// 
.................... } 
.................... //EPSON 
.................... void ticket(){//U1PRINTER //HHMMSSFFFFFFFFZ 
....................    // 1-Direccion1 para Folio 
....................    // 2-Direccion2 para Folio 
....................    // 3-Direccion3 para Folio 
....................    //int cta_l,cta_m,cta_h; 
....................    char fol_bol[20]; 
....................    /*//leer 
....................    cta_l=read_ext_eeprom(3); 
....................    cta_m=read_ext_eeprom(2); 
....................    cta_h=read_ext_eeprom(1); 
....................    folio=0;//24bits 16,777,215 
....................    folio=cta_h;// 
....................    folio=(folio<<8)|cta_m; 
....................    folio=(folio<<8)|cta_l; 
....................    //fin de leer 
....................    folio++; 
....................    //printf("Total:%Ld\r\n",folio); 
....................    write_ext_eeprom(3,folio);//graba 
....................    write_ext_eeprom(2,folio>>8);//graba 
....................    write_ext_eeprom(1,folio>>16);//graba 
....................    */ 
....................    //////////////////////////////// 
....................    ds1307_get_date(day,month,yr,dow); 
....................    ds1307_get_time(hrs,min,sec); 
....................    ////////texto////// 
....................    //inicializa el envio de codigos esc/pos 
....................    fputc(27, U1PRINTER); 
*
05DF2:  MOVLW  1B
05DF4:  MOVLB  9
05DF6:  MOVWF  x10
05DF8:  MOVLB  0
05DFA:  RCALL  59B6
....................    fputc('@', U1PRINTER); 
05DFC:  MOVLW  40
05DFE:  MOVLB  9
05E00:  MOVWF  x10
05E02:  MOVLB  0
05E04:  RCALL  59B6
....................    //linea de justificacion 1B "a" 0izquierda 1centrado 2derecha 
....................    fputc(27, U1PRINTER); 
05E06:  MOVLW  1B
05E08:  MOVLB  9
05E0A:  MOVWF  x10
05E0C:  MOVLB  0
05E0E:  RCALL  59B6
....................    fputc(97, U1PRINTER); 
05E10:  MOVLW  61
05E12:  MOVLB  9
05E14:  MOVWF  x10
05E16:  MOVLB  0
05E18:  RCALL  59B6
....................    fputc(1, U1PRINTER); 
05E1A:  MOVLW  01
05E1C:  MOVLB  9
05E1E:  MOVWF  x10
05E20:  MOVLB  0
05E22:  RCALL  59B6
....................    //////interlineado//////// 
....................    //fprintf(U1PRINTER,"\x1B"); 
....................    //fprintf(U1PRINTER,"3"); 
....................    fputc(27, U1PRINTER); 
05E24:  MOVLW  1B
05E26:  MOVLB  9
05E28:  MOVWF  x10
05E2A:  MOVLB  0
05E2C:  RCALL  59B6
....................    fputc(51, U1PRINTER); 
05E2E:  MOVLW  33
05E30:  MOVLB  9
05E32:  MOVWF  x10
05E34:  MOVLB  0
05E36:  RCALL  59B6
....................    fputc(40, U1PRINTER); 
05E38:  MOVLW  28
05E3A:  MOVLB  9
05E3C:  MOVWF  x10
05E3E:  MOVLB  0
05E40:  RCALL  59B6
....................    //////////// 
....................    /////negritas activas 
....................    fprintf(U1PRINTER,"\x1B"); 
05E42:  MOVLW  1B
05E44:  MOVLB  9
05E46:  MOVWF  x10
05E48:  MOVLB  0
05E4A:  RCALL  59B6
....................    fprintf(U1PRINTER,"G"); 
05E4C:  MOVLW  47
05E4E:  MOVLB  9
05E50:  MOVWF  x10
05E52:  MOVLB  0
05E54:  RCALL  59B6
....................    fprintf(U1PRINTER,"\x01"); 
05E56:  MOVLW  01
05E58:  MOVLB  9
05E5A:  MOVWF  x10
05E5C:  MOVLB  0
05E5E:  RCALL  59B6
....................    /////Tipo de fuente 
....................    fprintf(U1PRINTER,"\x1B"); 
05E60:  MOVLW  1B
05E62:  MOVLB  9
05E64:  MOVWF  x10
05E66:  MOVLB  0
05E68:  RCALL  59B6
....................    fprintf(U1PRINTER,"!"); 
05E6A:  MOVLW  21
05E6C:  MOVLB  9
05E6E:  MOVWF  x10
05E70:  MOVLB  0
05E72:  RCALL  59B6
....................    fputc(1, U1PRINTER); 
05E74:  MOVLW  01
05E76:  MOVLB  9
05E78:  MOVWF  x10
05E7A:  MOVLB  0
05E7C:  RCALL  59B6
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
05E7E:  MOVLW  1D
05E80:  MOVLB  9
05E82:  MOVWF  x10
05E84:  MOVLB  0
05E86:  RCALL  59B6
....................    fprintf(U1PRINTER,"!"); 
05E88:  MOVLW  21
05E8A:  MOVLB  9
05E8C:  MOVWF  x10
05E8E:  MOVLB  0
05E90:  RCALL  59B6
....................    fputc(17, U1PRINTER); 
05E92:  MOVLW  11
05E94:  MOVLB  9
05E96:  MOVWF  x10
05E98:  MOVLB  0
05E9A:  RCALL  59B6
....................    //printf("\x0A");//limpia la justificación 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    memset(fol_bol, 0, sizeof(fol_bol)); 
05E9C:  MOVLW  08
05E9E:  MOVWF  FEA
05EA0:  MOVLW  F6
05EA2:  MOVWF  FE9
05EA4:  CLRF   00
05EA6:  CLRF   02
05EA8:  MOVLW  14
05EAA:  MOVWF  01
05EAC:  RCALL  570E
....................    for(i=0;i<strlen(XX);i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
05EAE:  CLRF   41
05EB0:  CLRF   40
05EB2:  MOVLB  9
05EB4:  CLRF   x0C
05EB6:  MOVLW  52
05EB8:  MOVWF  x0B
05EBA:  MOVLB  0
05EBC:  CALL   5636
05EC0:  MOVFF  02,03
05EC4:  MOVF   41,W
05EC6:  SUBWF  02,W
05EC8:  BNC   5F0C
05ECA:  BNZ   5ED2
05ECC:  MOVF   01,W
05ECE:  SUBWF  40,W
05ED0:  BC    5F0C
05ED2:  MOVLW  F6
05ED4:  ADDWF  40,W
05ED6:  MOVWF  01
05ED8:  MOVLW  08
05EDA:  ADDWFC 41,W
05EDC:  MOVWF  03
05EDE:  MOVFF  01,90A
05EE2:  MOVLB  9
05EE4:  MOVWF  x0B
05EE6:  MOVLW  5C
05EE8:  ADDWF  40,W
05EEA:  MOVWF  FE9
05EEC:  MOVLW  00
05EEE:  ADDWFC 41,W
05EF0:  MOVWF  FEA
05EF2:  MOVFF  FEF,90E
05EF6:  MOVFF  03,FEA
05EFA:  MOVFF  01,FE9
05EFE:  MOVFF  90E,FEF
05F02:  INCF   40,F
05F04:  BTFSC  FD8.2
05F06:  INCF   41,F
05F08:  BRA    5EB4
05F0A:  MOVLB  0
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //folio = atoi32(fol_bol); 
....................    strcpy(fol_bol,"ABC1234567890"); 
05F0C:  MOVLW  08
05F0E:  MOVWF  FEA
05F10:  MOVLW  F6
05F12:  MOVWF  FE9
05F14:  MOVLW  00
05F16:  CALL   0106
05F1A:  TBLRD*-
05F1C:  TBLRD*+
05F1E:  MOVF   FF5,W
05F20:  MOVWF  FEE
05F22:  IORLW  00
05F24:  BNZ   5F1C
....................    fprintf(U1PRINTER,"Folio:%s",fol_bol); 
05F26:  MOVLW  F8
05F28:  MOVWF  FF6
05F2A:  MOVLW  03
05F2C:  MOVWF  FF7
05F2E:  MOVLW  06
05F30:  MOVLB  9
05F32:  MOVWF  x0A
05F34:  MOVLB  0
05F36:  RCALL  59C6
05F38:  MOVLW  08
05F3A:  MOVWF  FEA
05F3C:  MOVLW  F6
05F3E:  MOVWF  FE9
05F40:  RCALL  59EE
....................    strcpy(barra_codi,fol_bol); 
05F42:  MOVLW  02
05F44:  MOVWF  FEA
05F46:  MOVLW  4E
05F48:  MOVWF  FE9
05F4A:  MOVLW  08
05F4C:  MOVWF  FE2
05F4E:  MOVLW  F6
05F50:  MOVWF  FE1
05F52:  MOVF   FE7,F
05F54:  MOVFF  FE6,FEE
05F58:  BNZ   5F52
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
05F5A:  MOVLW  0A
05F5C:  MOVLB  9
05F5E:  MOVWF  x10
05F60:  MOVLB  0
05F62:  RCALL  59B6
....................    LF(); 
05F64:  RCALL  5A12
....................    /////////////////////////////////////////////////////////// 
....................    fprintf(U1PRINTER,"MARIA TERESA BAEZ MONROY"); 
05F66:  MOVLW  02
05F68:  MOVWF  FF6
05F6A:  MOVLW  04
05F6C:  MOVWF  FF7
05F6E:  RCALL  5A1E
....................    //printf("\x0A");//limpia la justificación  
....................    ////desactiva negritas 
....................    fprintf(U1PRINTER,"\x1B"); 
05F70:  MOVLW  1B
05F72:  MOVLB  9
05F74:  MOVWF  x10
05F76:  MOVLB  0
05F78:  RCALL  59B6
....................    fprintf(U1PRINTER,"G"); 
05F7A:  MOVLW  47
05F7C:  MOVLB  9
05F7E:  MOVWF  x10
05F80:  MOVLB  0
05F82:  RCALL  59B6
....................    fprintf(U1PRINTER,"\x00"); 
....................    /////////////////////////////////////////////////////////// 
....................    LF(); 
05F84:  RCALL  5A12
....................    LF(); 
05F86:  RCALL  5A12
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
05F88:  MOVLW  1D
05F8A:  MOVLB  9
05F8C:  MOVWF  x10
05F8E:  MOVLB  0
05F90:  RCALL  59B6
....................    fprintf(U1PRINTER,"!"); 
05F92:  MOVLW  21
05F94:  MOVLB  9
05F96:  MOVWF  x10
05F98:  MOVLB  0
05F9A:  RCALL  59B6
....................    fputc(0, U1PRINTER); 
05F9C:  MOVLB  9
05F9E:  CLRF   x10
05FA0:  MOVLB  0
05FA2:  RCALL  59B6
....................    ///// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
05FA4:  MOVLW  0A
05FA6:  MOVLB  9
05FA8:  MOVWF  x10
05FAA:  MOVLB  0
05FAC:  RCALL  59B6
....................    fprintf(U1PRINTER,"RFC:BAMT97052884A\x0A"); 
05FAE:  MOVLW  1C
05FB0:  MOVWF  FF6
05FB2:  MOVLW  04
05FB4:  MOVWF  FF7
05FB6:  RCALL  5A1E
....................    fprintf(U1PRINTER,"4 poniente 1302, colonia Centro  CP 72000\x0APuebla, Puebla\x0A"); 
05FB8:  MOVLW  30
05FBA:  MOVWF  FF6
05FBC:  MOVLW  04
05FBE:  MOVWF  FF7
05FC0:  RCALL  5A1E
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
05FC2:  MOVLW  1D
05FC4:  MOVLB  9
05FC6:  MOVWF  x10
05FC8:  MOVLB  0
05FCA:  RCALL  59B6
....................    fprintf(U1PRINTER,"!"); 
05FCC:  MOVLW  21
05FCE:  MOVLB  9
05FD0:  MOVWF  x10
05FD2:  MOVLB  0
05FD4:  RCALL  59B6
....................    fputc(17, U1PRINTER); 
05FD6:  MOVLW  11
05FD8:  MOVLB  9
05FDA:  MOVWF  x10
05FDC:  MOVLB  0
05FDE:  RCALL  59B6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
05FE0:  MOVLW  0A
05FE2:  MOVLB  9
05FE4:  MOVWF  x10
05FE6:  MOVLB  0
05FE8:  RCALL  59B6
....................    fprintf(U1PRINTER,"%02d/%02d/20%02d %02d:%02d:%02d",day,month,yr,hrs,min,sec); 
05FEA:  MOVFF  270,90A
05FEE:  MOVLW  01
05FF0:  MOVLB  9
05FF2:  MOVWF  x0B
05FF4:  MOVLB  0
05FF6:  RCALL  5A3E
05FF8:  MOVLW  2F
05FFA:  MOVLB  9
05FFC:  MOVWF  x10
05FFE:  MOVLB  0
06000:  RCALL  59B6
06002:  MOVFF  271,90A
06006:  MOVLW  01
06008:  MOVLB  9
0600A:  MOVWF  x0B
0600C:  MOVLB  0
0600E:  RCALL  5A3E
06010:  MOVLW  73
06012:  MOVWF  FF6
06014:  MOVLW  04
06016:  MOVWF  FF7
06018:  MOVLW  03
0601A:  MOVLB  9
0601C:  MOVWF  x0A
0601E:  MOVLB  0
06020:  RCALL  59C6
06022:  MOVFF  272,90A
06026:  MOVLW  01
06028:  MOVLB  9
0602A:  MOVWF  x0B
0602C:  MOVLB  0
0602E:  RCALL  5A3E
06030:  MOVLW  20
06032:  MOVLB  9
06034:  MOVWF  x10
06036:  MOVLB  0
06038:  RCALL  59B6
0603A:  MOVFF  273,90A
0603E:  MOVLW  01
06040:  MOVLB  9
06042:  MOVWF  x0B
06044:  MOVLB  0
06046:  RCALL  5A3E
06048:  MOVLW  3A
0604A:  MOVLB  9
0604C:  MOVWF  x10
0604E:  MOVLB  0
06050:  RCALL  59B6
06052:  MOVFF  274,90A
06056:  MOVLW  01
06058:  MOVLB  9
0605A:  MOVWF  x0B
0605C:  MOVLB  0
0605E:  RCALL  5A3E
06060:  MOVLW  3A
06062:  MOVLB  9
06064:  MOVWF  x10
06066:  MOVLB  0
06068:  RCALL  59B6
0606A:  MOVFF  275,90A
0606E:  MOVLW  01
06070:  MOVLB  9
06072:  MOVWF  x0B
06074:  MOVLB  0
06076:  RCALL  5A3E
....................    LF(); 
06078:  RCALL  5A12
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
0607A:  MOVLW  1D
0607C:  MOVLB  9
0607E:  MOVWF  x10
06080:  MOVLB  0
06082:  RCALL  59B6
....................    fprintf(U1PRINTER,"!"); 
06084:  MOVLW  21
06086:  MOVLB  9
06088:  MOVWF  x10
0608A:  MOVLB  0
0608C:  RCALL  59B6
....................    fputc(0, U1PRINTER); 
0608E:  MOVLB  9
06090:  CLRF   x10
06092:  MOVLB  0
06094:  RCALL  59B6
....................    ///// 
....................    //memset(barra_codi, 0, sizeof(barra_codi));// 
....................    barra1(); 
06096:  BRA    5AFE
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06098:  MOVLW  0A
0609A:  MOVLB  9
0609C:  MOVWF  x10
0609E:  MOVLB  0
060A0:  RCALL  59B6
....................    fprintf(U1PRINTER,"TARIFA:$15 Hora o Fraccion, TOLERANCIA:5 min.  \x0A"); 
060A2:  MOVLW  8A
060A4:  MOVWF  FF6
060A6:  MOVLW  04
060A8:  MOVWF  FF7
060AA:  RCALL  5A1E
....................    fprintf(U1PRINTER,"Horarios:de 8:00 a 21:00hrs. de lunes a viernes\x0A"); 
060AC:  MOVLW  BC
060AE:  MOVWF  FF6
060B0:  MOVLW  04
060B2:  MOVWF  FF7
060B4:  RCALL  5A1E
....................    fprintf(U1PRINTER,"Sabados de 8:00 a 14:00hrs.                    \x0A"); 
060B6:  MOVLW  EE
060B8:  MOVWF  FF6
060BA:  MOVLW  04
060BC:  MOVWF  FF7
060BE:  RCALL  5A1E
....................    //fprintf(U1PRINTER,"ESTA  EMPRESA  Y SUS TRABAJADORES  NO SE  HACEN\x0A"); 
....................    //fprintf(U1PRINTER,"RESPONSABLES  POR  LOS OBJETOS  NO DECLARADOS Y\x0A"); 
....................    //fprintf(U1PRINTER,"MOSTRADOS  PARA  CUSTODIAR  AL  RESPONSABLE  DE\x0A"); 
....................    //fprintf(U1PRINTER,"ELABORAR  EL  BOLETO, Y  NO  SE  ENTREGUE  ESTE\x0A"); 
....................    //fprintf(U1PRINTER,"BOLETO  HASTA  QUE  RECIBA  SU  VEHICULO  A  SU\x0A"); 
....................    //fprintf(U1PRINTER,"ENTERA  SATISFACCION  IMPORTANTE LEA AL REVERSO\x0A"); 
....................    //fprintf(U1PRINTER,"DE ESTE  BOLETO  YA  QUE INDICA  LOS LIMITES DE\x0A"); 
....................    //fprintf(U1PRINTER,"NUESTRA RESPONSABILIDAD                        \x0A"); 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060C0:  MOVLW  0A
060C2:  MOVLB  9
060C4:  MOVWF  x10
060C6:  MOVLB  0
060C8:  RCALL  59B6
....................    //////////////////// 
....................    barra2(); 
060CA:  BRA    5BAC
....................    //////////////////// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060CC:  MOVLW  0A
060CE:  MOVLB  9
060D0:  MOVWF  x10
060D2:  MOVLB  0
060D4:  RCALL  59B6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060D6:  MOVLW  0A
060D8:  MOVLB  9
060DA:  MOVWF  x10
060DC:  MOVLB  0
060DE:  RCALL  59B6
....................    fprintf(U1PRINTER,"\"ACCESA\" automatizacion "); 
060E0:  MOVLW  20
060E2:  MOVWF  FF6
060E4:  MOVLW  05
060E6:  MOVWF  FF7
060E8:  RCALL  5A1E
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060EA:  MOVLW  0A
060EC:  MOVLB  9
060EE:  MOVWF  x10
060F0:  MOVLB  0
060F2:  RCALL  59B6
....................    fprintf(U1PRINTER,"www.accesa.me  automatizacion@accesa.me"); 
060F4:  MOVLW  3A
060F6:  MOVWF  FF6
060F8:  MOVLW  05
060FA:  MOVWF  FF7
060FC:  RCALL  5A1E
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060FE:  MOVLW  0A
06100:  MOVLB  9
06102:  MOVWF  x10
06104:  MOVLB  0
06106:  RCALL  59B6
....................    /////////feed para corte de papel////////////// 
....................    fprintf(U1PRINTER,"\x1B"); 
06108:  MOVLW  1B
0610A:  MOVLB  9
0610C:  MOVWF  x10
0610E:  MOVLB  0
06110:  RCALL  59B6
....................    fprintf(U1PRINTER,"J"); 
06112:  MOVLW  4A
06114:  MOVLB  9
06116:  MOVWF  x10
06118:  MOVLB  0
0611A:  RCALL  59B6
....................    //fputc(190, U1PRINTER); 
....................    fputc(250, U1PRINTER); 
0611C:  MOVLW  FA
0611E:  MOVLB  9
06120:  MOVWF  x10
06122:  MOVLB  0
06124:  RCALL  59B6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación  
06126:  MOVLW  0A
06128:  MOVLB  9
0612A:  MOVWF  x10
0612C:  MOVLB  0
0612E:  RCALL  59B6
....................    LF(); 
06130:  RCALL  5A12
....................    ///////// 
....................    //ESC i 69 Corte total de papel 
....................    //ESC m 6D Corte parcial de papel 
....................    fprintf(U1PRINTER,"\x1B"); 
06132:  MOVLW  1B
06134:  MOVLB  9
06136:  MOVWF  x10
06138:  MOVLB  0
0613A:  RCALL  59B6
....................    fprintf(U1PRINTER,"m"); 
0613C:  MOVLW  6D
0613E:  MOVLB  9
06140:  MOVWF  x10
06142:  MOVLB  0
06144:  RCALL  59B6
06146:  RETURN 0
....................    //////////////////////////////////////// 
.................... } 
....................  
.................... void LF(){ 
.................... fprintf(U1PRINTER,"\x0A"); 
*
05A12:  MOVLW  0A
05A14:  MOVLB  9
05A16:  MOVWF  x10
05A18:  MOVLB  0
05A1A:  RCALL  59B6
05A1C:  RETURN 0
.................... } 
....................  
.................... void CR(){ 
.................... fprintf(U1PRINTER,"\x0D");//enter 
.................... } 
....................  
.................... void barra1(){ 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d",folio,yr,month,day,hrs,min,sec);// 
....................    //sprintf(con_barra,"%08Ld%d",folio,idbar);//01-id de camion 
....................     
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //fprintf(U1PRINTER,"%08Ld/%02d/%02d/%02d/%02d/%02d/%02d/%d/",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi)+2; 
*
05AFE:  MOVLW  02
05B00:  MOVLB  9
05B02:  MOVWF  x0C
05B04:  MOVLW  4E
05B06:  MOVWF  x0B
05B08:  MOVLB  0
05B0A:  RCALL  5636
05B0C:  MOVLW  02
05B0E:  MOVLB  9
05B10:  ADDWF  01,W
05B12:  MOVWF  x0A
....................    //printf (lcd_putc,"\fsize_bar:%u",size_bar); 
....................    //delay_ms(2000); 
.................... //////bar code/////// 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05B14:  MOVLW  62
05B16:  MOVWF  FF6
05B18:  MOVLW  05
05B1A:  MOVWF  FF7
05B1C:  MOVLB  0
05B1E:  RCALL  5A1E
....................    fprintf(U1PRINTER,"\x1D\x77\x01");// 
05B20:  MOVLW  66
05B22:  MOVWF  FF6
05B24:  MOVLW  05
05B26:  MOVWF  FF7
05B28:  RCALL  5A1E
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05B2A:  MOVLW  1D
05B2C:  MOVLB  9
05B2E:  MOVWF  x10
05B30:  MOVLB  0
05B32:  RCALL  59B6
....................    fputc(72,U1PRINTER);// 
05B34:  MOVLW  48
05B36:  MOVLB  9
05B38:  MOVWF  x10
05B3A:  MOVLB  0
05B3C:  RCALL  59B6
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05B3E:  MOVLW  02
05B40:  MOVLB  9
05B42:  MOVWF  x10
05B44:  MOVLB  0
05B46:  RCALL  59B6
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05B48:  MOVLW  1D
05B4A:  MOVLB  9
05B4C:  MOVWF  x10
05B4E:  MOVLB  0
05B50:  RCALL  59B6
....................    fputc(102,U1PRINTER);// 
05B52:  MOVLW  66
05B54:  MOVLB  9
05B56:  MOVWF  x10
05B58:  MOVLB  0
05B5A:  RCALL  59B6
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05B5C:  MOVLW  01
05B5E:  MOVLB  9
05B60:  MOVWF  x10
05B62:  MOVLB  0
05B64:  RCALL  59B6
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05B66:  MOVLW  1D
05B68:  MOVLB  9
05B6A:  MOVWF  x10
05B6C:  MOVLB  0
05B6E:  RCALL  59B6
....................    fputc('k',U1PRINTER); 
05B70:  MOVLW  6B
05B72:  MOVLB  9
05B74:  MOVWF  x10
05B76:  MOVLB  0
05B78:  RCALL  59B6
....................    fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
05B7A:  MOVLW  49
05B7C:  MOVLB  9
05B7E:  MOVWF  x10
05B80:  MOVLB  0
05B82:  RCALL  59B6
....................    //fputc(23,U1PRINTER); //numero de caracteres+2 (solo code128) 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05B84:  MOVFF  90A,910
05B88:  RCALL  59B6
....................    fputc(123,U1PRINTER);// d1 (solo code128) 
05B8A:  MOVLW  7B
05B8C:  MOVLB  9
05B8E:  MOVWF  x10
05B90:  MOVLB  0
05B92:  RCALL  59B6
....................    fputc(65,U1PRINTER); // d2 (solo code128) 
05B94:  MOVLW  41
05B96:  MOVLB  9
05B98:  MOVWF  x10
05B9A:  MOVLB  0
05B9C:  RCALL  59B6
....................     
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05B9E:  MOVLW  02
05BA0:  MOVWF  FEA
05BA2:  MOVLW  4E
05BA4:  MOVWF  FE9
05BA6:  RCALL  59EE
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05BA8:  GOTO   6098 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void barra2(){ 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi); 
05BAC:  MOVLW  02
05BAE:  MOVLB  9
05BB0:  MOVWF  x0C
05BB2:  MOVLW  4E
05BB4:  MOVWF  x0B
05BB6:  MOVLB  0
05BB8:  RCALL  5636
05BBA:  MOVFF  01,90A
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    //CODIGO DE BARRAS 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05BBE:  MOVLW  6A
05BC0:  MOVWF  FF6
05BC2:  MOVLW  05
05BC4:  MOVWF  FF7
05BC6:  RCALL  5A1E
....................    fprintf(U1PRINTER,"\x1D\x77\x01");//setea ancho 
05BC8:  MOVLW  6E
05BCA:  MOVWF  FF6
05BCC:  MOVLW  05
05BCE:  MOVWF  FF7
05BD0:  RCALL  5A1E
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05BD2:  MOVLW  1D
05BD4:  MOVLB  9
05BD6:  MOVWF  x10
05BD8:  MOVLB  0
05BDA:  RCALL  59B6
....................    fputc(72,U1PRINTER);// 
05BDC:  MOVLW  48
05BDE:  MOVLB  9
05BE0:  MOVWF  x10
05BE2:  MOVLB  0
05BE4:  RCALL  59B6
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05BE6:  MOVLW  02
05BE8:  MOVLB  9
05BEA:  MOVWF  x10
05BEC:  MOVLB  0
05BEE:  RCALL  59B6
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05BF0:  MOVLW  1D
05BF2:  MOVLB  9
05BF4:  MOVWF  x10
05BF6:  MOVLB  0
05BF8:  RCALL  59B6
....................    fputc(102,U1PRINTER);// 
05BFA:  MOVLW  66
05BFC:  MOVLB  9
05BFE:  MOVWF  x10
05C00:  MOVLB  0
05C02:  RCALL  59B6
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05C04:  MOVLW  01
05C06:  MOVLB  9
05C08:  MOVWF  x10
05C0A:  MOVLB  0
05C0C:  RCALL  59B6
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05C0E:  MOVLW  1D
05C10:  MOVLB  9
05C12:  MOVWF  x10
05C14:  MOVLB  0
05C16:  RCALL  59B6
....................    fputc('k',U1PRINTER); 
05C18:  MOVLW  6B
05C1A:  MOVLB  9
05C1C:  MOVWF  x10
05C1E:  MOVLB  0
05C20:  RCALL  59B6
....................    fputc(69,U1PRINTER);//69=code39//72=code93//73=code128//70=ITF(solo cantidades pares)// 
05C22:  MOVLW  45
05C24:  MOVLB  9
05C26:  MOVWF  x10
05C28:  MOVLB  0
05C2A:  RCALL  59B6
....................    //fputc(21,U1PRINTER);//numero de caracteres 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05C2C:  MOVFF  90A,910
05C30:  RCALL  59B6
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05C32:  MOVLW  02
05C34:  MOVWF  FEA
05C36:  MOVLW  4E
05C38:  MOVWF  FE9
05C3A:  RCALL  59EE
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05C3C:  GOTO   60CC (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void encri(){ 
....................  int tem; 
....................  //fprintf(U1PRINTER,"con_barra:%Lu\r\n",strlen(con_barra)); 
....................   
....................  for(tem=0;tem<=strlen(con_barra);tem++){ 
....................          if(con_barra[tem]=='0') barra_codi[tem]='5'; 
....................     else if(con_barra[tem]=='1') barra_codi[tem]='7'; 
....................     else if(con_barra[tem]=='2') barra_codi[tem]='8'; 
....................     else if(con_barra[tem]=='3') barra_codi[tem]='2'; 
....................     else if(con_barra[tem]=='4') barra_codi[tem]='9'; 
....................     else if(con_barra[tem]=='5') barra_codi[tem]='0'; 
....................     else if(con_barra[tem]=='6') barra_codi[tem]='6'; 
....................     else if(con_barra[tem]=='7') barra_codi[tem]='4'; 
....................     else if(con_barra[tem]=='8') barra_codi[tem]='1'; 
....................     else if(con_barra[tem]=='9') barra_codi[tem]='3'; 
....................  }//end for 
.................... } 
....................  
.................... ///////////////////// 
.................... void llaves(){ 
....................    int tem; 
....................    char texto[12]; 
....................    ////////////////llaves//////////// 
....................    ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
*
00782:  MOVLW  01
00784:  MOVLB  8
00786:  MOVWF  xF6
00788:  MOVF   xF6,W
0078A:  SUBLW  0E
0078C:  BTFSS  FD8.0
0078E:  BRA    0A4A
....................       switch (tem) { 
00790:  MOVLW  01
00792:  SUBWF  xF6,W
00794:  ADDLW  F2
00796:  BTFSC  FD8.0
00798:  BRA    0948
0079A:  ADDLW  0E
0079C:  MOVLB  0
0079E:  GOTO   0A50
....................            case 1: {// 
....................                strcpy(texto,texto1); 
007A2:  MOVLW  08
007A4:  MOVWF  FEA
007A6:  MOVLW  F7
007A8:  MOVWF  FE9
007AA:  MOVLW  02
007AC:  MOVWF  FE2
007AE:  MOVLW  8D
007B0:  MOVWF  FE1
007B2:  MOVF   FE7,F
007B4:  MOVFF  FE6,FEE
007B8:  BNZ   07B2
....................                break;} 
007BA:  MOVLB  8
007BC:  BRA    0948
007BE:  MOVLB  0
....................            case 2: {// 
....................                strcpy(texto,texto2); 
007C0:  MOVLW  08
007C2:  MOVWF  FEA
007C4:  MOVLW  F7
007C6:  MOVWF  FE9
007C8:  MOVLW  02
007CA:  MOVWF  FE2
007CC:  MOVLW  99
007CE:  MOVWF  FE1
007D0:  MOVF   FE7,F
007D2:  MOVFF  FE6,FEE
007D6:  BNZ   07D0
....................                break;} 
007D8:  MOVLB  8
007DA:  BRA    0948
007DC:  MOVLB  0
....................            case 3: {// 
....................                strcpy(texto,texto3); 
007DE:  MOVLW  08
007E0:  MOVWF  FEA
007E2:  MOVLW  F7
007E4:  MOVWF  FE9
007E6:  MOVLW  02
007E8:  MOVWF  FE2
007EA:  MOVLW  A5
007EC:  MOVWF  FE1
007EE:  MOVF   FE7,F
007F0:  MOVFF  FE6,FEE
007F4:  BNZ   07EE
....................                break;} 
007F6:  MOVLB  8
007F8:  BRA    0948
007FA:  MOVLB  0
....................            case 4: {// 
....................                strcpy(texto,texto4); 
007FC:  MOVLW  08
007FE:  MOVWF  FEA
00800:  MOVLW  F7
00802:  MOVWF  FE9
00804:  MOVLW  02
00806:  MOVWF  FE2
00808:  MOVLW  B1
0080A:  MOVWF  FE1
0080C:  MOVF   FE7,F
0080E:  MOVFF  FE6,FEE
00812:  BNZ   080C
....................                break;} 
00814:  MOVLB  8
00816:  BRA    0948
00818:  MOVLB  0
....................            case 5: {// 
....................                strcpy(texto,texto5); 
0081A:  MOVLW  08
0081C:  MOVWF  FEA
0081E:  MOVLW  F7
00820:  MOVWF  FE9
00822:  MOVLW  02
00824:  MOVWF  FE2
00826:  MOVLW  BD
00828:  MOVWF  FE1
0082A:  MOVF   FE7,F
0082C:  MOVFF  FE6,FEE
00830:  BNZ   082A
....................                break;} 
00832:  MOVLB  8
00834:  BRA    0948
00836:  MOVLB  0
....................            case 6: {// 
....................                strcpy(texto,texto6); 
00838:  MOVLW  08
0083A:  MOVWF  FEA
0083C:  MOVLW  F7
0083E:  MOVWF  FE9
00840:  MOVLW  02
00842:  MOVWF  FE2
00844:  MOVLW  C9
00846:  MOVWF  FE1
00848:  MOVF   FE7,F
0084A:  MOVFF  FE6,FEE
0084E:  BNZ   0848
....................                break;} 
00850:  MOVLB  8
00852:  BRA    0948
00854:  MOVLB  0
....................            case 7: {// 
....................                strcpy(texto,texto7); 
00856:  MOVLW  08
00858:  MOVWF  FEA
0085A:  MOVLW  F7
0085C:  MOVWF  FE9
0085E:  MOVLW  02
00860:  MOVWF  FE2
00862:  MOVLW  D5
00864:  MOVWF  FE1
00866:  MOVF   FE7,F
00868:  MOVFF  FE6,FEE
0086C:  BNZ   0866
....................                break;} 
0086E:  MOVLB  8
00870:  BRA    0948
00872:  MOVLB  0
....................            case 8: {// 
....................                strcpy(texto,texto8); 
00874:  MOVLW  08
00876:  MOVWF  FEA
00878:  MOVLW  F7
0087A:  MOVWF  FE9
0087C:  MOVLW  02
0087E:  MOVWF  FE2
00880:  MOVLW  E1
00882:  MOVWF  FE1
00884:  MOVF   FE7,F
00886:  MOVFF  FE6,FEE
0088A:  BNZ   0884
....................                break;} 
0088C:  MOVLB  8
0088E:  BRA    0948
00890:  MOVLB  0
....................            case 9: {// 
....................                strcpy(texto,texto9); 
00892:  MOVLW  08
00894:  MOVWF  FEA
00896:  MOVLW  F7
00898:  MOVWF  FE9
0089A:  MOVLW  02
0089C:  MOVWF  FE2
0089E:  MOVLW  ED
008A0:  MOVWF  FE1
008A2:  MOVF   FE7,F
008A4:  MOVFF  FE6,FEE
008A8:  BNZ   08A2
....................                break;} 
008AA:  MOVLB  8
008AC:  BRA    0948
008AE:  MOVLB  0
....................            case 10: {// 
....................                strcpy(texto,texto10); 
008B0:  MOVLW  08
008B2:  MOVWF  FEA
008B4:  MOVLW  F7
008B6:  MOVWF  FE9
008B8:  MOVLW  02
008BA:  MOVWF  FE2
008BC:  MOVLW  F9
008BE:  MOVWF  FE1
008C0:  MOVF   FE7,F
008C2:  MOVFF  FE6,FEE
008C6:  BNZ   08C0
....................                break;} 
008C8:  MOVLB  8
008CA:  BRA    0948
008CC:  MOVLB  0
....................            case 11: {// 
....................                strcpy(texto,texto11); 
008CE:  MOVLW  08
008D0:  MOVWF  FEA
008D2:  MOVLW  F7
008D4:  MOVWF  FE9
008D6:  MOVLW  03
008D8:  MOVWF  FE2
008DA:  MOVLW  05
008DC:  MOVWF  FE1
008DE:  MOVF   FE7,F
008E0:  MOVFF  FE6,FEE
008E4:  BNZ   08DE
....................                break;} 
008E6:  MOVLB  8
008E8:  BRA    0948
008EA:  MOVLB  0
....................            case 12: {// 
....................                strcpy(texto,texto12); 
008EC:  MOVLW  08
008EE:  MOVWF  FEA
008F0:  MOVLW  F7
008F2:  MOVWF  FE9
008F4:  MOVLW  03
008F6:  MOVWF  FE2
008F8:  MOVLW  11
008FA:  MOVWF  FE1
008FC:  MOVF   FE7,F
008FE:  MOVFF  FE6,FEE
00902:  BNZ   08FC
....................                break;} 
00904:  MOVLB  8
00906:  BRA    0948
00908:  MOVLB  0
....................            case 13: {// 
....................                strcpy(texto,texto13); 
0090A:  MOVLW  08
0090C:  MOVWF  FEA
0090E:  MOVLW  F7
00910:  MOVWF  FE9
00912:  MOVLW  03
00914:  MOVWF  FE2
00916:  MOVLW  1D
00918:  MOVWF  FE1
0091A:  MOVF   FE7,F
0091C:  MOVFF  FE6,FEE
00920:  BNZ   091A
....................                break;} 
00922:  MOVLB  8
00924:  BRA    0948
00926:  MOVLB  0
....................            case 14: {// 
....................                strcpy(texto,texto14); 
00928:  MOVLW  08
0092A:  MOVWF  FEA
0092C:  MOVLW  F7
0092E:  MOVWF  FE9
00930:  MOVLW  03
00932:  MOVWF  FE2
00934:  MOVLW  29
00936:  MOVWF  FE1
00938:  MOVF   FE7,F
0093A:  MOVFF  FE6,FEE
0093E:  BNZ   0938
....................                break;} 
00940:  MOVLB  8
00942:  BRA    0948
00944:  MOVLB  0
00946:  MOVLB  8
....................       } 
....................       a=i=0; 
00948:  CLRF   41
0094A:  CLRF   40
0094C:  MOVFF  40,1B
....................       while (i < instruccion_size) {  //word_size=8 
00950:  MOVF   41,F
00952:  BNZ   09D4
00954:  MOVF   40,W
00956:  SUBLW  09
00958:  BNC   09D4
....................            memory[i] = read_eeprom( (tem*instruccion_size)+i); 
0095A:  MOVLW  22
0095C:  ADDWF  40,W
0095E:  MOVWF  FE9
00960:  MOVLW  00
00962:  ADDWFC 41,W
00964:  MOVWF  FEA
00966:  MOVF   xF6,W
00968:  MULLW  0A
0096A:  MOVF   FF3,W
0096C:  ADDWF  40,W
0096E:  MOVLB  9
00970:  MOVWF  x05
00972:  MOVLW  00
00974:  ADDWFC 41,W
00976:  MOVWF  x06
00978:  MOVFF  FF2,907
0097C:  BCF    FF2.7
0097E:  MOVFF  906,FAA
00982:  MOVFF  905,FA9
00986:  BCF    FA6.6
00988:  BCF    FA6.7
0098A:  BSF    FA6.0
0098C:  MOVF   FA8,W
0098E:  BTFSC  x07.7
00990:  BSF    FF2.7
00992:  MOVWF  FEF
....................            if (memory[i] != texto[i])  break; 
00994:  MOVLW  22
00996:  ADDWF  40,W
00998:  MOVWF  FE9
0099A:  MOVLW  00
0099C:  ADDWFC 41,W
0099E:  MOVWF  FEA
009A0:  MOVFF  FEF,903
009A4:  MOVLW  F7
009A6:  ADDWF  40,W
009A8:  MOVWF  FE9
009AA:  MOVLW  08
009AC:  ADDWFC 41,W
009AE:  MOVWF  FEA
009B0:  MOVF   FEF,W
009B2:  SUBWF  x03,W
009B4:  BZ    09BC
009B6:  MOVLB  8
009B8:  BRA    09D4
009BA:  MOVLB  9
....................            i++; 
009BC:  INCF   40,F
009BE:  BTFSC  FD8.2
009C0:  INCF   41,F
....................            if (i==instruccion_size) a=1; 
009C2:  MOVF   40,W
009C4:  SUBLW  0A
009C6:  BNZ   09D0
009C8:  MOVF   41,F
009CA:  BNZ   09D0
009CC:  MOVLW  01
009CE:  MOVWF  1B
009D0:  MOVLB  8
009D2:  BRA    0950
....................       } 
....................       //fprintf(U1PRINTER,"\r\n"); 
....................       if (a==0){ 
009D4:  MOVF   1B,F
009D6:  BNZ   0A46
....................          i=0; 
009D8:  CLRF   41
009DA:  CLRF   40
....................          while (texto[i] != 0x00){ 
009DC:  MOVLW  F7
009DE:  ADDWF  40,W
009E0:  MOVWF  FE9
009E2:  MOVLW  08
009E4:  ADDWFC 41,W
009E6:  MOVWF  FEA
009E8:  MOVF   FEF,F
009EA:  BZ    0A46
....................             write_eeprom(i+(tem*instruccion_size),texto[i]); 
009EC:  MOVF   xF6,W
009EE:  MULLW  0A
009F0:  MOVF   FF3,W
009F2:  ADDWF  40,W
009F4:  MOVLB  9
009F6:  MOVWF  x03
009F8:  MOVLW  00
009FA:  ADDWFC 41,W
009FC:  MOVWF  x04
009FE:  MOVLW  F7
00A00:  ADDWF  40,W
00A02:  MOVWF  FE9
00A04:  MOVLW  08
00A06:  ADDWFC 41,W
00A08:  MOVWF  FEA
00A0A:  MOVFF  FEF,905
00A0E:  MOVF   FF2,W
00A10:  MOVWF  00
00A12:  BCF    FF2.7
00A14:  MOVFF  904,FAA
00A18:  MOVFF  903,FA9
00A1C:  MOVFF  905,FA8
00A20:  BCF    FA6.6
00A22:  BCF    FA6.7
00A24:  BSF    FA6.2
00A26:  MOVLB  F
00A28:  MOVLW  55
00A2A:  MOVWF  FA7
00A2C:  MOVLW  AA
00A2E:  MOVWF  FA7
00A30:  BSF    FA6.1
00A32:  BTFSC  FA6.1
00A34:  BRA    0A32
00A36:  BCF    FA6.2
00A38:  MOVF   00,W
00A3A:  IORWF  FF2,F
....................             //fprintf(U1PRINTER,"%c",texto[i]); 
....................             i++; 
00A3C:  INCF   40,F
00A3E:  BTFSC  FD8.2
00A40:  INCF   41,F
00A42:  MOVLB  8
00A44:  BRA    09DC
....................          }//end grabar 
....................       }//END a 
00A46:  INCF   xF6,F
00A48:  BRA    0788
....................    }//end for 
00A4A:  MOVLB  0
00A4C:  GOTO   6E7E (RETURN)
.................... } 
....................  
.................... void rd_eeprom(){ 
.................... n=a=b=0; 
*
061B8:  CLRF   45
061BA:  CLRF   44
061BC:  MOVFF  44,1B
061C0:  CLRF   43
061C2:  MOVFF  1B,42
.................... n=instruccion_size;// 
061C6:  CLRF   43
061C8:  MOVLW  0A
061CA:  MOVWF  42
.................... i=0; 
061CC:  CLRF   41
061CE:  CLRF   40
.................... while ((b <=data_numbers)&&(a==0)){//NUMERO TOTAL DE TARJETAS 
061D0:  MOVF   45,F
061D2:  BNZ   6274
061D4:  MOVF   44,W
061D6:  SUBLW  0E
061D8:  BNC   6274
061DA:  MOVF   1B,F
061DC:  BNZ   6274
....................     i=0; 
061DE:  CLRF   41
061E0:  CLRF   40
....................     b++; 
061E2:  INCF   44,F
061E4:  BTFSC  FD8.2
061E6:  INCF   45,F
....................     while (i < instruccion_size) {//WORD_SIZE_2=10 
061E8:  MOVF   41,F
061EA:  BNZ   6268
061EC:  MOVF   40,W
061EE:  SUBLW  09
061F0:  BNC   6268
....................         memory[i] = read_eeprom(n+i); 
061F2:  MOVLW  22
061F4:  ADDWF  40,W
061F6:  MOVWF  FE9
061F8:  MOVLW  00
061FA:  ADDWFC 41,W
061FC:  MOVWF  FEA
061FE:  MOVF   40,W
06200:  ADDWF  42,W
06202:  MOVLB  8
06204:  MOVWF  xF8
06206:  MOVF   41,W
06208:  ADDWFC 43,W
0620A:  MOVWF  xF9
0620C:  MOVFF  FF2,8FA
06210:  BCF    FF2.7
06212:  MOVFF  8F9,FAA
06216:  MOVFF  8F8,FA9
0621A:  BCF    FA6.6
0621C:  BCF    FA6.7
0621E:  BSF    FA6.0
06220:  MOVF   FA8,W
06222:  BTFSC  xFA.7
06224:  BSF    FF2.7
06226:  MOVWF  FEF
....................         //fprintf(U1PRINTER,"m[%Ld]=%c",i,memory[i]); 
....................         //fprintf(U1PRINTER,"X[%Ld]=%c",i,XX[i]); 
....................         if (memory[i] != XX[i]) 
06228:  MOVLW  22
0622A:  ADDWF  40,W
0622C:  MOVWF  FE9
0622E:  MOVLW  00
06230:  ADDWFC 41,W
06232:  MOVWF  FEA
06234:  MOVFF  FEF,8F6
06238:  MOVLW  52
0623A:  ADDWF  40,W
0623C:  MOVWF  FE9
0623E:  MOVLW  00
06240:  ADDWFC 41,W
06242:  MOVWF  FEA
06244:  MOVF   FEF,W
06246:  SUBWF  xF6,W
06248:  BZ    6250
....................             break; 
0624A:  MOVLB  0
0624C:  BRA    6268
0624E:  MOVLB  8
....................         i++; 
06250:  INCF   40,F
06252:  BTFSC  FD8.2
06254:  INCF   41,F
....................         if (i==instruccion_size) a=1; 
06256:  MOVF   40,W
06258:  SUBLW  0A
0625A:  BNZ   6264
0625C:  MOVF   41,F
0625E:  BNZ   6264
06260:  MOVLW  01
06262:  MOVWF  1B
06264:  MOVLB  0
06266:  BRA    61E8
....................     } 
....................     //fprintf(PRINTER," \r\n"); 
....................     //fprintf(PRINTER," n=%Ld ",n); 
....................     n=n+instruccion_size;//WORD_SIZE=30 
06268:  MOVLW  0A
0626A:  ADDWF  42,F
0626C:  MOVLW  00
0626E:  ADDWFC 43,F
....................     restart_wdt(); 
06270:  CLRWDT
06272:  BRA    61D0
....................     //fprintf(U1PRINTER," \r\n"); 
....................     //fprintf(U1PRINTER,"b=%Ld",b); 
....................     } 
06274:  GOTO   7116 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1E18   PUT NOBROWNOUT BORV21 NOWDT WDT32768
   Word  3: 8000   NOPBADEN NOLPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
