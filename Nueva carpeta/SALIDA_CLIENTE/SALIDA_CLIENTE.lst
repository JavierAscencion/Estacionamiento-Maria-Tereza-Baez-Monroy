CCS PCH C Compiler, Version 5.070, 56587               20-jun.-18 08:27

               Filename:   E:\Google Drive\01 ESTACIONAMIENTOS\MARIA TERESA BAEZ MONROY(matanzo)\SALIDA_CLIENTE\SALIDA_CLIENTE.lst

               ROM used:   30152 bytes (46%)
                           Largest free fragment is 35382
               RAM used:   2299 (69%) at main() level
                           2481 (75%) worst case
               Stack used: 10 locations (9 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   6A92
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0106
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   01AA
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   01C6
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   01FA
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... //2018/06/19 
.................... // Basado en: Programa de ejemplo 10 para comunicarme con el módulo ENC28J60. 
.................... // Cliente TCP. 
.................... // Incluimos las definiciones necesarias de la placa utilizada. 
.................... #include "Plantilla_Inicio.c" 
.................... // Controlador ETHERNET 
.................... // Fecha: 2018/02/19. 
.................... // Versión del compilador: v5.070 
.................... // Versión del programa: v0.1 
.................... // Revisión del programa: 0.00 
.................... // Definimos el microcontrolador utilizado. 
.................... #include <18F4680.h> // Definición de registros internos del PIC18F4520. 
.................... //////////// Standard Header file for the PIC18F4680 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4680 
000D2:  CLRF   FF7
000D4:  ADDLW  E2
000D6:  MOVWF  FF6
000D8:  MOVLW  00
000DA:  ADDWFC FF7,F
000DC:  TBLRD*+
000DE:  MOVF   FF5,W
000E0:  RETURN 0
000E2:  DATA 28,0C
000E4:  DATA 01,06
000E6:  CLRF   FF7
000E8:  ADDLW  F6
000EA:  MOVWF  FF6
000EC:  MOVLW  00
000EE:  ADDWFC FF7,F
000F0:  TBLRD*+
000F2:  MOVF   FF5,W
000F4:  RETURN 0
000F6:  DATA 42,4F
000F8:  DATA 4C,45
000FA:  DATA 54,45
000FC:  DATA 52,41
000FE:  DATA 5F,50
00100:  DATA 41,47
00102:  DATA 41,44
00104:  DATA 4F,00
*
0012A:  DATA 53,6F
0012C:  DATA 6C,69
0012E:  DATA 63,69
00130:  DATA 74,75
00132:  DATA 64,20
00134:  DATA 41,52
00136:  DATA 50,2E
00138:  DATA 20,20
0013A:  DATA 20,20
0013C:  DATA 20,20
0013E:  DATA 00,00
00140:  DATA 43,4F
00142:  DATA 4E,45
00144:  DATA 43,54
00146:  DATA 41,4E
00148:  DATA 44,4F
0014A:  DATA 2E,2E
0014C:  DATA 2E,20
0014E:  DATA 20,20
00150:  DATA 20,20
00152:  DATA 20,20
00154:  DATA 00,00
00156:  DATA 45,72
00158:  DATA 72,6F
0015A:  DATA 72,20
0015C:  DATA 65,6E
0015E:  DATA 20,65
00160:  DATA 6C,20
00162:  DATA 73,6F
00164:  DATA 63,6B
00166:  DATA 65,74
00168:  DATA 2E,20
0016A:  DATA 00,00
0016C:  DATA 43,4F
0016E:  DATA 4E,45
00170:  DATA 43,54
00172:  DATA 41,44
00174:  DATA 4F,20
00176:  DATA 20,20
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 20,20
00180:  DATA 00,00
00182:  DATA 44,45
00184:  DATA 53,43
00186:  DATA 4F,4E
00188:  DATA 45,43
0018A:  DATA 54,41
0018C:  DATA 44,4F
0018E:  DATA 20,20
00190:  DATA 20,20
00192:  DATA 20,20
00194:  DATA 20,00
00196:  DATA 44,45
00198:  DATA 53,43
0019A:  DATA 4F,4E
0019C:  DATA 45,43
0019E:  DATA 54,41
001A0:  DATA 44,4F
001A2:  DATA 20,20
001A4:  DATA 20,20
001A6:  DATA 20,20
001A8:  DATA 20,00
*
0022C:  DATA 0C,49
0022E:  DATA 4E,49
00230:  DATA 43,49
00232:  DATA 41,4E
00234:  DATA 44,4F
00236:  DATA 00,00
00238:  DATA 44,69
0023A:  DATA 61,73
0023C:  DATA 3A,25
0023E:  DATA 75,20
00240:  DATA 50,41
00242:  DATA 47,4F
00244:  DATA 3A,25
00246:  DATA 64,00
00248:  DATA 52,65
0024A:  DATA 73,74
0024C:  DATA 61,6E
0024E:  DATA 3A,25
00250:  DATA 75,20
00252:  DATA 00,00
00254:  DATA 54,49
00256:  DATA 45,4D
00258:  DATA 50,4F
0025A:  DATA 20,44
0025C:  DATA 45,20
0025E:  DATA 50,52
00260:  DATA 55,45
00262:  DATA 42,41
00264:  DATA 00,00
00266:  DATA 20,20
00268:  DATA 48,41
0026A:  DATA 20,45
0026C:  DATA 58,50
0026E:  DATA 49,52
00270:  DATA 41,44
00272:  DATA 4F,20
00274:  DATA 20,20
00276:  DATA 00,00
00278:  DATA 0C,0A
0027A:  DATA 20,20
0027C:  DATA 20,54
0027E:  DATA 4F,4D
00280:  DATA 45,20
00282:  DATA 53,55
00284:  DATA 20,42
00286:  DATA 4F,4C
00288:  DATA 45,54
0028A:  DATA 4F,0A
0028C:  DATA 20,59
0028E:  DATA 20,41
00290:  DATA 56,41
00292:  DATA 4E,43
00294:  DATA 45,20
00296:  DATA 50,4F
00298:  DATA 52,20
0029A:  DATA 46,41
0029C:  DATA 56,4F
0029E:  DATA 52,00
002A0:  DATA 0C,00
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 20,20
002B2:  DATA 20,20
002B4:  DATA 20,20
002B6:  DATA 00,00
002B8:  DATA 20,20
002BA:  DATA 20,25
002BC:  DATA 30,32
002BE:  DATA 64,20
002C0:  DATA 25,30
002C2:  DATA 32,64
002C4:  DATA 20,25
002C6:  DATA 30,32
002C8:  DATA 64,2F
002CA:  DATA 25,30
002CC:  DATA 32,64
002CE:  DATA 2F,25
002D0:  DATA 30,32
002D2:  DATA 64,20
002D4:  DATA 20,20
002D6:  DATA 20,00
002D8:  DATA 20,20
002DA:  DATA 20,25
002DC:  DATA 30,32
002DE:  DATA 64,3A
002E0:  DATA 25,30
002E2:  DATA 32,64
002E4:  DATA 20,25
002E6:  DATA 30,32
002E8:  DATA 64,2F
002EA:  DATA 25,30
002EC:  DATA 32,64
002EE:  DATA 2F,25
002F0:  DATA 30,32
002F2:  DATA 64,20
002F4:  DATA 20,20
002F6:  DATA 20,00
002F8:  DATA 20,20
002FA:  DATA 20,57
002FC:  DATA 57,57
002FE:  DATA 2E,41
00300:  DATA 43,43
00302:  DATA 45,53
00304:  DATA 41,2E
00306:  DATA 4D,45
00308:  DATA 20,20
0030A:  DATA 20,20
0030C:  DATA 00,00
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,41
00316:  DATA 43,43
00318:  DATA 45,53
0031A:  DATA 41,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 20,20
0032A:  DATA 20,20
0032C:  DATA 20,20
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 00,00
0033A:  DATA 20,20
0033C:  DATA 48,6F
0033E:  DATA 72,61
00340:  DATA 20,41
00342:  DATA 63,74
00344:  DATA 75,61
00346:  DATA 6C,69
00348:  DATA 7A,61
0034A:  DATA 64,61
0034C:  DATA 20,20
0034E:  DATA 00,00
00350:  DATA 53,41
00352:  DATA 31,2D
00354:  DATA 25,30
00356:  DATA 38,4C
00358:  DATA 58,00
0035A:  DATA 42,4F
0035C:  DATA 54,4F
0035E:  DATA 4E,5F
00360:  DATA 42,4F
00362:  DATA 4C,45
00364:  DATA 54,4F
00366:  DATA 00,00
00368:  DATA 46,6F
0036A:  DATA 6C,69
0036C:  DATA 6F,3A
0036E:  DATA 25,73
00370:  DATA 00,00
00372:  DATA 4D,41
00374:  DATA 52,49
00376:  DATA 41,20
00378:  DATA 54,45
0037A:  DATA 52,45
0037C:  DATA 53,41
0037E:  DATA 20,42
00380:  DATA 41,45
00382:  DATA 5A,20
00384:  DATA 4D,4F
00386:  DATA 4E,52
00388:  DATA 4F,59
0038A:  DATA 00,00
0038C:  DATA 52,46
0038E:  DATA 43,3A
00390:  DATA 42,41
00392:  DATA 4D,54
00394:  DATA 39,37
00396:  DATA 30,35
00398:  DATA 32,38
0039A:  DATA 38,34
0039C:  DATA 41,0A
0039E:  DATA 00,00
003A0:  DATA 34,20
003A2:  DATA 70,6F
003A4:  DATA 6E,69
003A6:  DATA 65,6E
003A8:  DATA 74,65
003AA:  DATA 20,31
003AC:  DATA 33,30
003AE:  DATA 32,2C
003B0:  DATA 20,63
003B2:  DATA 6F,6C
003B4:  DATA 6F,6E
003B6:  DATA 69,61
003B8:  DATA 20,43
003BA:  DATA 65,6E
003BC:  DATA 74,72
003BE:  DATA 6F,20
003C0:  DATA 20,43
003C2:  DATA 50,20
003C4:  DATA 37,32
003C6:  DATA 30,30
003C8:  DATA 30,0A
003CA:  DATA 50,75
003CC:  DATA 65,62
003CE:  DATA 6C,61
003D0:  DATA 2C,20
003D2:  DATA 50,75
003D4:  DATA 65,62
003D6:  DATA 6C,61
003D8:  DATA 0A,00
003DA:  DATA 25,30
003DC:  DATA 32,64
003DE:  DATA 2F,25
003E0:  DATA 30,32
003E2:  DATA 64,2F
003E4:  DATA 32,30
003E6:  DATA 25,30
003E8:  DATA 32,64
003EA:  DATA 20,25
003EC:  DATA 30,32
003EE:  DATA 64,3A
003F0:  DATA 25,30
003F2:  DATA 32,64
003F4:  DATA 3A,25
003F6:  DATA 30,32
003F8:  DATA 64,00
003FA:  DATA 54,41
003FC:  DATA 52,49
003FE:  DATA 46,41
00400:  DATA 3A,24
00402:  DATA 31,35
00404:  DATA 20,48
00406:  DATA 6F,72
00408:  DATA 61,20
0040A:  DATA 6F,20
0040C:  DATA 46,72
0040E:  DATA 61,63
00410:  DATA 63,69
00412:  DATA 6F,6E
00414:  DATA 2C,20
00416:  DATA 54,4F
00418:  DATA 4C,45
0041A:  DATA 52,41
0041C:  DATA 4E,43
0041E:  DATA 49,41
00420:  DATA 3A,35
00422:  DATA 20,6D
00424:  DATA 69,6E
00426:  DATA 2E,20
00428:  DATA 20,0A
0042A:  DATA 00,00
0042C:  DATA 48,6F
0042E:  DATA 72,61
00430:  DATA 72,69
00432:  DATA 6F,73
00434:  DATA 3A,64
00436:  DATA 65,20
00438:  DATA 38,3A
0043A:  DATA 30,30
0043C:  DATA 20,61
0043E:  DATA 20,32
00440:  DATA 31,3A
00442:  DATA 30,30
00444:  DATA 68,72
00446:  DATA 73,2E
00448:  DATA 20,64
0044A:  DATA 65,20
0044C:  DATA 6C,75
0044E:  DATA 6E,65
00450:  DATA 73,20
00452:  DATA 61,20
00454:  DATA 76,69
00456:  DATA 65,72
00458:  DATA 6E,65
0045A:  DATA 73,0A
0045C:  DATA 00,00
0045E:  DATA 53,61
00460:  DATA 62,61
00462:  DATA 64,6F
00464:  DATA 73,20
00466:  DATA 64,65
00468:  DATA 20,38
0046A:  DATA 3A,30
0046C:  DATA 30,20
0046E:  DATA 61,20
00470:  DATA 31,34
00472:  DATA 3A,30
00474:  DATA 30,68
00476:  DATA 72,73
00478:  DATA 2E,20
0047A:  DATA 20,20
0047C:  DATA 20,20
0047E:  DATA 20,20
00480:  DATA 20,20
00482:  DATA 20,20
00484:  DATA 20,20
00486:  DATA 20,20
00488:  DATA 20,20
0048A:  DATA 20,20
0048C:  DATA 20,0A
0048E:  DATA 00,00
00490:  DATA 22,41
00492:  DATA 43,43
00494:  DATA 45,53
00496:  DATA 41,22
00498:  DATA 20,61
0049A:  DATA 75,74
0049C:  DATA 6F,6D
0049E:  DATA 61,74
004A0:  DATA 69,7A
004A2:  DATA 61,63
004A4:  DATA 69,6F
004A6:  DATA 6E,20
004A8:  DATA 00,00
004AA:  DATA 77,77
004AC:  DATA 77,2E
004AE:  DATA 61,63
004B0:  DATA 63,65
004B2:  DATA 73,61
004B4:  DATA 2E,6D
004B6:  DATA 65,20
004B8:  DATA 20,61
004BA:  DATA 75,74
004BC:  DATA 6F,6D
004BE:  DATA 61,74
004C0:  DATA 69,7A
004C2:  DATA 61,63
004C4:  DATA 69,6F
004C6:  DATA 6E,40
004C8:  DATA 61,63
004CA:  DATA 63,65
004CC:  DATA 73,61
004CE:  DATA 2E,6D
004D0:  DATA 65,00
004D2:  DATA 1D,68
004D4:  DATA 8C,00
004D6:  DATA 1D,77
004D8:  DATA 01,00
004DA:  DATA 1D,68
004DC:  DATA 8C,00
004DE:  DATA 1D,77
004E0:  DATA 01,00
004E2:  DATA 0D,0A
004E4:  DATA 52,45
004E6:  DATA 49,4E
004E8:  DATA 49,43
004EA:  DATA 49,4F
004EC:  DATA 2D,57
004EE:  DATA 44,00
004F0:  DATA 0D,0A
004F2:  DATA 52,45
004F4:  DATA 49,4E
004F6:  DATA 49,43
004F8:  DATA 49,4F
004FA:  DATA 2D,4D
004FC:  DATA 43,4C
004FE:  DATA 52,00
00500:  DATA 0D,0A
00502:  DATA 52,45
00504:  DATA 49,4E
00506:  DATA 49,43
00508:  DATA 49,4F
0050A:  DATA 2D,56
0050C:  DATA 4F,4C
0050E:  DATA 54,41
00510:  DATA 4A,45
00512:  DATA 5F,42
00514:  DATA 41,4A
00516:  DATA 4F,00
00518:  DATA 0D,0A
0051A:  DATA 50,4F
0051C:  DATA 57,45
0051E:  DATA 52,5F
00520:  DATA 55,50
00522:  DATA 00,00
*
00694:  TBLRD*+
00696:  MOVF   FF5,F
00698:  BZ    06B2
0069A:  MOVFF  FF6,8F9
0069E:  MOVFF  FF7,8FA
006A2:  MOVFF  FF5,8FC
006A6:  RCALL  0630
006A8:  MOVFF  8F9,FF6
006AC:  MOVFF  8FA,FF7
006B0:  BRA    0694
006B2:  RETURN 0
*
00A06:  ADDWF  FE8,W
00A08:  CLRF   FF7
00A0A:  RLCF   FF7,F
00A0C:  ADDLW  21
00A0E:  MOVWF  FF6
00A10:  MOVLW  0A
00A12:  ADDWFC FF7,F
00A14:  TBLRD*-
00A16:  MOVF   FF5,W
00A18:  MOVWF  FFA
00A1A:  TBLRD*
00A1C:  MOVF   FF5,W
00A1E:  MOVWF  FF9
00A20:  DATA 58,07
00A22:  DATA 76,07
00A24:  DATA 94,07
00A26:  DATA B2,07
00A28:  DATA D0,07
00A2A:  DATA EE,07
00A2C:  DATA 0C,08
00A2E:  DATA 2A,08
00A30:  DATA 48,08
00A32:  DATA 66,08
00A34:  DATA 84,08
00A36:  DATA A2,08
00A38:  DATA C0,08
00A3A:  DATA DE,08
*
00FBC:  MOVLB  9
00FBE:  MOVF   x46,W
00FC0:  MULWF  x48
00FC2:  MOVFF  FF3,01
00FC6:  MOVFF  FF4,00
00FCA:  MULWF  x49
00FCC:  MOVF   FF3,W
00FCE:  ADDWF  00,F
00FD0:  MOVF   x47,W
00FD2:  MULWF  x48
00FD4:  MOVF   FF3,W
00FD6:  ADDWFC 00,W
00FD8:  MOVWF  02
00FDA:  MOVLB  0
00FDC:  RETURN 0
*
00FF2:  MOVLB  9
00FF4:  CLRF   x01
00FF6:  CLRF   x02
00FF8:  MOVLW  01
00FFA:  MOVWF  x03
00FFC:  CLRF   FDA
00FFE:  CLRF   FD9
01000:  MOVLW  08
01002:  MOVWF  x06
01004:  MOVLW  F9
01006:  MOVWF  x05
01008:  MOVLW  08
0100A:  MOVWF  FEA
0100C:  MOVLW  FD
0100E:  MOVWF  FE9
01010:  MOVFF  906,FE2
01014:  MOVFF  905,FE1
01018:  MOVFF  903,904
0101C:  BCF    FD8.0
0101E:  MOVF   FE5,W
01020:  MULWF  FEE
01022:  MOVF   FF3,W
01024:  ADDWFC x01,F
01026:  MOVF   FF4,W
01028:  ADDWFC x02,F
0102A:  DECFSZ x04,F
0102C:  BRA    101C
0102E:  MOVFF  901,FDE
01032:  MOVFF  902,901
01036:  CLRF   x02
01038:  BTFSC  FD8.0
0103A:  INCF   x02,F
0103C:  INCF   x05,F
0103E:  BTFSC  FD8.2
01040:  INCF   x06,F
01042:  INCF   x03,F
01044:  MOVF   x03,W
01046:  SUBLW  05
01048:  BNZ   1008
0104A:  MOVLB  0
0104C:  GOTO   10BE (RETURN)
01050:  CLRF   01
01052:  CLRF   02
01054:  CLRF   00
01056:  CLRF   03
01058:  MOVLB  9
0105A:  MOVF   x0B,W
0105C:  BNZ   1062
0105E:  MOVF   x0A,W
01060:  BZ    1092
01062:  MOVLW  10
01064:  MOVWF  x0C
01066:  BCF    FD8.0
01068:  RLCF   x08,F
0106A:  RLCF   x09,F
0106C:  RLCF   00,F
0106E:  RLCF   03,F
01070:  MOVF   x0B,W
01072:  SUBWF  03,W
01074:  BNZ   107A
01076:  MOVF   x0A,W
01078:  SUBWF  00,W
0107A:  BNC   108A
0107C:  MOVF   x0A,W
0107E:  SUBWF  00,F
01080:  BTFSS  FD8.0
01082:  DECF   03,F
01084:  MOVF   x0B,W
01086:  SUBWF  03,F
01088:  BSF    FD8.0
0108A:  RLCF   01,F
0108C:  RLCF   02,F
0108E:  DECFSZ x0C,F
01090:  BRA    1066
01092:  MOVLB  0
01094:  RETURN 0
*
0150E:  TBLRD*+
01510:  MOVFF  FF6,8F8
01514:  MOVFF  FF7,8F9
01518:  MOVFF  FF5,8FC
0151C:  CALL   0630
01520:  MOVFF  8F8,FF6
01524:  MOVFF  8F9,FF7
01528:  MOVLB  8
0152A:  DECFSZ xF7,F
0152C:  BRA    1530
0152E:  BRA    1534
01530:  MOVLB  0
01532:  BRA    150E
01534:  MOVLB  0
01536:  RETURN 0
01538:  MOVLB  9
0153A:  MOVF   x11,W
0153C:  CLRF   01
0153E:  SUBWF  x10,W
01540:  BC    1548
01542:  MOVFF  910,00
01546:  BRA    1560
01548:  CLRF   00
0154A:  MOVLW  08
0154C:  MOVWF  x12
0154E:  RLCF   x10,F
01550:  RLCF   00,F
01552:  MOVF   x11,W
01554:  SUBWF  00,W
01556:  BTFSC  FD8.0
01558:  MOVWF  00
0155A:  RLCF   01,F
0155C:  DECFSZ x12,F
0155E:  BRA    154E
01560:  MOVLB  0
01562:  RETURN 0
01564:  MOVF   01,W
01566:  MOVFF  8F7,910
0156A:  MOVLW  64
0156C:  MOVLB  9
0156E:  MOVWF  x11
01570:  MOVLB  0
01572:  RCALL  1538
01574:  MOVFF  00,8F7
01578:  MOVF   01,W
0157A:  MOVLW  30
0157C:  BNZ   158E
0157E:  MOVLB  8
01580:  BTFSS  xF8.1
01582:  BRA    15A2
01584:  BTFSC  xF8.3
01586:  BRA    15A2
01588:  BTFSC  xF8.4
0158A:  MOVLW  20
0158C:  BRA    1596
0158E:  MOVLB  8
01590:  BCF    xF8.3
01592:  BCF    xF8.4
01594:  BSF    xF8.0
01596:  ADDWF  01,F
01598:  MOVFF  01,8FC
0159C:  MOVLB  0
0159E:  CALL   0630
015A2:  MOVFF  8F7,910
015A6:  MOVLW  0A
015A8:  MOVLB  9
015AA:  MOVWF  x11
015AC:  MOVLB  0
015AE:  RCALL  1538
015B0:  MOVFF  00,8F7
015B4:  MOVF   01,W
015B6:  MOVLW  30
015B8:  BNZ   15CA
015BA:  MOVLB  8
015BC:  BTFSC  xF8.3
015BE:  BRA    15D6
015C0:  BTFSS  xF8.0
015C2:  BRA    15D6
015C4:  BTFSC  xF8.4
015C6:  MOVLW  20
015C8:  MOVLB  0
015CA:  ADDWF  01,F
015CC:  MOVFF  01,8FC
015D0:  CALL   0630
015D4:  MOVLB  8
015D6:  MOVLW  30
015D8:  ADDWF  xF7,F
015DA:  MOVFF  8F7,8FC
015DE:  MOVLB  0
015E0:  CALL   0630
015E4:  RETURN 0
015E6:  MOVLW  20
015E8:  MOVLB  8
015EA:  BTFSS  xF7.4
015EC:  MOVLW  30
015EE:  MOVWF  xF8
015F0:  MOVFF  8F6,00
015F4:  BTFSS  xF6.7
015F6:  BRA    1608
015F8:  COMF   00,F
015FA:  INCF   00,F
015FC:  MOVFF  00,8F6
01600:  MOVLW  2D
01602:  MOVWF  xF8
01604:  BSF    xF7.7
01606:  BSF    xF7.0
01608:  MOVF   01,W
0160A:  MOVFF  8F6,910
0160E:  MOVLW  64
01610:  MOVLB  9
01612:  MOVWF  x11
01614:  MOVLB  0
01616:  RCALL  1538
01618:  MOVFF  00,8F6
0161C:  MOVLW  30
0161E:  ADDWF  01,W
01620:  MOVLB  8
01622:  MOVWF  xF9
01624:  MOVFF  8F6,910
01628:  MOVLW  0A
0162A:  MOVLB  9
0162C:  MOVWF  x11
0162E:  MOVLB  0
01630:  RCALL  1538
01632:  MOVLW  30
01634:  ADDWF  00,W
01636:  MOVLB  8
01638:  MOVWF  xFB
0163A:  MOVLW  30
0163C:  ADDWF  01,W
0163E:  MOVWF  xFA
01640:  MOVFF  8F8,00
01644:  MOVLW  30
01646:  SUBWF  xF9,W
01648:  BZ    1652
0164A:  BSF    xF7.1
0164C:  BTFSC  xF7.7
0164E:  BSF    xF7.2
01650:  BRA    1676
01652:  MOVFF  8F8,8F9
01656:  MOVLW  20
01658:  MOVWF  xF8
0165A:  MOVLW  30
0165C:  SUBWF  xFA,W
0165E:  BZ    1668
01660:  BSF    xF7.0
01662:  BTFSC  xF7.7
01664:  BSF    xF7.1
01666:  BRA    1676
01668:  BTFSS  FD8.2
0166A:  BSF    xF7.0
0166C:  BNZ   1676
0166E:  MOVFF  8F9,8FA
01672:  MOVLW  20
01674:  MOVWF  xF9
01676:  BTFSC  xF7.2
01678:  BRA    1684
0167A:  BTFSC  xF7.1
0167C:  BRA    168E
0167E:  BTFSC  xF7.0
01680:  BRA    1698
01682:  BRA    16A2
01684:  MOVFF  8F8,8FC
01688:  MOVLB  0
0168A:  CALL   0630
0168E:  MOVFF  8F9,8FC
01692:  MOVLB  0
01694:  CALL   0630
01698:  MOVFF  8FA,8FC
0169C:  MOVLB  0
0169E:  CALL   0630
016A2:  MOVFF  8FB,8FC
016A6:  MOVLB  0
016A8:  CALL   0630
016AC:  GOTO   6D58 (RETURN)
*
016C0:  TBLRD*+
016C2:  MOVF   FF5,F
016C4:  BZ    16DE
016C6:  MOVFF  FF6,90B
016CA:  MOVFF  FF7,90C
016CE:  MOVFF  FF5,910
016D2:  RCALL  16B0
016D4:  MOVFF  90B,FF6
016D8:  MOVFF  90C,FF7
016DC:  BRA    16C0
016DE:  RETURN 0
*
044A2:  ADDWF  FE8,W
044A4:  CLRF   FF7
044A6:  RLCF   FF7,F
044A8:  ADDLW  BD
044AA:  MOVWF  FF6
044AC:  MOVLW  44
044AE:  ADDWFC FF7,F
044B0:  TBLRD*-
044B2:  MOVF   FF5,W
044B4:  MOVWF  FFA
044B6:  TBLRD*
044B8:  MOVF   FF5,W
044BA:  MOVWF  FF9
044BC:  DATA 3A,42
044BE:  DATA 42,42
044C0:  DATA 8A,42
044C2:  DATA 2A,43
044C4:  DATA 56,43
044C6:  DATA 56,43
044C8:  DATA 66,43
044CA:  DATA 76,43
044CC:  DATA 8A,43
*
04682:  ADDWF  FE8,W
04684:  CLRF   FF7
04686:  RLCF   FF7,F
04688:  ADDLW  9D
0468A:  MOVWF  FF6
0468C:  MOVLW  46
0468E:  ADDWFC FF7,F
04690:  TBLRD*-
04692:  MOVF   FF5,W
04694:  MOVWF  FFA
04696:  TBLRD*
04698:  MOVF   FF5,W
0469A:  MOVWF  FF9
0469C:  DATA E4,44
0469E:  DATA E4,44
046A0:  DATA 3C,45
046A2:  DATA CC,45
046A4:  DATA 2C,46
046A6:  DATA 2A,45
046A8:  DATA 9E,45
*
05646:  ADDWF  FE8,W
05648:  CLRF   FF7
0564A:  RLCF   FF7,F
0564C:  ADDLW  61
0564E:  MOVWF  FF6
05650:  MOVLW  56
05652:  ADDWFC FF7,F
05654:  TBLRD*-
05656:  MOVF   FF5,W
05658:  MOVWF  FFA
0565A:  TBLRD*
0565C:  MOVF   FF5,W
0565E:  MOVWF  FF9
05660:  DATA 22,53
05662:  DATA 5E,53
05664:  DATA 92,53
05666:  DATA 38,54
05668:  DATA 9E,54
0566A:  DATA 3C,55
0566C:  DATA 6C,55
0566E:  DATA 06,56
*
056B8:  MOVFF  8F4,FEA
056BC:  MOVFF  8F3,FE9
056C0:  MOVLB  8
056C2:  MOVFF  8F9,FEF
056C6:  INCF   FE9,F
056C8:  BTFSC  FD8.2
056CA:  INCF   FEA,F
056CC:  CLRF   FEF
056CE:  INCF   xF3,F
056D0:  BTFSC  FD8.2
056D2:  INCF   xF4,F
056D4:  MOVLB  0
056D6:  RETURN 0
056D8:  MOVLB  8
056DA:  BTFSC  xF7.7
056DC:  BRA    5700
056DE:  MOVLW  0F
056E0:  MOVWF  00
056E2:  SWAPF  xF6,W
056E4:  ANDWF  00,F
056E6:  MOVLW  0A
056E8:  SUBWF  00,W
056EA:  BC    56F2
056EC:  MOVLW  30
056EE:  ADDWF  00,F
056F0:  BRA    56F6
056F2:  MOVF   xF7,W
056F4:  ADDWF  00,F
056F6:  MOVFF  00,8F9
056FA:  MOVLB  0
056FC:  RCALL  56B8
056FE:  MOVLB  8
05700:  MOVLW  0F
05702:  ANDWF  xF6,F
05704:  MOVLW  0A
05706:  SUBWF  xF6,W
05708:  BC    570E
0570A:  MOVLW  30
0570C:  BRA    5712
0570E:  BCF    xF7.7
05710:  MOVF   xF7,W
05712:  ADDWF  xF6,F
05714:  MOVFF  8F6,8F9
05718:  MOVLB  0
0571A:  RCALL  56B8
0571C:  RETURN 0
0571E:  TBLRD*+
05720:  MOVFF  FF6,8F7
05724:  MOVFF  FF7,8F8
05728:  MOVFF  FF5,8F9
0572C:  RCALL  56B8
0572E:  MOVFF  8F7,FF6
05732:  MOVFF  8F8,FF7
05736:  MOVLB  8
05738:  DECFSZ xF6,F
0573A:  BRA    573E
0573C:  BRA    5742
0573E:  MOVLB  0
05740:  BRA    571E
05742:  MOVLB  0
05744:  GOTO   5826 (RETURN)
05748:  TSTFSZ 01
0574A:  BRA    5752
0574C:  TSTFSZ 02
0574E:  BRA    5754
05750:  BRA    5760
05752:  INCF   02,F
05754:  MOVFF  00,FEE
05758:  DECFSZ 01,F
0575A:  BRA    5754
0575C:  DECFSZ 02,F
0575E:  BRA    5754
05760:  RETURN 0
*
05AB0:  TBLRD*+
05AB2:  MOVFF  FF6,90B
05AB6:  MOVFF  FF7,90C
05ABA:  MOVFF  FF5,910
05ABE:  CALL   16B0
05AC2:  MOVFF  90B,FF6
05AC6:  MOVFF  90C,FF7
05ACA:  MOVLB  9
05ACC:  DECFSZ x0A,F
05ACE:  BRA    5AD2
05AD0:  BRA    5AD6
05AD2:  MOVLB  0
05AD4:  BRA    5AB0
05AD6:  MOVLB  0
05AD8:  RETURN 0
05ADA:  MOVF   FEF,F
05ADC:  BZ    5AFE
05ADE:  MOVFF  FEA,90C
05AE2:  MOVFF  FE9,90B
05AE6:  MOVFF  FEF,910
05AEA:  CALL   16B0
05AEE:  MOVFF  90C,FEA
05AF2:  MOVFF  90B,FE9
05AF6:  INCF   FE9,F
05AF8:  BTFSC  FD8.2
05AFA:  INCF   FEA,F
05AFC:  BRA    5ADA
05AFE:  RETURN 0
*
05B0E:  MOVLW  20
05B10:  MOVLB  9
05B12:  BTFSS  x0B.4
05B14:  MOVLW  30
05B16:  MOVWF  x0C
05B18:  MOVFF  90A,00
05B1C:  BTFSS  x0A.7
05B1E:  BRA    5B30
05B20:  COMF   00,F
05B22:  INCF   00,F
05B24:  MOVFF  00,90A
05B28:  MOVLW  2D
05B2A:  MOVWF  x0C
05B2C:  BSF    x0B.7
05B2E:  BSF    x0B.0
05B30:  MOVF   01,W
05B32:  MOVFF  90A,910
05B36:  MOVLW  64
05B38:  MOVWF  x11
05B3A:  MOVLB  0
05B3C:  CALL   1538
05B40:  MOVFF  00,90A
05B44:  MOVLW  30
05B46:  ADDWF  01,W
05B48:  MOVLB  9
05B4A:  MOVWF  x0D
05B4C:  MOVFF  90A,910
05B50:  MOVLW  0A
05B52:  MOVWF  x11
05B54:  MOVLB  0
05B56:  CALL   1538
05B5A:  MOVLW  30
05B5C:  ADDWF  00,W
05B5E:  MOVLB  9
05B60:  MOVWF  x0F
05B62:  MOVLW  30
05B64:  ADDWF  01,W
05B66:  MOVWF  x0E
05B68:  MOVFF  90C,00
05B6C:  MOVLW  30
05B6E:  SUBWF  x0D,W
05B70:  BZ    5B7A
05B72:  BSF    x0B.1
05B74:  BTFSC  x0B.7
05B76:  BSF    x0B.2
05B78:  BRA    5B9E
05B7A:  BTFSC  x0B.2
05B7C:  BRA    5B9E
05B7E:  MOVFF  90C,90D
05B82:  BTFSC  x0B.1
05B84:  BRA    5B8E
05B86:  MOVLW  30
05B88:  SUBWF  x0E,W
05B8A:  BZ    5B94
05B8C:  BSF    x0B.0
05B8E:  BTFSC  x0B.7
05B90:  BSF    x0B.1
05B92:  BRA    5B9E
05B94:  BTFSS  FD8.2
05B96:  BSF    x0B.0
05B98:  BTFSC  FD8.2
05B9A:  MOVFF  90D,90E
05B9E:  BTFSC  x0B.2
05BA0:  BRA    5BAC
05BA2:  BTFSC  x0B.1
05BA4:  BRA    5BB6
05BA6:  BTFSC  x0B.0
05BA8:  BRA    5BC0
05BAA:  BRA    5BCA
05BAC:  MOVFF  90C,910
05BB0:  MOVLB  0
05BB2:  CALL   16B0
05BB6:  MOVFF  90D,910
05BBA:  MOVLB  0
05BBC:  CALL   16B0
05BC0:  MOVFF  90E,910
05BC4:  MOVLB  0
05BC6:  CALL   16B0
05BCA:  MOVFF  90F,910
05BCE:  MOVLB  0
05BD0:  CALL   16B0
05BD4:  RETURN 0
*
069A6:  MOVLW  20
069A8:  MOVLB  8
069AA:  BTFSS  xF7.4
069AC:  MOVLW  30
069AE:  MOVWF  xF8
069B0:  MOVFF  8F6,00
069B4:  BTFSS  xF6.7
069B6:  BRA    69C8
069B8:  COMF   00,F
069BA:  INCF   00,F
069BC:  MOVFF  00,8F6
069C0:  MOVLW  2D
069C2:  MOVWF  xF8
069C4:  BSF    xF7.7
069C6:  BSF    xF7.0
069C8:  MOVF   01,W
069CA:  MOVFF  8F6,910
069CE:  MOVLW  64
069D0:  MOVLB  9
069D2:  MOVWF  x11
069D4:  MOVLB  0
069D6:  CALL   1538
069DA:  MOVFF  00,8F6
069DE:  MOVLW  30
069E0:  ADDWF  01,W
069E2:  MOVLB  8
069E4:  MOVWF  xF9
069E6:  MOVFF  8F6,910
069EA:  MOVLW  0A
069EC:  MOVLB  9
069EE:  MOVWF  x11
069F0:  MOVLB  0
069F2:  CALL   1538
069F6:  MOVLW  30
069F8:  ADDWF  00,W
069FA:  MOVLB  8
069FC:  MOVWF  xFB
069FE:  MOVLW  30
06A00:  ADDWF  01,W
06A02:  MOVWF  xFA
06A04:  MOVFF  8F8,00
06A08:  MOVLW  30
06A0A:  SUBWF  xF9,W
06A0C:  BZ    6A16
06A0E:  BSF    xF7.1
06A10:  BTFSC  xF7.7
06A12:  BSF    xF7.2
06A14:  BRA    6A3A
06A16:  BTFSC  xF7.2
06A18:  BRA    6A3A
06A1A:  MOVFF  8F8,8F9
06A1E:  BTFSC  xF7.1
06A20:  BRA    6A2A
06A22:  MOVLW  30
06A24:  SUBWF  xFA,W
06A26:  BZ    6A30
06A28:  BSF    xF7.0
06A2A:  BTFSC  xF7.7
06A2C:  BSF    xF7.1
06A2E:  BRA    6A3A
06A30:  BTFSS  FD8.2
06A32:  BSF    xF7.0
06A34:  BTFSC  FD8.2
06A36:  MOVFF  8F9,8FA
06A3A:  BTFSC  xF7.2
06A3C:  BRA    6A48
06A3E:  BTFSC  xF7.1
06A40:  BRA    6A52
06A42:  BTFSC  xF7.0
06A44:  BRA    6A5C
06A46:  BRA    6A66
06A48:  MOVFF  8F8,8FC
06A4C:  MOVLB  0
06A4E:  CALL   0630
06A52:  MOVFF  8F9,8FC
06A56:  MOVLB  0
06A58:  CALL   0630
06A5C:  MOVFF  8FA,8FC
06A60:  MOVLB  0
06A62:  CALL   0630
06A66:  MOVFF  8FB,8FC
06A6A:  MOVLB  0
06A6C:  CALL   0630
06A70:  RETURN 0
....................  
.................... #list 
....................  
.................... // Conversor de 10 bits con justificación a la derecha. 
.................... //#device ADC=10 
.................... // Configuramos velocidad de operación. 
.................... #use delay(clock=40000000) // Trabajamos a 20.00Mhz.  
*
005B2:  MOVLW  08
005B4:  MOVWF  FEA
005B6:  MOVLW  FD
005B8:  MOVWF  FE9
005BA:  MOVF   FEF,W
005BC:  BZ    05DA
005BE:  MOVLW  0C
005C0:  MOVWF  01
005C2:  CLRF   00
005C4:  DECFSZ 00,F
005C6:  BRA    05C4
005C8:  DECFSZ 01,F
005CA:  BRA    05C2
005CC:  MOVLW  F7
005CE:  MOVWF  00
005D0:  DECFSZ 00,F
005D2:  BRA    05D0
005D4:  BRA    05D6
005D6:  DECFSZ FEF,F
005D8:  BRA    05BE
005DA:  RETURN 0
.................... // Configuramos fusibles de programación. 
.................... //#FUSES NOWDT                    // No utilizamos el perro guardían. 
.................... #FUSES WDT4096 
.................... #FUSES H4                       // Oscilador de alta velocidad 40Mhz. 
.................... #FUSES FCMEN                    // Monitor de reloj activado. 
.................... #FUSES PUT                      // Temporizador de encendido. 
.................... #FUSES NOBROWNOUT               // No activamos el reset por bajo voltaje. 
.................... #FUSES NOPBADEN                 // Deshabilitamos el módulo conversor ADC del puerto B. 
.................... #FUSES NOLPT1OSC                // Timer 1 configurado para una alta potencia de operación. 
.................... //#FUSES NOMCLR                   // Pin Master Clear deshabilitado. 
.................... #FUSES MCLR                     // Pin Master Clear habilitado. 
.................... #FUSES STVREN                   // Si se rebalsa o llena el stack el microcontrolador se resetea. 
.................... #FUSES NOLVP                    // No utilizamos bajo voltaje para programación. 
.................... #FUSES NOXINST                  // Set de instruccciones ampliado, desactivado. 
.................... #FUSES NODEBUG                  // No utilizamos código para debug. 
.................... #FUSES PROTECT                  // Código protejido contra lecturas. 
.................... #FUSES NOCPB                    // Sector de booteo no protejido. 
.................... #FUSES NOCPD                    // Sin protección de código en la EEPROM. 
.................... #FUSES NOWRT                    // Memoria de programa no protejida contra escrituras. 
.................... #FUSES NOWRTC                   // Registros de configuración no protegido contra escritura. 
.................... #FUSES NOWRTB                   // Bloque de booteo no protejido contra escritura. 
.................... #FUSES NOWRTD                   // Memoria EEPROM no protejida contra escritura. 
.................... #FUSES NOEBTR                   // Memoria no protejida contra lectuas de tablas de memoria. 
.................... #FUSES NOEBTRB                  // Bloque de booteo no protejido contra lectura de tablas de memoria. 
....................  
.................... // Configuramos los puertos RS232 utilizados. 
.................... #use RS232(uart1, baud=38400,RESTART_WDT,stream=U1PRINTER,TIMEOUT=40,DISABLE_INTS) 
*
016B0:  CLRWDT
016B2:  BTFSS  F9E.4
016B4:  BRA    16B0
016B6:  MOVLB  9
016B8:  MOVFF  910,FAD
016BC:  MOVLB  0
016BE:  RETURN 0
....................  
.................... const int data_set=14;//CANTIDAD DE INSTRUCCIONES GRABADAS 
.................... const int port_size=90; 
.................... const int tag_size = 8; 
.................... const int word_size_reg =12;//TAMAÑO DE REGISTRO 
.................... const int16 lim_reg=300; 
.................... const int16 data_numbers_ext=2000;//maximo de tags en eeprom 
.................... const int instruccion_size = 10; 
....................  
.................... int envia_pc,a,b2,relay1,tcp_recibe,time_relay1,falla_grabar,f_graba; 
.................... char memory[30]; 
.................... int16 i,n,b,c_envia; 
.................... int size_tx_tcp,con_activas; 
.................... unsigned int16 m,dir; 
....................  
.................... int edo_str, reintento_envio,inicializado,socket2; 
.................... char XX[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RECIBIDOS DE TCP) 
.................... char YY[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RESPALDO EN RAM) 
.................... char txtcp[port_size];//ARREGLO DE TRANSMICION 
.................... char rxtcp[port_size];//1536->112 tags,se direcciona mal la ram con valores mas grandes 
.................... //500-alcanza para 54 tags, mas no alcanza la ram, 700au cabe 
.................... char lcd_men[port_size-10]; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size=26;//34;// 
.................... int deteccion_nulo,pre_cuenta; 
.................... int wieg,wigmal,tecla; 
.................... int sub_indice=0; 
.................... int wieg_full=0; 
.................... int wiegand_cuenta; 
.................... unsigned int32 deci; 
.................... char data[wieg_size]; 
.................... char con_barra[30],barra_codi[30]; 
.................... int32 folio; 
.................... const int idbar=1; 
.................... const int data_numbers=14; 
.................... //RELOJ/CALENDARIO 
.................... int day,month,yr,hrs,min,sec,dow,puntos,cambio_msj; 
.................... int dias_prueba,dia_temp,pago,cuenta,espera,hrs2; 
.................... int16 mes2,dia; 
.................... const int dia_limite=90; 
.................... //variables de entradas 
.................... int en1,en2,en3,en4,en5,flag_pluma; 
.................... //boleto 
.................... int time_boleto,re_bol,cta_lcd; 
.................... // Definimos macros hardware: 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00524:  MOVLB  9
00526:  BTFSC  x04.0
00528:  BRA    052E
0052A:  BCF    F89.4
0052C:  BRA    0530
0052E:  BSF    F89.4
00530:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00532:  BTFSC  x04.1
00534:  BRA    053A
00536:  BCF    F89.2
00538:  BRA    053C
0053A:  BSF    F89.2
0053C:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
0053E:  BTFSC  x04.2
00540:  BRA    0546
00542:  BCF    F89.1
00544:  BRA    0548
00546:  BSF    F89.1
00548:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0054A:  BTFSC  x04.3
0054C:  BRA    0552
0054E:  BCF    F89.0
00550:  BRA    0554
00552:  BSF    F89.0
00554:  BCF    F92.0
....................  
....................  delay_cycles(1);  
00556:  NOP   
....................  output_high(LCD_E);  
00558:  BCF    F92.3
0055A:  BSF    F89.3
....................  delay_us(2);  
0055C:  MOVLW  06
0055E:  MOVWF  00
00560:  DECFSZ 00,F
00562:  BRA    0560
00564:  NOP   
....................  output_low(LCD_E);  
00566:  BCF    F92.3
00568:  BCF    F89.3
0056A:  MOVLB  0
0056C:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
0056E:  BCF    F96.2
00570:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
00572:  MOVLW  C7
00574:  MOVWF  00
00576:  DECFSZ 00,F
00578:  BRA    0576
0057A:  BRA    057C
.................... #endif  
....................  
.................... if(address)  
0057C:  MOVLB  9
0057E:  MOVF   x01,F
00580:  BZ    0588
....................    output_high(LCD_RS);  
00582:  BCF    F96.2
00584:  BSF    F8D.2
00586:  BRA    058C
.................... else  
....................    output_low(LCD_RS);  
00588:  BCF    F96.2
0058A:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0058C:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0058E:  BCF    F92.3
00590:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
00592:  SWAPF  x02,W
00594:  MOVWF  x03
00596:  MOVLW  0F
00598:  ANDWF  x03,F
0059A:  MOVFF  903,904
0059E:  MOVLB  0
005A0:  RCALL  0524
.................... lcd_send_nibble(n & 0xf);  
005A2:  MOVLB  9
005A4:  MOVF   x02,W
005A6:  ANDLW  0F
005A8:  MOVWF  x03
005AA:  MOVWF  x04
005AC:  MOVLB  0
005AE:  RCALL  0524
005B0:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
*
006BC:  MOVLW  01
006BE:  MOVLB  2
006C0:  MOVWF  x8C
....................  
....................    output_low(LCD_RS);  
006C2:  BCF    F96.2
006C4:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
006C6:  BCF    F92.3
006C8:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
006CA:  MOVLW  23
006CC:  MOVLB  8
006CE:  MOVWF  xFD
006D0:  MOVLB  0
006D2:  RCALL  05B2
....................  
....................    for(i=0 ;i < 3; i++)  
006D4:  MOVLB  8
006D6:  CLRF   xF6
006D8:  MOVF   xF6,W
006DA:  SUBLW  02
006DC:  BNC   06F8
....................    {  
....................       lcd_send_nibble(0x03);  
006DE:  MOVLW  03
006E0:  MOVLB  9
006E2:  MOVWF  x04
006E4:  MOVLB  0
006E6:  RCALL  0524
....................       delay_ms(5);  
006E8:  MOVLW  05
006EA:  MOVLB  8
006EC:  MOVWF  xFD
006EE:  MOVLB  0
006F0:  RCALL  05B2
006F2:  MOVLB  8
006F4:  INCF   xF6,F
006F6:  BRA    06D8
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
006F8:  MOVLW  02
006FA:  MOVLB  9
006FC:  MOVWF  x04
006FE:  MOVLB  0
00700:  RCALL  0524
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00702:  MOVLB  8
00704:  CLRF   xF6
00706:  MOVF   xF6,W
00708:  SUBLW  03
0070A:  BNC   0732
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
0070C:  CLRF   03
0070E:  MOVF   xF6,W
00710:  MOVLB  0
00712:  RCALL  00D2
00714:  MOVLB  8
00716:  MOVWF  xF7
00718:  MOVLB  9
0071A:  CLRF   x01
0071C:  MOVWF  x02
0071E:  MOVLB  0
00720:  RCALL  056E
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
00722:  MOVLW  05
00724:  MOVLB  8
00726:  MOVWF  xFD
00728:  MOVLB  0
0072A:  RCALL  05B2
....................       #endif  
0072C:  MOVLB  8
0072E:  INCF   xF6,F
00730:  BRA    0706
....................    }  
00732:  MOVLB  0
00734:  GOTO   6C34 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
005DC:  MOVLB  8
005DE:  MOVF   xFE,W
005E0:  XORLW  01
005E2:  MOVLB  0
005E4:  BZ    05F4
005E6:  XORLW  03
005E8:  BZ    05FA
005EA:  XORLW  01
005EC:  BZ    0602
005EE:  XORLW  07
005F0:  BZ    060A
005F2:  BRA    0614
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
005F4:  MOVLB  8
005F6:  CLRF   xFF
....................      break;  
005F8:  BRA    0618
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
005FA:  MOVLW  40
005FC:  MOVLB  8
005FE:  MOVWF  xFF
....................      break;  
00600:  BRA    0618
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
00602:  MOVLW  14
00604:  MOVLB  8
00606:  MOVWF  xFF
....................      break;  
00608:  BRA    0618
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0060A:  MOVLW  54
0060C:  MOVLB  8
0060E:  MOVWF  xFF
....................      break;  
00610:  BRA    0618
00612:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
00614:  MOVLB  8
00616:  CLRF   xFF
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
00618:  MOVLW  01
0061A:  SUBWF  xFD,W
0061C:  ADDWF  xFF,F
.................... lcd_send_byte(0, 0x80 | address);  
0061E:  MOVF   xFF,W
00620:  IORLW  80
00622:  MOVLB  9
00624:  MOVWF  x00
00626:  CLRF   x01
00628:  MOVWF  x02
0062A:  MOVLB  0
0062C:  RCALL  056E
0062E:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
00630:  MOVLB  8
00632:  MOVF   xFC,W
00634:  XORLW  0C
00636:  MOVLB  0
00638:  BZ    0644
0063A:  XORLW  06
0063C:  BZ    0662
0063E:  XORLW  02
00640:  BZ    0676
00642:  BRA    0684
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
00644:  MOVLB  9
00646:  CLRF   x01
00648:  MOVLW  01
0064A:  MOVWF  x02
0064C:  MOVLB  0
0064E:  RCALL  056E
....................       lcd_line = 1;  
00650:  MOVLW  01
00652:  MOVLB  2
00654:  MOVWF  x8C
....................       delay_ms(2);  
00656:  MOVLW  02
00658:  MOVLB  8
0065A:  MOVWF  xFD
0065C:  MOVLB  0
0065E:  RCALL  05B2
....................       break;  
00660:  BRA    0692
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
00662:  MOVLB  2
00664:  INCF   x8C,F
00666:  MOVLW  01
00668:  MOVLB  8
0066A:  MOVWF  xFD
0066C:  MOVFF  28C,8FE
00670:  MOVLB  0
00672:  RCALL  05DC
....................        break;  
00674:  BRA    0692
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
00676:  MOVLB  9
00678:  CLRF   x01
0067A:  MOVLW  10
0067C:  MOVWF  x02
0067E:  MOVLB  0
00680:  RCALL  056E
....................        break;  
00682:  BRA    0692
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
00684:  MOVLW  01
00686:  MOVLB  9
00688:  MOVWF  x01
0068A:  MOVFF  8FC,902
0068E:  MOVLB  0
00690:  RCALL  056E
....................        break;  
....................    }  
00692:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_SEGUINT.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B5//PIN_B7 
.................... #define EEPROM_SCL  PIN_B4//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
0127E:  MOVLW  08
01280:  MOVWF  01
01282:  MOVLW  0E
01284:  MOVWF  00
01286:  DECFSZ 00,F
01288:  BRA    1286
0128A:  BCF    F8A.4
0128C:  BCF    F93.4
0128E:  MOVLW  0E
01290:  MOVWF  00
01292:  DECFSZ 00,F
01294:  BRA    1292
01296:  MOVLB  9
01298:  RLCF   x0C,F
0129A:  BCF    F8A.5
0129C:  BTFSC  FD8.0
0129E:  BSF    F93.5
012A0:  BTFSS  FD8.0
012A2:  BCF    F93.5
012A4:  BSF    F93.4
012A6:  BTFSS  F81.4
012A8:  BRA    12A6
012AA:  DECFSZ 01,F
012AC:  BRA    12B0
012AE:  BRA    12B4
012B0:  MOVLB  0
012B2:  BRA    1282
012B4:  MOVLW  0E
012B6:  MOVWF  00
012B8:  DECFSZ 00,F
012BA:  BRA    12B8
012BC:  BCF    F8A.4
012BE:  BCF    F93.4
012C0:  NOP   
012C2:  BSF    F93.5
012C4:  MOVLW  0E
012C6:  MOVWF  00
012C8:  DECFSZ 00,F
012CA:  BRA    12C8
012CC:  MOVLW  0E
012CE:  MOVWF  00
012D0:  DECFSZ 00,F
012D2:  BRA    12D0
012D4:  BSF    F93.4
012D6:  BTFSS  F81.4
012D8:  BRA    12D6
012DA:  CLRF   01
012DC:  MOVLW  0E
012DE:  MOVWF  00
012E0:  DECFSZ 00,F
012E2:  BRA    12E0
012E4:  BTFSC  F81.5
012E6:  BSF    01.0
012E8:  BCF    F8A.4
012EA:  BCF    F93.4
012EC:  BCF    F8A.5
012EE:  BCF    F93.5
012F0:  MOVLB  0
012F2:  RETURN 0
012F4:  MOVLW  08
012F6:  MOVLB  9
012F8:  MOVWF  x0A
012FA:  MOVFF  00,90B
012FE:  BSF    F93.5
01300:  MOVLW  0E
01302:  MOVWF  00
01304:  DECFSZ 00,F
01306:  BRA    1304
01308:  BSF    F93.4
0130A:  BTFSS  F81.4
0130C:  BRA    130A
0130E:  BTFSC  F81.5
01310:  BSF    FD8.0
01312:  BTFSS  F81.5
01314:  BCF    FD8.0
01316:  RLCF   01,F
01318:  MOVLW  0E
0131A:  MOVWF  00
0131C:  DECFSZ 00,F
0131E:  BRA    131C
01320:  BCF    F93.4
01322:  BCF    F8A.4
01324:  DECFSZ x0A,F
01326:  BRA    12FE
01328:  BSF    F93.5
0132A:  MOVLW  0E
0132C:  MOVWF  00
0132E:  DECFSZ 00,F
01330:  BRA    132E
01332:  BCF    F8A.5
01334:  MOVF   x0B,W
01336:  BTFSS  FD8.2
01338:  BCF    F93.5
0133A:  NOP   
0133C:  BSF    F93.4
0133E:  BTFSS  F81.4
01340:  BRA    133E
01342:  MOVLW  0E
01344:  MOVWF  00
01346:  DECFSZ 00,F
01348:  BRA    1346
0134A:  BCF    F8A.4
0134C:  BCF    F93.4
0134E:  MOVLW  0E
01350:  MOVWF  00
01352:  DECFSZ 00,F
01354:  BRA    1352
01356:  BCF    F8A.5
01358:  BCF    F93.5
0135A:  MOVLB  0
0135C:  GOTO   13DA (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
006B4:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
006B6:  BSF    F93.5
006B8:  GOTO   6C30 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data){ 
....................    short int status; 
....................    i2c_start(); 
*
01408:  BSF    F93.5
0140A:  MOVLW  0E
0140C:  MOVWF  00
0140E:  DECFSZ 00,F
01410:  BRA    140E
01412:  BSF    F93.4
01414:  MOVLW  0E
01416:  MOVWF  00
01418:  DECFSZ 00,F
0141A:  BRA    1418
0141C:  BCF    F8A.5
0141E:  BCF    F93.5
01420:  MOVLW  0E
01422:  MOVWF  00
01424:  DECFSZ 00,F
01426:  BRA    1424
01428:  BCF    F8A.4
0142A:  BCF    F93.4
....................    i2c_write(0xa0); 
0142C:  MOVLW  A0
0142E:  MOVLB  9
01430:  MOVWF  x0C
01432:  MOVLB  0
01434:  RCALL  127E
....................    i2c_write(address>>8); 
01436:  MOVFF  907,90A
0143A:  MOVLB  9
0143C:  CLRF   x0B
0143E:  MOVFF  907,90C
01442:  MOVLB  0
01444:  RCALL  127E
....................    i2c_write(address); 
01446:  MOVFF  906,90C
0144A:  RCALL  127E
....................    i2c_write(data); 
0144C:  MOVFF  908,90C
01450:  RCALL  127E
....................    i2c_stop(); 
01452:  BCF    F93.5
01454:  NOP   
01456:  BSF    F93.4
01458:  BTFSS  F81.4
0145A:  BRA    1458
0145C:  MOVLW  0E
0145E:  MOVWF  00
01460:  DECFSZ 00,F
01462:  BRA    1460
01464:  BRA    1466
01466:  NOP   
01468:  BSF    F93.5
0146A:  MOVLW  0E
0146C:  MOVWF  00
0146E:  DECFSZ 00,F
01470:  BRA    146E
....................    i2c_start(); 
01472:  BSF    F93.5
01474:  MOVLW  0E
01476:  MOVWF  00
01478:  DECFSZ 00,F
0147A:  BRA    1478
0147C:  BSF    F93.4
0147E:  MOVLW  0E
01480:  MOVWF  00
01482:  DECFSZ 00,F
01484:  BRA    1482
01486:  BCF    F8A.5
01488:  BCF    F93.5
0148A:  MOVLW  0E
0148C:  MOVWF  00
0148E:  DECFSZ 00,F
01490:  BRA    148E
01492:  BCF    F8A.4
01494:  BCF    F93.4
....................    status=i2c_write(0xa0); 
01496:  MOVLW  A0
01498:  MOVLB  9
0149A:  MOVWF  x0C
0149C:  MOVLB  0
0149E:  RCALL  127E
014A0:  MOVF   01,W
014A2:  MOVLB  9
014A4:  BCF    x09.0
014A6:  BTFSC  01.0
014A8:  BSF    x09.0
....................    while(status==1) 
014AA:  BTFSS  x09.0
014AC:  BRA    14EA
....................    { 
....................    i2c_start(); 
014AE:  BSF    F93.5
014B0:  MOVLW  0E
014B2:  MOVWF  00
014B4:  DECFSZ 00,F
014B6:  BRA    14B4
014B8:  BSF    F93.4
014BA:  MOVLW  0E
014BC:  MOVWF  00
014BE:  DECFSZ 00,F
014C0:  BRA    14BE
014C2:  BTFSS  F81.4
014C4:  BRA    14C2
014C6:  BCF    F8A.5
014C8:  BCF    F93.5
014CA:  MOVLW  0E
014CC:  MOVWF  00
014CE:  DECFSZ 00,F
014D0:  BRA    14CE
014D2:  BCF    F8A.4
014D4:  BCF    F93.4
....................    status=i2c_write(0xa0); 
014D6:  MOVLW  A0
014D8:  MOVWF  x0C
014DA:  MOVLB  0
014DC:  RCALL  127E
014DE:  MOVF   01,W
014E0:  MOVLB  9
014E2:  BCF    x09.0
014E4:  BTFSC  01.0
014E6:  BSF    x09.0
014E8:  BRA    14AA
....................    } 
....................    i2c_stop(); 
014EA:  BCF    F93.5
014EC:  NOP   
014EE:  BSF    F93.4
014F0:  BTFSS  F81.4
014F2:  BRA    14F0
014F4:  MOVLW  0E
014F6:  MOVWF  00
014F8:  DECFSZ 00,F
014FA:  BRA    14F8
014FC:  BRA    14FE
014FE:  NOP   
01500:  BSF    F93.5
01502:  MOVLW  0E
01504:  MOVWF  00
01506:  DECFSZ 00,F
01508:  BRA    1506
0150A:  MOVLB  0
0150C:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
01360:  BSF    F93.5
01362:  MOVLW  0E
01364:  MOVWF  00
01366:  DECFSZ 00,F
01368:  BRA    1366
0136A:  BSF    F93.4
0136C:  MOVLW  0E
0136E:  MOVWF  00
01370:  DECFSZ 00,F
01372:  BRA    1370
01374:  BCF    F8A.5
01376:  BCF    F93.5
01378:  MOVLW  0E
0137A:  MOVWF  00
0137C:  DECFSZ 00,F
0137E:  BRA    137C
01380:  BCF    F8A.4
01382:  BCF    F93.4
....................    i2c_write(0xa0); 
01384:  MOVLW  A0
01386:  MOVLB  9
01388:  MOVWF  x0C
0138A:  MOVLB  0
0138C:  RCALL  127E
....................    i2c_write(address>>8); 
0138E:  MOVFF  907,909
01392:  MOVLB  9
01394:  CLRF   x0A
01396:  MOVFF  907,90C
0139A:  MOVLB  0
0139C:  RCALL  127E
....................    i2c_write(address); 
0139E:  MOVFF  906,90C
013A2:  RCALL  127E
....................    i2c_start(); 
013A4:  BSF    F93.5
013A6:  MOVLW  0E
013A8:  MOVWF  00
013AA:  DECFSZ 00,F
013AC:  BRA    13AA
013AE:  BSF    F93.4
013B0:  MOVLW  0E
013B2:  MOVWF  00
013B4:  DECFSZ 00,F
013B6:  BRA    13B4
013B8:  BTFSS  F81.4
013BA:  BRA    13B8
013BC:  BCF    F8A.5
013BE:  BCF    F93.5
013C0:  MOVLW  0E
013C2:  MOVWF  00
013C4:  DECFSZ 00,F
013C6:  BRA    13C4
013C8:  BCF    F8A.4
013CA:  BCF    F93.4
....................    i2c_write(0xa1); 
013CC:  MOVLW  A1
013CE:  MOVLB  9
013D0:  MOVWF  x0C
013D2:  MOVLB  0
013D4:  RCALL  127E
....................    data=i2c_read(0); 
013D6:  CLRF   00
013D8:  BRA    12F4
013DA:  MOVFF  01,908
....................    i2c_stop(); 
013DE:  BCF    F93.5
013E0:  NOP   
013E2:  BSF    F93.4
013E4:  BTFSS  F81.4
013E6:  BRA    13E4
013E8:  MOVLW  0E
013EA:  MOVWF  00
013EC:  DECFSZ 00,F
013EE:  BRA    13EC
013F0:  BRA    13F2
013F2:  NOP   
013F4:  BSF    F93.5
013F6:  MOVLW  0E
013F8:  MOVWF  00
013FA:  DECFSZ 00,F
013FC:  BRA    13FA
....................    return(data); 
013FE:  MOVLB  9
01400:  MOVFF  908,01
01404:  MOVLB  0
01406:  RETURN 0
.................... } 
....................  
.................... #include "ds1307_3.c" //reloj 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_D6 
.................... #define RTC_SCL  PIN_E1 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
059A6:  MOVLW  08
059A8:  MOVWF  01
059AA:  MOVLW  0E
059AC:  MOVWF  00
059AE:  DECFSZ 00,F
059B0:  BRA    59AE
059B2:  BCF    F8D.1
059B4:  BCF    F96.1
059B6:  MOVLW  0E
059B8:  MOVWF  00
059BA:  DECFSZ 00,F
059BC:  BRA    59BA
059BE:  MOVLB  9
059C0:  RLCF   x0E,F
059C2:  BCF    F8C.6
059C4:  BTFSC  FD8.0
059C6:  BSF    F95.6
059C8:  BTFSS  FD8.0
059CA:  BCF    F95.6
059CC:  BSF    F96.1
059CE:  BTFSS  F84.1
059D0:  BRA    59CE
059D2:  DECFSZ 01,F
059D4:  BRA    59D8
059D6:  BRA    59DC
059D8:  MOVLB  0
059DA:  BRA    59AA
059DC:  MOVLW  0E
059DE:  MOVWF  00
059E0:  DECFSZ 00,F
059E2:  BRA    59E0
059E4:  BCF    F8D.1
059E6:  BCF    F96.1
059E8:  NOP   
059EA:  BSF    F95.6
059EC:  MOVLW  0E
059EE:  MOVWF  00
059F0:  DECFSZ 00,F
059F2:  BRA    59F0
059F4:  MOVLW  0E
059F6:  MOVWF  00
059F8:  DECFSZ 00,F
059FA:  BRA    59F8
059FC:  BSF    F96.1
059FE:  BTFSS  F84.1
05A00:  BRA    59FE
05A02:  CLRF   01
05A04:  MOVLW  0E
05A06:  MOVWF  00
05A08:  DECFSZ 00,F
05A0A:  BRA    5A08
05A0C:  BTFSC  F83.6
05A0E:  BSF    01.0
05A10:  BCF    F8D.1
05A12:  BCF    F96.1
05A14:  BCF    F8C.6
05A16:  BCF    F95.6
05A18:  MOVLB  0
05A1A:  RETURN 0
05A1C:  MOVLW  08
05A1E:  MOVLB  9
05A20:  MOVWF  x0F
05A22:  MOVFF  00,910
05A26:  BSF    F95.6
05A28:  MOVLW  0E
05A2A:  MOVWF  00
05A2C:  DECFSZ 00,F
05A2E:  BRA    5A2C
05A30:  BSF    F96.1
05A32:  BTFSS  F84.1
05A34:  BRA    5A32
05A36:  BTFSC  F83.6
05A38:  BSF    FD8.0
05A3A:  BTFSS  F83.6
05A3C:  BCF    FD8.0
05A3E:  RLCF   01,F
05A40:  MOVLW  0E
05A42:  MOVWF  00
05A44:  DECFSZ 00,F
05A46:  BRA    5A44
05A48:  BCF    F96.1
05A4A:  BCF    F8D.1
05A4C:  DECFSZ x0F,F
05A4E:  BRA    5A26
05A50:  BSF    F95.6
05A52:  MOVLW  0E
05A54:  MOVWF  00
05A56:  DECFSZ 00,F
05A58:  BRA    5A56
05A5A:  BCF    F8C.6
05A5C:  MOVF   x10,W
05A5E:  BTFSS  FD8.2
05A60:  BCF    F95.6
05A62:  NOP   
05A64:  BSF    F96.1
05A66:  BTFSS  F84.1
05A68:  BRA    5A66
05A6A:  MOVLW  0E
05A6C:  MOVWF  00
05A6E:  DECFSZ 00,F
05A70:  BRA    5A6E
05A72:  BCF    F8D.1
05A74:  BCF    F96.1
05A76:  MOVLW  0E
05A78:  MOVWF  00
05A7A:  DECFSZ 00,F
05A7C:  BRA    5A7A
05A7E:  BCF    F8C.6
05A80:  BCF    F95.6
05A82:  MOVLB  0
05A84:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
....................  
.................... }  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
*
0637C:  MOVLB  9
0637E:  BCF    x0C.7
....................   hr &= 0x3F;  
06380:  MOVLW  3F
06382:  ANDWF  x0A,F
....................  
....................   i2c_start();  
06384:  BSF    F95.6
06386:  MOVLW  0E
06388:  MOVWF  00
0638A:  DECFSZ 00,F
0638C:  BRA    638A
0638E:  BSF    F96.1
06390:  MOVLW  0E
06392:  MOVWF  00
06394:  DECFSZ 00,F
06396:  BRA    6394
06398:  BCF    F8C.6
0639A:  BCF    F95.6
0639C:  MOVLW  0E
0639E:  MOVWF  00
063A0:  DECFSZ 00,F
063A2:  BRA    63A0
063A4:  BCF    F8D.1
063A6:  BCF    F96.1
....................   i2c_write(0xD0);            // I2C write address  
063A8:  MOVLW  D0
063AA:  MOVWF  x0E
063AC:  MOVLB  0
063AE:  CALL   59A6
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
063B2:  MOVLB  9
063B4:  CLRF   x0E
063B6:  MOVLB  0
063B8:  CALL   59A6
....................   i2c_write(bin2bcd(sec));      // REG 0  
063BC:  MOVFF  90C,90D
063C0:  RCALL  6354
063C2:  MOVFF  01,90D
063C6:  MOVFF  01,90E
063CA:  CALL   59A6
....................   i2c_write(bin2bcd(min));      // REG 1  
063CE:  MOVFF  90B,90D
063D2:  RCALL  6354
063D4:  MOVFF  01,90D
063D8:  MOVFF  01,90E
063DC:  CALL   59A6
....................   i2c_write(bin2bcd(hr));      // REG 2  
063E0:  MOVFF  90A,90D
063E4:  RCALL  6354
063E6:  MOVFF  01,90D
063EA:  MOVFF  01,90E
063EE:  CALL   59A6
....................   i2c_write(bin2bcd(dow));      // REG 3  
063F2:  MOVFF  909,90D
063F6:  RCALL  6354
063F8:  MOVFF  01,90D
063FC:  MOVFF  01,90E
06400:  CALL   59A6
....................   i2c_write(bin2bcd(day));      // REG 4  
06404:  MOVFF  906,90D
06408:  RCALL  6354
0640A:  MOVFF  01,90D
0640E:  MOVFF  01,90E
06412:  CALL   59A6
....................   i2c_write(bin2bcd(mth));      // REG 5  
06416:  MOVFF  907,90D
0641A:  RCALL  6354
0641C:  MOVFF  01,90D
06420:  MOVFF  01,90E
06424:  CALL   59A6
....................   i2c_write(bin2bcd(year));      // REG 6  
06428:  MOVFF  908,90D
0642C:  RCALL  6354
0642E:  MOVFF  01,90D
06432:  MOVFF  01,90E
06436:  CALL   59A6
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
0643A:  MOVLW  80
0643C:  MOVLB  9
0643E:  MOVWF  x0E
06440:  MOVLB  0
06442:  CALL   59A6
....................   i2c_stop();  
06446:  BCF    F95.6
06448:  NOP   
0644A:  BSF    F96.1
0644C:  BTFSS  F84.1
0644E:  BRA    644C
06450:  MOVLW  0E
06452:  MOVWF  00
06454:  DECFSZ 00,F
06456:  BRA    6454
06458:  BRA    645A
0645A:  NOP   
0645C:  BSF    F95.6
0645E:  MOVLW  0E
06460:  MOVWF  00
06462:  DECFSZ 00,F
06464:  BRA    6462
06466:  RETURN 0
.................... }  
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
*
05D4C:  BSF    F95.6
05D4E:  MOVLW  0E
05D50:  MOVWF  00
05D52:  DECFSZ 00,F
05D54:  BRA    5D52
05D56:  BSF    F96.1
05D58:  MOVLW  0E
05D5A:  MOVWF  00
05D5C:  DECFSZ 00,F
05D5E:  BRA    5D5C
05D60:  BCF    F8C.6
05D62:  BCF    F95.6
05D64:  MOVLW  0E
05D66:  MOVWF  00
05D68:  DECFSZ 00,F
05D6A:  BRA    5D68
05D6C:  BCF    F8D.1
05D6E:  BCF    F96.1
*
066F0:  BSF    F95.6
066F2:  MOVLW  0E
066F4:  MOVWF  00
066F6:  DECFSZ 00,F
066F8:  BRA    66F6
066FA:  BSF    F96.1
066FC:  MOVLW  0E
066FE:  MOVWF  00
06700:  DECFSZ 00,F
06702:  BRA    6700
06704:  BCF    F8C.6
06706:  BCF    F95.6
06708:  MOVLW  0E
0670A:  MOVWF  00
0670C:  DECFSZ 00,F
0670E:  BRA    670C
06710:  BCF    F8D.1
06712:  BCF    F96.1
*
0725E:  BSF    F95.6
07260:  MOVLW  0E
07262:  MOVWF  00
07264:  DECFSZ 00,F
07266:  BRA    7264
07268:  BSF    F96.1
0726A:  MOVLW  0E
0726C:  MOVWF  00
0726E:  DECFSZ 00,F
07270:  BRA    726E
07272:  BCF    F8C.6
07274:  BCF    F95.6
07276:  MOVLW  0E
07278:  MOVWF  00
0727A:  DECFSZ 00,F
0727C:  BRA    727A
0727E:  BCF    F8D.1
07280:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05D70:  MOVLW  D0
05D72:  MOVLB  9
05D74:  MOVWF  x0E
05D76:  MOVLB  0
05D78:  RCALL  59A6
*
06714:  MOVLW  D0
06716:  MOVWF  x0E
06718:  MOVLB  0
0671A:  CALL   59A6
*
07282:  MOVLW  D0
07284:  MOVLB  9
07286:  MOVWF  x0E
07288:  MOVLB  0
0728A:  CALL   59A6
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
*
05D7A:  MOVLW  03
05D7C:  MOVLB  9
05D7E:  MOVWF  x0E
05D80:  MOVLB  0
05D82:  RCALL  59A6
*
0671E:  MOVLW  03
06720:  MOVLB  9
06722:  MOVWF  x0E
06724:  MOVLB  0
06726:  CALL   59A6
*
0728E:  MOVLW  03
07290:  MOVLB  9
07292:  MOVWF  x0E
07294:  MOVLB  0
07296:  CALL   59A6
....................   i2c_start();  
*
05D84:  BSF    F95.6
05D86:  MOVLW  0E
05D88:  MOVWF  00
05D8A:  DECFSZ 00,F
05D8C:  BRA    5D8A
05D8E:  BSF    F96.1
05D90:  MOVLW  0E
05D92:  MOVWF  00
05D94:  DECFSZ 00,F
05D96:  BRA    5D94
05D98:  BTFSS  F84.1
05D9A:  BRA    5D98
05D9C:  BCF    F8C.6
05D9E:  BCF    F95.6
05DA0:  MOVLW  0E
05DA2:  MOVWF  00
05DA4:  DECFSZ 00,F
05DA6:  BRA    5DA4
05DA8:  BCF    F8D.1
05DAA:  BCF    F96.1
*
0672A:  BSF    F95.6
0672C:  MOVLW  0E
0672E:  MOVWF  00
06730:  DECFSZ 00,F
06732:  BRA    6730
06734:  BSF    F96.1
06736:  MOVLW  0E
06738:  MOVWF  00
0673A:  DECFSZ 00,F
0673C:  BRA    673A
0673E:  BTFSS  F84.1
06740:  BRA    673E
06742:  BCF    F8C.6
06744:  BCF    F95.6
06746:  MOVLW  0E
06748:  MOVWF  00
0674A:  DECFSZ 00,F
0674C:  BRA    674A
0674E:  BCF    F8D.1
06750:  BCF    F96.1
*
0729A:  BSF    F95.6
0729C:  MOVLW  0E
0729E:  MOVWF  00
072A0:  DECFSZ 00,F
072A2:  BRA    72A0
072A4:  BSF    F96.1
072A6:  MOVLW  0E
072A8:  MOVWF  00
072AA:  DECFSZ 00,F
072AC:  BRA    72AA
072AE:  BTFSS  F84.1
072B0:  BRA    72AE
072B2:  BCF    F8C.6
072B4:  BCF    F95.6
072B6:  MOVLW  0E
072B8:  MOVWF  00
072BA:  DECFSZ 00,F
072BC:  BRA    72BA
072BE:  BCF    F8D.1
072C0:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05DAC:  MOVLW  D1
05DAE:  MOVLB  9
05DB0:  MOVWF  x0E
05DB2:  MOVLB  0
05DB4:  RCALL  59A6
*
06752:  MOVLW  D1
06754:  MOVLB  9
06756:  MOVWF  x0E
06758:  MOVLB  0
0675A:  CALL   59A6
*
072C2:  MOVLW  D1
072C4:  MOVLB  9
072C6:  MOVWF  x0E
072C8:  MOVLB  0
072CA:  CALL   59A6
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
*
05DB6:  MOVLW  01
05DB8:  MOVWF  00
05DBA:  RCALL  5A1C
05DBC:  MOVF   01,W
05DBE:  ANDLW  7F
05DC0:  MOVLB  9
05DC2:  MOVWF  x0A
05DC4:  MOVWF  x0F
05DC6:  MOVLB  0
05DC8:  RCALL  5A86
05DCA:  MOVFF  01,276
*
0675E:  MOVLW  01
06760:  MOVWF  00
06762:  CALL   5A1C
06766:  MOVF   01,W
06768:  ANDLW  7F
0676A:  MOVLB  9
0676C:  MOVWF  x0A
0676E:  MOVWF  x0F
06770:  MOVLB  0
06772:  CALL   5A86
06776:  MOVFF  01,276
*
072CE:  MOVLW  01
072D0:  MOVWF  00
072D2:  CALL   5A1C
072D6:  MOVF   01,W
072D8:  ANDLW  7F
072DA:  MOVLB  9
072DC:  MOVWF  x0A
072DE:  MOVWF  x0F
072E0:  MOVLB  0
072E2:  CALL   5A86
072E6:  MOVFF  01,276
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
*
05DCE:  MOVLW  01
05DD0:  MOVWF  00
05DD2:  RCALL  5A1C
05DD4:  MOVF   01,W
05DD6:  ANDLW  3F
05DD8:  MOVLB  9
05DDA:  MOVWF  x0A
05DDC:  MOVWF  x0F
05DDE:  MOVLB  0
05DE0:  RCALL  5A86
05DE2:  MOVFF  01,270
*
0677A:  MOVLW  01
0677C:  MOVWF  00
0677E:  CALL   5A1C
06782:  MOVF   01,W
06784:  ANDLW  3F
06786:  MOVLB  9
06788:  MOVWF  x0A
0678A:  MOVWF  x0F
0678C:  MOVLB  0
0678E:  CALL   5A86
06792:  MOVFF  01,270
*
072EA:  MOVLW  01
072EC:  MOVWF  00
072EE:  CALL   5A1C
072F2:  MOVF   01,W
072F4:  ANDLW  3F
072F6:  MOVLB  9
072F8:  MOVWF  x0A
072FA:  MOVWF  x0F
072FC:  MOVLB  0
072FE:  CALL   5A86
07302:  MOVFF  01,270
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
*
05DE6:  MOVLW  01
05DE8:  MOVWF  00
05DEA:  RCALL  5A1C
05DEC:  MOVF   01,W
05DEE:  ANDLW  1F
05DF0:  MOVLB  9
05DF2:  MOVWF  x0A
05DF4:  MOVWF  x0F
05DF6:  MOVLB  0
05DF8:  RCALL  5A86
05DFA:  MOVFF  01,271
*
06796:  MOVLW  01
06798:  MOVWF  00
0679A:  CALL   5A1C
0679E:  MOVF   01,W
067A0:  ANDLW  1F
067A2:  MOVLB  9
067A4:  MOVWF  x0A
067A6:  MOVWF  x0F
067A8:  MOVLB  0
067AA:  CALL   5A86
067AE:  MOVFF  01,271
*
07306:  MOVLW  01
07308:  MOVWF  00
0730A:  CALL   5A1C
0730E:  MOVF   01,W
07310:  ANDLW  1F
07312:  MOVLB  9
07314:  MOVWF  x0A
07316:  MOVWF  x0F
07318:  MOVLB  0
0731A:  CALL   5A86
0731E:  MOVFF  01,271
....................   year = bcd2bin(i2c_read(0));            // REG 6  
*
05DFE:  CLRF   00
05E00:  RCALL  5A1C
05E02:  MOVFF  01,90A
05E06:  MOVFF  01,90F
05E0A:  RCALL  5A86
05E0C:  MOVFF  01,272
*
067B2:  CLRF   00
067B4:  CALL   5A1C
067B8:  MOVFF  01,90A
067BC:  MOVFF  01,90F
067C0:  CALL   5A86
067C4:  MOVFF  01,272
*
07322:  CLRF   00
07324:  CALL   5A1C
07328:  MOVFF  01,90A
0732C:  MOVFF  01,90F
07330:  CALL   5A86
07334:  MOVFF  01,272
....................   i2c_stop();  
*
05E10:  BCF    F95.6
05E12:  NOP   
05E14:  BSF    F96.1
05E16:  BTFSS  F84.1
05E18:  BRA    5E16
05E1A:  MOVLW  0E
05E1C:  MOVWF  00
05E1E:  DECFSZ 00,F
05E20:  BRA    5E1E
05E22:  BRA    5E24
05E24:  NOP   
05E26:  BSF    F95.6
05E28:  MOVLW  0E
05E2A:  MOVWF  00
05E2C:  DECFSZ 00,F
05E2E:  BRA    5E2C
*
067C8:  BCF    F95.6
067CA:  NOP   
067CC:  BSF    F96.1
067CE:  BTFSS  F84.1
067D0:  BRA    67CE
067D2:  MOVLW  0E
067D4:  MOVWF  00
067D6:  DECFSZ 00,F
067D8:  BRA    67D6
067DA:  BRA    67DC
067DC:  NOP   
067DE:  BSF    F95.6
067E0:  MOVLW  0E
067E2:  MOVWF  00
067E4:  DECFSZ 00,F
067E6:  BRA    67E4
*
07338:  BCF    F95.6
0733A:  NOP   
0733C:  BSF    F96.1
0733E:  BTFSS  F84.1
07340:  BRA    733E
07342:  MOVLW  0E
07344:  MOVWF  00
07346:  DECFSZ 00,F
07348:  BRA    7346
0734A:  BRA    734C
0734C:  NOP   
0734E:  BSF    F95.6
07350:  MOVLW  0E
07352:  MOVWF  00
07354:  DECFSZ 00,F
07356:  BRA    7354
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
05E30:  BSF    F95.6
05E32:  MOVLW  0E
05E34:  MOVWF  00
05E36:  DECFSZ 00,F
05E38:  BRA    5E36
05E3A:  BSF    F96.1
05E3C:  MOVLW  0E
05E3E:  MOVWF  00
05E40:  DECFSZ 00,F
05E42:  BRA    5E40
05E44:  BCF    F8C.6
05E46:  BCF    F95.6
05E48:  MOVLW  0E
05E4A:  MOVWF  00
05E4C:  DECFSZ 00,F
05E4E:  BRA    5E4C
05E50:  BCF    F8D.1
05E52:  BCF    F96.1
*
067E8:  BSF    F95.6
067EA:  MOVLW  0E
067EC:  MOVWF  00
067EE:  DECFSZ 00,F
067F0:  BRA    67EE
067F2:  BSF    F96.1
067F4:  MOVLW  0E
067F6:  MOVWF  00
067F8:  DECFSZ 00,F
067FA:  BRA    67F8
067FC:  BCF    F8C.6
067FE:  BCF    F95.6
06800:  MOVLW  0E
06802:  MOVWF  00
06804:  DECFSZ 00,F
06806:  BRA    6804
06808:  BCF    F8D.1
0680A:  BCF    F96.1
*
0717E:  BSF    F95.6
07180:  MOVLW  0E
07182:  MOVWF  00
07184:  DECFSZ 00,F
07186:  BRA    7184
07188:  BSF    F96.1
0718A:  MOVLW  0E
0718C:  MOVWF  00
0718E:  DECFSZ 00,F
07190:  BRA    718E
07192:  BCF    F8C.6
07194:  BCF    F95.6
07196:  MOVLW  0E
07198:  MOVWF  00
0719A:  DECFSZ 00,F
0719C:  BRA    719A
0719E:  BCF    F8D.1
071A0:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05E54:  MOVLW  D0
05E56:  MOVLB  9
05E58:  MOVWF  x0E
05E5A:  MOVLB  0
05E5C:  RCALL  59A6
*
0680C:  MOVLW  D0
0680E:  MOVLB  9
06810:  MOVWF  x0E
06812:  MOVLB  0
06814:  CALL   59A6
*
071A2:  MOVLW  D0
071A4:  MOVLB  9
071A6:  MOVWF  x0E
071A8:  MOVLB  0
071AA:  CALL   59A6
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
*
05E5E:  MOVLB  9
05E60:  CLRF   x0E
05E62:  MOVLB  0
05E64:  RCALL  59A6
*
06818:  MOVLB  9
0681A:  CLRF   x0E
0681C:  MOVLB  0
0681E:  CALL   59A6
*
071AE:  MOVLB  9
071B0:  CLRF   x0E
071B2:  MOVLB  0
071B4:  CALL   59A6
....................   i2c_start();  
*
05E66:  BSF    F95.6
05E68:  MOVLW  0E
05E6A:  MOVWF  00
05E6C:  DECFSZ 00,F
05E6E:  BRA    5E6C
05E70:  BSF    F96.1
05E72:  MOVLW  0E
05E74:  MOVWF  00
05E76:  DECFSZ 00,F
05E78:  BRA    5E76
05E7A:  BTFSS  F84.1
05E7C:  BRA    5E7A
05E7E:  BCF    F8C.6
05E80:  BCF    F95.6
05E82:  MOVLW  0E
05E84:  MOVWF  00
05E86:  DECFSZ 00,F
05E88:  BRA    5E86
05E8A:  BCF    F8D.1
05E8C:  BCF    F96.1
*
06822:  BSF    F95.6
06824:  MOVLW  0E
06826:  MOVWF  00
06828:  DECFSZ 00,F
0682A:  BRA    6828
0682C:  BSF    F96.1
0682E:  MOVLW  0E
06830:  MOVWF  00
06832:  DECFSZ 00,F
06834:  BRA    6832
06836:  BTFSS  F84.1
06838:  BRA    6836
0683A:  BCF    F8C.6
0683C:  BCF    F95.6
0683E:  MOVLW  0E
06840:  MOVWF  00
06842:  DECFSZ 00,F
06844:  BRA    6842
06846:  BCF    F8D.1
06848:  BCF    F96.1
*
071B8:  BSF    F95.6
071BA:  MOVLW  0E
071BC:  MOVWF  00
071BE:  DECFSZ 00,F
071C0:  BRA    71BE
071C2:  BSF    F96.1
071C4:  MOVLW  0E
071C6:  MOVWF  00
071C8:  DECFSZ 00,F
071CA:  BRA    71C8
071CC:  BTFSS  F84.1
071CE:  BRA    71CC
071D0:  BCF    F8C.6
071D2:  BCF    F95.6
071D4:  MOVLW  0E
071D6:  MOVWF  00
071D8:  DECFSZ 00,F
071DA:  BRA    71D8
071DC:  BCF    F8D.1
071DE:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05E8E:  MOVLW  D1
05E90:  MOVLB  9
05E92:  MOVWF  x0E
05E94:  MOVLB  0
05E96:  RCALL  59A6
*
0684A:  MOVLW  D1
0684C:  MOVLB  9
0684E:  MOVWF  x0E
06850:  MOVLB  0
06852:  CALL   59A6
*
071E0:  MOVLW  D1
071E2:  MOVLB  9
071E4:  MOVWF  x0E
071E6:  MOVLB  0
071E8:  CALL   59A6
....................   sec = bcd2bin(i2c_read() & 0x7f);  
*
05E98:  MOVLW  01
05E9A:  MOVWF  00
05E9C:  RCALL  5A1C
05E9E:  MOVF   01,W
05EA0:  ANDLW  7F
05EA2:  MOVLB  9
05EA4:  MOVWF  x0A
05EA6:  MOVWF  x0F
05EA8:  MOVLB  0
05EAA:  RCALL  5A86
05EAC:  MOVFF  01,275
*
06856:  MOVLW  01
06858:  MOVWF  00
0685A:  CALL   5A1C
0685E:  MOVF   01,W
06860:  ANDLW  7F
06862:  MOVLB  9
06864:  MOVWF  x0A
06866:  MOVWF  x0F
06868:  MOVLB  0
0686A:  CALL   5A86
0686E:  MOVFF  01,275
*
071EC:  MOVLW  01
071EE:  MOVWF  00
071F0:  CALL   5A1C
071F4:  MOVF   01,W
071F6:  ANDLW  7F
071F8:  MOVLB  9
071FA:  MOVWF  x0A
071FC:  MOVWF  x0F
071FE:  MOVLB  0
07200:  CALL   5A86
07204:  MOVFF  01,275
....................   min = bcd2bin(i2c_read() & 0x7f);  
*
05EB0:  MOVLW  01
05EB2:  MOVWF  00
05EB4:  RCALL  5A1C
05EB6:  MOVF   01,W
05EB8:  ANDLW  7F
05EBA:  MOVLB  9
05EBC:  MOVWF  x0A
05EBE:  MOVWF  x0F
05EC0:  MOVLB  0
05EC2:  RCALL  5A86
05EC4:  MOVFF  01,274
*
06872:  MOVLW  01
06874:  MOVWF  00
06876:  CALL   5A1C
0687A:  MOVF   01,W
0687C:  ANDLW  7F
0687E:  MOVLB  9
06880:  MOVWF  x0A
06882:  MOVWF  x0F
06884:  MOVLB  0
06886:  CALL   5A86
0688A:  MOVFF  01,274
*
07208:  MOVLW  01
0720A:  MOVWF  00
0720C:  CALL   5A1C
07210:  MOVF   01,W
07212:  ANDLW  7F
07214:  MOVLB  9
07216:  MOVWF  x0A
07218:  MOVWF  x0F
0721A:  MOVLB  0
0721C:  CALL   5A86
07220:  MOVFF  01,274
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
*
05EC8:  CLRF   00
05ECA:  RCALL  5A1C
05ECC:  MOVF   01,W
05ECE:  ANDLW  3F
05ED0:  MOVLB  9
05ED2:  MOVWF  x0A
05ED4:  MOVWF  x0F
05ED6:  MOVLB  0
05ED8:  RCALL  5A86
05EDA:  MOVFF  01,273
*
0688E:  CLRF   00
06890:  CALL   5A1C
06894:  MOVF   01,W
06896:  ANDLW  3F
06898:  MOVLB  9
0689A:  MOVWF  x0A
0689C:  MOVWF  x0F
0689E:  MOVLB  0
068A0:  CALL   5A86
068A4:  MOVFF  01,273
*
07224:  CLRF   00
07226:  CALL   5A1C
0722A:  MOVF   01,W
0722C:  ANDLW  3F
0722E:  MOVLB  9
07230:  MOVWF  x0A
07232:  MOVWF  x0F
07234:  MOVLB  0
07236:  CALL   5A86
0723A:  MOVFF  01,273
....................   i2c_stop();  
*
05EDE:  BCF    F95.6
05EE0:  NOP   
05EE2:  BSF    F96.1
05EE4:  BTFSS  F84.1
05EE6:  BRA    5EE4
05EE8:  MOVLW  0E
05EEA:  MOVWF  00
05EEC:  DECFSZ 00,F
05EEE:  BRA    5EEC
05EF0:  BRA    5EF2
05EF2:  NOP   
05EF4:  BSF    F95.6
05EF6:  MOVLW  0E
05EF8:  MOVWF  00
05EFA:  DECFSZ 00,F
05EFC:  BRA    5EFA
*
068A8:  BCF    F95.6
068AA:  NOP   
068AC:  BSF    F96.1
068AE:  BTFSS  F84.1
068B0:  BRA    68AE
068B2:  MOVLW  0E
068B4:  MOVWF  00
068B6:  DECFSZ 00,F
068B8:  BRA    68B6
068BA:  BRA    68BC
068BC:  NOP   
068BE:  BSF    F95.6
068C0:  MOVLW  0E
068C2:  MOVWF  00
068C4:  DECFSZ 00,F
068C6:  BRA    68C4
*
0723E:  BCF    F95.6
07240:  NOP   
07242:  BSF    F96.1
07244:  BTFSS  F84.1
07246:  BRA    7244
07248:  MOVLW  0E
0724A:  MOVWF  00
0724C:  DECFSZ 00,F
0724E:  BRA    724C
07250:  BRA    7252
07252:  NOP   
07254:  BSF    F95.6
07256:  MOVLW  0E
07258:  MOVWF  00
0725A:  DECFSZ 00,F
0725C:  BRA    725A
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
06354:  MOVFF  90D,90E
....................   retval = 0;  
06358:  MOVLB  9
0635A:  CLRF   x0F
....................  
....................   while(TRUE)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
0635C:  MOVF   x0E,W
0635E:  SUBLW  09
06360:  BC    636C
....................     {  
....................       temp -= 10;  
06362:  MOVLW  0A
06364:  SUBWF  x0E,F
....................       retval += 0x10;  
06366:  MOVLW  10
06368:  ADDWF  x0F,F
....................     }  
0636A:  BRA    6372
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
0636C:  MOVF   x0E,W
0636E:  ADDWF  x0F,F
....................       break;  
06370:  BRA    6374
....................     }  
06372:  BRA    635C
....................   }  
....................  
....................   return(retval);  
06374:  MOVFF  90F,01
06378:  MOVLB  0
0637A:  RETURN 0
.................... }  
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
05A86:  MOVFF  90F,910
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
05A8A:  BCF    FD8.0
05A8C:  MOVLB  9
05A8E:  RRCF   x10,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
05A90:  MOVLW  78
05A92:  ANDWF  x10,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
05A94:  RRCF   x10,W
05A96:  MOVWF  00
05A98:  RRCF   00,F
05A9A:  MOVLW  3F
05A9C:  ANDWF  00,F
05A9E:  MOVF   00,W
05AA0:  ADDWF  x10,W
05AA2:  MOVWF  x11
05AA4:  MOVF   x0F,W
05AA6:  ANDLW  0F
05AA8:  ADDWF  x11,W
05AAA:  MOVWF  01
05AAC:  MOVLB  0
05AAE:  RETURN 0
.................... } 
....................  
.................... // Entradas. 
.................... #define entrada01 PIN_D4// 
.................... #define entrada02 PIN_B0//DATA1  
.................... #define entrada03 PIN_B1//DATA0 
.................... #define entrada04 PIN_D0// 
.................... #define entrada05 PIN_D1//SENSOR BARRERA 
....................  
.................... // Salidas. 
.................... #define salida01 PIN_A5//abre entrada 
.................... #define salida02 PIN_E0//abre entrada 
.................... #define salida03 PIN_D2//abre salida 
.................... #define salida04 PIN_D3//indicador de cupo lleno 
.................... #define salida05 PIN_D7// 
.................... #define salida06 PIN_C2//indicador de conexion 
.................... // Macros de entrada: 
.................... char texto1[12]= "BOLETO_FOL";// 
.................... char texto2[12]= "BORRARTODO";// 
.................... char texto3[12]= "BORRAR_TAG";// 
.................... char texto4[12]= "ABRIR_SALI";// 
.................... char texto5[12]= "CUPO_LLENO";//CANCELA BOLETOS 
.................... char texto6[12]= "CUPO_DISPO";//ACTIVA BOLETOS 
.................... char texto7[12]= "MENSAJEEN1";// 
.................... char texto8[12]= "          ";// 
.................... char texto9[12]= "CONSULTA01";// 
.................... char texto10[12]="CONFIGDATE";// 
.................... char texto11[12]="CONFIGURAB";// 
.................... char texto12[12]="BORRA_CON1";// 
.................... char texto13[12]="FOLIORESET";//REINICIAR FOLIOS 
.................... char texto14[12]="PAGADO0000";// 
.................... char boleto[]= "BOLETO"; // 
.................... char barrera[] ="BARRERAABIERTAE1"; 
.................... int fmensaje; 
.................... int16 time_lcd; 
.................... //int en5,flag_pluma; 
....................  
....................  
.................... // Define el stack usado: ENC28J60. 
.................... #define STACK_USE_CCS_PICENS   1 
.................... // Utilizamos el stack para el protocolo ICPM. 
.................... #define STACK_USE_ICMP  1 
.................... // Utilizamos el stack para el protocolo ARP. 
.................... #define STACK_USE_ARP 1 
.................... // Utilizamos el stack para el protocolo TCP. 
.................... #define STACK_USE_TCP 1 
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... // Definimos los pines utilizados. 
.................... #define  PIN_ENC_MAC_SO    PIN_C4 
.................... #define  PIN_ENC_MAC_SI    PIN_C5 
.................... #define  PIN_ENC_MAC_CLK   PIN_C3 
....................  
.................... #define  PIN_ENC_MAC_CS    PIN_C1 
.................... #define  PIN_ENC_MAC_RST   PIN_C0 
.................... #define  PIN_ENC_MAC_INT   PIN_D2 
.................... #define  PIN_ENC_MAC_WOL   PIN_D3 
....................  
.................... // Incluimos las definiciones necesarias para utilizar el stack TCP/IP. 
.................... #include "tcpip/stacktsk.c"  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_C0 
....................       #define PIN_ENC_MAC_RST PIN_C1 
....................       #define PIN_ENC_MAC_INT PIN_C6 
....................       #define PIN_ENC_MAC_WOL PIN_C7 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................       
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_MCPENC 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
.................... */ 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     35 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
05670:  MOVFF  90C,90E
05674:  MOVFF  90B,90D
05678:  MOVFF  90E,03
0567C:  MOVLB  9
0567E:  MOVFF  90D,FE9
05682:  MOVFF  90E,FEA
05686:  MOVF   FEF,F
05688:  BZ    5696
0568A:  INCF   x0D,F
0568C:  BTFSC  FD8.2
0568E:  INCF   x0E,F
05690:  MOVLB  0
05692:  BRA    5678
05694:  MOVLB  9
....................    return(sc - s); 
05696:  MOVF   x0B,W
05698:  SUBWF  x0D,W
0569A:  MOVWF  00
0569C:  MOVF   x0C,W
0569E:  SUBWFB x0E,W
056A0:  MOVWF  03
056A2:  MOVFF  00,01
056A6:  MOVWF  02
056A8:  MOVLB  0
056AA:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01096:  MOVFF  386,8FC
0109A:  MOVFF  385,8FB
0109E:  MOVFF  384,8FA
010A2:  MOVFF  383,8F9
010A6:  MOVLW  41
010A8:  MOVLB  9
010AA:  MOVWF  x00
010AC:  MOVLW  C6
010AE:  MOVLB  8
010B0:  MOVWF  xFF
010B2:  MOVLW  4E
010B4:  MOVWF  xFE
010B6:  MOVLW  6D
010B8:  MOVWF  xFD
010BA:  MOVLB  0
010BC:  BRA    0FF2
010BE:  MOVLW  39
010C0:  MOVLB  8
010C2:  ADDWF  00,W
010C4:  MOVLB  3
010C6:  MOVWF  x83
010C8:  MOVLW  30
010CA:  MOVLB  8
010CC:  ADDWFC 01,W
010CE:  MOVLB  3
010D0:  MOVWF  x84
010D2:  MOVLW  00
010D4:  MOVLB  8
010D6:  ADDWFC 02,W
010D8:  MOVLB  3
010DA:  MOVWF  x85
010DC:  MOVLW  00
010DE:  MOVLB  8
010E0:  ADDWFC 03,W
010E2:  MOVLB  3
010E4:  MOVWF  x86
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
010E6:  MOVFF  385,00
010EA:  MOVFF  386,01
010EE:  CLRF   02
010F0:  CLRF   03
010F2:  MOVFF  386,8FB
010F6:  MOVFF  385,8FA
010FA:  MOVFF  386,909
010FE:  MOVFF  385,908
01102:  MOVLW  7F
01104:  MOVLB  9
01106:  MOVWF  x0B
01108:  SETF   x0A
0110A:  MOVLB  0
0110C:  RCALL  1050
0110E:  MOVFF  00,01
01112:  MOVFF  03,02
01116:  GOTO   1234 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
00FDE:  MOVFF  8FC,386
00FE2:  MOVFF  8FB,385
00FE6:  MOVFF  8FA,384
00FEA:  MOVFF  8F9,383
00FEE:  GOTO   1232 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
01810:  MOVFF  9A2,9A3
....................     new.v[1]=v.v[0]; 
01814:  MOVFF  9A1,9A4
....................  
....................     return(new.Val); 
01818:  MOVLB  9
0181A:  MOVFF  9A3,01
0181E:  MOVFF  9A4,02
01822:  MOVLB  0
01824:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
02750:  MOVFF  98D,98E
....................     new.v[1]=v.v[2]; 
02754:  MOVFF  98C,98F
....................     new.v[2]=v.v[1]; 
02758:  MOVFF  98B,990
....................     new.v[3]=v.v[0]; 
0275C:  MOVFF  98A,991
....................  
....................     return(new.Val); 
02760:  MOVFF  98E,00
02764:  MOVFF  98F,01
02768:  MOVFF  990,02
0276C:  MOVFF  991,03
02770:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
024BA:  MOVLB  9
024BC:  CLRF   x93
024BE:  CLRF   x92
024C0:  CLRF   x91
024C2:  CLRF   x90
....................  
....................    i = count >> 1; 
024C4:  BCF    FD8.0
024C6:  RRCF   x87,W
024C8:  MOVWF  x89
024CA:  RRCF   x86,W
024CC:  MOVWF  x88
....................    val = (WORD *)buffer; 
024CE:  MOVFF  985,98B
024D2:  MOVFF  984,98A
....................  
....................    while( i-- ) 
024D6:  MOVFF  989,03
024DA:  MOVF   x88,W
024DC:  BTFSC  FD8.2
024DE:  DECF   x89,F
024E0:  DECF   x88,F
024E2:  IORWF  03,W
024E4:  BZ    2514
....................       sum.Val += *val++; 
024E6:  MOVFF  98B,03
024EA:  MOVFF  98A,00
024EE:  MOVLW  02
024F0:  ADDWF  x8A,F
024F2:  BTFSC  FD8.0
024F4:  INCF   x8B,F
024F6:  MOVFF  00,FE9
024FA:  MOVFF  03,FEA
024FE:  MOVFF  FEC,03
02502:  MOVF   FED,F
02504:  MOVF   FEF,W
02506:  ADDWF  x90,F
02508:  MOVF   03,W
0250A:  ADDWFC x91,F
0250C:  MOVLW  00
0250E:  ADDWFC x92,F
02510:  ADDWFC x93,F
02512:  BRA    24D6
....................  
....................    if ( count & 1 ) 
02514:  MOVF   x86,W
02516:  ANDLW  01
02518:  MOVWF  00
0251A:  CLRF   03
0251C:  MOVF   00,W
0251E:  IORWF  03,W
02520:  BZ    2536
....................       sum.Val += *(BYTE *)val; 
02522:  MOVFF  98A,FE9
02526:  MOVFF  98B,FEA
0252A:  MOVF   FEF,W
0252C:  ADDWF  x90,F
0252E:  MOVLW  00
02530:  ADDWFC x91,F
02532:  ADDWFC x92,F
02534:  ADDWFC x93,F
....................  
....................    tempSum.Val = sum.Val; 
02536:  MOVFF  993,98F
0253A:  MOVFF  992,98E
0253E:  MOVFF  991,98D
02542:  MOVFF  990,98C
....................    i = tempSum.words.MSB.Val; 
02546:  MOVFF  98F,989
0254A:  MOVFF  98E,988
....................  
....................    while( i != 0u ) 
0254E:  MOVF   x88,F
02550:  BNZ   2556
02552:  MOVF   x89,F
02554:  BZ    259C
....................    { 
....................       sum.words.MSB.Val = 0; 
02556:  CLRF   x93
02558:  CLRF   x92
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
0255A:  CLRF   x97
0255C:  CLRF   x96
0255E:  MOVFF  991,995
02562:  MOVFF  990,994
02566:  CLRF   02
02568:  CLRF   03
0256A:  MOVF   x88,W
0256C:  ADDWF  x90,W
0256E:  MOVWF  x90
02570:  MOVF   x89,W
02572:  ADDWFC x91,W
02574:  MOVWF  x91
02576:  MOVF   02,W
02578:  ADDWFC x96,W
0257A:  MOVWF  x92
0257C:  MOVF   03,W
0257E:  ADDWFC x97,W
02580:  MOVWF  x93
....................       tempSum.Val = sum.Val; 
02582:  MOVFF  993,98F
02586:  MOVFF  992,98E
0258A:  MOVFF  991,98D
0258E:  MOVFF  990,98C
....................       i = tempSum.words.MSB.Val; 
02592:  MOVFF  98F,989
02596:  MOVFF  98E,988
0259A:  BRA    254E
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
0259C:  MOVFF  991,03
025A0:  COMF   03,F
025A2:  MOVF   x90,W
025A4:  XORLW  FF
025A6:  MOVWF  01
025A8:  MOVFF  03,02
025AC:  MOVLB  0
025AE:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
00A9E:  MOVLW  83
00AA0:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
00AA2:  MOVLW  34
00AA4:  MOVWF  FD7
00AA6:  MOVLW  8C
00AA8:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
00AAA:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
00AAC:  MOVLW  C0
00AAE:  IORWF  FF2,F
00AB0:  GOTO   1274 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
02B52:  BCF    FF2.5
....................     ret=TickCount; 
02B54:  MOVFF  389,949
02B58:  MOVFF  388,948
....................     enable_interrupts(INT_TIMER0); 
02B5C:  BSF    FF2.5
....................     return ret; 
02B5E:  MOVLB  9
02B60:  MOVFF  948,01
02B64:  MOVFF  949,02
02B68:  MOVLB  0
02B6A:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00106:  MOVLB  3
00108:  INCF   x88,F
0010A:  BTFSC  FD8.2
0010C:  INCF   x89,F
....................  
....................         second_counter_intermediate++; 
0010E:  INCF   x8B,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00110:  MOVF   x8B,W
00112:  SUBLW  0B
00114:  BC    011A
....................             second_counter++; //increment this ever 1s 
00116:  INCF   x8A,F
....................             second_counter_intermediate=0; 
00118:  CLRF   x8B
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
0011A:  MOVLW  34
0011C:  MOVWF  FD7
0011E:  MOVLW  8C
00120:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
.................... /* 
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
.................... */  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
00122:  BCF    FF2.2
00124:  MOVLB  0
00126:  GOTO   0084
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
00AB4:  BCF    F94.3
00AB6:  BCF    F8B.3
....................    output_float(PIN_ENC_MAC_SO); 
00AB8:  BSF    F94.4
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
00ABA:  BCF    F94.1
00ABC:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00ABE:  BCF    F94.0
00AC0:  BSF    F8B.0
00AC2:  GOTO   0DCC (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
00AC6:  MOVLB  9
00AC8:  CLRF   xAD
00ACA:  MOVF   xAD,W
00ACC:  SUBLW  07
00ACE:  BNC   0AF8
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
00AD0:  BCF    FD8.0
00AD2:  RLCF   xAC,F
00AD4:  BC    0ADA
00AD6:  BCF    F8B.5
00AD8:  BRA    0ADC
00ADA:  BSF    F8B.5
00ADC:  BCF    F94.5
....................       output_high(PIN_ENC_MAC_CLK); 
00ADE:  BCF    F94.3
00AE0:  BSF    F8B.3
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
00AE2:  BSF    F94.4
00AE4:  BTFSC  F82.4
00AE6:  BRA    0AEC
00AE8:  BCF    FD8.0
00AEA:  BRA    0AEE
00AEC:  BSF    FD8.0
00AEE:  RLCF   xAE,F
....................       output_low(PIN_ENC_MAC_CLK); 
00AF0:  BCF    F94.3
00AF2:  BCF    F8B.3
00AF4:  INCF   xAD,F
00AF6:  BRA    0ACA
....................    } 
....................    return(in); 
00AF8:  MOVFF  9AE,01
....................  #endif 
00AFC:  MOVLB  0
00AFE:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
00DCA:  BRA    0AB4
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
00DCC:  MOVLW  1D
00DCE:  MOVLB  9
00DD0:  MOVWF  xA1
00DD2:  MOVLB  0
00DD4:  RCALL  0B00
00DD6:  MOVFF  01,8F6
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00DDA:  MOVLB  8
00DDC:  BTFSS  xF6.3
00DDE:  BRA    0DE4
00DE0:  MOVLB  0
00DE2:  BRA    0DCC
00DE4:  MOVF   xF6,W
00DE6:  XORLW  FF
00DE8:  ANDLW  01
00DEA:  BTFSC  FD8.2
00DEC:  BRA    0DF2
00DEE:  MOVLB  0
00DF0:  BRA    0DCC
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
00DF2:  MOVLB  0
00DF4:  BRA    0B2A
....................     delay_ms(1); 
00DF6:  MOVLW  01
00DF8:  MOVLB  8
00DFA:  MOVWF  xFD
00DFC:  MOVLB  0
00DFE:  CALL   05B2
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
00E02:  MOVLB  3
00E04:  CLRF   x87
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
00E06:  BSF    x90.0
....................    NextPacketLocation.Val = RXSTART; 
00E08:  CLRF   x8D
00E0A:  CLRF   x8C
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
00E0C:  MOVLW  08
00E0E:  MOVLB  9
00E10:  MOVWF  xA7
00E12:  CLRF   xA8
00E14:  MOVLB  0
00E16:  RCALL  0B3E
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
00E18:  MOVLW  09
00E1A:  MOVLB  9
00E1C:  MOVWF  xA7
00E1E:  CLRF   xA8
00E20:  MOVLB  0
00E22:  RCALL  0B3E
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
00E24:  MOVLW  0C
00E26:  MOVLB  9
00E28:  MOVWF  xA7
00E2A:  MOVLW  F7
00E2C:  MOVWF  xA8
00E2E:  MOVLB  0
00E30:  RCALL  0B3E
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00E32:  MOVLW  0D
00E34:  MOVLB  9
00E36:  MOVWF  xA7
00E38:  MOVLW  1B
00E3A:  MOVWF  xA8
00E3C:  MOVLB  0
00E3E:  RCALL  0B3E
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
00E40:  MOVLW  0A
00E42:  MOVLB  9
00E44:  MOVWF  xA7
00E46:  MOVLW  F7
00E48:  MOVWF  xA8
00E4A:  MOVLB  0
00E4C:  RCALL  0B3E
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
00E4E:  MOVLW  0B
00E50:  MOVLB  9
00E52:  MOVWF  xA7
00E54:  MOVLW  1B
00E56:  MOVWF  xA8
00E58:  MOVLB  0
00E5A:  RCALL  0B3E
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
00E5C:  MOVLW  04
00E5E:  MOVLB  9
00E60:  MOVWF  xA7
00E62:  MOVLW  F8
00E64:  MOVWF  xA8
00E66:  MOVLB  0
00E68:  RCALL  0B3E
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
00E6A:  MOVLW  05
00E6C:  MOVLB  9
00E6E:  MOVWF  xA7
00E70:  MOVLW  1B
00E72:  MOVWF  xA8
00E74:  MOVLB  0
00E76:  RCALL  0B3E
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
00E78:  MOVLW  02
00E7A:  MOVLB  9
00E7C:  MOVWF  xA5
00E7E:  CLRF   xA4
00E80:  MOVLB  0
00E82:  RCALL  0B98
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00E84:  MOVLB  9
00E86:  CLRF   xA7
00E88:  MOVLW  0D
00E8A:  MOVWF  xA8
00E8C:  MOVLB  0
00E8E:  RCALL  0B3E
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00E90:  MOVLW  02
00E92:  MOVLB  9
00E94:  MOVWF  xA7
00E96:  MOVLW  32
00E98:  MOVWF  xA8
00E9A:  MOVLB  0
00E9C:  RCALL  0B3E
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00E9E:  MOVLW  03
00EA0:  MOVLB  9
00EA2:  MOVWF  xA7
00EA4:  MOVLW  40
00EA6:  MOVWF  xA8
00EA8:  MOVLB  0
00EAA:  RCALL  0B3E
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00EAC:  MOVLW  09
00EAE:  MOVLB  9
00EB0:  MOVWF  xA7
00EB2:  MOVLW  3F
00EB4:  MOVWF  xA8
00EB6:  MOVLB  0
00EB8:  RCALL  0B3E
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
00EBA:  MOVLW  06
00EBC:  MOVLB  9
00EBE:  MOVWF  xA7
00EC0:  MOVLW  12
00EC2:  MOVWF  xA8
00EC4:  MOVLB  0
00EC6:  RCALL  0B3E
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
00EC8:  MOVLW  07
00ECA:  MOVLB  9
00ECC:  MOVWF  xA7
00ECE:  MOVLW  0C
00ED0:  MOVWF  xA8
00ED2:  MOVLB  0
00ED4:  RCALL  0B3E
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
00ED6:  MOVLW  0A
00ED8:  MOVLB  9
00EDA:  MOVWF  xA7
00EDC:  MOVLW  EE
00EDE:  MOVWF  xA8
00EE0:  MOVLB  0
00EE2:  RCALL  0B3E
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
00EE4:  MOVLW  0B
00EE6:  MOVLB  9
00EE8:  MOVWF  xA7
00EEA:  MOVLW  05
00EEC:  MOVWF  xA8
00EEE:  MOVLB  0
00EF0:  RCALL  0B3E
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
00EF2:  MOVLW  03
00EF4:  MOVLB  9
00EF6:  MOVWF  xA5
00EF8:  MOVLW  04
00EFA:  MOVWF  xA4
00EFC:  MOVLB  0
00EFE:  RCALL  0B98
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00F00:  MOVLW  04
00F02:  MOVLB  9
00F04:  MOVWF  xA7
00F06:  MOVFF  354,9A8
00F0A:  MOVLB  0
00F0C:  RCALL  0B3E
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00F0E:  MOVLW  05
00F10:  MOVLB  9
00F12:  MOVWF  xA7
00F14:  MOVFF  355,9A8
00F18:  MOVLB  0
00F1A:  RCALL  0B3E
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00F1C:  MOVLW  02
00F1E:  MOVLB  9
00F20:  MOVWF  xA7
00F22:  MOVFF  356,9A8
00F26:  MOVLB  0
00F28:  RCALL  0B3E
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00F2A:  MOVLW  03
00F2C:  MOVLB  9
00F2E:  MOVWF  xA7
00F30:  MOVFF  357,9A8
00F34:  MOVLB  0
00F36:  RCALL  0B3E
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00F38:  MOVLB  9
00F3A:  CLRF   xA7
00F3C:  MOVFF  358,9A8
00F40:  MOVLB  0
00F42:  RCALL  0B3E
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00F44:  MOVLW  01
00F46:  MOVLB  9
00F48:  MOVWF  xA7
00F4A:  MOVFF  359,9A8
00F4E:  MOVLB  0
00F50:  RCALL  0B3E
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00F52:  MOVLW  12
00F54:  MOVLB  9
00F56:  MOVWF  xA1
00F58:  MOVLB  0
00F5A:  RCALL  0B00
00F5C:  MOVFF  01,391
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00F60:  MOVLW  10
00F62:  MOVLB  8
00F64:  MOVWF  xFB
00F66:  MOVLW  01
00F68:  MOVWF  xFD
00F6A:  CLRF   xFC
00F6C:  MOVLB  0
00F6E:  RCALL  0BFC
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
00F70:  MOVLW  14
00F72:  MOVLB  8
00F74:  MOVWF  xFB
00F76:  MOVLW  04
00F78:  MOVWF  xFD
00F7A:  MOVLW  72
00F7C:  MOVWF  xFC
00F7E:  MOVLB  0
00F80:  RCALL  0BFC
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
00F82:  MOVLB  8
00F84:  CLRF   xF7
00F86:  MOVLB  0
00F88:  BRA    0D28
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
00F8A:  MOVLW  1F
00F8C:  MOVLB  9
00F8E:  MOVWF  xA9
00F90:  MOVLW  04
00F92:  MOVWF  xAA
00F94:  MOVLB  0
00F96:  RCALL  0B7A
00F98:  GOTO   1276 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
06A72:  MOVLW  01
06A74:  MOVLB  8
06A76:  MOVWF  xFB
06A78:  MOVLB  0
06A7A:  CALL   0C8C
06A7E:  MOVFF  01,8F6
06A82:  MOVLW  00
06A84:  MOVLB  8
06A86:  BTFSC  01.2
06A88:  MOVLW  01
06A8A:  MOVWF  01
06A8C:  MOVLB  0
06A8E:  GOTO   75B6 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
02C6A:  MOVLW  1F
02C6C:  MOVLB  9
02C6E:  MOVWF  xA1
02C70:  MOVLB  0
02C72:  CALL   0B00
02C76:  MOVFF  01,983
02C7A:  MOVLW  00
02C7C:  MOVLB  9
02C7E:  BTFSC  01.3
02C80:  MOVLW  01
02C82:  XORLW  00
02C84:  BZ    2C8A
02C86:  MOVLW  00
02C88:  BRA    2C8C
02C8A:  MOVLW  01
02C8C:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
02C8E:  MOVLB  0
02C90:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
01B28:  MOVLW  1F
01B2A:  MOVLB  9
01B2C:  MOVWF  xA1
01B2E:  MOVLB  0
01B30:  CALL   0B00
01B34:  MOVFF  01,983
01B38:  MOVLW  00
01B3A:  MOVLB  9
01B3C:  BTFSC  01.3
01B3E:  MOVLW  01
01B40:  XORLW  00
01B42:  BNZ   1B48
01B44:  MOVLW  00
01B46:  BRA    1B4A
01B48:  MOVLW  FF
01B4A:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
01B4C:  MOVLB  0
01B4E:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
01736:  MOVLB  3
01738:  BTFSS  x90.0
0173A:  BRA    173E
....................       return; 
0173C:  BRA    17A8
....................    WasDiscarded = TRUE; 
0173E:  BSF    x90.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
01740:  MOVLW  01
01742:  SUBWF  x8C,W
01744:  MOVLB  9
01746:  MOVWF  x48
01748:  MOVLW  00
0174A:  MOVLB  3
0174C:  SUBWFB x8D,W
0174E:  MOVLB  9
01750:  MOVWF  x49
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
01752:  MOVF   x49,W
01754:  SUBLW  1A
01756:  BC    176A
01758:  XORLW  FF
0175A:  BNZ   1762
0175C:  MOVF   x48,W
0175E:  SUBLW  F7
01760:  BC    176A
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
01762:  MOVLW  1B
01764:  MOVWF  x49
01766:  MOVLW  F7
01768:  MOVWF  x48
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
0176A:  MOVLW  1E
0176C:  MOVWF  xA9
0176E:  MOVLW  40
01770:  MOVWF  xAA
01772:  MOVLB  0
01774:  CALL   0B7A
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
01778:  MOVLB  9
0177A:  CLRF   xA5
0177C:  MOVLW  0C
0177E:  MOVWF  xA4
01780:  MOVLB  0
01782:  CALL   0B98
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
01786:  MOVLW  0C
01788:  MOVLB  9
0178A:  MOVWF  xA7
0178C:  MOVFF  948,9A8
01790:  MOVLB  0
01792:  CALL   0B3E
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
01796:  MOVLW  0D
01798:  MOVLB  9
0179A:  MOVWF  xA7
0179C:  MOVFF  949,9A8
017A0:  MOVLB  0
017A2:  CALL   0B3E
017A6:  MOVLB  3
017A8:  MOVLB  0
017AA:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
02C92:  MOVLW  01
02C94:  MOVLB  9
02C96:  MOVWF  xA5
02C98:  MOVLW  19
02C9A:  MOVWF  xA4
02C9C:  MOVLB  0
02C9E:  CALL   0B98
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
02CA2:  MOVLW  19
02CA4:  MOVLB  9
02CA6:  MOVWF  xA1
02CA8:  MOVLB  0
02CAA:  CALL   0B00
02CAE:  MOVFF  01,982
....................  
....................       BankSel(ERXWRPTL); 
02CB2:  MOVLB  9
02CB4:  CLRF   xA5
02CB6:  MOVLW  0E
02CB8:  MOVWF  xA4
02CBA:  MOVLB  0
02CBC:  CALL   0B98
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
02CC0:  MOVLW  0E
02CC2:  MOVLB  9
02CC4:  MOVWF  xA1
02CC6:  MOVLB  0
02CC8:  CALL   0B00
02CCC:  MOVFF  01,984
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
02CD0:  MOVLW  0F
02CD2:  MOVLB  9
02CD4:  MOVWF  xA1
02CD6:  MOVLB  0
02CD8:  CALL   0B00
02CDC:  MOVFF  01,985
....................  
....................       BankSel(EPKTCNT); 
02CE0:  MOVLW  01
02CE2:  MOVLB  9
02CE4:  MOVWF  xA5
02CE6:  MOVLW  19
02CE8:  MOVWF  xA4
02CEA:  MOVLB  0
02CEC:  CALL   0B98
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
02CF0:  MOVLW  19
02CF2:  MOVLB  9
02CF4:  MOVWF  xA1
02CF6:  MOVLB  0
02CF8:  CALL   0B00
02CFC:  MOVFF  01,986
02D00:  MOVLB  9
02D02:  MOVF   x82,W
02D04:  SUBWF  01,W
02D06:  BTFSC  FD8.2
02D08:  BRA    2D0E
02D0A:  MOVLB  0
02D0C:  BRA    2CA2
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
02D0E:  CLRF   xA5
02D10:  MOVLW  0C
02D12:  MOVWF  xA4
02D14:  MOVLB  0
02D16:  CALL   0B98
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
02D1A:  MOVLW  0C
02D1C:  MOVLB  9
02D1E:  MOVWF  xA1
02D20:  MOVLB  0
02D22:  CALL   0B00
02D26:  MOVFF  01,982
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
02D2A:  MOVLW  0D
02D2C:  MOVLB  9
02D2E:  MOVWF  xA1
02D30:  MOVLB  0
02D32:  CALL   0B00
02D36:  MOVFF  01,983
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
02D3A:  MOVLB  9
02D3C:  MOVF   x83,W
02D3E:  SUBWF  x85,W
02D40:  BNC   2D6E
02D42:  BNZ   2D4A
02D44:  MOVF   x84,W
02D46:  SUBWF  x82,W
02D48:  BC    2D6E
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
02D4A:  MOVF   x82,W
02D4C:  SUBWF  x84,W
02D4E:  MOVWF  00
02D50:  MOVF   x83,W
02D52:  SUBWFB x85,W
02D54:  MOVWF  03
02D56:  MOVF   00,W
02D58:  XORLW  FF
02D5A:  ADDLW  F8
02D5C:  MOVWF  00
02D5E:  MOVLW  1B
02D60:  SUBFWB 03,F
02D62:  MOVFF  00,01
02D66:  MOVFF  03,02
02D6A:  BRA    2DA4
....................    } 
02D6C:  BRA    2DA4
....................    else if ( WritePT.Val == ReadPT.Val ) 
02D6E:  MOVF   x82,W
02D70:  SUBWF  x84,W
02D72:  BNZ   2D86
02D74:  MOVF   x83,W
02D76:  SUBWF  x85,W
02D78:  BNZ   2D86
....................    { 
....................       return RXSIZE - 1; 
02D7A:  MOVLW  F7
02D7C:  MOVWF  01
02D7E:  MOVLW  1B
02D80:  MOVWF  02
02D82:  BRA    2DA4
....................    } 
02D84:  BRA    2DA4
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
02D86:  MOVF   x84,W
02D88:  SUBWF  x82,W
02D8A:  MOVWF  x86
02D8C:  MOVF   x85,W
02D8E:  SUBWFB x83,W
02D90:  MOVWF  x87
02D92:  MOVLW  01
02D94:  SUBWF  x86,W
02D96:  MOVWF  00
02D98:  MOVLW  00
02D9A:  SUBWFB x87,W
02D9C:  MOVWF  03
02D9E:  MOVFF  00,01
02DA2:  MOVWF  02
....................    } 
02DA4:  MOVLB  0
02DA6:  GOTO   3028 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
01826:  MOVLW  01
01828:  MOVLB  9
0182A:  MOVWF  xA5
0182C:  MOVLW  19
0182E:  MOVWF  xA4
01830:  MOVLB  0
01832:  CALL   0B98
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
01836:  MOVLW  19
01838:  MOVLB  9
0183A:  MOVWF  xA1
0183C:  MOVLB  0
0183E:  CALL   0B00
01842:  MOVFF  01,914
01846:  MOVLB  9
01848:  MOVF   x14,F
0184A:  BNZ   1852
....................       return FALSE; 
0184C:  MOVLW  00
0184E:  MOVWF  01
01850:  BRA    196E
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
01852:  MOVLB  3
01854:  BTFSC  x90.0
01856:  BRA    1866
....................    { 
....................       MACDiscardRx(); 
01858:  MOVLB  0
0185A:  RCALL  1736
....................       return FALSE; 
0185C:  MOVLW  00
0185E:  MOVWF  01
01860:  MOVLB  9
01862:  BRA    196E
01864:  MOVLB  3
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
01866:  MOVFF  38D,38F
0186A:  MOVFF  38C,38E
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
0186E:  MOVLB  9
01870:  CLRF   xA5
01872:  CLRF   xA4
01874:  MOVLB  0
01876:  CALL   0B98
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
0187A:  MOVLB  9
0187C:  CLRF   xA7
0187E:  MOVFF  38C,9A8
01882:  MOVLB  0
01884:  CALL   0B3E
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
01888:  MOVLW  01
0188A:  MOVLB  9
0188C:  MOVWF  xA7
0188E:  MOVFF  38D,9A8
01892:  MOVLB  0
01894:  CALL   0B3E
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
01898:  MOVLW  09
0189A:  MOVLB  9
0189C:  MOVWF  x15
0189E:  CLRF   x14
018A0:  MOVWF  x91
018A2:  MOVFF  914,990
018A6:  CLRF   x93
018A8:  MOVLW  14
018AA:  MOVWF  x92
018AC:  MOVLB  0
018AE:  RCALL  17AC
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
018B0:  MOVFF  913,9A2
018B4:  MOVFF  912,9A1
018B8:  RCALL  1810
018BA:  MOVFF  02,913
018BE:  MOVFF  01,912
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
018C2:  MOVLB  9
018C4:  MOVF   x01,W
018C6:  SUBLW  1A
018C8:  BC    18D4
018CA:  XORLW  FF
018CC:  BNZ   18FE
018CE:  MOVF   x00,W
018D0:  SUBLW  F7
018D2:  BNC   18FE
018D4:  MOVLW  09
018D6:  CLRF   x14
018D8:  MOVFF  914,FE9
018DC:  MOVWF  FEA
018DE:  BTFSC  FEF.0
018E0:  BRA    18FE
018E2:  BTFSC  x05.7
018E4:  BRA    18FE
018E6:  BTFSC  x04.4
018E8:  BRA    18FE
018EA:  MOVF   x03,W
018EC:  SUBLW  04
018EE:  BC    18FA
018F0:  XORLW  FF
018F2:  BNZ   18FE
018F4:  MOVF   x02,W
018F6:  SUBLW  EE
018F8:  BNC   18FE
018FA:  BTFSC  x04.7
018FC:  BRA    1900
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
018FE:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
01900:  MOVFF  901,38D
01904:  MOVFF  900,38C
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
01908:  MOVFF  8FD,03
0190C:  MOVFF  8FC,914
01910:  MOVLB  9
01912:  MOVFF  8FD,915
01916:  MOVFF  8FD,FEA
0191A:  MOVFF  8FC,FE9
0191E:  MOVLW  09
01920:  MOVWF  FE2
01922:  MOVLW  0C
01924:  MOVWF  FE1
01926:  MOVLW  06
01928:  MOVWF  01
0192A:  MOVFF  FE6,FEE
0192E:  DECFSZ 01,F
01930:  BRA    192A
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
01932:  MOVFF  8FF,03
01936:  MOVLB  8
01938:  MOVFF  8FE,FE9
0193C:  MOVFF  03,FEA
01940:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
01942:  MOVLB  9
01944:  MOVF   x13,W
01946:  SUBLW  08
01948:  BNZ   1964
0194A:  MOVF   x12,F
0194C:  BZ    1954
0194E:  MOVF   x12,W
01950:  SUBLW  06
01952:  BNZ   1964
....................     { 
....................        *type = header.Type.v[0]; 
01954:  MOVLB  8
01956:  MOVFF  8FE,FE9
0195A:  MOVFF  8FF,FEA
0195E:  MOVFF  912,FEF
01962:  MOVLB  9
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
01964:  MOVLB  3
01966:  BCF    x90.0
....................    return TRUE; 
01968:  MOVLW  01
0196A:  MOVWF  01
0196C:  MOVLB  9
0196E:  MOVLB  0
01970:  GOTO   44FC (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
01C56:  MOVLB  9
01C58:  CLRF   xA5
01C5A:  MOVLW  02
01C5C:  MOVWF  xA4
01C5E:  MOVLB  0
01C60:  CALL   0B98
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
01C64:  MOVLW  02
01C66:  MOVLB  9
01C68:  MOVWF  xA7
01C6A:  MOVLW  F8
01C6C:  MOVWF  xA8
01C6E:  MOVLB  0
01C70:  CALL   0B3E
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
01C74:  MOVLW  03
01C76:  MOVLB  9
01C78:  MOVWF  xA7
01C7A:  MOVLW  1B
01C7C:  MOVWF  xA8
01C7E:  MOVLB  0
01C80:  CALL   0B3E
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C84:  MOVLW  06
01C86:  MOVLB  9
01C88:  ADDWF  xA2,F
01C8A:  MOVLW  1C
01C8C:  ADDWFC xA3,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C8E:  MOVLW  09
01C90:  MOVWF  xA5
01C92:  MOVLW  A2
01C94:  MOVWF  xA4
01C96:  MOVWF  FE9
01C98:  MOVFF  9A5,FEA
01C9C:  MOVFF  FEF,9A8
01CA0:  MOVLW  06
01CA2:  MOVWF  xA7
01CA4:  MOVLB  0
01CA6:  CALL   0B3E
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01CAA:  MOVLW  09
01CAC:  MOVLB  9
01CAE:  MOVWF  xA5
01CB0:  MOVLW  A2
01CB2:  MOVWF  xA4
01CB4:  MOVLW  01
01CB6:  ADDWF  xA4,W
01CB8:  MOVWF  FE9
01CBA:  MOVLW  00
01CBC:  ADDWFC xA5,W
01CBE:  MOVWF  FEA
01CC0:  MOVFF  FEF,9A8
01CC4:  MOVLW  07
01CC6:  MOVWF  xA7
01CC8:  MOVLB  0
01CCA:  CALL   0B3E
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
01CCE:  MOVLB  9
01CD0:  CLRF   xA5
01CD2:  MOVLB  0
01CD4:  RCALL  1BEE
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01CD6:  MOVFF  9A0,9A7
01CDA:  MOVFF  99F,9A6
01CDE:  MOVLB  9
01CE0:  CLRF   xA9
01CE2:  MOVLW  06
01CE4:  MOVWF  xA8
01CE6:  MOVLB  0
01CE8:  RCALL  1C0C
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01CEA:  MOVLW  03
01CEC:  MOVLB  9
01CEE:  MOVWF  xA5
01CF0:  MOVLW  54
01CF2:  MOVWF  xA4
01CF4:  MOVFF  9A5,9A7
01CF8:  MOVWF  xA6
01CFA:  CLRF   xA9
01CFC:  MOVLW  06
01CFE:  MOVWF  xA8
01D00:  MOVLB  0
01D02:  RCALL  1C0C
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01D04:  MOVLW  08
01D06:  MOVLB  9
01D08:  MOVWF  xA5
01D0A:  MOVLB  0
01D0C:  RCALL  1BEE
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01D0E:  MOVLB  9
01D10:  MOVF   xA1,F
01D12:  BNZ   1D18
01D14:  MOVLW  00
01D16:  BRA    1D1A
01D18:  MOVLW  06
01D1A:  MOVWF  xA4
01D1C:  MOVWF  xA5
01D1E:  MOVLB  0
01D20:  RCALL  1BEE
01D22:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
01D24:  MOVLW  1C
01D26:  MOVLB  9
01D28:  MOVWF  xA1
01D2A:  MOVLB  0
01D2C:  CALL   0B00
01D30:  MOVFF  01,98E
01D34:  MOVLW  00
01D36:  MOVLB  9
01D38:  BTFSC  01.1
01D3A:  MOVLW  01
01D3C:  XORLW  00
01D3E:  BZ    1D60
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
01D40:  MOVLW  1F
01D42:  MOVWF  xA9
01D44:  MOVLW  80
01D46:  MOVWF  xAA
01D48:  MOVLB  0
01D4A:  CALL   0B7A
....................       BFCReg(ECON1, ECON1_TXRST); 
01D4E:  MOVLW  1F
01D50:  MOVLB  9
01D52:  MOVWF  xA6
01D54:  MOVLW  80
01D56:  MOVWF  xA7
01D58:  MOVLB  0
01D5A:  CALL   0B5C
01D5E:  MOVLB  9
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01D60:  MOVLW  1C
01D62:  MOVWF  xA6
01D64:  MOVLW  0A
01D66:  MOVWF  xA7
01D68:  MOVLB  0
01D6A:  CALL   0B5C
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
01D6E:  MOVLW  1F
01D70:  MOVLB  9
01D72:  MOVWF  xA9
01D74:  MOVLW  08
01D76:  MOVWF  xAA
01D78:  MOVLB  0
01D7A:  CALL   0B7A
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
01D7E:  MOVLB  3
01D80:  MOVF   x91,W
01D82:  SUBLW  05
01D84:  BTFSS  FD8.2
01D86:  BRA    1F50
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01D88:  MOVLW  1C
01D8A:  MOVLB  9
01D8C:  MOVWF  xA1
01D8E:  MOVLB  0
01D90:  CALL   0B00
01D94:  MOVFF  01,98E
01D98:  MOVLB  9
01D9A:  MOVF   01,W
01D9C:  ANDLW  0A
01D9E:  BTFSS  FD8.2
01DA0:  BRA    1DA6
01DA2:  MOVLB  3
01DA4:  BRA    1D88
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
01DA6:  MOVLW  1C
01DA8:  MOVWF  xA1
01DAA:  MOVLB  0
01DAC:  CALL   0B00
01DB0:  MOVFF  01,98E
01DB4:  MOVLW  00
01DB6:  MOVLB  9
01DB8:  BTFSC  01.1
01DBA:  MOVLW  01
01DBC:  XORLW  00
01DBE:  BTFSC  FD8.2
01DC0:  BRA    1F4E
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
01DC2:  MOVLW  1F
01DC4:  MOVWF  xA6
01DC6:  MOVLW  08
01DC8:  MOVWF  xA7
01DCA:  MOVLB  0
01DCC:  CALL   0B5C
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
01DD0:  MOVLB  9
01DD2:  CLRF   xA5
01DD4:  CLRF   xA4
01DD6:  MOVLB  0
01DD8:  CALL   0B98
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01DDC:  MOVLB  9
01DDE:  CLRF   xA1
01DE0:  MOVLB  0
01DE2:  CALL   0B00
01DE6:  MOVFF  01,982
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01DEA:  MOVLW  01
01DEC:  MOVLB  9
01DEE:  MOVWF  xA1
01DF0:  MOVLB  0
01DF2:  CALL   0B00
01DF6:  MOVFF  01,983
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01DFA:  MOVLW  06
01DFC:  MOVLB  9
01DFE:  MOVWF  xA1
01E00:  MOVLB  0
01E02:  CALL   0B00
01E06:  MOVFF  01,984
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01E0A:  MOVLW  07
01E0C:  MOVLB  9
01E0E:  MOVWF  xA1
01E10:  MOVLB  0
01E12:  CALL   0B00
01E16:  MOVFF  01,985
....................          TXEnd.Val++; 
01E1A:  MOVLB  9
01E1C:  INCF   x84,F
01E1E:  BTFSC  FD8.2
01E20:  INCF   x85,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
01E22:  CLRF   xA7
01E24:  MOVFF  984,9A8
01E28:  MOVLB  0
01E2A:  CALL   0B3E
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
01E2E:  MOVLW  01
01E30:  MOVLB  9
01E32:  MOVWF  xA7
01E34:  MOVFF  985,9A8
01E38:  MOVLB  0
01E3A:  CALL   0B3E
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01E3E:  MOVLW  09
01E40:  MOVLB  9
01E42:  MOVWF  x8F
01E44:  MOVLW  86
01E46:  MOVWF  x8E
01E48:  MOVFF  98F,991
01E4C:  MOVWF  x90
01E4E:  CLRF   x93
01E50:  MOVLW  07
01E52:  MOVWF  x92
01E54:  MOVLB  0
01E56:  RCALL  17AC
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
01E58:  MOVLB  9
01E5A:  CLRF   x8D
01E5C:  MOVF   x8D,W
01E5E:  SUBLW  0F
01E60:  BNC   1F30
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01E62:  MOVLW  1C
01E64:  MOVWF  xA1
01E66:  MOVLB  0
01E68:  CALL   0B00
01E6C:  MOVFF  01,98E
01E70:  MOVLW  00
01E72:  MOVLB  9
01E74:  BTFSC  01.1
01E76:  MOVLW  01
01E78:  XORLW  00
01E7A:  BZ    1F26
01E7C:  BTFSS  x89.5
01E7E:  BRA    1F26
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
01E80:  MOVLW  1F
01E82:  MOVWF  xA9
01E84:  MOVLW  80
01E86:  MOVWF  xAA
01E88:  MOVLB  0
01E8A:  CALL   0B7A
....................                BFCReg(ECON1, ECON1_TXRST); 
01E8E:  MOVLW  1F
01E90:  MOVLB  9
01E92:  MOVWF  xA6
01E94:  MOVLW  80
01E96:  MOVWF  xA7
01E98:  MOVLB  0
01E9A:  CALL   0B5C
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01E9E:  MOVLW  1C
01EA0:  MOVLB  9
01EA2:  MOVWF  xA6
01EA4:  MOVLW  0A
01EA6:  MOVWF  xA7
01EA8:  MOVLB  0
01EAA:  CALL   0B5C
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
01EAE:  MOVLW  1F
01EB0:  MOVLB  9
01EB2:  MOVWF  xA9
01EB4:  MOVLW  08
01EB6:  MOVWF  xAA
01EB8:  MOVLB  0
01EBA:  CALL   0B7A
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01EBE:  MOVLW  1C
01EC0:  MOVLB  9
01EC2:  MOVWF  xA1
01EC4:  MOVLB  0
01EC6:  CALL   0B00
01ECA:  MOVFF  01,98E
01ECE:  MOVLB  9
01ED0:  MOVF   01,W
01ED2:  ANDLW  0A
01ED4:  BTFSS  FD8.2
01ED6:  BRA    1EDC
01ED8:  MOVLB  0
01EDA:  BRA    1EBE
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
01EDC:  MOVLW  1F
01EDE:  MOVWF  xA6
01EE0:  MOVLW  08
01EE2:  MOVWF  xA7
01EE4:  MOVLB  0
01EE6:  CALL   0B5C
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
01EEA:  MOVLB  9
01EEC:  CLRF   xA7
01EEE:  MOVFF  984,9A8
01EF2:  MOVLB  0
01EF4:  CALL   0B3E
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
01EF8:  MOVLW  01
01EFA:  MOVLB  9
01EFC:  MOVWF  xA7
01EFE:  MOVFF  985,9A8
01F02:  MOVLB  0
01F04:  CALL   0B3E
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01F08:  MOVLW  09
01F0A:  MOVLB  9
01F0C:  MOVWF  x8F
01F0E:  MOVLW  86
01F10:  MOVWF  x8E
01F12:  MOVFF  98F,991
01F16:  MOVWF  x90
01F18:  CLRF   x93
01F1A:  MOVLW  07
01F1C:  MOVWF  x92
01F1E:  MOVLB  0
01F20:  RCALL  17AC
....................             } 
01F22:  BRA    1F2A
01F24:  MOVLB  9
....................             else 
....................             { 
....................                break; 
01F26:  BRA    1F30
01F28:  MOVLB  0
....................             } 
01F2A:  MOVLB  9
01F2C:  INCF   x8D,F
01F2E:  BRA    1E5C
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01F30:  CLRF   xA7
01F32:  MOVFF  982,9A8
01F36:  MOVLB  0
01F38:  CALL   0B3E
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01F3C:  MOVLW  01
01F3E:  MOVLB  9
01F40:  MOVWF  xA7
01F42:  MOVFF  983,9A8
01F46:  MOVLB  0
01F48:  CALL   0B3E
01F4C:  MOVLB  9
01F4E:  MOVLB  3
....................       } 
....................    } 
01F50:  MOVLB  0
01F52:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02284:  MOVLW  14
02286:  MOVLB  3
02288:  ADDWF  x8E,W
0228A:  MOVLB  9
0228C:  MOVWF  x31
0228E:  MOVLW  00
02290:  MOVLB  3
02292:  ADDWFC x8F,W
02294:  MOVLB  9
02296:  MOVWF  x32
02298:  MOVF   x2D,W
0229A:  ADDWF  x31,W
0229C:  MOVWF  x2F
0229E:  MOVF   x2E,W
022A0:  ADDWFC x32,W
022A2:  MOVWF  x30
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
022A4:  MOVF   x30,W
022A6:  SUBLW  1A
022A8:  BC    22BC
022AA:  XORLW  FF
022AC:  BNZ   22B4
022AE:  MOVF   x2F,W
022B0:  SUBLW  F7
022B2:  BC    22BC
....................       ReadPT.Val -= RXSIZE; 
022B4:  MOVLW  F8
022B6:  SUBWF  x2F,F
022B8:  MOVLW  1B
022BA:  SUBWFB x30,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
022BC:  CLRF   xA5
022BE:  CLRF   xA4
022C0:  MOVLB  0
022C2:  CALL   0B98
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
022C6:  MOVLB  9
022C8:  CLRF   xA7
022CA:  MOVFF  92F,9A8
022CE:  MOVLB  0
022D0:  CALL   0B3E
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
022D4:  MOVLW  01
022D6:  MOVLB  9
022D8:  MOVWF  xA7
022DA:  MOVFF  930,9A8
022DE:  MOVLB  0
022E0:  CALL   0B3E
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
022E4:  MOVLW  02
022E6:  MOVLB  9
022E8:  MOVWF  xA7
022EA:  MOVFF  92F,9A8
022EE:  MOVLB  0
022F0:  CALL   0B3E
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
022F4:  MOVLW  03
022F6:  MOVLB  9
022F8:  MOVWF  xA7
022FA:  MOVFF  930,9A8
022FE:  MOVLB  0
02300:  CALL   0B3E
02304:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01B50:  MOVFF  99B,387
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
01B54:  MOVLW  07
01B56:  MOVLB  9
01B58:  ADDWF  x9C,F
01B5A:  MOVLW  1C
01B5C:  ADDWFC x9D,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
01B5E:  CLRF   xA5
01B60:  MOVLW  02
01B62:  MOVWF  xA4
01B64:  MOVLB  0
01B66:  CALL   0B98
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01B6A:  MOVLW  09
01B6C:  MOVLB  9
01B6E:  MOVWF  x9F
01B70:  MOVLW  9C
01B72:  MOVWF  x9E
01B74:  MOVWF  FE9
01B76:  MOVFF  99F,FEA
01B7A:  MOVFF  FEF,9A8
01B7E:  CLRF   xA7
01B80:  MOVLB  0
01B82:  CALL   0B3E
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
01B86:  MOVLW  09
01B88:  MOVLB  9
01B8A:  MOVWF  x9F
01B8C:  MOVLW  9C
01B8E:  MOVWF  x9E
01B90:  MOVLW  01
01B92:  ADDWF  x9E,W
01B94:  MOVWF  FE9
01B96:  MOVLW  00
01B98:  ADDWFC x9F,W
01B9A:  MOVWF  FEA
01B9C:  MOVFF  FEF,9A8
01BA0:  MOVLW  01
01BA2:  MOVWF  xA7
01BA4:  MOVLB  0
01BA6:  CALL   0B3E
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01BAA:  MOVLW  09
01BAC:  MOVLB  9
01BAE:  MOVWF  x9F
01BB0:  MOVLW  9C
01BB2:  MOVWF  x9E
01BB4:  MOVWF  FE9
01BB6:  MOVFF  99F,FEA
01BBA:  MOVFF  FEF,9A8
01BBE:  MOVLW  02
01BC0:  MOVWF  xA7
01BC2:  MOVLB  0
01BC4:  CALL   0B3E
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
01BC8:  MOVLW  09
01BCA:  MOVLB  9
01BCC:  MOVWF  x9F
01BCE:  MOVLW  9C
01BD0:  MOVWF  x9E
01BD2:  MOVLW  01
01BD4:  ADDWF  x9E,W
01BD6:  MOVWF  FE9
01BD8:  MOVLW  00
01BDA:  ADDWFC x9F,W
01BDC:  MOVWF  FEA
01BDE:  MOVFF  FEF,9A8
01BE2:  MOVLW  03
01BE4:  MOVWF  xA7
01BE6:  MOVLB  0
01BE8:  CALL   0B3E
01BEC:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02176:  MOVLW  14
02178:  MOVLB  3
0217A:  ADDWF  x8E,W
0217C:  MOVLB  9
0217E:  MOVWF  x5D
02180:  MOVLW  00
02182:  MOVLB  3
02184:  ADDWFC x8F,W
02186:  MOVLB  9
02188:  MOVWF  x5E
0218A:  MOVF   x57,W
0218C:  ADDWF  x5D,W
0218E:  MOVWF  x5B
02190:  MOVF   x58,W
02192:  ADDWFC x5E,W
02194:  MOVWF  x5C
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
02196:  MOVF   x5C,W
02198:  SUBLW  1A
0219A:  BC    21AE
0219C:  XORLW  FF
0219E:  BNZ   21A6
021A0:  MOVF   x5B,W
021A2:  SUBLW  F7
021A4:  BC    21AE
....................    { 
....................       temp.Val -= RXSIZE; 
021A6:  MOVLW  F8
021A8:  SUBWF  x5B,F
021AA:  MOVLW  1B
021AC:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
021AE:  CLRF   xA5
021B0:  MOVLW  10
021B2:  MOVWF  xA4
021B4:  MOVLB  0
021B6:  CALL   0B98
....................    WriteReg(EDMASTL, temp.v[0]); 
021BA:  MOVLW  10
021BC:  MOVLB  9
021BE:  MOVWF  xA7
021C0:  MOVFF  95B,9A8
021C4:  MOVLB  0
021C6:  CALL   0B3E
....................    WriteReg(EDMASTH, temp.v[1]); 
021CA:  MOVLW  11
021CC:  MOVLB  9
021CE:  MOVWF  xA7
021D0:  MOVFF  95C,9A8
021D4:  MOVLB  0
021D6:  CALL   0B3E
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
021DA:  MOVLW  01
021DC:  MOVLB  9
021DE:  SUBWF  x59,W
021E0:  MOVWF  00
021E2:  MOVLW  00
021E4:  SUBWFB x5A,W
021E6:  MOVWF  03
021E8:  MOVF   00,W
021EA:  ADDWF  x5B,F
021EC:  MOVF   03,W
021EE:  ADDWFC x5C,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
021F0:  MOVF   x5C,W
021F2:  SUBLW  1A
021F4:  BC    2208
021F6:  XORLW  FF
021F8:  BNZ   2200
021FA:  MOVF   x5B,W
021FC:  SUBLW  F7
021FE:  BC    2208
....................    { 
....................       temp.Val -= RXSIZE; 
02200:  MOVLW  F8
02202:  SUBWF  x5B,F
02204:  MOVLW  1B
02206:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
02208:  MOVLW  12
0220A:  MOVWF  xA7
0220C:  MOVFF  95B,9A8
02210:  MOVLB  0
02212:  CALL   0B3E
....................    WriteReg(EDMANDH, temp.v[1]); 
02216:  MOVLW  13
02218:  MOVLB  9
0221A:  MOVWF  xA7
0221C:  MOVFF  95C,9A8
02220:  MOVLB  0
02222:  CALL   0B3E
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02226:  MOVLW  1F
02228:  MOVLB  9
0222A:  MOVWF  xA9
0222C:  MOVLW  30
0222E:  MOVWF  xAA
02230:  MOVLB  0
02232:  CALL   0B7A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02236:  MOVLW  1F
02238:  MOVLB  9
0223A:  MOVWF  xA1
0223C:  MOVLB  0
0223E:  CALL   0B00
02242:  MOVFF  01,95D
02246:  MOVLW  00
02248:  MOVLB  9
0224A:  BTFSC  01.5
0224C:  MOVLW  01
0224E:  XORLW  00
02250:  BTFSC  FD8.2
02252:  BRA    2258
02254:  MOVLB  0
02256:  BRA    2236
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02258:  MOVLW  16
0225A:  MOVWF  xA1
0225C:  MOVLB  0
0225E:  CALL   0B00
02262:  MOVFF  01,95C
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02266:  MOVLW  17
02268:  MOVLB  9
0226A:  MOVWF  xA1
0226C:  MOVLB  0
0226E:  CALL   0B00
02272:  MOVFF  01,95B
....................    return temp.Val; 
02276:  MOVLB  9
02278:  MOVFF  95B,01
0227C:  MOVFF  95C,02
02280:  MOVLB  0
02282:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
02DAA:  MOVLW  06
02DAC:  MOVLB  9
02DAE:  ADDWF  x9B,W
02DB0:  MOVWF  xA1
02DB2:  MOVLW  1C
02DB4:  ADDWFC x9C,W
02DB6:  MOVWF  xA2
02DB8:  MOVLW  01
02DBA:  ADDWF  xA1,W
02DBC:  MOVWF  x9F
02DBE:  MOVLW  00
02DC0:  ADDWFC xA2,W
02DC2:  MOVWF  xA0
.................... #endif 
....................    BankSel(EDMASTL); 
02DC4:  CLRF   xA5
02DC6:  MOVLW  10
02DC8:  MOVWF  xA4
02DCA:  MOVLB  0
02DCC:  CALL   0B98
....................    WriteReg(EDMASTL, temp.v[0]); 
02DD0:  MOVLW  10
02DD2:  MOVLB  9
02DD4:  MOVWF  xA7
02DD6:  MOVFF  99F,9A8
02DDA:  MOVLB  0
02DDC:  CALL   0B3E
....................    WriteReg(EDMASTH, temp.v[1]); 
02DE0:  MOVLW  11
02DE2:  MOVLB  9
02DE4:  MOVWF  xA7
02DE6:  MOVFF  9A0,9A8
02DEA:  MOVLB  0
02DEC:  CALL   0B3E
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
02DF0:  MOVLW  01
02DF2:  MOVLB  9
02DF4:  SUBWF  x9D,W
02DF6:  MOVWF  00
02DF8:  MOVLW  00
02DFA:  SUBWFB x9E,W
02DFC:  MOVWF  03
02DFE:  MOVF   00,W
02E00:  ADDWF  x9F,F
02E02:  MOVF   03,W
02E04:  ADDWFC xA0,F
....................    WriteReg(EDMANDL, temp.v[0]); 
02E06:  MOVLW  12
02E08:  MOVWF  xA7
02E0A:  MOVFF  99F,9A8
02E0E:  MOVLB  0
02E10:  CALL   0B3E
....................    WriteReg(EDMANDH, temp.v[1]); 
02E14:  MOVLW  13
02E16:  MOVLB  9
02E18:  MOVWF  xA7
02E1A:  MOVFF  9A0,9A8
02E1E:  MOVLB  0
02E20:  CALL   0B3E
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02E24:  MOVLW  1F
02E26:  MOVLB  9
02E28:  MOVWF  xA9
02E2A:  MOVLW  30
02E2C:  MOVWF  xAA
02E2E:  MOVLB  0
02E30:  CALL   0B7A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02E34:  MOVLW  1F
02E36:  MOVLB  9
02E38:  MOVWF  xA1
02E3A:  MOVLB  0
02E3C:  CALL   0B00
02E40:  MOVFF  01,9A1
02E44:  MOVLW  00
02E46:  MOVLB  9
02E48:  BTFSC  01.5
02E4A:  MOVLW  01
02E4C:  XORLW  00
02E4E:  BTFSC  FD8.2
02E50:  BRA    2E56
02E52:  MOVLB  0
02E54:  BRA    2E34
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02E56:  MOVLW  16
02E58:  MOVWF  xA1
02E5A:  MOVLB  0
02E5C:  CALL   0B00
02E60:  MOVFF  01,9A0
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02E64:  MOVLW  17
02E66:  MOVLB  9
02E68:  MOVWF  xA1
02E6A:  MOVLB  0
02E6C:  CALL   0B00
02E70:  MOVFF  01,99F
....................    return temp.Val; 
02E74:  MOVLB  9
02E76:  MOVFF  99F,01
02E7A:  MOVFF  9A0,02
02E7E:  MOVLB  0
02E80:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
025DC:  MOVLB  9
025DE:  MOVF   x82,F
025E0:  BNZ   25F0
025E2:  MOVF   x83,F
025E4:  BNZ   25F0
....................    { 
....................       return 0xFFFF; 
025E6:  MOVLW  FF
025E8:  MOVWF  01
025EA:  MOVWF  02
025EC:  BRA    2730
....................    } 
025EE:  BRA    261E
....................    else if(len == 1u) 
025F0:  DECFSZ x82,W
025F2:  BRA    261E
025F4:  MOVF   x83,F
025F6:  BNZ   261E
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
025F8:  MOVLB  0
025FA:  RCALL  25B0
025FC:  MOVLB  9
025FE:  CLRF   x87
02600:  MOVFF  01,986
02604:  MOVFF  01,03
02608:  MOVLW  00
0260A:  CLRF   00
0260C:  DECF   00,F
0260E:  XORWF  00,F
02610:  MOVLW  FF
02612:  XORWF  03,F
02614:  MOVFF  00,01
02618:  MOVFF  03,02
0261C:  BRA    2730
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
0261E:  CLRF   xA5
02620:  CLRF   xA4
02622:  MOVLB  0
02624:  CALL   0B98
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
02628:  MOVLB  9
0262A:  CLRF   xA1
0262C:  MOVLB  0
0262E:  CALL   0B00
02632:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
02636:  MOVLW  01
02638:  MOVLB  9
0263A:  MOVWF  xA1
0263C:  MOVLB  0
0263E:  CALL   0B00
02642:  MOVFF  01,985
....................    WriteReg(EDMASTL, temp.v[0]); 
02646:  MOVLW  10
02648:  MOVLB  9
0264A:  MOVWF  xA7
0264C:  MOVFF  984,9A8
02650:  MOVLB  0
02652:  CALL   0B3E
....................    WriteReg(EDMASTH, temp.v[1]); 
02656:  MOVLW  11
02658:  MOVLB  9
0265A:  MOVWF  xA7
0265C:  MOVFF  985,9A8
02660:  MOVLB  0
02662:  CALL   0B3E
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
02666:  MOVLB  9
02668:  MOVF   x85,W
0266A:  SUBLW  1B
0266C:  BNC   26A4
0266E:  BNZ   2676
02670:  MOVF   x84,W
02672:  SUBLW  F7
02674:  BNC   26A4
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
02676:  MOVLW  01
02678:  SUBWF  x82,W
0267A:  MOVWF  00
0267C:  MOVLW  00
0267E:  SUBWFB x83,W
02680:  MOVWF  03
02682:  MOVF   00,W
02684:  ADDWF  x84,F
02686:  MOVF   03,W
02688:  ADDWFC x85,F
....................       if(temp.Val > RXSTOP) 
0268A:  MOVF   x85,W
0268C:  SUBLW  1A
0268E:  BC    26A2
02690:  XORLW  FF
02692:  BNZ   269A
02694:  MOVF   x84,W
02696:  SUBLW  F7
02698:  BC    26A2
....................       { 
....................          temp.Val -= RXSIZE; 
0269A:  MOVLW  F8
0269C:  SUBWF  x84,F
0269E:  MOVLW  1B
026A0:  SUBWFB x85,F
....................       } 
....................    } 
026A2:  BRA    26B8
....................    else 
....................    { 
....................       temp.Val += len-1; 
026A4:  MOVLW  01
026A6:  SUBWF  x82,W
026A8:  MOVWF  00
026AA:  MOVLW  00
026AC:  SUBWFB x83,W
026AE:  MOVWF  03
026B0:  MOVF   00,W
026B2:  ADDWF  x84,F
026B4:  MOVF   03,W
026B6:  ADDWFC x85,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
026B8:  MOVLW  12
026BA:  MOVWF  xA7
026BC:  MOVFF  984,9A8
026C0:  MOVLB  0
026C2:  CALL   0B3E
....................    WriteReg(EDMANDH, temp.v[1]); 
026C6:  MOVLW  13
026C8:  MOVLB  9
026CA:  MOVWF  xA7
026CC:  MOVFF  985,9A8
026D0:  MOVLB  0
026D2:  CALL   0B3E
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
026D6:  MOVLW  1F
026D8:  MOVLB  9
026DA:  MOVWF  xA9
026DC:  MOVLW  30
026DE:  MOVWF  xAA
026E0:  MOVLB  0
026E2:  CALL   0B7A
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
026E6:  MOVLW  1F
026E8:  MOVLB  9
026EA:  MOVWF  xA1
026EC:  MOVLB  0
026EE:  CALL   0B00
026F2:  MOVFF  01,986
026F6:  MOVLW  00
026F8:  MOVLB  9
026FA:  BTFSC  01.5
026FC:  MOVLW  01
026FE:  XORLW  00
02700:  BTFSC  FD8.2
02702:  BRA    2708
02704:  MOVLB  0
02706:  BRA    26E6
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
02708:  MOVLW  16
0270A:  MOVWF  xA1
0270C:  MOVLB  0
0270E:  CALL   0B00
02712:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
02716:  MOVLW  17
02718:  MOVLB  9
0271A:  MOVWF  xA1
0271C:  MOVLB  0
0271E:  CALL   0B00
02722:  MOVFF  01,985
....................    return temp.Val; 
02726:  MOVLB  9
02728:  MOVFF  984,01
0272C:  MOVFF  985,02
02730:  MOVLB  0
02732:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
025B0:  BCF    F94.1
025B2:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
025B4:  MOVLW  3A
025B6:  MOVLB  9
025B8:  MOVWF  xAC
025BA:  MOVLB  0
025BC:  CALL   0AC6
....................    c=ENCSPIXfer(0); 
025C0:  MOVLB  9
025C2:  CLRF   xAC
025C4:  MOVLB  0
025C6:  CALL   0AC6
025CA:  MOVFF  01,986
....................    SPIUnselectEthernet(); 
025CE:  BCF    F94.1
025D0:  BSF    F8B.1
....................    return(c); 
025D2:  MOVLB  9
025D4:  MOVFF  986,01
025D8:  MOVLB  0
025DA:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
017AC:  MOVLB  9
017AE:  CLRF   x95
017B0:  CLRF   x94
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
017B2:  BCF    F94.1
017B4:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
017B6:  MOVLW  3A
017B8:  MOVWF  xAC
017BA:  MOVLB  0
017BC:  CALL   0AC6
....................    while(i<len) 
017C0:  MOVLB  9
017C2:  MOVF   x95,W
017C4:  SUBWF  x93,W
017C6:  BNC   1800
017C8:  BNZ   17D0
017CA:  MOVF   x92,W
017CC:  SUBWF  x94,W
017CE:  BC    1800
....................    { 
....................       *val=ENCSPIXfer(0); 
017D0:  MOVFF  991,03
017D4:  MOVFF  990,996
017D8:  MOVFF  991,997
017DC:  CLRF   xAC
017DE:  MOVLB  0
017E0:  CALL   0AC6
017E4:  MOVFF  997,FEA
017E8:  MOVFF  996,FE9
017EC:  MOVFF  01,FEF
....................       val++; 
017F0:  MOVLB  9
017F2:  INCF   x90,F
017F4:  BTFSC  FD8.2
017F6:  INCF   x91,F
....................       i++; 
017F8:  INCF   x94,F
017FA:  BTFSC  FD8.2
017FC:  INCF   x95,F
017FE:  BRA    17C2
....................    } 
....................    SPIUnselectEthernet(); 
01800:  BCF    F94.1
01802:  BSF    F8B.1
....................  
....................    return(i); 
01804:  MOVFF  994,01
01808:  MOVFF  995,02
0180C:  MOVLB  0
0180E:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01BEE:  BCF    F94.1
01BF0:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BF2:  MOVLW  7A
01BF4:  MOVLB  9
01BF6:  MOVWF  xAC
01BF8:  MOVLB  0
01BFA:  CALL   0AC6
....................    ENCSPIXfer(val); 
01BFE:  MOVFF  9A5,9AC
01C02:  CALL   0AC6
....................    SPIUnselectEthernet(); 
01C06:  BCF    F94.1
01C08:  BSF    F8B.1
01C0A:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01C0C:  BCF    F94.1
01C0E:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01C10:  MOVLW  7A
01C12:  MOVLB  9
01C14:  MOVWF  xAC
01C16:  MOVLB  0
01C18:  CALL   0AC6
....................    while(len--) 
01C1C:  MOVLB  9
01C1E:  MOVFF  9A9,03
01C22:  MOVF   xA8,W
01C24:  BTFSC  FD8.2
01C26:  DECF   xA9,F
01C28:  DECF   xA8,F
01C2A:  IORWF  03,W
01C2C:  BZ    1C4E
....................    { 
....................       ENCSPIXfer(*val); 
01C2E:  MOVFF  9A7,03
01C32:  MOVFF  9A6,FE9
01C36:  MOVFF  9A7,FEA
01C3A:  MOVFF  FEF,9AC
01C3E:  MOVLB  0
01C40:  CALL   0AC6
....................       val++; 
01C44:  MOVLB  9
01C46:  INCF   xA6,F
01C48:  BTFSC  FD8.2
01C4A:  INCF   xA7,F
01C4C:  BRA    1C1E
....................    } 
....................    SPIUnselectEthernet(); 
01C4E:  BCF    F94.1
01C50:  BSF    F8B.1
01C52:  MOVLB  0
01C54:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B2A:  BCF    F94.1
00B2C:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
00B2E:  MOVLB  9
00B30:  SETF   xAC
00B32:  MOVLB  0
00B34:  RCALL  0AC6
....................    SPIUnselectEthernet(); 
00B36:  BCF    F94.1
00B38:  BSF    F8B.1
00B3A:  GOTO   0DF6 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
00B00:  BCF    F94.1
00B02:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
00B04:  MOVFF  9A1,9A3
00B08:  MOVFF  9A1,9AC
00B0C:  MOVLB  0
00B0E:  RCALL  0AC6
....................    c=ENCSPIXfer(0); 
00B10:  MOVLB  9
00B12:  CLRF   xAC
00B14:  MOVLB  0
00B16:  RCALL  0AC6
00B18:  MOVFF  01,9A2
....................    SPIUnselectEthernet(); 
00B1C:  BCF    F94.1
00B1E:  BSF    F8B.1
....................    return(c); 
00B20:  MOVLB  9
00B22:  MOVFF  9A2,01
00B26:  MOVLB  0
00B28:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
00BCA:  BCF    F94.1
00BCC:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
00BCE:  MOVFF  8FE,900
00BD2:  MOVFF  8FE,9AC
00BD6:  MOVLB  0
00BD8:  RCALL  0AC6
....................    ENCSPIXfer(0); 
00BDA:  MOVLB  9
00BDC:  CLRF   xAC
00BDE:  MOVLB  0
00BE0:  RCALL  0AC6
....................    c=ENCSPIXfer(0); 
00BE2:  MOVLB  9
00BE4:  CLRF   xAC
00BE6:  MOVLB  0
00BE8:  RCALL  0AC6
00BEA:  MOVFF  01,8FF
....................  
....................    SPIUnselectEthernet(); 
00BEE:  BCF    F94.1
00BF0:  BSF    F8B.1
....................  
....................    return(c); 
00BF2:  MOVLB  8
00BF4:  MOVFF  8FF,01
00BF8:  MOVLB  0
00BFA:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
00C8C:  MOVLW  02
00C8E:  MOVLB  9
00C90:  MOVWF  xA5
00C92:  MOVLW  14
00C94:  MOVWF  xA4
00C96:  MOVLB  0
00C98:  RCALL  0B98
....................    WriteReg(MIREGADR, Register); 
00C9A:  MOVLW  14
00C9C:  MOVLB  9
00C9E:  MOVWF  xA7
00CA0:  MOVFF  8FB,9A8
00CA4:  MOVLB  0
00CA6:  RCALL  0B3E
....................    WriteReg(MICMD, MICMD_MIIRD); 
00CA8:  MOVLW  12
00CAA:  MOVLB  9
00CAC:  MOVWF  xA7
00CAE:  MOVLW  01
00CB0:  MOVWF  xA8
00CB2:  MOVLB  0
00CB4:  RCALL  0B3E
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
00CB6:  MOVLW  03
00CB8:  MOVLB  9
00CBA:  MOVWF  xA5
00CBC:  MOVLW  0A
00CBE:  MOVWF  xA4
00CC0:  MOVLB  0
00CC2:  RCALL  0B98
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00CC4:  MOVLW  0A
00CC6:  MOVLB  8
00CC8:  MOVWF  xFE
00CCA:  MOVLB  0
00CCC:  RCALL  0BCA
00CCE:  MOVFF  01,8FE
00CD2:  MOVLW  00
00CD4:  MOVLB  8
00CD6:  BTFSC  01.0
00CD8:  MOVLW  01
00CDA:  XORLW  00
00CDC:  BTFSC  FD8.2
00CDE:  BRA    0CE4
00CE0:  MOVLB  0
00CE2:  BRA    0CC4
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
00CE4:  MOVLW  02
00CE6:  MOVLB  9
00CE8:  MOVWF  xA5
00CEA:  MOVLW  14
00CEC:  MOVWF  xA4
00CEE:  MOVLB  0
00CF0:  RCALL  0B98
....................    WriteReg(MICMD, 0x00); 
00CF2:  MOVLW  12
00CF4:  MOVLB  9
00CF6:  MOVWF  xA7
00CF8:  CLRF   xA8
00CFA:  MOVLB  0
00CFC:  RCALL  0B3E
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
00CFE:  MOVLW  18
00D00:  MOVLB  8
00D02:  MOVWF  xFE
00D04:  MOVLB  0
00D06:  RCALL  0BCA
00D08:  MOVFF  01,8FC
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
00D0C:  MOVLW  19
00D0E:  MOVLB  8
00D10:  MOVWF  xFE
00D12:  MOVLB  0
00D14:  RCALL  0BCA
00D16:  MOVFF  01,8FD
....................    return Result; 
00D1A:  MOVLB  8
00D1C:  MOVFF  8FC,01
00D20:  MOVFF  8FD,02
00D24:  MOVLB  0
00D26:  RETURN 0
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B3E:  BCF    F94.1
00B40:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
00B42:  MOVLB  9
00B44:  MOVF   xA7,W
00B46:  IORLW  40
00B48:  MOVWF  xA9
00B4A:  MOVWF  xAC
00B4C:  MOVLB  0
00B4E:  RCALL  0AC6
....................    ENCSPIXfer(Data); 
00B50:  MOVFF  9A8,9AC
00B54:  RCALL  0AC6
....................    SPIUnselectEthernet(); 
00B56:  BCF    F94.1
00B58:  BSF    F8B.1
00B5A:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00B5C:  BCF    F94.1
00B5E:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
00B60:  MOVLB  9
00B62:  MOVF   xA6,W
00B64:  IORLW  A0
00B66:  MOVWF  xA8
00B68:  MOVWF  xAC
00B6A:  MOVLB  0
00B6C:  RCALL  0AC6
....................    ENCSPIXfer(Data); 
00B6E:  MOVFF  9A7,9AC
00B72:  RCALL  0AC6
....................    SPIUnselectEthernet(); 
00B74:  BCF    F94.1
00B76:  BSF    F8B.1
00B78:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00B7A:  BCF    F94.1
00B7C:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
00B7E:  MOVLB  9
00B80:  MOVF   xA9,W
00B82:  IORLW  80
00B84:  MOVWF  xAB
00B86:  MOVWF  xAC
00B88:  MOVLB  0
00B8A:  RCALL  0AC6
....................    ENCSPIXfer(Data); 
00B8C:  MOVFF  9AA,9AC
00B90:  RCALL  0AC6
....................    SPIUnselectEthernet(); 
00B92:  BCF    F94.1
00B94:  BSF    F8B.1
00B96:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
00BFC:  MOVLW  02
00BFE:  MOVLB  9
00C00:  MOVWF  xA5
00C02:  MOVLW  14
00C04:  MOVWF  xA4
00C06:  MOVLB  0
00C08:  RCALL  0B98
....................    WriteReg(MIREGADR, Register); 
00C0A:  MOVLW  14
00C0C:  MOVLB  9
00C0E:  MOVWF  xA7
00C10:  MOVFF  8FB,9A8
00C14:  MOVLB  0
00C16:  RCALL  0B3E
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00C18:  MOVLW  08
00C1A:  MOVLB  8
00C1C:  MOVWF  xFF
00C1E:  MOVLW  FC
00C20:  MOVWF  xFE
00C22:  MOVWF  FE9
00C24:  MOVFF  8FF,FEA
00C28:  MOVFF  FEF,9A8
00C2C:  MOVLW  16
00C2E:  MOVLB  9
00C30:  MOVWF  xA7
00C32:  MOVLB  0
00C34:  RCALL  0B3E
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00C36:  MOVLW  08
00C38:  MOVLB  8
00C3A:  MOVWF  xFF
00C3C:  MOVLW  FC
00C3E:  MOVWF  xFE
00C40:  MOVLW  01
00C42:  ADDWF  xFE,W
00C44:  MOVWF  FE9
00C46:  MOVLW  00
00C48:  ADDWFC xFF,W
00C4A:  MOVWF  FEA
00C4C:  MOVFF  FEF,9A8
00C50:  MOVLW  17
00C52:  MOVLB  9
00C54:  MOVWF  xA7
00C56:  MOVLB  0
00C58:  RCALL  0B3E
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
00C5A:  MOVLW  03
00C5C:  MOVLB  9
00C5E:  MOVWF  xA5
00C60:  MOVLW  0A
00C62:  MOVWF  xA4
00C64:  MOVLB  0
00C66:  RCALL  0B98
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00C68:  MOVLW  0A
00C6A:  MOVLB  8
00C6C:  MOVWF  xFE
00C6E:  MOVLB  0
00C70:  RCALL  0BCA
00C72:  MOVFF  01,8FE
00C76:  MOVLW  00
00C78:  MOVLB  8
00C7A:  BTFSC  01.0
00C7C:  MOVLW  01
00C7E:  XORLW  00
00C80:  BTFSC  FD8.2
00C82:  BRA    0C88
00C84:  MOVLB  0
00C86:  BRA    0C68
00C88:  MOVLB  0
00C8A:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
00B98:  MOVLW  1F
00B9A:  MOVLB  9
00B9C:  MOVWF  xA6
00B9E:  MOVLW  03
00BA0:  MOVWF  xA7
00BA2:  MOVLB  0
00BA4:  RCALL  0B5C
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00BA6:  MOVLW  09
00BA8:  MOVLB  9
00BAA:  MOVWF  xA7
00BAC:  MOVLW  A4
00BAE:  MOVWF  xA6
00BB0:  MOVLW  01
00BB2:  ADDWF  xA6,W
00BB4:  MOVWF  FE9
00BB6:  MOVLW  00
00BB8:  ADDWFC xA7,W
00BBA:  MOVWF  FEA
00BBC:  MOVFF  FEF,9AA
00BC0:  MOVLW  1F
00BC2:  MOVWF  xA9
00BC4:  MOVLB  0
00BC6:  RCALL  0B7A
00BC8:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
00D28:  MOVLW  1F
00D2A:  MOVLB  9
00D2C:  MOVWF  xA6
00D2E:  MOVLW  0C
00D30:  MOVWF  xA7
00D32:  MOVLB  0
00D34:  RCALL  0B5C
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
00D36:  MOVLB  8
00D38:  CLRF   xFB
00D3A:  MOVLB  0
00D3C:  RCALL  0C8C
00D3E:  MOVFF  02,8FA
00D42:  MOVFF  01,8F9
....................    if(DuplexState == USE_PHY) 
00D46:  MOVLB  8
00D48:  MOVF   xF7,W
00D4A:  SUBLW  02
00D4C:  BNZ   0D56
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
00D4E:  CLRF   xF7
00D50:  BTFSC  xFA.0
00D52:  INCF   xF7,F
....................    } 
00D54:  BRA    0D6C
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
00D56:  BCF    xFA.0
00D58:  BTFSC  xF7.0
00D5A:  BSF    xFA.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
00D5C:  CLRF   xFB
00D5E:  MOVFF  8FA,8FD
00D62:  MOVFF  8F9,8FC
00D66:  MOVLB  0
00D68:  RCALL  0BFC
00D6A:  MOVLB  8
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
00D6C:  MOVLW  02
00D6E:  MOVLB  9
00D70:  MOVWF  xA5
00D72:  MOVWF  xA4
00D74:  MOVLB  0
00D76:  RCALL  0B98
....................    Register = ReadMACReg(MACON3); 
00D78:  MOVLW  02
00D7A:  MOVLB  8
00D7C:  MOVWF  xFE
00D7E:  MOVLB  0
00D80:  RCALL  0BCA
00D82:  MOVFF  01,8F8
....................    Register.MACON3bits.FULDPX = DuplexState; 
00D86:  MOVLB  8
00D88:  BCF    xF8.0
00D8A:  BTFSC  xF7.0
00D8C:  BSF    xF8.0
....................    WriteReg(MACON3, Register.Val); 
00D8E:  MOVLW  02
00D90:  MOVLB  9
00D92:  MOVWF  xA7
00D94:  MOVFF  8F8,9A8
00D98:  MOVLB  0
00D9A:  RCALL  0B3E
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
00D9C:  MOVLB  8
00D9E:  MOVF   xF7,F
00DA0:  BZ    0DA6
00DA2:  MOVLW  15
00DA4:  BRA    0DA8
00DA6:  MOVLW  12
00DA8:  MOVWF  xFB
00DAA:  MOVLW  04
00DAC:  MOVLB  9
00DAE:  MOVWF  xA7
00DB0:  MOVFF  8FB,9A8
00DB4:  MOVLB  0
00DB6:  RCALL  0B3E
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
00DB8:  MOVLW  1F
00DBA:  MOVLB  9
00DBC:  MOVWF  xA9
00DBE:  MOVLW  04
00DC0:  MOVWF  xAA
00DC2:  MOVLB  0
00DC4:  RCALL  0B7A
00DC6:  GOTO   0F8A (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
023CE:  MOVLW  09
023D0:  MOVLB  9
023D2:  MOVWF  x1B
023D4:  MOVLW  06
023D6:  MOVWF  x1A
023D8:  MOVFF  91B,991
023DC:  MOVWF  x90
023DE:  CLRF   x93
023E0:  MOVLW  14
023E2:  MOVWF  x92
023E4:  MOVLB  0
023E6:  CALL   17AC
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
023EA:  MOVLB  9
023EC:  MOVF   x06,W
023EE:  ANDLW  F0
023F0:  SUBLW  40
023F2:  BZ    23FA
....................     	return FALSE; 
023F4:  MOVLW  00
023F6:  MOVWF  01
023F8:  BRA    24B4
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
023FA:  MOVF   x06,W
023FC:  ANDLW  0F
023FE:  MOVWF  00
02400:  RLCF   00,W
02402:  MOVLB  3
02404:  MOVWF  x94
02406:  RLCF   x94,F
02408:  MOVLW  FC
0240A:  ANDWF  x94,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
0240C:  MOVLB  9
0240E:  CLRF   x58
02410:  CLRF   x57
02412:  CLRF   x5A
02414:  MOVFF  394,959
02418:  MOVLB  0
0241A:  RCALL  2176
0241C:  MOVFF  02,905
02420:  MOVFF  01,904
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
02424:  MOVLB  9
02426:  CLRF   x2E
02428:  MOVFF  394,92D
0242C:  MOVLB  0
0242E:  RCALL  2284
....................  
....................     if(CalcChecksum.Val) 
02430:  MOVLB  9
02432:  MOVF   x04,W
02434:  IORWF  x05,W
02436:  BZ    243E
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
02438:  MOVLW  00
0243A:  MOVWF  01
0243C:  BRA    24B4
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
0243E:  MOVLW  09
02440:  MOVWF  x9C
02442:  MOVLW  06
02444:  MOVWF  x9B
02446:  MOVLB  0
02448:  RCALL  2306
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
0244A:  MOVLB  8
0244C:  MOVF   xFC,W
0244E:  IORWF  xFD,W
02450:  BZ    246A
....................         localIP->Val    = header.DestAddress.Val; 
02452:  MOVFF  8FC,FE9
02456:  MOVFF  8FD,FEA
0245A:  MOVFF  916,FEF
0245E:  MOVFF  917,FEC
02462:  MOVFF  918,FEC
02466:  MOVFF  919,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
0246A:  MOVLW  06
0246C:  ADDWF  xFE,W
0246E:  MOVWF  FE9
02470:  MOVLW  00
02472:  ADDWFC xFF,W
02474:  MOVWF  FEA
02476:  MOVFF  912,FEF
0247A:  MOVFF  913,FEC
0247E:  MOVFF  914,FEC
02482:  MOVFF  915,FEC
....................     *protocol           = header.Protocol; 
02486:  MOVLB  9
02488:  MOVFF  900,FE9
0248C:  MOVFF  901,FEA
02490:  MOVFF  90F,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
02494:  MOVFF  902,FE9
02498:  MOVFF  903,FEA
0249C:  MOVLB  3
0249E:  MOVF   x94,W
024A0:  MOVLB  9
024A2:  SUBWF  x08,W
024A4:  MOVWF  00
024A6:  MOVLW  00
024A8:  SUBWFB x09,W
024AA:  MOVFF  00,FEF
024AE:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
024B0:  MOVLW  01
024B2:  MOVWF  01
024B4:  MOVLB  0
024B6:  GOTO   4566 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02E82:  MOVLW  14
02E84:  MOVLB  3
02E86:  MOVWF  x94
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
02E88:  MOVLW  45
02E8A:  MOVLB  9
02E8C:  MOVWF  x87
....................     header.TypeOfService    = IP_SERVICE; 
02E8E:  CLRF   x88
....................     header.TotalLength      = sizeof(header) + len; 
02E90:  MOVLW  14
02E92:  ADDWF  x85,W
02E94:  MOVWF  x89
02E96:  MOVLW  00
02E98:  ADDWFC x86,W
02E9A:  MOVWF  x8A
....................     header.Identification   = ++_Identifier; 
02E9C:  MOVLB  3
02E9E:  INCF   x92,F
02EA0:  BTFSC  FD8.2
02EA2:  INCF   x93,F
02EA4:  MOVFF  393,98C
02EA8:  MOVFF  392,98B
....................     header.FragmentInfo     = 0; 
02EAC:  MOVLB  9
02EAE:  CLRF   x8E
02EB0:  CLRF   x8D
....................     header.TimeToLive       = MY_IP_TTL; 
02EB2:  MOVLW  64
02EB4:  MOVWF  x8F
....................     header.Protocol         = protocol; 
02EB6:  MOVFF  984,990
....................     header.HeaderChecksum   = 0; 
02EBA:  CLRF   x92
02EBC:  CLRF   x91
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
02EBE:  MOVFF  353,996
02EC2:  MOVFF  352,995
02EC6:  MOVFF  351,994
02ECA:  MOVFF  350,993
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02ECE:  MOVLW  06
02ED0:  ADDWF  x82,W
02ED2:  MOVWF  FE9
02ED4:  MOVLW  00
02ED6:  ADDWFC x83,W
02ED8:  MOVWF  FEA
02EDA:  MOVFF  FEF,997
02EDE:  MOVFF  FEC,998
02EE2:  MOVFF  FEC,999
02EE6:  MOVFF  FEC,99A
....................  
....................     SwapIPHeader(&header); 
02EEA:  MOVLW  09
02EEC:  MOVWF  x9C
02EEE:  MOVLW  87
02EF0:  MOVWF  x9B
02EF2:  MOVLB  0
02EF4:  CALL   2306
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
02EF8:  MOVLB  9
02EFA:  MOVFF  982,01
02EFE:  MOVFF  983,03
02F02:  MOVFF  982,99B
02F06:  MOVFF  983,99C
02F0A:  MOVLW  14
02F0C:  ADDWF  x85,W
02F0E:  MOVWF  x9D
02F10:  MOVLW  00
02F12:  ADDWFC x86,W
02F14:  MOVWF  x9E
02F16:  MOVFF  983,9A0
02F1A:  MOVFF  982,99F
02F1E:  CLRF   xA1
02F20:  MOVWF  xA3
02F22:  MOVFF  99D,9A2
02F26:  MOVLB  0
02F28:  CALL   1C56
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
02F2C:  MOVLW  09
02F2E:  MOVLB  9
02F30:  MOVWF  x9C
02F32:  MOVLW  87
02F34:  MOVWF  x9B
02F36:  MOVFF  99C,9A7
02F3A:  MOVWF  xA6
02F3C:  CLRF   xA9
02F3E:  MOVLW  14
02F40:  MOVWF  xA8
02F42:  MOVLB  0
02F44:  CALL   1C0C
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
02F48:  MOVLB  9
02F4A:  CLRF   x9C
02F4C:  CLRF   x9B
02F4E:  CLRF   x9E
02F50:  MOVLW  14
02F52:  MOVWF  x9D
02F54:  MOVLB  0
02F56:  RCALL  2DAA
02F58:  MOVFF  02,992
02F5C:  MOVFF  01,991
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
02F60:  MOVFF  387,99B
02F64:  MOVLB  9
02F66:  CLRF   x9D
02F68:  MOVLW  0A
02F6A:  MOVWF  x9C
02F6C:  MOVLB  0
02F6E:  CALL   1B50
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02F72:  MOVLW  09
02F74:  MOVLB  9
02F76:  MOVWF  x9C
02F78:  MOVLW  91
02F7A:  MOVWF  x9B
02F7C:  MOVFF  99C,9A7
02F80:  MOVWF  xA6
02F82:  CLRF   xA9
02F84:  MOVLW  02
02F86:  MOVWF  xA8
02F88:  MOVLB  0
02F8A:  CALL   1C0C
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
02F8E:  MOVFF  387,99B
02F92:  MOVLB  9
02F94:  CLRF   x9D
02F96:  MOVLW  14
02F98:  MOVWF  x9C
02F9A:  MOVLB  0
02F9C:  CALL   1B50
.................... #endif 
....................  
....................     return 0x0; 
02FA0:  MOVLW  00
02FA2:  MOVWF  01
02FA4:  MOVWF  02
02FA6:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
02734:  MOVLB  3
02736:  MOVF   x94,W
02738:  MOVLB  9
0273A:  ADDWF  x29,W
0273C:  MOVWF  x2B
0273E:  MOVLW  00
02740:  ADDWFC x2A,W
02742:  MOVWF  x2C
02744:  MOVWF  x2E
02746:  MOVFF  92B,92D
0274A:  MOVLB  0
0274C:  RCALL  2284
0274E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
02306:  MOVLW  02
02308:  MOVLB  9
0230A:  ADDWF  x9B,W
0230C:  MOVWF  01
0230E:  MOVLW  00
02310:  ADDWFC x9C,W
02312:  MOVWF  03
02314:  MOVFF  01,99D
02318:  MOVWF  x9E
0231A:  MOVLW  02
0231C:  ADDWF  x9B,W
0231E:  MOVWF  FE9
02320:  MOVLW  00
02322:  ADDWFC x9C,W
02324:  MOVWF  FEA
02326:  MOVFF  FEC,9A2
0232A:  MOVF   FED,F
0232C:  MOVFF  FEF,9A1
02330:  MOVLB  0
02332:  CALL   1810
02336:  MOVFF  99E,FEA
0233A:  MOVFF  99D,FE9
0233E:  MOVFF  02,FEC
02342:  MOVF   FED,F
02344:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
02348:  MOVLW  04
0234A:  MOVLB  9
0234C:  ADDWF  x9B,W
0234E:  MOVWF  01
02350:  MOVLW  00
02352:  ADDWFC x9C,W
02354:  MOVWF  03
02356:  MOVFF  01,99D
0235A:  MOVWF  x9E
0235C:  MOVLW  04
0235E:  ADDWF  x9B,W
02360:  MOVWF  FE9
02362:  MOVLW  00
02364:  ADDWFC x9C,W
02366:  MOVWF  FEA
02368:  MOVFF  FEC,9A2
0236C:  MOVF   FED,F
0236E:  MOVFF  FEF,9A1
02372:  MOVLB  0
02374:  CALL   1810
02378:  MOVFF  99E,FEA
0237C:  MOVFF  99D,FE9
02380:  MOVFF  02,FEC
02384:  MOVF   FED,F
02386:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
0238A:  MOVLW  0A
0238C:  MOVLB  9
0238E:  ADDWF  x9B,W
02390:  MOVWF  01
02392:  MOVLW  00
02394:  ADDWFC x9C,W
02396:  MOVWF  03
02398:  MOVFF  01,99D
0239C:  MOVWF  x9E
0239E:  MOVLW  0A
023A0:  ADDWF  x9B,W
023A2:  MOVWF  FE9
023A4:  MOVLW  00
023A6:  ADDWFC x9C,W
023A8:  MOVWF  FEA
023AA:  MOVFF  FEC,9A2
023AE:  MOVF   FED,F
023B0:  MOVFF  FEF,9A1
023B4:  MOVLB  0
023B6:  CALL   1810
023BA:  MOVFF  99E,FEA
023BE:  MOVFF  99D,FE9
023C2:  MOVFF  02,FEC
023C6:  MOVF   FED,F
023C8:  MOVFF  01,FEF
023CC:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
0111A:  MOVLB  8
0111C:  CLRF   xF6
0111E:  MOVF   xF6,W
01120:  SUBLW  22
01122:  BNC   1202
....................     { 
....................         ps = &TCB[s]; 
01124:  MOVLB  9
01126:  CLRF   x47
01128:  MOVFF  8F6,946
0112C:  CLRF   x49
0112E:  MOVLW  24
01130:  MOVWF  x48
01132:  MOVLB  0
01134:  RCALL  0FBC
01136:  MOVFF  02,03
0113A:  MOVF   01,W
0113C:  ADDLW  97
0113E:  MOVWF  01
01140:  MOVLW  03
01142:  ADDWFC 03,F
01144:  MOVFF  01,8F7
01148:  MOVLB  8
0114A:  MOVFF  03,8F8
....................  
....................         ps->smState             = TCP_CLOSED; 
0114E:  MOVFF  8F7,FE9
01152:  MOVFF  8F8,FEA
01156:  MOVLW  0A
01158:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
0115A:  MOVLW  23
0115C:  ADDWF  xF7,W
0115E:  MOVWF  FE9
01160:  MOVLW  00
01162:  ADDWFC xF8,W
01164:  MOVWF  FEA
01166:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
01168:  MOVLW  23
0116A:  ADDWF  xF7,W
0116C:  MOVWF  FE9
0116E:  MOVLW  00
01170:  ADDWFC xF8,W
01172:  MOVWF  FEA
01174:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
01176:  MOVLW  23
01178:  ADDWF  xF7,W
0117A:  MOVWF  FE9
0117C:  MOVLW  00
0117E:  ADDWFC xF8,W
01180:  MOVWF  FEA
01182:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
01184:  MOVLW  23
01186:  ADDWF  xF7,W
01188:  MOVWF  FE9
0118A:  MOVLW  00
0118C:  ADDWFC xF8,W
0118E:  MOVWF  FEA
01190:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
01192:  MOVLW  23
01194:  ADDWF  xF7,W
01196:  MOVWF  FE9
01198:  MOVLW  00
0119A:  ADDWFC xF8,W
0119C:  MOVWF  FEA
0119E:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
011A0:  MOVLW  0F
011A2:  ADDWF  xF7,W
011A4:  MOVWF  FE9
011A6:  MOVLW  00
011A8:  ADDWFC xF8,W
011AA:  MOVWF  FEA
011AC:  INCFSZ FEF,W
011AE:  BRA    11B2
011B0:  BRA    11D8
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
011B2:  MOVLW  0F
011B4:  ADDWF  xF7,W
011B6:  MOVWF  FE9
011B8:  MOVLW  00
011BA:  ADDWFC xF8,W
011BC:  MOVWF  FEA
011BE:  MOVFF  FEF,949
011C2:  MOVLB  0
011C4:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
011C8:  MOVLW  0F
011CA:  MOVLB  8
011CC:  ADDWF  xF7,W
011CE:  MOVWF  FE9
011D0:  MOVLW  00
011D2:  ADDWFC xF8,W
011D4:  MOVWF  FEA
011D6:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
011D8:  MOVLW  21
011DA:  ADDWF  xF7,W
011DC:  MOVWF  FE9
011DE:  MOVLW  00
011E0:  ADDWFC xF8,W
011E2:  MOVWF  FEA
011E4:  CLRF   FEC
011E6:  MOVF   FED,F
011E8:  MOVLW  24
011EA:  MOVWF  FEF
....................       ps->TxCount            = 0; 
011EC:  MOVLW  10
011EE:  ADDWF  xF7,W
011F0:  MOVWF  FE9
011F2:  MOVLW  00
011F4:  ADDWFC xF8,W
011F6:  MOVWF  FEA
011F8:  CLRF   FEC
011FA:  MOVF   FED,F
011FC:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
011FE:  INCF   xF6,F
01200:  BRA    111E
....................     TCPInit_RandSeed+=get_timer0(); 
01202:  MOVF   FD6,W
01204:  ADDWF  x83,F
01206:  MOVF   FD7,W
01208:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0120A:  MOVF   FCE,W
0120C:  ADDWF  x83,F
0120E:  MOVF   FCF,W
01210:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
01212:  MOVF   FCC,W
01214:  ADDWF  x83,F
01216:  MOVLW  00
01218:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0121A:  MOVF   FB2,W
0121C:  ADDWF  x83,F
0121E:  MOVF   FB3,W
01220:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
01222:  CLRF   xFC
01224:  CLRF   xFB
01226:  MOVFF  884,8FA
0122A:  MOVFF  883,8F9
0122E:  MOVLB  0
01230:  BRA    0FDE
....................     _NextPort=rand(); 
01232:  BRA    1096
01234:  MOVFF  02,396
01238:  MOVFF  01,395
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
0123C:  MOVLW  04
0123E:  MOVLB  3
01240:  ADDWF  x96,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
01242:  MOVF   x96,W
01244:  SUBLW  12
01246:  BC    125C
01248:  XORLW  FF
0124A:  BNZ   1252
0124C:  MOVF   x95,W
0124E:  SUBLW  87
01250:  BC    125C
01252:  MOVLW  88
01254:  SUBWF  x95,F
01256:  MOVLW  13
01258:  SUBWFB x96,F
0125A:  BRA    1242
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
0125C:  MOVF   x96,W
0125E:  SUBLW  03
01260:  BNC   1266
01262:  MOVLW  04
01264:  ADDWF  x96,F
01266:  MOVLB  0
01268:  GOTO   127A (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
04766:  MOVLB  9
04768:  BCF    x00.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
0476A:  MOVLB  8
0476C:  CLRF   xFD
0476E:  MOVF   xFD,W
04770:  SUBLW  22
04772:  BNC   47BA
....................    { 
....................       ps = &TCB[s]; 
04774:  MOVLB  9
04776:  CLRF   x47
04778:  MOVFF  8FD,946
0477C:  CLRF   x49
0477E:  MOVLW  24
04780:  MOVWF  x48
04782:  MOVLB  0
04784:  CALL   0FBC
04788:  MOVFF  02,03
0478C:  MOVF   01,W
0478E:  ADDLW  97
04790:  MOVWF  01
04792:  MOVLW  03
04794:  ADDWFC 03,F
04796:  MOVFF  01,8FE
0479A:  MOVLB  8
0479C:  MOVFF  03,8FF
....................       if(ps->smState == TCP_CLOSED) 
047A0:  MOVFF  8FE,FE9
047A4:  MOVFF  8FF,FEA
047A8:  MOVF   FEF,W
047AA:  SUBLW  0A
047AC:  BNZ   47B6
....................       { 
....................          lbFound = TRUE; 
047AE:  MOVLB  9
047B0:  BSF    x00.0
....................          break; 
047B2:  MOVLB  8
047B4:  BRA    47BA
....................       } 
047B6:  INCF   xFD,F
047B8:  BRA    476E
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
047BA:  MOVLB  9
047BC:  BTFSC  x00.0
047BE:  BRA    47C6
....................       return INVALID_SOCKET; 
047C0:  MOVLW  FE
047C2:  MOVWF  01
047C4:  BRA    4976
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
047C6:  MOVLW  0B
047C8:  MOVLB  8
047CA:  ADDWF  xFE,W
047CC:  MOVWF  FE9
047CE:  MOVLW  00
047D0:  ADDWFC xFF,W
047D2:  MOVWF  FEA
047D4:  MOVLB  3
047D6:  INCF   x95,F
047D8:  BTFSC  FD8.2
047DA:  INCF   x96,F
047DC:  MOVFF  396,FEC
047E0:  MOVF   FED,F
047E2:  MOVFF  395,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
047E6:  MOVF   x96,W
047E8:  SUBLW  12
047EA:  BC    47FC
047EC:  XORLW  FF
047EE:  BNZ   47F6
047F0:  MOVF   x95,W
047F2:  SUBLW  87
047F4:  BC    47FC
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
047F6:  MOVLW  03
047F8:  MOVWF  x96
047FA:  SETF   x95
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
047FC:  MOVLW  23
047FE:  MOVLB  8
04800:  ADDWF  xFE,W
04802:  MOVWF  FE9
04804:  MOVLW  00
04806:  ADDWFC xFF,W
04808:  MOVWF  FEA
0480A:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
0480C:  MOVLW  0D
0480E:  ADDWF  xFE,W
04810:  MOVWF  FE9
04812:  MOVLW  00
04814:  ADDWFC xFF,W
04816:  MOVWF  FEA
04818:  MOVFF  8FC,FEC
0481C:  MOVF   FED,F
0481E:  MOVFF  8FB,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
04822:  MOVLW  16
04824:  ADDWF  xFE,W
04826:  MOVWF  FE9
04828:  MOVLW  00
0482A:  ADDWFC xFF,W
0482C:  MOVWF  FEA
0482E:  MOVLW  01
04830:  ADDWF  FEE,F
04832:  MOVLW  00
04834:  ADDWFC FEE,F
04836:  ADDWFC FEE,F
04838:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
0483A:  MOVLW  1A
0483C:  ADDWF  xFE,W
0483E:  MOVWF  FE9
04840:  MOVLW  00
04842:  ADDWFC xFF,W
04844:  MOVWF  FEA
04846:  MOVF   FEE,F
04848:  MOVF   FEE,F
0484A:  CLRF   FEC
0484C:  MOVF   FED,F
0484E:  CLRF   FEF
04850:  MOVF   FED,F
04852:  CLRF   FEF
04854:  MOVF   FED,F
04856:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
04858:  MOVLW  01
0485A:  ADDWF  xFE,W
0485C:  MOVWF  01
0485E:  MOVLW  00
04860:  ADDWFC xFF,W
04862:  MOVWF  03
04864:  MOVFF  01,901
04868:  MOVLB  9
0486A:  MOVWF  x02
0486C:  MOVWF  FEA
0486E:  MOVFF  01,FE9
04872:  MOVFF  8FA,FE2
04876:  MOVFF  8F9,FE1
0487A:  MOVLW  0A
0487C:  MOVWF  01
0487E:  MOVFF  FE6,FEE
04882:  DECFSZ 01,F
04884:  BRA    487E
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
04886:  MOVLW  01
04888:  MOVLB  8
0488A:  ADDWF  xFE,W
0488C:  MOVWF  01
0488E:  MOVLW  00
04890:  ADDWFC xFF,W
04892:  MOVWF  03
04894:  MOVFF  01,901
04898:  MOVLB  9
0489A:  MOVWF  x02
0489C:  MOVLW  0B
0489E:  MOVLB  8
048A0:  ADDWF  xFE,W
048A2:  MOVWF  FE9
048A4:  MOVLW  00
048A6:  ADDWFC xFF,W
048A8:  MOVWF  FEA
048AA:  MOVFF  FEC,94D
048AE:  MOVF   FED,F
048B0:  MOVFF  FEF,94C
048B4:  MOVLW  0D
048B6:  ADDWF  xFE,W
048B8:  MOVWF  FE9
048BA:  MOVLW  00
048BC:  ADDWFC xFF,W
048BE:  MOVWF  FEA
048C0:  MOVFF  FEC,94F
048C4:  MOVF   FED,F
048C6:  MOVFF  FEF,94E
048CA:  MOVLW  16
048CC:  ADDWF  xFE,W
048CE:  MOVWF  FE9
048D0:  MOVLW  00
048D2:  ADDWFC xFF,W
048D4:  MOVWF  FEA
048D6:  MOVFF  FEF,950
048DA:  MOVFF  FEC,951
048DE:  MOVFF  FEC,952
048E2:  MOVFF  FEC,953
048E6:  MOVLW  1A
048E8:  ADDWF  xFE,W
048EA:  MOVWF  FE9
048EC:  MOVLW  00
048EE:  ADDWFC xFF,W
048F0:  MOVWF  FEA
048F2:  MOVFF  FEF,954
048F6:  MOVFF  FEC,955
048FA:  MOVFF  FEC,956
048FE:  MOVFF  FEC,957
04902:  MOVFF  03,94B
04906:  MOVFF  01,94A
0490A:  MOVLW  02
0490C:  MOVLB  9
0490E:  MOVWF  x58
04910:  SETF   x59
04912:  CLRF   x5B
04914:  CLRF   x5A
04916:  MOVLB  0
04918:  CALL   2FA8
....................  
....................    ps->smState = TCP_SYN_SENT; 
0491C:  MOVLB  8
0491E:  MOVFF  8FE,FE9
04922:  MOVFF  8FF,FEA
04926:  MOVLW  01
04928:  MOVWF  FEF
....................    ps->SND_SEQ++; 
0492A:  MOVLW  16
0492C:  ADDWF  xFE,W
0492E:  MOVWF  FE9
04930:  MOVLW  00
04932:  ADDWFC xFF,W
04934:  MOVWF  FEA
04936:  MOVLW  01
04938:  ADDWF  FEE,F
0493A:  MOVLW  00
0493C:  ADDWFC FEE,F
0493E:  ADDWFC FEE,F
04940:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
04942:  MOVLW  1F
04944:  ADDWF  xFE,W
04946:  MOVWF  01
04948:  MOVLW  00
0494A:  ADDWFC xFF,W
0494C:  MOVWF  03
0494E:  MOVFF  01,901
04952:  MOVLB  9
04954:  MOVWF  x02
04956:  MOVLB  0
04958:  CALL   2B52
0495C:  MOVFF  902,FEA
04960:  MOVFF  901,FE9
04964:  MOVFF  02,FEC
04968:  MOVF   FED,F
0496A:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
0496E:  MOVLB  8
04970:  MOVFF  8FD,01
04974:  MOVLB  9
04976:  MOVLB  0
04978:  GOTO   5450 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
0497C:  MOVLB  9
0497E:  CLRF   x47
04980:  MOVFF  8F9,946
04984:  CLRF   x49
04986:  MOVLW  24
04988:  MOVWF  x48
0498A:  MOVLB  0
0498C:  CALL   0FBC
04990:  MOVFF  02,8FB
04994:  MOVFF  01,8FA
04998:  MOVLW  97
0499A:  MOVLB  8
0499C:  ADDWF  01,W
0499E:  MOVWF  FE9
049A0:  MOVLW  03
049A2:  ADDWFC 02,W
049A4:  MOVWF  FEA
049A6:  MOVF   FEF,W
049A8:  SUBLW  03
049AA:  BZ    49B0
049AC:  MOVLW  00
049AE:  BRA    49B2
049B0:  MOVLW  01
049B2:  MOVWF  01
049B4:  MOVLB  0
049B6:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
050D6:  MOVLB  9
050D8:  CLRF   x47
050DA:  MOVFF  8FB,946
050DE:  CLRF   x49
050E0:  MOVLW  24
050E2:  MOVWF  x48
050E4:  MOVLB  0
050E6:  CALL   0FBC
050EA:  MOVFF  02,03
050EE:  MOVF   01,W
050F0:  ADDLW  97
050F2:  MOVWF  01
050F4:  MOVLW  03
050F6:  ADDWFC 03,F
050F8:  MOVFF  01,8FC
050FC:  MOVLB  8
050FE:  MOVFF  03,8FD
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
05102:  MOVFF  8FC,FE9
05106:  MOVFF  8FD,FEA
0510A:  MOVF   FEF,W
0510C:  SUBLW  03
0510E:  BZ    5130
05110:  MOVFF  8FC,FE9
05114:  MOVFF  8FD,FEA
05118:  MOVF   FEF,W
0511A:  SUBLW  02
0511C:  BZ    5130
....................    { 
....................       CloseSocket(ps); 
0511E:  MOVFF  8FD,947
05122:  MOVFF  8FC,946
05126:  MOVLB  0
05128:  CALL   2B6C
....................       return; 
0512C:  BRA    51F6
0512E:  MOVLB  8
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
05130:  MOVFF  8FB,903
05134:  MOVLB  0
05136:  BRA    5074
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
05138:  MOVLW  01
0513A:  MOVLB  8
0513C:  ADDWF  xFC,W
0513E:  MOVWF  01
05140:  MOVLW  00
05142:  ADDWFC xFD,W
05144:  MOVWF  03
05146:  MOVFF  01,900
0514A:  MOVLB  9
0514C:  MOVWF  x01
0514E:  MOVLW  0B
05150:  MOVLB  8
05152:  ADDWF  xFC,W
05154:  MOVWF  FE9
05156:  MOVLW  00
05158:  ADDWFC xFD,W
0515A:  MOVWF  FEA
0515C:  MOVFF  FEC,94D
05160:  MOVF   FED,F
05162:  MOVFF  FEF,94C
05166:  MOVLW  0D
05168:  ADDWF  xFC,W
0516A:  MOVWF  FE9
0516C:  MOVLW  00
0516E:  ADDWFC xFD,W
05170:  MOVWF  FEA
05172:  MOVFF  FEC,94F
05176:  MOVF   FED,F
05178:  MOVFF  FEF,94E
0517C:  MOVLW  16
0517E:  ADDWF  xFC,W
05180:  MOVWF  FE9
05182:  MOVLW  00
05184:  ADDWFC xFD,W
05186:  MOVWF  FEA
05188:  MOVFF  FEF,950
0518C:  MOVFF  FEC,951
05190:  MOVFF  FEC,952
05194:  MOVFF  FEC,953
05198:  MOVLW  1A
0519A:  ADDWF  xFC,W
0519C:  MOVWF  FE9
0519E:  MOVLW  00
051A0:  ADDWFC xFD,W
051A2:  MOVWF  FEA
051A4:  MOVFF  FEF,954
051A8:  MOVFF  FEC,955
051AC:  MOVFF  FEC,956
051B0:  MOVFF  FEC,957
051B4:  MOVFF  03,94B
051B8:  MOVFF  01,94A
051BC:  MOVLW  11
051BE:  MOVLB  9
051C0:  MOVWF  x58
051C2:  SETF   x59
051C4:  CLRF   x5B
051C6:  CLRF   x5A
051C8:  MOVLB  0
051CA:  CALL   2FA8
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
051CE:  MOVLW  16
051D0:  MOVLB  8
051D2:  ADDWF  xFC,W
051D4:  MOVWF  FE9
051D6:  MOVLW  00
051D8:  ADDWFC xFD,W
051DA:  MOVWF  FEA
051DC:  MOVLW  01
051DE:  ADDWF  FEE,F
051E0:  MOVLW  00
051E2:  ADDWFC FEE,F
051E4:  ADDWFC FEE,F
051E6:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
051E8:  MOVFF  8FC,FE9
051EC:  MOVFF  8FD,FEA
051F0:  MOVLW  04
051F2:  MOVWF  FEF
051F4:  MOVLB  0
....................  
....................    return; 
051F6:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
04CF0:  MOVLB  9
04CF2:  CLRF   x47
04CF4:  MOVFF  904,946
04CF8:  CLRF   x49
04CFA:  MOVLW  24
04CFC:  MOVWF  x48
04CFE:  MOVLB  0
04D00:  CALL   0FBC
04D04:  MOVFF  02,03
04D08:  MOVF   01,W
04D0A:  ADDLW  97
04D0C:  MOVWF  01
04D0E:  MOVLW  03
04D10:  ADDWFC 03,F
04D12:  MOVFF  01,905
04D16:  MOVLB  9
04D18:  MOVFF  03,906
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
04D1C:  MOVLW  0F
04D1E:  ADDWF  x05,W
04D20:  MOVWF  FE9
04D22:  MOVLW  00
04D24:  ADDWFC x06,W
04D26:  MOVWF  FEA
04D28:  INCFSZ FEF,W
04D2A:  BRA    4D32
....................       return FALSE; 
04D2C:  MOVLW  00
04D2E:  MOVWF  01
04D30:  BRA    4E8C
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
04D32:  MOVLW  23
04D34:  ADDWF  x05,W
04D36:  MOVWF  FE9
04D38:  MOVLW  00
04D3A:  ADDWFC x06,W
04D3C:  MOVWF  FEA
04D3E:  MOVFF  FEF,00
04D42:  RRCF   00,W
04D44:  ANDLW  01
04D46:  BNZ   4D4E
....................       return FALSE; 
04D48:  MOVLW  00
04D4A:  MOVWF  01
04D4C:  BRA    4E8C
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
04D4E:  MOVLW  01
04D50:  ADDWF  x05,W
04D52:  MOVWF  01
04D54:  MOVLW  00
04D56:  ADDWFC x06,W
04D58:  MOVWF  03
04D5A:  MOVFF  01,907
04D5E:  MOVWF  x08
04D60:  MOVLW  0B
04D62:  ADDWF  x05,W
04D64:  MOVWF  FE9
04D66:  MOVLW  00
04D68:  ADDWFC x06,W
04D6A:  MOVWF  FEA
04D6C:  MOVFF  FEC,94D
04D70:  MOVF   FED,F
04D72:  MOVFF  FEF,94C
04D76:  MOVLW  0D
04D78:  ADDWF  x05,W
04D7A:  MOVWF  FE9
04D7C:  MOVLW  00
04D7E:  ADDWFC x06,W
04D80:  MOVWF  FEA
04D82:  MOVFF  FEC,94F
04D86:  MOVF   FED,F
04D88:  MOVFF  FEF,94E
04D8C:  MOVLW  16
04D8E:  ADDWF  x05,W
04D90:  MOVWF  FE9
04D92:  MOVLW  00
04D94:  ADDWFC x06,W
04D96:  MOVWF  FEA
04D98:  MOVFF  FEF,950
04D9C:  MOVFF  FEC,951
04DA0:  MOVFF  FEC,952
04DA4:  MOVFF  FEC,953
04DA8:  MOVLW  1A
04DAA:  ADDWF  x05,W
04DAC:  MOVWF  FE9
04DAE:  MOVLW  00
04DB0:  ADDWFC x06,W
04DB2:  MOVWF  FEA
04DB4:  MOVFF  FEF,954
04DB8:  MOVFF  FEC,955
04DBC:  MOVFF  FEC,956
04DC0:  MOVFF  FEC,957
04DC4:  MOVLW  0F
04DC6:  ADDWF  x05,W
04DC8:  MOVWF  FE9
04DCA:  MOVLW  00
04DCC:  ADDWFC x06,W
04DCE:  MOVWF  FEA
04DD0:  MOVFF  FEF,959
04DD4:  MOVLW  10
04DD6:  ADDWF  x05,W
04DD8:  MOVWF  FE9
04DDA:  MOVLW  00
04DDC:  ADDWFC x06,W
04DDE:  MOVWF  FEA
04DE0:  MOVFF  FEC,95B
04DE4:  MOVF   FED,F
04DE6:  MOVFF  FEF,95A
04DEA:  MOVFF  03,94B
04DEE:  MOVFF  01,94A
04DF2:  MOVLW  18
04DF4:  MOVWF  x58
04DF6:  MOVLB  0
04DF8:  CALL   2FA8
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
04DFC:  MOVLW  16
04DFE:  MOVLB  9
04E00:  ADDWF  x05,W
04E02:  MOVWF  01
04E04:  MOVLW  00
04E06:  ADDWFC x06,W
04E08:  MOVWF  03
04E0A:  MOVFF  01,907
04E0E:  MOVWF  x08
04E10:  MOVWF  FEA
04E12:  MOVFF  01,FE9
04E16:  MOVFF  FEF,909
04E1A:  MOVFF  FEC,90A
04E1E:  MOVFF  FEC,90B
04E22:  MOVFF  FEC,90C
04E26:  MOVLW  10
04E28:  ADDWF  x05,W
04E2A:  MOVWF  FE9
04E2C:  MOVLW  00
04E2E:  ADDWFC x06,W
04E30:  MOVWF  FEA
04E32:  MOVFF  FEC,03
04E36:  MOVF   FED,F
04E38:  MOVFF  FEF,00
04E3C:  MOVFF  03,01
04E40:  CLRF   02
04E42:  CLRF   03
04E44:  MOVF   x09,W
04E46:  ADDWF  00,F
04E48:  MOVF   x0A,W
04E4A:  ADDWFC 01,F
04E4C:  MOVF   x0B,W
04E4E:  ADDWFC 02,F
04E50:  MOVF   x0C,W
04E52:  ADDWFC 03,F
04E54:  MOVFF  908,FEA
04E58:  MOVFF  907,FE9
04E5C:  MOVFF  00,FEF
04E60:  MOVFF  01,FEC
04E64:  MOVFF  02,FEC
04E68:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
04E6C:  MOVLW  23
04E6E:  ADDWF  x05,W
04E70:  MOVWF  FE9
04E72:  MOVLW  00
04E74:  ADDWFC x06,W
04E76:  MOVWF  FEA
04E78:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
04E7A:  MOVLW  23
04E7C:  ADDWF  x05,W
04E7E:  MOVWF  FE9
04E80:  MOVLW  00
04E82:  ADDWFC x06,W
04E84:  MOVWF  FEA
04E86:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
04E88:  MOVLW  01
04E8A:  MOVWF  01
04E8C:  MOVLB  0
04E8E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
04AE4:  MOVLB  9
04AE6:  CLRF   x47
04AE8:  MOVFF  909,946
04AEC:  CLRF   x49
04AEE:  MOVLW  24
04AF0:  MOVWF  x48
04AF2:  MOVLB  0
04AF4:  CALL   0FBC
04AF8:  MOVFF  01,90A
04AFC:  MOVLW  14
04AFE:  MOVLB  9
04B00:  ADDWF  01,W
04B02:  MOVWF  01
04B04:  MOVLW  00
04B06:  ADDWFC 02,W
04B08:  MOVWF  03
04B0A:  MOVF   01,W
04B0C:  ADDLW  97
04B0E:  MOVWF  FE9
04B10:  MOVLW  03
04B12:  ADDWFC 03,W
04B14:  MOVWF  FEA
04B16:  MOVFF  FEC,90B
04B1A:  MOVF   FED,F
04B1C:  MOVFF  FEF,90A
04B20:  MOVF   x0A,F
04B22:  BNZ   4B2E
04B24:  MOVF   x0B,F
04B26:  BNZ   4B2E
....................       return FALSE; 
04B28:  MOVLW  00
04B2A:  MOVWF  01
04B2C:  BRA    4BAE
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04B2E:  CLRF   x47
04B30:  MOVFF  909,946
04B34:  CLRF   x49
04B36:  MOVLW  24
04B38:  MOVWF  x48
04B3A:  MOVLB  0
04B3C:  CALL   0FBC
04B40:  MOVFF  02,90B
04B44:  MOVFF  01,90A
04B48:  MOVLW  0F
04B4A:  MOVLB  9
04B4C:  ADDWF  01,W
04B4E:  MOVWF  01
04B50:  MOVLW  00
04B52:  ADDWFC 02,W
04B54:  MOVWF  03
04B56:  MOVF   01,W
04B58:  ADDLW  97
04B5A:  MOVWF  FE9
04B5C:  MOVLW  03
04B5E:  ADDWFC 03,W
04B60:  MOVWF  FEA
04B62:  INCFSZ FEF,W
04B64:  BRA    4B76
....................       return IPIsTxReady(FALSE); 
04B66:  CLRF   x82
04B68:  MOVLB  0
04B6A:  CALL   2C6A
04B6E:  MOVF   01,W
04B70:  MOVLB  9
04B72:  BRA    4BAE
04B74:  BRA    4BAE
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
04B76:  CLRF   x47
04B78:  MOVFF  909,946
04B7C:  CLRF   x49
04B7E:  MOVLW  24
04B80:  MOVWF  x48
04B82:  MOVLB  0
04B84:  CALL   0FBC
04B88:  MOVFF  02,90B
04B8C:  MOVFF  01,90A
04B90:  MOVLW  23
04B92:  MOVLB  9
04B94:  ADDWF  x0A,F
04B96:  MOVLW  00
04B98:  ADDWFC x0B,F
04B9A:  MOVLW  97
04B9C:  ADDWF  x0A,W
04B9E:  MOVWF  FE9
04BA0:  MOVLW  03
04BA2:  ADDWFC x0B,W
04BA4:  MOVWF  FEA
04BA6:  MOVLW  00
04BA8:  BTFSC  FEF.1
04BAA:  MOVLW  01
04BAC:  MOVWF  01
04BAE:  MOVLB  0
04BB0:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
04BB2:  MOVFF  904,909
04BB6:  RCALL  4AE4
04BB8:  MOVF   01,F
04BBA:  BNZ   4BC4
....................       return(0); 
04BBC:  MOVLW  00
04BBE:  MOVWF  01
04BC0:  MOVWF  02
04BC2:  BRA    4CEA
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04BC4:  MOVLB  9
04BC6:  CLRF   x47
04BC8:  MOVFF  904,946
04BCC:  CLRF   x49
04BCE:  MOVLW  24
04BD0:  MOVWF  x48
04BD2:  MOVLB  0
04BD4:  CALL   0FBC
04BD8:  MOVFF  02,90A
04BDC:  MOVFF  01,909
04BE0:  MOVLW  0F
04BE2:  MOVLB  9
04BE4:  ADDWF  01,W
04BE6:  MOVWF  01
04BE8:  MOVLW  00
04BEA:  ADDWFC 02,W
04BEC:  MOVWF  03
04BEE:  MOVF   01,W
04BF0:  ADDLW  97
04BF2:  MOVWF  FE9
04BF4:  MOVLW  03
04BF6:  ADDWFC 03,W
04BF8:  MOVWF  FEA
04BFA:  INCFSZ FEF,W
04BFC:  BRA    4C04
....................       txCount = 0; 
04BFE:  CLRF   x06
04C00:  CLRF   x05
04C02:  BRA    4C3E
....................    else 
....................       txCount = TCB[s].TxCount; 
04C04:  CLRF   x47
04C06:  MOVFF  904,946
04C0A:  CLRF   x49
04C0C:  MOVLW  24
04C0E:  MOVWF  x48
04C10:  MOVLB  0
04C12:  CALL   0FBC
04C16:  MOVFF  01,909
04C1A:  MOVLW  10
04C1C:  MOVLB  9
04C1E:  ADDWF  01,W
04C20:  MOVWF  01
04C22:  MOVLW  00
04C24:  ADDWFC 02,W
04C26:  MOVWF  03
04C28:  MOVF   01,W
04C2A:  ADDLW  97
04C2C:  MOVWF  FE9
04C2E:  MOVLW  03
04C30:  ADDWFC 03,W
04C32:  MOVWF  FEA
04C34:  MOVFF  FEC,906
04C38:  MOVF   FED,F
04C3A:  MOVFF  FEF,905
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
04C3E:  MOVLW  CA
04C40:  BSF    FD8.0
04C42:  SUBFWB x05,W
04C44:  MOVWF  x07
04C46:  MOVLW  03
04C48:  SUBFWB x06,W
04C4A:  MOVWF  x08
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
04C4C:  CLRF   x47
04C4E:  MOVFF  904,946
04C52:  CLRF   x49
04C54:  MOVLW  24
04C56:  MOVWF  x48
04C58:  MOVLB  0
04C5A:  CALL   0FBC
04C5E:  MOVFF  02,90A
04C62:  MOVFF  01,909
04C66:  MOVLW  14
04C68:  MOVLB  9
04C6A:  ADDWF  01,W
04C6C:  MOVWF  01
04C6E:  MOVLW  00
04C70:  ADDWFC 02,W
04C72:  MOVWF  03
04C74:  MOVF   01,W
04C76:  ADDLW  97
04C78:  MOVWF  FE9
04C7A:  MOVLW  03
04C7C:  ADDWFC 03,W
04C7E:  MOVWF  FEA
04C80:  MOVFF  FEC,03
04C84:  MOVF   FED,F
04C86:  MOVFF  FEF,01
04C8A:  MOVF   03,W
04C8C:  SUBWF  x08,W
04C8E:  BNC   4CD6
04C90:  BNZ   4C98
04C92:  MOVF   x07,W
04C94:  SUBWF  01,W
04C96:  BC    4CD6
04C98:  CLRF   x47
04C9A:  MOVFF  904,946
04C9E:  CLRF   x49
04CA0:  MOVLW  24
04CA2:  MOVWF  x48
04CA4:  MOVLB  0
04CA6:  CALL   0FBC
04CAA:  MOVFF  02,90A
04CAE:  MOVFF  01,909
04CB2:  MOVLW  14
04CB4:  MOVLB  9
04CB6:  ADDWF  01,W
04CB8:  MOVWF  01
04CBA:  MOVLW  00
04CBC:  ADDWFC 02,W
04CBE:  MOVWF  03
04CC0:  MOVF   01,W
04CC2:  ADDLW  97
04CC4:  MOVWF  FE9
04CC6:  MOVLW  03
04CC8:  ADDWFC 03,W
04CCA:  MOVWF  FEA
04CCC:  MOVFF  FEC,03
04CD0:  MOVF   FED,F
04CD2:  MOVF   FEF,W
04CD4:  BRA    4CDC
04CD6:  MOVFF  908,03
04CDA:  MOVF   x07,W
04CDC:  MOVWF  x07
04CDE:  MOVFF  03,908
....................  
....................    return(txAvail); 
04CE2:  MOVFF  907,01
04CE6:  MOVFF  908,02
04CEA:  MOVLB  0
04CEC:  GOTO   4F6A (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
04E90:  MOVLB  9
04E92:  CLRF   x47
04E94:  MOVFF  8FB,946
04E98:  CLRF   x49
04E9A:  MOVLW  24
04E9C:  MOVWF  x48
04E9E:  MOVLB  0
04EA0:  CALL   0FBC
04EA4:  MOVFF  02,03
04EA8:  MOVF   01,W
04EAA:  ADDLW  97
04EAC:  MOVWF  01
04EAE:  MOVLW  03
04EB0:  ADDWFC 03,F
04EB2:  MOVFF  01,900
04EB6:  MOVLB  9
04EB8:  MOVFF  03,901
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
04EBC:  MOVLW  14
04EBE:  ADDWF  x00,W
04EC0:  MOVWF  FE9
04EC2:  MOVLW  00
04EC4:  ADDWFC x01,W
04EC6:  MOVWF  FEA
04EC8:  MOVFF  FEC,905
04ECC:  MOVF   FED,F
04ECE:  MOVFF  FEF,904
04ED2:  MOVF   x04,F
04ED4:  BNZ   4EE2
04ED6:  MOVF   x05,F
04ED8:  BNZ   4EE2
....................       return 0; 
04EDA:  MOVLW  00
04EDC:  MOVWF  01
04EDE:  MOVWF  02
04EE0:  BRA    506E
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
04EE2:  MOVLW  0F
04EE4:  ADDWF  x00,W
04EE6:  MOVWF  FE9
04EE8:  MOVLW  00
04EEA:  ADDWFC x01,W
04EEC:  MOVWF  FEA
04EEE:  INCFSZ FEF,W
04EF0:  BRA    4F62
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
04EF2:  MOVLW  0F
04EF4:  ADDWF  x00,W
04EF6:  MOVWF  01
04EF8:  MOVLW  00
04EFA:  ADDWFC x01,W
04EFC:  MOVWF  03
04EFE:  MOVFF  01,904
04F02:  MOVWF  x05
04F04:  CLRF   x82
04F06:  MOVLB  0
04F08:  CALL   1B28
04F0C:  MOVFF  905,FEA
04F10:  MOVFF  904,FE9
04F14:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
04F18:  MOVLW  0F
04F1A:  MOVLB  9
04F1C:  ADDWF  x00,W
04F1E:  MOVWF  FE9
04F20:  MOVLW  00
04F22:  ADDWFC x01,W
04F24:  MOVWF  FEA
04F26:  INCFSZ FEF,W
04F28:  BRA    4F32
....................          return 0; 
04F2A:  MOVLW  00
04F2C:  MOVWF  01
04F2E:  MOVWF  02
04F30:  BRA    506E
....................  
....................       ps->TxCount = 0; 
04F32:  MOVLW  10
04F34:  ADDWF  x00,W
04F36:  MOVWF  FE9
04F38:  MOVLW  00
04F3A:  ADDWFC x01,W
04F3C:  MOVWF  FEA
04F3E:  CLRF   FEC
04F40:  MOVF   FED,F
04F42:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
04F44:  MOVLW  0F
04F46:  ADDWF  x00,W
04F48:  MOVWF  FE9
04F4A:  MOVLW  00
04F4C:  ADDWFC x01,W
04F4E:  MOVWF  FEA
04F50:  MOVFF  FEF,99B
04F54:  CLRF   x9D
04F56:  MOVLW  28
04F58:  MOVWF  x9C
04F5A:  MOVLB  0
04F5C:  CALL   1B50
04F60:  MOVLB  9
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
04F62:  MOVFF  8FB,904
04F66:  MOVLB  0
04F68:  BRA    4BB2
04F6A:  MOVFF  02,903
04F6E:  MOVFF  01,902
....................     
....................    len = n < len ? n : len; 
04F72:  MOVLB  9
04F74:  MOVF   x03,W
04F76:  MOVLB  8
04F78:  SUBWF  xFF,W
04F7A:  BNC   4F98
04F7C:  BNZ   4F8C
04F7E:  MOVF   xFE,W
04F80:  MOVLB  9
04F82:  SUBWF  x02,W
04F84:  BTFSS  FD8.0
04F86:  BRA    4F8C
04F88:  MOVLB  8
04F8A:  BRA    4F98
04F8C:  MOVFF  903,03
04F90:  MOVLB  9
04F92:  MOVF   x02,W
04F94:  BRA    4F9E
04F96:  MOVLB  8
04F98:  MOVFF  8FF,03
04F9C:  MOVF   xFE,W
04F9E:  MOVLB  8
04FA0:  MOVWF  xFE
04FA2:  MOVFF  03,8FF
....................    n = len; 
04FA6:  MOVFF  8FF,903
04FAA:  MOVFF  8FE,902
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
04FAE:  MOVLW  23
04FB0:  MOVLB  9
04FB2:  ADDWF  x00,W
04FB4:  MOVWF  FE9
04FB6:  MOVLW  00
04FB8:  ADDWFC x01,W
04FBA:  MOVWF  FEA
04FBC:  BSF    FEF.4
....................  
....................    while (n--) 
04FBE:  MOVFF  903,03
04FC2:  MOVF   x02,W
04FC4:  BTFSC  FD8.2
04FC6:  DECF   x03,F
04FC8:  DECF   x02,F
04FCA:  IORWF  03,W
04FCC:  BZ    5032
....................    { 
....................       MACPut(*ptr++); 
04FCE:  MOVLB  8
04FD0:  MOVFF  8FD,03
04FD4:  MOVF   xFC,W
04FD6:  INCF   xFC,F
04FD8:  BTFSC  FD8.2
04FDA:  INCF   xFD,F
04FDC:  MOVWF  FE9
04FDE:  MOVFF  03,FEA
04FE2:  MOVFF  FEF,9A5
04FE6:  MOVLB  0
04FE8:  CALL   1BEE
....................       ps->RemoteWindow -= 1; 
04FEC:  MOVLW  14
04FEE:  MOVLB  9
04FF0:  ADDWF  x00,W
04FF2:  MOVWF  FE9
04FF4:  MOVLW  00
04FF6:  ADDWFC x01,W
04FF8:  MOVWF  FEA
04FFA:  MOVLW  01
04FFC:  SUBWF  FEF,W
04FFE:  MOVWF  00
05000:  MOVLW  00
05002:  SUBWFB FEC,W
05004:  MOVWF  03
05006:  MOVF   00,W
05008:  MOVF   FED,F
0500A:  MOVWF  FEF
0500C:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
05010:  MOVLW  10
05012:  ADDWF  x00,W
05014:  MOVWF  FE9
05016:  MOVLW  00
05018:  ADDWFC x01,W
0501A:  MOVWF  FEA
0501C:  MOVLW  01
0501E:  ADDWF  FEF,W
05020:  MOVWF  01
05022:  MOVLW  00
05024:  ADDWFC FEC,W
05026:  MOVWF  03
05028:  MOVF   FED,F
0502A:  MOVFF  01,FEF
0502E:  MOVWF  FEC
05030:  BRA    4FBE
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
05032:  MOVLW  10
05034:  ADDWF  x00,W
05036:  MOVWF  FE9
05038:  MOVLW  00
0503A:  ADDWFC x01,W
0503C:  MOVWF  FEA
0503E:  MOVFF  FEC,905
05042:  MOVF   FED,F
05044:  MOVFF  FEF,904
05048:  MOVF   x05,W
0504A:  SUBLW  02
0504C:  BC    5062
0504E:  XORLW  FF
05050:  BNZ   5058
05052:  MOVF   x04,W
05054:  SUBLW  C9
05056:  BC    5062
....................       TCPFlush(s); 
05058:  MOVFF  8FB,904
0505C:  MOVLB  0
0505E:  RCALL  4CF0
05060:  MOVLB  9
....................  
....................    return(len); 
05062:  MOVLB  8
05064:  MOVFF  8FE,01
05068:  MOVFF  8FF,02
0506C:  MOVLB  9
0506E:  MOVLB  0
05070:  GOTO   52BC (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
05074:  MOVLB  9
05076:  CLRF   x47
05078:  MOVFF  903,946
0507C:  CLRF   x49
0507E:  MOVLW  24
05080:  MOVWF  x48
05082:  MOVLB  0
05084:  CALL   0FBC
05088:  MOVFF  02,03
0508C:  MOVF   01,W
0508E:  ADDLW  97
05090:  MOVWF  01
05092:  MOVLW  03
05094:  ADDWFC 03,F
05096:  MOVFF  01,904
0509A:  MOVLB  9
0509C:  MOVFF  03,905
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
050A0:  MOVLW  23
050A2:  ADDWF  x04,W
050A4:  MOVWF  FE9
050A6:  MOVLW  00
050A8:  ADDWFC x05,W
050AA:  MOVWF  FEA
050AC:  BTFSC  FEF.3
050AE:  BRA    50B6
....................         return FALSE; 
050B0:  MOVLW  00
050B2:  MOVWF  01
050B4:  BRA    50D0
....................  
....................     MACDiscardRx(); 
050B6:  MOVLB  0
050B8:  CALL   1736
....................     ps->Flags.bIsGetReady = FALSE; 
050BC:  MOVLW  23
050BE:  MOVLB  9
050C0:  ADDWF  x04,W
050C2:  MOVWF  FE9
050C4:  MOVLW  00
050C6:  ADDWFC x05,W
050C8:  MOVWF  FEA
050CA:  BCF    FEF.3
....................  
....................     return TRUE; 
050CC:  MOVLW  01
050CE:  MOVWF  01
050D0:  MOVLB  0
050D2:  GOTO   5138 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
049F8:  MOVLB  9
049FA:  CLRF   x47
049FC:  MOVFF  8FB,946
04A00:  CLRF   x49
04A02:  MOVLW  24
04A04:  MOVWF  x48
04A06:  MOVLB  0
04A08:  CALL   0FBC
04A0C:  MOVFF  02,03
04A10:  MOVF   01,W
04A12:  ADDLW  97
04A14:  MOVWF  01
04A16:  MOVLW  03
04A18:  ADDWFC 03,F
04A1A:  MOVFF  01,8FE
04A1E:  MOVLB  8
04A20:  MOVFF  03,8FF
....................  
....................     if ( ps->Flags.bIsGetReady ) 
04A24:  MOVLW  23
04A26:  ADDWF  xFE,W
04A28:  MOVWF  FE9
04A2A:  MOVLW  00
04A2C:  ADDWFC xFF,W
04A2E:  MOVWF  FEA
04A30:  BTFSS  FEF.3
04A32:  BRA    4ADA
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
04A34:  MOVLW  23
04A36:  ADDWF  xFE,W
04A38:  MOVWF  FE9
04A3A:  MOVLW  00
04A3C:  ADDWFC xFF,W
04A3E:  MOVWF  FEA
04A40:  BTFSS  FEF.2
04A42:  BRA    4A62
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
04A44:  MOVLB  9
04A46:  CLRF   x2A
04A48:  MOVLW  14
04A4A:  MOVWF  x29
04A4C:  MOVLB  0
04A4E:  CALL   2734
....................  
....................             ps->Flags.bFirstRead = FALSE; 
04A52:  MOVLW  23
04A54:  MOVLB  8
04A56:  ADDWF  xFE,W
04A58:  MOVWF  FE9
04A5A:  MOVLW  00
04A5C:  ADDWFC xFF,W
04A5E:  MOVWF  FEA
04A60:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
04A62:  MOVLW  12
04A64:  ADDWF  xFE,W
04A66:  MOVWF  FE9
04A68:  MOVLW  00
04A6A:  ADDWFC xFF,W
04A6C:  MOVWF  FEA
04A6E:  MOVFF  FEC,901
04A72:  MOVF   FED,F
04A74:  MOVFF  FEF,900
04A78:  MOVLB  9
04A7A:  MOVF   x00,F
04A7C:  BNZ   4AA0
04A7E:  MOVF   x01,F
04A80:  BNZ   4AA0
....................         { 
....................             MACDiscardRx(); 
04A82:  MOVLB  0
04A84:  CALL   1736
....................             ps->Flags.bIsGetReady = FALSE; 
04A88:  MOVLW  23
04A8A:  MOVLB  8
04A8C:  ADDWF  xFE,W
04A8E:  MOVWF  FE9
04A90:  MOVLW  00
04A92:  ADDWFC xFF,W
04A94:  MOVWF  FEA
04A96:  BCF    FEF.3
....................             return FALSE; 
04A98:  MOVLW  00
04A9A:  MOVWF  01
04A9C:  BRA    4ADE
04A9E:  MOVLB  9
....................         } 
....................  
....................          ps->RxCount--; 
04AA0:  MOVLW  12
04AA2:  MOVLB  8
04AA4:  ADDWF  xFE,W
04AA6:  MOVWF  FE9
04AA8:  MOVLW  00
04AAA:  ADDWFC xFF,W
04AAC:  MOVWF  FEA
04AAE:  MOVLW  FF
04AB0:  ADDWF  FEF,F
04AB2:  BC    4AB8
04AB4:  MOVF   FEE,F
04AB6:  DECF   FED,F
....................          *data = MACGet(); 
04AB8:  MOVFF  8FD,901
04ABC:  MOVFF  8FC,900
04AC0:  MOVLB  0
04AC2:  CALL   25B0
04AC6:  MOVFF  901,FEA
04ACA:  MOVFF  900,FE9
04ACE:  MOVFF  01,FEF
....................         return TRUE; 
04AD2:  MOVLW  01
04AD4:  MOVWF  01
04AD6:  MOVLB  8
04AD8:  BRA    4ADE
....................     } 
....................     return FALSE; 
04ADA:  MOVLW  00
04ADC:  MOVWF  01
04ADE:  MOVLB  0
04AE0:  GOTO   5220 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
049B8:  MOVLB  9
049BA:  CLRF   x47
049BC:  MOVFF  8FB,946
049C0:  CLRF   x49
049C2:  MOVLW  24
049C4:  MOVWF  x48
049C6:  MOVLB  0
049C8:  CALL   0FBC
049CC:  MOVFF  02,8FD
049D0:  MOVFF  01,8FC
049D4:  MOVLW  23
049D6:  MOVLB  8
049D8:  ADDWF  xFC,F
049DA:  MOVLW  00
049DC:  ADDWFC xFD,F
049DE:  MOVLW  97
049E0:  ADDWF  xFC,W
049E2:  MOVWF  FE9
049E4:  MOVLW  03
049E6:  ADDWFC xFD,W
049E8:  MOVWF  FEA
049EA:  MOVLW  00
049EC:  BTFSC  FEF.3
049EE:  MOVLW  01
049F0:  MOVWF  01
049F2:  MOVLB  0
049F4:  GOTO   5200 (RETURN)
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
04022:  MOVLB  9
04024:  CLRF   x07
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
04026:  MOVLB  8
04028:  CLRF   xFC
0402A:  MOVF   xFC,W
0402C:  SUBLW  22
0402E:  BTFSS  FD8.0
04030:  BRA    449C
....................    { 
....................       ps = &TCB[s]; 
04032:  MOVLB  9
04034:  CLRF   x47
04036:  MOVFF  8FC,946
0403A:  CLRF   x49
0403C:  MOVLW  24
0403E:  MOVWF  x48
04040:  MOVLB  0
04042:  CALL   0FBC
04046:  MOVFF  02,03
0404A:  MOVF   01,W
0404C:  ADDLW  97
0404E:  MOVWF  01
04050:  MOVLW  03
04052:  ADDWFC 03,F
04054:  MOVFF  01,901
04058:  MOVLB  9
0405A:  MOVFF  03,902
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
0405E:  MOVLW  23
04060:  ADDWF  x01,W
04062:  MOVWF  FE9
04064:  MOVLW  00
04066:  ADDWFC x02,W
04068:  MOVWF  FEA
0406A:  BTFSC  FEF.3
0406C:  BRA    407E
0406E:  MOVLW  23
04070:  ADDWF  x01,W
04072:  MOVWF  FE9
04074:  MOVLW  00
04076:  ADDWFC x02,W
04078:  MOVWF  FEA
0407A:  BTFSS  FEF.4
0407C:  BRA    4080
....................          continue; 
0407E:  BRA    4496
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
04080:  MOVFF  901,FE9
04084:  MOVFF  902,FEA
04088:  MOVF   FEF,W
0408A:  SUBLW  0A
0408C:  BZ    40AE
0408E:  MOVFF  901,FE9
04092:  MOVFF  902,FEA
04096:  MOVF   FEF,F
04098:  BNZ   40B0
0409A:  MOVLW  23
0409C:  ADDWF  x01,W
0409E:  MOVWF  FE9
040A0:  MOVLW  00
040A2:  ADDWFC x02,W
040A4:  MOVWF  FEA
040A6:  MOVF   FEF,W
040A8:  ANDLW  01
040AA:  SUBLW  01
040AC:  BNZ   40B0
....................          continue; 
040AE:  BRA    4496
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
040B0:  MOVFF  901,FE9
040B4:  MOVFF  902,FEA
040B8:  MOVF   FEF,W
040BA:  SUBLW  03
040BC:  BNZ   40D4
040BE:  MOVLW  23
040C0:  ADDWF  x01,W
040C2:  MOVWF  FE9
040C4:  MOVLW  00
040C6:  ADDWFC x02,W
040C8:  MOVWF  FEA
040CA:  MOVF   FEF,W
040CC:  ANDLW  01
040CE:  SUBLW  01
040D0:  BNZ   40D4
....................          continue; 
040D2:  BRA    4496
....................  
....................  
....................       tick = TickGet(); 
040D4:  MOVLB  0
040D6:  CALL   2B52
040DA:  MOVFF  02,900
040DE:  MOVFF  01,8FF
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
040E2:  MOVLW  1F
040E4:  MOVLB  9
040E6:  ADDWF  x01,W
040E8:  MOVWF  FE9
040EA:  MOVLW  00
040EC:  ADDWFC x02,W
040EE:  MOVWF  FEA
040F0:  MOVFF  FEC,03
040F4:  MOVF   FED,F
040F6:  MOVFF  FEF,01
040FA:  MOVF   x00,W
040FC:  SUBWF  03,W
040FE:  BNC   4112
04100:  BNZ   4116
04102:  MOVF   01,W
04104:  MOVLB  8
04106:  SUBWF  xFF,W
04108:  BTFSC  FD8.0
0410A:  BRA    4110
0410C:  MOVLB  9
0410E:  BRA    4116
04110:  MOVLB  9
04112:  MOVLW  00
04114:  BRA    4118
04116:  MOVLW  01
04118:  CLRF   03
0411A:  IORWF  03,W
0411C:  BZ    4158
0411E:  MOVLW  1F
04120:  ADDWF  x01,W
04122:  MOVWF  FE9
04124:  MOVLW  00
04126:  ADDWFC x02,W
04128:  MOVWF  FEA
0412A:  MOVFF  FEC,03
0412E:  MOVF   FED,F
04130:  MOVF   FEF,W
04132:  SUBLW  FF
04134:  MOVWF  x08
04136:  MOVLW  FF
04138:  SUBFWB 03,W
0413A:  MOVWF  x09
0413C:  MOVLB  8
0413E:  MOVF   xFF,W
04140:  MOVLB  9
04142:  ADDWF  x08,F
04144:  MOVF   x00,W
04146:  ADDWFC x09,F
04148:  MOVLW  01
0414A:  ADDWF  x08,W
0414C:  MOVWF  01
0414E:  MOVLW  00
04150:  ADDWFC x09,W
04152:  MOVWF  03
04154:  MOVF   01,W
04156:  BRA    417C
04158:  MOVLW  1F
0415A:  ADDWF  x01,W
0415C:  MOVWF  FE9
0415E:  MOVLW  00
04160:  ADDWFC x02,W
04162:  MOVWF  FEA
04164:  MOVFF  FEC,03
04168:  MOVF   FED,F
0416A:  MOVF   FEF,W
0416C:  MOVLB  8
0416E:  SUBWF  xFF,W
04170:  MOVWF  00
04172:  MOVF   03,W
04174:  MOVLB  9
04176:  SUBWFB x00,W
04178:  MOVWF  03
0417A:  MOVF   00,W
0417C:  MOVLB  8
0417E:  MOVWF  xFD
04180:  MOVFF  03,8FE
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
04184:  MOVLW  21
04186:  MOVLB  9
04188:  ADDWF  x01,W
0418A:  MOVWF  FE9
0418C:  MOVLW  00
0418E:  ADDWFC x02,W
04190:  MOVWF  FEA
04192:  MOVFF  FEC,03
04196:  MOVF   FED,F
04198:  MOVFF  FEF,01
0419C:  MOVLB  8
0419E:  MOVF   xFE,W
041A0:  SUBWF  03,W
041A2:  BNC   41B2
041A4:  BNZ   41AC
041A6:  MOVF   xFD,W
041A8:  SUBWF  01,W
041AA:  BNC   41B2
....................          continue; 
041AC:  MOVLB  9
041AE:  BRA    4496
041B0:  MOVLB  8
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
041B2:  MOVLW  01
041B4:  MOVLB  9
041B6:  MOVWF  x82
041B8:  MOVLB  0
041BA:  CALL   2C6A
041BE:  MOVF   01,F
041C0:  BNZ   41C4
....................          return; 
041C2:  BRA    449C
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
041C4:  MOVLW  1F
041C6:  MOVLB  9
041C8:  ADDWF  x01,W
041CA:  MOVWF  01
041CC:  MOVLW  00
041CE:  ADDWFC x02,W
041D0:  MOVWF  03
041D2:  MOVFF  01,908
041D6:  MOVWF  x09
041D8:  MOVLB  0
041DA:  CALL   2B52
041DE:  MOVFF  909,FEA
041E2:  MOVFF  908,FE9
041E6:  MOVFF  02,FEC
041EA:  MOVF   FED,F
041EC:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
041F0:  MOVLW  21
041F2:  MOVLB  9
041F4:  ADDWF  x01,W
041F6:  MOVWF  FE9
041F8:  MOVLW  00
041FA:  ADDWFC x02,W
041FC:  MOVWF  FEA
041FE:  BCF    FD8.0
04200:  RLCF   FEF,W
04202:  MOVWF  02
04204:  RLCF   FEC,W
04206:  MOVWF  03
04208:  MOVF   02,W
0420A:  MOVF   FED,F
0420C:  MOVWF  FEF
0420E:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
04212:  MOVLW  1E
04214:  ADDWF  x01,W
04216:  MOVWF  FE9
04218:  MOVLW  00
0421A:  ADDWFC x02,W
0421C:  MOVWF  FEA
0421E:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
04220:  MOVFF  901,FE9
04224:  MOVFF  902,FEA
04228:  MOVLW  01
0422A:  SUBWF  FEF,W
0422C:  ADDLW  F7
0422E:  BTFSC  FD8.0
04230:  BRA    43B8
04232:  ADDLW  09
04234:  MOVLB  0
04236:  GOTO   44A2
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
0423A:  MOVLW  02
0423C:  MOVLB  9
0423E:  MOVWF  x07
....................          break; 
04240:  BRA    43B8
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04242:  MOVLW  1E
04244:  MOVLB  9
04246:  ADDWF  x01,W
04248:  MOVWF  FE9
0424A:  MOVLW  00
0424C:  ADDWFC x02,W
0424E:  MOVWF  FEA
04250:  MOVF   FEF,W
04252:  SUBLW  03
04254:  BNC   425C
....................          { 
....................             flags = SYN | ACK; 
04256:  MOVLW  12
04258:  MOVWF  x07
....................          } 
0425A:  BRA    4288
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
0425C:  MOVLW  23
0425E:  ADDWF  x01,W
04260:  MOVWF  FE9
04262:  MOVLW  00
04264:  ADDWFC x02,W
04266:  MOVWF  FEA
04268:  BTFSS  FEF.0
0426A:  BRA    4278
....................             { 
....................                ps->smState = TCP_LISTEN; 
0426C:  MOVFF  901,FE9
04270:  MOVFF  902,FEA
04274:  CLRF   FEF
....................             } 
04276:  BRA    4288
....................             else 
....................             { 
....................                flags = SYN; 
04278:  MOVLW  02
0427A:  MOVWF  x07
....................                ps->smState = TCP_SYN_SENT; 
0427C:  MOVFF  901,FE9
04280:  MOVFF  902,FEA
04284:  MOVLW  01
04286:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
04288:  BRA    43B8
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0428A:  MOVLW  1E
0428C:  MOVLB  9
0428E:  ADDWF  x01,W
04290:  MOVWF  FE9
04292:  MOVLW  00
04294:  ADDWFC x02,W
04296:  MOVWF  FEA
04298:  MOVF   FEF,W
0429A:  SUBLW  03
0429C:  BNC   42DC
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
0429E:  MOVLW  0F
042A0:  ADDWF  x01,W
042A2:  MOVWF  FE9
042A4:  MOVLW  00
042A6:  ADDWFC x02,W
042A8:  MOVWF  FEA
042AA:  INCFSZ FEF,W
042AC:  BRA    42B0
042AE:  BRA    42D2
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
042B0:  MOVLW  0F
042B2:  ADDWF  x01,W
042B4:  MOVWF  FE9
042B6:  MOVLW  00
042B8:  ADDWFC x02,W
042BA:  MOVWF  FEA
042BC:  MOVFF  FEF,99B
042C0:  CLRF   x9D
042C2:  CLRF   x9C
042C4:  MOVLB  0
042C6:  CALL   1B50
....................                MACFlush(); 
042CA:  CALL   1D24
....................             } 
042CE:  BRA    42D8
042D0:  MOVLB  9
....................             else 
....................                flags = ACK; 
042D2:  MOVLW  10
042D4:  MOVWF  x07
042D6:  MOVLB  0
....................          } 
042D8:  BRA    4326
042DA:  MOVLB  9
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
042DC:  MOVLW  0F
042DE:  ADDWF  x01,W
042E0:  MOVWF  FE9
042E2:  MOVLW  00
042E4:  ADDWFC x02,W
042E6:  MOVWF  FEA
042E8:  INCFSZ FEF,W
042EA:  BRA    42EE
042EC:  BRA    4314
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
042EE:  MOVLW  0F
042F0:  ADDWF  x01,W
042F2:  MOVWF  FE9
042F4:  MOVLW  00
042F6:  ADDWFC x02,W
042F8:  MOVWF  FEA
042FA:  MOVFF  FEF,949
042FE:  MOVLB  0
04300:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
04304:  MOVLW  0F
04306:  MOVLB  9
04308:  ADDWF  x01,W
0430A:  MOVWF  FE9
0430C:  MOVLW  00
0430E:  ADDWFC x02,W
04310:  MOVWF  FEA
04312:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
04314:  MOVLW  11
04316:  MOVWF  x07
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
04318:  MOVFF  901,FE9
0431C:  MOVFF  902,FEA
04320:  MOVLW  04
04322:  MOVWF  FEF
04324:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
04326:  MOVLB  9
04328:  BRA    43B8
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0432A:  MOVLW  1E
0432C:  MOVLB  9
0432E:  ADDWF  x01,W
04330:  MOVWF  FE9
04332:  MOVLW  00
04334:  ADDWFC x02,W
04336:  MOVWF  FEA
04338:  MOVF   FEF,W
0433A:  SUBLW  03
0433C:  BNC   4344
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
0433E:  MOVLW  01
04340:  MOVWF  x07
....................          } 
04342:  BRA    4354
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
04344:  MOVFF  902,947
04348:  MOVFF  901,946
0434C:  MOVLB  0
0434E:  CALL   2B6C
04352:  MOVLB  9
....................          } 
....................          break; 
04354:  BRA    43B8
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
04356:  MOVFF  902,947
0435A:  MOVFF  901,946
0435E:  CALL   2B6C
....................          break; 
04362:  MOVLB  9
04364:  BRA    43B8
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
04366:  MOVFF  902,947
0436A:  MOVFF  901,946
0436E:  CALL   2B6C
....................          break; 
04372:  MOVLB  9
04374:  BRA    43B8
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
04376:  MOVLW  01
04378:  MOVLB  9
0437A:  MOVWF  x07
....................          ps->smState = TCP_LAST_ACK; 
0437C:  MOVFF  901,FE9
04380:  MOVFF  902,FEA
04384:  MOVLW  09
04386:  MOVWF  FEF
....................          break; 
04388:  BRA    43B8
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0438A:  MOVLW  1E
0438C:  MOVLB  9
0438E:  ADDWF  x01,W
04390:  MOVWF  FE9
04392:  MOVLW  00
04394:  ADDWFC x02,W
04396:  MOVWF  FEA
04398:  MOVF   FEF,W
0439A:  SUBLW  03
0439C:  BNC   43A4
....................             flags = FIN; 
0439E:  MOVLW  01
043A0:  MOVWF  x07
043A2:  BRA    43B4
....................          else 
....................             CloseSocket(ps); 
043A4:  MOVFF  902,947
043A8:  MOVFF  901,946
043AC:  MOVLB  0
043AE:  CALL   2B6C
043B2:  MOVLB  9
....................          break; 
043B4:  BRA    43B8
043B6:  MOVLB  9
....................       } 
....................  
....................  
....................       if(flags) 
043B8:  MOVF   x07,F
043BA:  BZ    4496
....................       { 
....................          if(flags & ACK) 
043BC:  BTFSS  x07.4
043BE:  BRA    43DE
....................             seq = ps->SND_SEQ; 
043C0:  MOVLW  16
043C2:  ADDWF  x01,W
043C4:  MOVWF  FE9
043C6:  MOVLW  00
043C8:  ADDWFC x02,W
043CA:  MOVWF  FEA
043CC:  MOVFF  FEF,903
043D0:  MOVFF  FEC,904
043D4:  MOVFF  FEC,905
043D8:  MOVFF  FEC,906
043DC:  BRA    4412
....................          else 
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
043DE:  MOVLW  16
043E0:  ADDWF  x01,W
043E2:  MOVWF  FE9
043E4:  MOVLW  00
043E6:  ADDWFC x02,W
043E8:  MOVWF  FEA
043EA:  MOVFF  FEF,903
043EE:  MOVFF  FEC,904
043F2:  MOVFF  FEC,905
043F6:  MOVFF  FEC,906
....................             ps->SND_SEQ++; 
043FA:  MOVLW  16
043FC:  ADDWF  x01,W
043FE:  MOVWF  FE9
04400:  MOVLW  00
04402:  ADDWFC x02,W
04404:  MOVWF  FEA
04406:  MOVLW  01
04408:  ADDWF  FEE,F
0440A:  MOVLW  00
0440C:  ADDWFC FEE,F
0440E:  ADDWFC FEE,F
04410:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
04412:  MOVLW  01
04414:  ADDWF  x01,W
04416:  MOVWF  01
04418:  MOVLW  00
0441A:  ADDWFC x02,W
0441C:  MOVWF  03
0441E:  MOVFF  01,908
04422:  MOVWF  x09
04424:  MOVLW  0B
04426:  ADDWF  x01,W
04428:  MOVWF  FE9
0442A:  MOVLW  00
0442C:  ADDWFC x02,W
0442E:  MOVWF  FEA
04430:  MOVFF  FEC,94D
04434:  MOVF   FED,F
04436:  MOVFF  FEF,94C
0443A:  MOVLW  0D
0443C:  ADDWF  x01,W
0443E:  MOVWF  FE9
04440:  MOVLW  00
04442:  ADDWFC x02,W
04444:  MOVWF  FEA
04446:  MOVFF  FEC,94F
0444A:  MOVF   FED,F
0444C:  MOVFF  FEF,94E
04450:  MOVLW  1A
04452:  ADDWF  x01,W
04454:  MOVWF  FE9
04456:  MOVLW  00
04458:  ADDWFC x02,W
0445A:  MOVWF  FEA
0445C:  MOVFF  FEF,954
04460:  MOVFF  FEC,955
04464:  MOVFF  FEC,956
04468:  MOVFF  FEC,957
0446C:  MOVFF  03,94B
04470:  MOVFF  01,94A
04474:  MOVFF  906,953
04478:  MOVFF  905,952
0447C:  MOVFF  904,951
04480:  MOVFF  903,950
04484:  MOVFF  907,958
04488:  SETF   x59
0448A:  CLRF   x5B
0448C:  CLRF   x5A
0448E:  MOVLB  0
04490:  CALL   2FA8
04494:  MOVLB  9
....................       } 
04496:  MOVLB  8
04498:  INCF   xFC,F
0449A:  BRA    402A
0449C:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
0449E:  GOTO   4680 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
03BE2:  MOVLW  06
03BE4:  MOVLB  8
03BE6:  ADDWF  xFC,W
03BE8:  MOVWF  FE9
03BEA:  MOVLW  00
03BEC:  ADDWFC xFD,W
03BEE:  MOVWF  FEA
03BF0:  MOVFF  FEF,916
03BF4:  MOVFF  FEC,917
03BF8:  MOVFF  FEC,918
03BFC:  MOVFF  FEC,919
....................    pseudoHeader.DestAddress        = *localIP; 
03C00:  MOVFF  8FE,FE9
03C04:  MOVFF  8FF,FEA
03C08:  MOVFF  FEF,91A
03C0C:  MOVFF  FEC,91B
03C10:  MOVFF  FEC,91C
03C14:  MOVFF  FEC,91D
....................    pseudoHeader.Zero               = 0x0; 
03C18:  MOVLB  9
03C1A:  CLRF   x1E
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
03C1C:  MOVLW  06
03C1E:  MOVWF  x1F
....................    pseudoHeader.TCPLength          = len; 
03C20:  MOVFF  901,921
03C24:  MOVFF  900,920
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03C28:  MOVFF  921,9A2
03C2C:  MOVFF  920,9A1
03C30:  MOVLB  0
03C32:  CALL   1810
03C36:  MOVFF  02,921
03C3A:  MOVFF  01,920
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03C3E:  MOVLW  09
03C40:  MOVLB  9
03C42:  MOVWF  x29
03C44:  MOVLW  16
03C46:  MOVWF  x28
03C48:  MOVFF  929,985
03C4C:  MOVWF  x84
03C4E:  CLRF   x87
03C50:  MOVLW  0C
03C52:  MOVWF  x86
03C54:  MOVLB  0
03C56:  CALL   24BA
03C5A:  MOVFF  01,923
03C5E:  MOVLB  9
03C60:  COMF   x23,F
03C62:  MOVFF  02,924
03C66:  COMF   x24,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
03C68:  MOVFF  901,983
03C6C:  MOVFF  900,982
03C70:  MOVLB  0
03C72:  CALL   25DC
03C76:  MOVFF  02,926
03C7A:  MOVFF  01,925
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
03C7E:  MOVLB  9
03C80:  MOVF   x26,W
03C82:  SUBWF  x23,W
03C84:  BNZ   3C8C
03C86:  MOVF   x25,W
03C88:  SUBWF  x24,W
03C8A:  BZ    3C9A
....................    { 
....................       MACDiscardRx(); 
03C8C:  MOVLB  0
03C8E:  CALL   1736
....................       return TRUE; 
03C92:  MOVLW  01
03C94:  MOVWF  01
03C96:  BRA    3D6E
03C98:  MOVLB  9
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
03C9A:  CLRF   x2A
03C9C:  CLRF   x29
03C9E:  MOVLB  0
03CA0:  CALL   2734
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
03CA4:  MOVLW  09
03CA6:  MOVLB  9
03CA8:  MOVWF  x29
03CAA:  MOVLW  02
03CAC:  MOVWF  x28
03CAE:  MOVFF  929,991
03CB2:  MOVWF  x90
03CB4:  CLRF   x93
03CB6:  MOVLW  14
03CB8:  MOVWF  x92
03CBA:  MOVLB  0
03CBC:  CALL   17AC
....................    SwapTCPHeader(&TCPHeader); 
03CC0:  MOVLW  09
03CC2:  MOVLB  9
03CC4:  MOVWF  x83
03CC6:  MOVLW  02
03CC8:  MOVWF  x82
03CCA:  MOVLB  0
03CCC:  CALL   2772
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
03CD0:  MOVLB  9
03CD2:  SWAPF  x0E,W
03CD4:  ANDLW  0F
03CD6:  MOVWF  00
03CD8:  RLCF   00,F
03CDA:  RLCF   00,F
03CDC:  MOVLW  FC
03CDE:  ANDWF  00,F
03CE0:  MOVF   00,W
03CE2:  ADDLW  EC
03CE4:  MOVWF  x27
....................    len = len - optionsSize - sizeof(TCPHeader); 
03CE6:  MOVF   x27,W
03CE8:  SUBWF  x00,W
03CEA:  MOVWF  x28
03CEC:  MOVLW  00
03CEE:  SUBWFB x01,W
03CF0:  MOVWF  x29
03CF2:  MOVLW  14
03CF4:  SUBWF  x28,W
03CF6:  MOVWF  x00
03CF8:  MOVLW  00
03CFA:  SUBWFB x29,W
03CFC:  MOVWF  x01
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
03CFE:  SWAPF  x0E,W
03D00:  ANDLW  0F
03D02:  MOVWF  00
03D04:  RLCF   00,W
03D06:  MOVWF  x28
03D08:  RLCF   x28,F
03D0A:  MOVLW  FC
03D0C:  ANDWF  x28,F
03D0E:  CLRF   x2A
03D10:  MOVFF  928,929
03D14:  MOVLB  0
03D16:  CALL   2734
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
03D1A:  MOVLW  09
03D1C:  MOVLB  9
03D1E:  MOVWF  x29
03D20:  MOVLW  02
03D22:  MOVWF  x28
03D24:  MOVFF  8FD,92B
03D28:  MOVFF  8FC,92A
03D2C:  MOVLB  0
03D2E:  GOTO   2950
03D32:  MOVFF  01,922
....................    if(socket != INVALID_SOCKET) 
03D36:  MOVLB  9
03D38:  MOVF   x22,W
03D3A:  SUBLW  FE
03D3C:  BZ    3D64
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
03D3E:  MOVFF  922,928
03D42:  MOVFF  8FD,92A
03D46:  MOVFF  8FC,929
03D4A:  MOVLW  09
03D4C:  MOVWF  x2C
03D4E:  MOVLW  02
03D50:  MOVWF  x2B
03D52:  MOVFF  901,92E
03D56:  MOVFF  900,92D
03D5A:  MOVLB  0
03D5C:  GOTO   31CC
....................    } 
03D60:  BRA    3D6A
03D62:  MOVLB  9
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
03D64:  MOVLB  0
03D66:  CALL   1736
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
03D6A:  MOVLW  01
03D6C:  MOVWF  01
03D6E:  GOTO   45BE (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
02FA8:  MOVLW  01
02FAA:  MOVLB  9
02FAC:  MOVWF  x82
02FAE:  MOVLB  0
02FB0:  RCALL  2C6A
02FB2:  MOVF   01,F
02FB4:  BZ    2FA8
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
02FB6:  MOVLB  9
02FB8:  INCFSZ x59,W
02FBA:  BRA    2FCC
....................       buff = MACGetTxBuffer(TRUE); 
02FBC:  MOVLW  01
02FBE:  MOVWF  x82
02FC0:  MOVLB  0
02FC2:  CALL   1B28
02FC6:  MOVFF  01,959
02FCA:  MOVLB  9
....................  
....................    if(buff == INVALID_BUFFER) 
02FCC:  INCFSZ x59,W
02FCE:  BRA    2FD2
....................       return; 
02FD0:  BRA    31C8
....................  
....................    IPSetTxBuffer(buff, 0); 
02FD2:  MOVFF  959,99B
02FD6:  CLRF   x9D
02FD8:  MOVLW  14
02FDA:  MOVWF  x9C
02FDC:  MOVLB  0
02FDE:  CALL   1B50
....................  
....................    header.SourcePort           = localPort; 
02FE2:  MOVFF  94D,95F
02FE6:  MOVFF  94C,95E
....................    header.DestPort             = remotePort; 
02FEA:  MOVFF  94F,961
02FEE:  MOVFF  94E,960
....................    header.SeqNumber            = tseq; 
02FF2:  MOVFF  953,965
02FF6:  MOVFF  952,964
02FFA:  MOVFF  951,963
02FFE:  MOVFF  950,962
....................    header.AckNumber            = tack; 
03002:  MOVFF  957,969
03006:  MOVFF  956,968
0300A:  MOVFF  955,967
0300E:  MOVFF  954,966
....................    header.Flags.bits.Reserved2 = 0; 
03012:  MOVLW  3F
03014:  MOVLB  9
03016:  ANDWF  x6B,W
03018:  MOVWF  x6B
....................    header.DataOffset.Reserved3 = 0; 
0301A:  MOVLW  F0
0301C:  ANDWF  x6A,W
0301E:  MOVWF  x6A
....................    header.Flags.b              = flags; 
03020:  MOVFF  958,96B
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
03024:  MOVLB  0
03026:  BRA    2C92
03028:  MOVFF  02,96D
0302C:  MOVFF  01,96C
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
03030:  MOVLB  9
03032:  MOVF   x6D,F
03034:  BNZ   303C
03036:  MOVF   x6C,W
03038:  SUBLW  28
0303A:  BC    3046
....................    { 
....................       header.Window -= 40; 
0303C:  MOVLW  28
0303E:  SUBWF  x6C,F
03040:  MOVLW  00
03042:  SUBWFB x6D,F
....................    } 
03044:  BRA    304A
....................    else 
....................       header.Window = 0; 
03046:  CLRF   x6D
03048:  CLRF   x6C
.................... #endif 
....................  
....................    header.Checksum             = 0; 
0304A:  CLRF   x6F
0304C:  CLRF   x6E
....................    header.UrgentPointer        = 0; 
0304E:  CLRF   x71
03050:  CLRF   x70
....................  
....................    SwapTCPHeader(&header); 
03052:  MOVLW  09
03054:  MOVWF  x83
03056:  MOVLW  5E
03058:  MOVWF  x82
0305A:  MOVLB  0
0305C:  CALL   2772
....................  
....................    len += sizeof(header); 
03060:  MOVLW  14
03062:  MOVLB  9
03064:  ADDWF  x5A,F
03066:  MOVLW  00
03068:  ADDWFC x5B,F
....................  
....................    if ( flags & SYN ) 
0306A:  BTFSS  x58.1
0306C:  BRA    308C
....................    { 
....................       len += sizeof(options); 
0306E:  MOVLW  04
03070:  ADDWF  x5A,F
03072:  MOVLW  00
03074:  ADDWFC x5B,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03076:  MOVLW  02
03078:  MOVWF  x72
....................       options.Length = 0x04; 
0307A:  MOVLW  04
0307C:  MOVWF  x73
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
0307E:  MOVWF  x74
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
03080:  CLRF   x75
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
03082:  MOVLW  0F
03084:  ANDWF  x6A,W
03086:  IORLW  60
03088:  MOVWF  x6A
....................    } 
0308A:  BRA    3094
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
0308C:  MOVLW  0F
0308E:  ANDWF  x6A,W
03090:  IORLW  50
03092:  MOVWF  x6A
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
03094:  MOVFF  353,979
03098:  MOVFF  352,978
0309C:  MOVFF  351,977
030A0:  MOVFF  350,976
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
030A4:  MOVLW  06
030A6:  ADDWF  x4A,W
030A8:  MOVWF  FE9
030AA:  MOVLW  00
030AC:  ADDWFC x4B,W
030AE:  MOVWF  FEA
030B0:  MOVFF  FEF,97A
030B4:  MOVFF  FEC,97B
030B8:  MOVFF  FEC,97C
030BC:  MOVFF  FEC,97D
....................    pseudoHeader.Zero           = 0x0; 
030C0:  CLRF   x7E
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
030C2:  MOVLW  06
030C4:  MOVWF  x7F
....................    pseudoHeader.TCPLength      = len; 
030C6:  MOVFF  95B,981
030CA:  MOVFF  95A,980
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
030CE:  MOVFF  981,9A2
030D2:  MOVFF  980,9A1
030D6:  MOVLB  0
030D8:  CALL   1810
030DC:  MOVFF  02,981
030E0:  MOVFF  01,980
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
030E4:  MOVLW  09
030E6:  MOVLB  9
030E8:  MOVWF  x83
030EA:  MOVLW  76
030EC:  MOVWF  x82
030EE:  MOVFF  983,985
030F2:  MOVWF  x84
030F4:  CLRF   x87
030F6:  MOVLW  0C
030F8:  MOVWF  x86
030FA:  MOVLB  0
030FC:  CALL   24BA
03100:  MOVFF  01,96E
03104:  MOVLB  9
03106:  COMF   x6E,F
03108:  MOVFF  02,96F
0310C:  COMF   x6F,F
....................    checkSum.Val = header.Checksum; 
0310E:  MOVFF  96F,95D
03112:  MOVFF  96E,95C
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
03116:  MOVFF  94B,983
0311A:  MOVFF  94A,982
0311E:  MOVLW  06
03120:  MOVWF  x84
03122:  MOVFF  95B,986
03126:  MOVFF  95A,985
0312A:  MOVLB  0
0312C:  RCALL  2E82
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
0312E:  MOVLW  09
03130:  MOVLB  9
03132:  MOVWF  x83
03134:  MOVLW  5E
03136:  MOVWF  x82
03138:  MOVFF  983,9A7
0313C:  MOVWF  xA6
0313E:  CLRF   xA9
03140:  MOVLW  14
03142:  MOVWF  xA8
03144:  MOVLB  0
03146:  CALL   1C0C
....................  
....................    if ( flags & SYN ) 
0314A:  MOVLB  9
0314C:  BTFSS  x58.1
0314E:  BRA    316C
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
03150:  MOVLW  09
03152:  MOVWF  x83
03154:  MOVLW  72
03156:  MOVWF  x82
03158:  MOVFF  983,9A7
0315C:  MOVWF  xA6
0315E:  CLRF   xA9
03160:  MOVLW  04
03162:  MOVWF  xA8
03164:  MOVLB  0
03166:  CALL   1C0C
0316A:  MOVLB  9
....................  
....................    IPSetTxBuffer(buff, 0); 
0316C:  MOVFF  959,99B
03170:  CLRF   x9D
03172:  MOVLW  14
03174:  MOVWF  x9C
03176:  MOVLB  0
03178:  CALL   1B50
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
0317C:  MOVFF  95B,983
03180:  MOVFF  95A,982
03184:  CALL   25DC
03188:  MOVFF  02,95D
0318C:  MOVFF  01,95C
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
03190:  MOVFF  959,99B
03194:  MOVLB  9
03196:  CLRF   x9D
03198:  MOVLW  24
0319A:  MOVWF  x9C
0319C:  MOVLB  0
0319E:  CALL   1B50
....................    MACPut(checkSum.v[1]); 
031A2:  MOVFF  95D,9A5
031A6:  CALL   1BEE
....................    MACPut(checkSum.v[0]); 
031AA:  MOVFF  95C,9A5
031AE:  CALL   1BEE
....................    MACSetTxBuffer(buff, 0); 
031B2:  MOVFF  959,99B
031B6:  MOVLB  9
031B8:  CLRF   x9D
031BA:  CLRF   x9C
031BC:  MOVLB  0
031BE:  CALL   1B50
....................  
....................    MACFlush(); 
031C2:  CALL   1D24
031C6:  MOVLB  9
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
031C8:  MOVLB  0
031CA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
02950:  MOVLW  FE
02952:  MOVLB  9
02954:  MOVWF  x2F
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
02956:  CLRF   x2E
02958:  MOVF   x2E,W
0295A:  SUBLW  22
0295C:  BTFSS  FD8.0
0295E:  BRA    2A66
....................    { 
....................       ps = &TCB[s]; 
02960:  CLRF   x47
02962:  MOVFF  92E,946
02966:  CLRF   x49
02968:  MOVLW  24
0296A:  MOVWF  x48
0296C:  MOVLB  0
0296E:  CALL   0FBC
02972:  MOVFF  02,03
02976:  MOVF   01,W
02978:  ADDLW  97
0297A:  MOVWF  01
0297C:  MOVLW  03
0297E:  ADDWFC 03,F
02980:  MOVFF  01,92C
02984:  MOVLB  9
02986:  MOVFF  03,92D
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
0298A:  MOVFF  92C,FE9
0298E:  MOVFF  92D,FEA
02992:  MOVF   FEF,W
02994:  SUBLW  0A
02996:  BZ    2A62
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
02998:  MOVLW  0B
0299A:  ADDWF  x2C,W
0299C:  MOVWF  FE9
0299E:  MOVLW  00
029A0:  ADDWFC x2D,W
029A2:  MOVWF  FEA
029A4:  MOVFF  FEC,931
029A8:  MOVF   FED,F
029AA:  MOVFF  FEF,930
029AE:  MOVLW  02
029B0:  ADDWF  x28,W
029B2:  MOVWF  FE9
029B4:  MOVLW  00
029B6:  ADDWFC x29,W
029B8:  MOVWF  FEA
029BA:  MOVFF  FEC,03
029BE:  MOVF   FED,F
029C0:  MOVF   FEF,W
029C2:  SUBWF  x30,W
029C4:  BNZ   2A62
029C6:  MOVF   03,W
029C8:  SUBWF  x31,W
029CA:  BNZ   2A62
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
029CC:  MOVFF  92C,FE9
029D0:  MOVFF  92D,FEA
029D4:  MOVF   FEF,F
029D6:  BNZ   29DC
....................                partialMatch = s; 
029D8:  MOVFF  92E,92F
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
029DC:  MOVLW  0D
029DE:  ADDWF  x2C,W
029E0:  MOVWF  FE9
029E2:  MOVLW  00
029E4:  ADDWFC x2D,W
029E6:  MOVWF  FEA
029E8:  MOVFF  FEC,931
029EC:  MOVF   FED,F
029EE:  MOVFF  FEF,930
029F2:  MOVFF  928,FE9
029F6:  MOVFF  929,FEA
029FA:  MOVFF  FEC,03
029FE:  MOVF   FED,F
02A00:  MOVF   FEF,W
02A02:  SUBWF  x30,W
02A04:  BNZ   2A62
02A06:  MOVF   03,W
02A08:  SUBWF  x31,W
02A0A:  BNZ   2A62
02A0C:  MOVLW  07
02A0E:  ADDWF  x2C,W
02A10:  MOVWF  FE9
02A12:  MOVLW  00
02A14:  ADDWFC x2D,W
02A16:  MOVWF  FEA
02A18:  MOVFF  FEF,930
02A1C:  MOVFF  FEC,931
02A20:  MOVFF  FEC,932
02A24:  MOVFF  FEC,933
02A28:  MOVLW  06
02A2A:  ADDWF  x2A,W
02A2C:  MOVWF  FE9
02A2E:  MOVLW  00
02A30:  ADDWFC x2B,W
02A32:  MOVWF  FEA
02A34:  MOVFF  FEF,00
02A38:  MOVFF  FEC,01
02A3C:  MOVFF  FEC,02
02A40:  MOVFF  FEC,03
02A44:  MOVF   00,W
02A46:  SUBWF  x30,W
02A48:  BNZ   2A62
02A4A:  MOVF   01,W
02A4C:  SUBWF  x31,W
02A4E:  BNZ   2A62
02A50:  MOVF   02,W
02A52:  SUBWF  x32,W
02A54:  BNZ   2A62
02A56:  MOVF   03,W
02A58:  SUBWF  x33,W
02A5A:  BNZ   2A62
....................             { 
....................                return s; 
02A5C:  MOVFF  92E,01
02A60:  BRA    2B4C
....................             } 
....................          } 
....................       } 
02A62:  INCF   x2E,F
02A64:  BRA    2958
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
02A66:  MOVF   x2F,W
02A68:  SUBLW  FE
02A6A:  BNZ   2A72
....................       return INVALID_SOCKET; 
02A6C:  MOVLW  FE
02A6E:  MOVWF  01
02A70:  BRA    2B4C
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
02A72:  CLRF   x47
02A74:  MOVFF  92F,946
02A78:  CLRF   x49
02A7A:  MOVLW  24
02A7C:  MOVWF  x48
02A7E:  MOVLB  0
02A80:  CALL   0FBC
02A84:  MOVFF  02,03
02A88:  MOVF   01,W
02A8A:  ADDLW  97
02A8C:  MOVWF  01
02A8E:  MOVLW  03
02A90:  ADDWFC 03,F
02A92:  MOVFF  01,92C
02A96:  MOVLB  9
02A98:  MOVFF  03,92D
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
02A9C:  MOVLW  01
02A9E:  ADDWF  x2C,W
02AA0:  MOVWF  01
02AA2:  MOVLW  00
02AA4:  ADDWFC x2D,W
02AA6:  MOVWF  03
02AA8:  MOVFF  01,930
02AAC:  MOVWF  x31
02AAE:  MOVWF  FEA
02AB0:  MOVFF  01,FE9
02AB4:  MOVFF  92B,FE2
02AB8:  MOVFF  92A,FE1
02ABC:  MOVLW  0A
02ABE:  MOVWF  01
02AC0:  MOVFF  FE6,FEE
02AC4:  DECFSZ 01,F
02AC6:  BRA    2AC0
....................    ps->remotePort          = h->SourcePort; 
02AC8:  MOVLW  0D
02ACA:  ADDWF  x2C,W
02ACC:  MOVWF  01
02ACE:  MOVLW  00
02AD0:  ADDWFC x2D,W
02AD2:  MOVFF  928,FE9
02AD6:  MOVFF  929,FEA
02ADA:  MOVFF  FEC,03
02ADE:  MOVF   FED,F
02AE0:  MOVFF  FEF,932
02AE4:  MOVWF  FEA
02AE6:  MOVFF  01,FE9
02AEA:  MOVFF  03,FEC
02AEE:  MOVF   FED,F
02AF0:  MOVFF  932,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
02AF4:  MOVLW  23
02AF6:  ADDWF  x2C,W
02AF8:  MOVWF  FE9
02AFA:  MOVLW  00
02AFC:  ADDWFC x2D,W
02AFE:  MOVWF  FEA
02B00:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
02B02:  MOVLW  0F
02B04:  ADDWF  x2C,W
02B06:  MOVWF  FE9
02B08:  MOVLW  00
02B0A:  ADDWFC x2D,W
02B0C:  MOVWF  FEA
02B0E:  INCFSZ FEF,W
02B10:  BRA    2B14
02B12:  BRA    2B3A
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
02B14:  MOVLW  0F
02B16:  ADDWF  x2C,W
02B18:  MOVWF  FE9
02B1A:  MOVLW  00
02B1C:  ADDWFC x2D,W
02B1E:  MOVWF  FEA
02B20:  MOVFF  FEF,949
02B24:  MOVLB  0
02B26:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
02B2A:  MOVLW  0F
02B2C:  MOVLB  9
02B2E:  ADDWF  x2C,W
02B30:  MOVWF  FE9
02B32:  MOVLW  00
02B34:  ADDWFC x2D,W
02B36:  MOVWF  FEA
02B38:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
02B3A:  MOVLW  23
02B3C:  ADDWF  x2C,W
02B3E:  MOVWF  FE9
02B40:  MOVLW  00
02B42:  ADDWFC x2D,W
02B44:  MOVWF  FEA
02B46:  BSF    FEF.1
....................  
....................    return partialMatch; 
02B48:  MOVFF  92F,01
02B4C:  MOVLB  0
02B4E:  GOTO   3D32 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
02772:  MOVLB  9
02774:  MOVFF  982,01
02778:  MOVFF  983,03
0277C:  MOVFF  982,984
02780:  MOVFF  983,985
02784:  MOVFF  982,FE9
02788:  MOVFF  983,FEA
0278C:  MOVFF  FEC,9A2
02790:  MOVF   FED,F
02792:  MOVFF  FEF,9A1
02796:  MOVLB  0
02798:  CALL   1810
0279C:  MOVFF  985,FEA
027A0:  MOVFF  984,FE9
027A4:  MOVFF  02,FEC
027A8:  MOVF   FED,F
027AA:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
027AE:  MOVLW  02
027B0:  MOVLB  9
027B2:  ADDWF  x82,W
027B4:  MOVWF  01
027B6:  MOVLW  00
027B8:  ADDWFC x83,W
027BA:  MOVWF  03
027BC:  MOVFF  01,984
027C0:  MOVWF  x85
027C2:  MOVLW  02
027C4:  ADDWF  x82,W
027C6:  MOVWF  FE9
027C8:  MOVLW  00
027CA:  ADDWFC x83,W
027CC:  MOVWF  FEA
027CE:  MOVFF  FEC,9A2
027D2:  MOVF   FED,F
027D4:  MOVFF  FEF,9A1
027D8:  MOVLB  0
027DA:  CALL   1810
027DE:  MOVFF  985,FEA
027E2:  MOVFF  984,FE9
027E6:  MOVFF  02,FEC
027EA:  MOVF   FED,F
027EC:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
027F0:  MOVLW  04
027F2:  MOVLB  9
027F4:  ADDWF  x82,W
027F6:  MOVWF  01
027F8:  MOVLW  00
027FA:  ADDWFC x83,W
027FC:  MOVWF  03
027FE:  MOVFF  01,984
02802:  MOVWF  x85
02804:  MOVLW  04
02806:  ADDWF  x82,W
02808:  MOVWF  FE9
0280A:  MOVLW  00
0280C:  ADDWFC x83,W
0280E:  MOVWF  FEA
02810:  MOVFF  FEF,98A
02814:  MOVFF  FEC,98B
02818:  MOVFF  FEC,98C
0281C:  MOVFF  FEC,98D
02820:  MOVLB  0
02822:  RCALL  2750
02824:  MOVFF  985,FEA
02828:  MOVFF  984,FE9
0282C:  MOVFF  00,FEF
02830:  MOVFF  01,FEC
02834:  MOVFF  02,FEC
02838:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
0283C:  MOVLW  08
0283E:  MOVLB  9
02840:  ADDWF  x82,W
02842:  MOVWF  01
02844:  MOVLW  00
02846:  ADDWFC x83,W
02848:  MOVWF  03
0284A:  MOVFF  01,984
0284E:  MOVWF  x85
02850:  MOVLW  08
02852:  ADDWF  x82,W
02854:  MOVWF  FE9
02856:  MOVLW  00
02858:  ADDWFC x83,W
0285A:  MOVWF  FEA
0285C:  MOVFF  FEF,98A
02860:  MOVFF  FEC,98B
02864:  MOVFF  FEC,98C
02868:  MOVFF  FEC,98D
0286C:  MOVLB  0
0286E:  RCALL  2750
02870:  MOVFF  985,FEA
02874:  MOVFF  984,FE9
02878:  MOVFF  00,FEF
0287C:  MOVFF  01,FEC
02880:  MOVFF  02,FEC
02884:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
02888:  MOVLW  0E
0288A:  MOVLB  9
0288C:  ADDWF  x82,W
0288E:  MOVWF  01
02890:  MOVLW  00
02892:  ADDWFC x83,W
02894:  MOVWF  03
02896:  MOVFF  01,984
0289A:  MOVWF  x85
0289C:  MOVLW  0E
0289E:  ADDWF  x82,W
028A0:  MOVWF  FE9
028A2:  MOVLW  00
028A4:  ADDWFC x83,W
028A6:  MOVWF  FEA
028A8:  MOVFF  FEC,9A2
028AC:  MOVF   FED,F
028AE:  MOVFF  FEF,9A1
028B2:  MOVLB  0
028B4:  CALL   1810
028B8:  MOVFF  985,FEA
028BC:  MOVFF  984,FE9
028C0:  MOVFF  02,FEC
028C4:  MOVF   FED,F
028C6:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
028CA:  MOVLW  10
028CC:  MOVLB  9
028CE:  ADDWF  x82,W
028D0:  MOVWF  01
028D2:  MOVLW  00
028D4:  ADDWFC x83,W
028D6:  MOVWF  03
028D8:  MOVFF  01,984
028DC:  MOVWF  x85
028DE:  MOVLW  10
028E0:  ADDWF  x82,W
028E2:  MOVWF  FE9
028E4:  MOVLW  00
028E6:  ADDWFC x83,W
028E8:  MOVWF  FEA
028EA:  MOVFF  FEC,9A2
028EE:  MOVF   FED,F
028F0:  MOVFF  FEF,9A1
028F4:  MOVLB  0
028F6:  CALL   1810
028FA:  MOVFF  985,FEA
028FE:  MOVFF  984,FE9
02902:  MOVFF  02,FEC
02906:  MOVF   FED,F
02908:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
0290C:  MOVLW  12
0290E:  MOVLB  9
02910:  ADDWF  x82,W
02912:  MOVWF  01
02914:  MOVLW  00
02916:  ADDWFC x83,W
02918:  MOVWF  03
0291A:  MOVFF  01,984
0291E:  MOVWF  x85
02920:  MOVLW  12
02922:  ADDWF  x82,W
02924:  MOVWF  FE9
02926:  MOVLW  00
02928:  ADDWFC x83,W
0292A:  MOVWF  FEA
0292C:  MOVFF  FEC,9A2
02930:  MOVF   FED,F
02932:  MOVFF  FEF,9A1
02936:  MOVLB  0
02938:  CALL   1810
0293C:  MOVFF  985,FEA
02940:  MOVFF  984,FE9
02944:  MOVFF  02,FEC
02948:  MOVF   FED,F
0294A:  MOVFF  01,FEF
0294E:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
02B6C:  MOVLW  0F
02B6E:  MOVLB  9
02B70:  ADDWF  x46,W
02B72:  MOVWF  FE9
02B74:  MOVLW  00
02B76:  ADDWFC x47,W
02B78:  MOVWF  FEA
02B7A:  INCFSZ FEF,W
02B7C:  BRA    2B80
02B7E:  BRA    2BB4
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
02B80:  MOVLW  0F
02B82:  ADDWF  x46,W
02B84:  MOVWF  FE9
02B86:  MOVLW  00
02B88:  ADDWFC x47,W
02B8A:  MOVWF  FEA
02B8C:  MOVFF  FEF,949
02B90:  MOVLB  0
02B92:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
02B96:  MOVLW  0F
02B98:  MOVLB  9
02B9A:  ADDWF  x46,W
02B9C:  MOVWF  FE9
02B9E:  MOVLW  00
02BA0:  ADDWFC x47,W
02BA2:  MOVWF  FEA
02BA4:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
02BA6:  MOVLW  23
02BA8:  ADDWF  x46,W
02BAA:  MOVWF  FE9
02BAC:  MOVLW  00
02BAE:  ADDWFC x47,W
02BB0:  MOVWF  FEA
02BB2:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
02BB4:  MOVLW  07
02BB6:  ADDWF  x46,W
02BB8:  MOVWF  FE9
02BBA:  MOVLW  00
02BBC:  ADDWFC x47,W
02BBE:  MOVWF  FEA
02BC0:  MOVF   FEE,F
02BC2:  MOVF   FEE,F
02BC4:  CLRF   FEC
02BC6:  MOVF   FED,F
02BC8:  CLRF   FEF
02BCA:  MOVF   FED,F
02BCC:  CLRF   FEF
02BCE:  MOVF   FED,F
02BD0:  CLRF   FEF
....................     ps->remotePort = 0x00; 
02BD2:  MOVLW  0D
02BD4:  ADDWF  x46,W
02BD6:  MOVWF  FE9
02BD8:  MOVLW  00
02BDA:  ADDWFC x47,W
02BDC:  MOVWF  FEA
02BDE:  CLRF   FEC
02BE0:  MOVF   FED,F
02BE2:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
02BE4:  MOVLW  23
02BE6:  ADDWF  x46,W
02BE8:  MOVWF  FE9
02BEA:  MOVLW  00
02BEC:  ADDWFC x47,W
02BEE:  MOVWF  FEA
02BF0:  BTFSS  FEF.3
02BF2:  BRA    2BFC
....................     { 
....................         MACDiscardRx(); 
02BF4:  MOVLB  0
02BF6:  CALL   1736
02BFA:  MOVLB  9
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
02BFC:  MOVLW  23
02BFE:  ADDWF  x46,W
02C00:  MOVWF  FE9
02C02:  MOVLW  00
02C04:  ADDWFC x47,W
02C06:  MOVWF  FEA
02C08:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
02C0A:  MOVLW  21
02C0C:  ADDWF  x46,W
02C0E:  MOVWF  FE9
02C10:  MOVLW  00
02C12:  ADDWFC x47,W
02C14:  MOVWF  FEA
02C16:  CLRF   FEC
02C18:  MOVF   FED,F
02C1A:  MOVLW  24
02C1C:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
02C1E:  MOVLW  23
02C20:  ADDWF  x46,W
02C22:  MOVWF  FE9
02C24:  MOVLW  00
02C26:  ADDWFC x47,W
02C28:  MOVWF  FEA
02C2A:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
02C2C:  MOVLW  23
02C2E:  ADDWF  x46,W
02C30:  MOVWF  FE9
02C32:  MOVLW  00
02C34:  ADDWFC x47,W
02C36:  MOVWF  FEA
02C38:  BTFSS  FEF.0
02C3A:  BRA    2C48
....................     { 
....................         ps->smState = TCP_LISTEN; 
02C3C:  MOVFF  946,FE9
02C40:  MOVFF  947,FEA
02C44:  CLRF   FEF
....................     } 
02C46:  BRA    2C54
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
02C48:  MOVFF  946,FE9
02C4C:  MOVFF  947,FEA
02C50:  MOVLW  0A
02C52:  MOVWF  FEF
....................     } 
....................     //ps->smState = TCP_CLOSED; 
....................  
....................    ps->TxCount = 0; 
02C54:  MOVLW  10
02C56:  ADDWF  x46,W
02C58:  MOVWF  FE9
02C5A:  MOVLW  00
02C5C:  ADDWFC x47,W
02C5E:  MOVWF  FEA
02C60:  CLRF   FEC
02C62:  MOVF   FED,F
02C64:  CLRF   FEF
....................  
....................     return; 
02C66:  MOVLB  0
02C68:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
031CC:  MOVLB  9
031CE:  CLRF   x47
031D0:  MOVFF  928,946
031D4:  CLRF   x49
031D6:  MOVLW  24
031D8:  MOVWF  x48
031DA:  MOVLB  0
031DC:  CALL   0FBC
031E0:  MOVFF  02,03
031E4:  MOVF   01,W
031E6:  ADDLW  97
031E8:  MOVWF  01
031EA:  MOVLW  03
031EC:  ADDWFC 03,F
031EE:  MOVFF  01,93F
031F2:  MOVLB  9
031F4:  MOVFF  03,940
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
031F8:  CLRF   x41
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
031FA:  MOVLW  1E
031FC:  ADDWF  x3F,W
031FE:  MOVWF  FE9
03200:  MOVLW  00
03202:  ADDWFC x40,W
03204:  MOVWF  FEA
03206:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
03208:  MOVLW  1F
0320A:  ADDWF  x3F,W
0320C:  MOVWF  01
0320E:  MOVLW  00
03210:  ADDWFC x40,W
03212:  MOVWF  03
03214:  MOVFF  01,946
03218:  MOVWF  x47
0321A:  MOVLB  0
0321C:  RCALL  2B52
0321E:  MOVFF  947,FEA
03222:  MOVFF  946,FE9
03226:  MOVFF  02,FEC
0322A:  MOVF   FED,F
0322C:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
03230:  MOVLW  21
03232:  MOVLB  9
03234:  ADDWF  x3F,W
03236:  MOVWF  FE9
03238:  MOVLW  00
0323A:  ADDWFC x40,W
0323C:  MOVWF  FEA
0323E:  CLRF   FEC
03240:  MOVF   FED,F
03242:  MOVLW  24
03244:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
03246:  MOVLW  0D
03248:  ADDWF  x2B,W
0324A:  MOVWF  FE9
0324C:  MOVLW  00
0324E:  ADDWFC x2C,W
03250:  MOVWF  FEA
03252:  BTFSS  FEF.2
03254:  BRA    3292
....................    { 
....................       MACDiscardRx(); 
03256:  MOVLB  0
03258:  CALL   1736
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
0325C:  MOVLB  9
0325E:  MOVFF  93F,01
03262:  MOVFF  940,03
03266:  MOVFF  93F,946
0326A:  MOVFF  940,947
0326E:  MOVLW  23
03270:  ADDWF  x3F,W
03272:  MOVWF  FE9
03274:  MOVLW  00
03276:  ADDWFC x40,W
03278:  MOVWF  FEA
0327A:  BTFSS  FEF.0
0327C:  BRA    3282
0327E:  MOVLW  00
03280:  BRA    3284
03282:  MOVLW  01
03284:  MOVFF  947,FEA
03288:  MOVFF  946,FE9
0328C:  MOVWF  FEF
....................       return; 
0328E:  GOTO   3BDC
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
03292:  MOVLW  16
03294:  ADDWF  x3F,W
03296:  MOVWF  FE9
03298:  MOVLW  00
0329A:  ADDWFC x40,W
0329C:  MOVWF  FEA
0329E:  MOVFF  FEF,933
032A2:  MOVFF  FEC,934
032A6:  MOVFF  FEC,935
032AA:  MOVFF  FEC,936
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
032AE:  MOVLW  0E
032B0:  ADDWF  x2B,W
032B2:  MOVWF  FE9
032B4:  MOVLW  00
032B6:  ADDWFC x2C,W
032B8:  MOVWF  FEA
032BA:  MOVFF  FEC,947
032BE:  MOVF   FED,F
032C0:  MOVFF  FEF,946
032C4:  CLRF   x48
032C6:  CLRF   x49
032C8:  MOVLW  08
032CA:  ADDWF  x2B,W
032CC:  MOVWF  FE9
032CE:  MOVLW  00
032D0:  ADDWFC x2C,W
032D2:  MOVWF  FEA
032D4:  MOVFF  FEF,00
032D8:  MOVFF  FEC,01
032DC:  MOVFF  FEC,02
032E0:  MOVFF  FEC,03
032E4:  MOVF   00,W
032E6:  SUBWF  x33,W
032E8:  MOVWF  00
032EA:  MOVF   01,W
032EC:  SUBWFB x34,W
032EE:  MOVWF  01
032F0:  MOVF   02,W
032F2:  SUBWFB x35,W
032F4:  MOVWF  02
032F6:  MOVF   03,W
032F8:  SUBWFB x36,W
032FA:  MOVWF  03
032FC:  MOVF   00,W
032FE:  SUBWF  x46,F
03300:  MOVF   01,W
03302:  SUBWFB x47,F
03304:  MOVF   02,W
03306:  SUBWFB x48,F
03308:  MOVF   03,W
0330A:  SUBWFB x49,F
0330C:  MOVLW  10
0330E:  ADDWF  x3F,W
03310:  MOVWF  FE9
03312:  MOVLW  00
03314:  ADDWFC x40,W
03316:  MOVWF  FEA
03318:  MOVFF  FEC,03
0331C:  MOVF   FED,F
0331E:  MOVFF  FEF,00
03322:  MOVFF  03,01
03326:  CLRF   02
03328:  CLRF   03
0332A:  MOVF   00,W
0332C:  SUBWF  x46,W
0332E:  MOVWF  x42
03330:  MOVF   01,W
03332:  SUBWFB x47,W
03334:  MOVWF  x43
03336:  MOVF   02,W
03338:  SUBWFB x48,W
0333A:  MOVWF  x44
0333C:  MOVF   03,W
0333E:  SUBWFB x49,W
03340:  MOVWF  x45
....................    if(temp < 0) 
03342:  BTFSS  x45.7
03344:  BRA    335A
....................    { 
....................       ps->RemoteWindow = 0; 
03346:  MOVLW  14
03348:  ADDWF  x3F,W
0334A:  MOVWF  FE9
0334C:  MOVLW  00
0334E:  ADDWFC x40,W
03350:  MOVWF  FEA
03352:  CLRF   FEC
03354:  MOVF   FED,F
03356:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
03358:  BRA    336E
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
0335A:  MOVLW  14
0335C:  ADDWF  x3F,W
0335E:  MOVWF  FE9
03360:  MOVLW  00
03362:  ADDWFC x40,W
03364:  MOVWF  FEA
03366:  MOVFF  92F,FEF
0336A:  MOVFF  930,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
0336E:  MOVFF  93F,FE9
03372:  MOVFF  940,FEA
03376:  DECFSZ FEF,W
03378:  BRA    34E4
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
0337A:  MOVLW  0D
0337C:  ADDWF  x2B,W
0337E:  MOVWF  FE9
03380:  MOVLW  00
03382:  ADDWFC x2C,W
03384:  MOVWF  FEA
03386:  BTFSC  FEF.1
03388:  BRA    33AE
....................       { 
....................          MACDiscardRx(); 
0338A:  MOVLB  0
0338C:  CALL   1736
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
03390:  MOVLW  0D
03392:  MOVLB  9
03394:  ADDWF  x2B,W
03396:  MOVWF  FE9
03398:  MOVLW  00
0339A:  ADDWFC x2C,W
0339C:  MOVWF  FEA
0339E:  BTFSS  FEF.4
033A0:  BRA    33AA
....................           { 
....................             flags = RST; 
033A2:  MOVLW  04
033A4:  MOVWF  x41
....................             goto SendTCPControlPacket; 
033A6:  GOTO   3B76
....................            } 
....................  
....................          return; 
033AA:  GOTO   3BDC
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
033AE:  MOVLW  1A
033B0:  ADDWF  x3F,W
033B2:  MOVWF  01
033B4:  MOVLW  00
033B6:  ADDWFC x40,W
033B8:  MOVFF  01,946
033BC:  MOVWF  x47
033BE:  MOVLW  04
033C0:  ADDWF  x2B,W
033C2:  MOVWF  FE9
033C4:  MOVLW  00
033C6:  ADDWFC x2C,W
033C8:  MOVWF  FEA
033CA:  MOVFF  FEF,948
033CE:  MOVFF  FEC,949
033D2:  MOVFF  FEC,94A
033D6:  MOVFF  FEC,94B
033DA:  MOVF   x2D,W
033DC:  ADDWF  x48,F
033DE:  MOVF   x2E,W
033E0:  ADDWFC x49,F
033E2:  MOVLW  00
033E4:  ADDWFC x4A,F
033E6:  ADDWFC x4B,F
033E8:  MOVLW  01
033EA:  ADDWF  x48,W
033EC:  MOVWF  00
033EE:  MOVLW  00
033F0:  ADDWFC x49,W
033F2:  MOVWF  01
033F4:  MOVLW  00
033F6:  ADDWFC x4A,W
033F8:  MOVWF  02
033FA:  MOVLW  00
033FC:  ADDWFC x4B,W
033FE:  MOVFF  947,FEA
03402:  MOVFF  946,FE9
03406:  MOVFF  00,FEF
0340A:  MOVFF  01,FEC
0340E:  MOVFF  02,FEC
03412:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
03414:  MOVLW  1A
03416:  ADDWF  x3F,W
03418:  MOVWF  FE9
0341A:  MOVLW  00
0341C:  ADDWFC x40,W
0341E:  MOVWF  FEA
03420:  MOVFF  FEF,92F
03424:  MOVFF  FEC,930
03428:  MOVFF  FEC,931
0342C:  MOVFF  FEC,932
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
03430:  MOVLW  0D
03432:  ADDWF  x2B,W
03434:  MOVWF  FE9
03436:  MOVLW  00
03438:  ADDWFC x2C,W
0343A:  MOVWF  FEA
0343C:  BTFSC  FEF.4
0343E:  BRA    345A
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
03440:  MOVFF  93F,FE9
03444:  MOVFF  940,FEA
03448:  MOVLW  02
0344A:  MOVWF  FEF
....................          MACDiscardRx(); 
0344C:  MOVLB  0
0344E:  CALL   1736
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
03452:  MOVLW  12
03454:  MOVLB  9
03456:  MOVWF  x41
....................          goto SendTCPControlPacket; 
03458:  BRA    3B76
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
0345A:  MOVFF  93F,FE9
0345E:  MOVFF  940,FEA
03462:  MOVLW  03
03464:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
03466:  MOVLW  10
03468:  MOVWF  x41
....................  
....................       ps->RemoteWindow = h->Window; 
0346A:  MOVLW  14
0346C:  ADDWF  x3F,W
0346E:  MOVWF  01
03470:  MOVLW  00
03472:  ADDWFC x40,W
03474:  MOVWF  03
03476:  MOVWF  x47
03478:  MOVLW  0E
0347A:  ADDWF  x2B,W
0347C:  MOVWF  FE9
0347E:  MOVLW  00
03480:  ADDWFC x2C,W
03482:  MOVWF  FEA
03484:  MOVFF  FEC,03
03488:  MOVF   FED,F
0348A:  MOVFF  FEF,948
0348E:  MOVFF  947,FEA
03492:  MOVFF  01,FE9
03496:  MOVFF  03,FEC
0349A:  MOVF   FED,F
0349C:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
034A0:  MOVF   x2D,W
034A2:  IORWF  x2E,W
034A4:  BZ    34DA
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
034A6:  MOVLW  23
034A8:  ADDWF  x3F,W
034AA:  MOVWF  FE9
034AC:  MOVLW  00
034AE:  ADDWFC x40,W
034B0:  MOVWF  FEA
034B2:  BSF    FEF.3
....................          ps->RxCount             = len; 
034B4:  MOVLW  12
034B6:  ADDWF  x3F,W
034B8:  MOVWF  FE9
034BA:  MOVLW  00
034BC:  ADDWFC x40,W
034BE:  MOVWF  FEA
034C0:  MOVFF  92E,FEC
034C4:  MOVF   FED,F
034C6:  MOVFF  92D,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
034CA:  MOVLW  23
034CC:  ADDWF  x3F,W
034CE:  MOVWF  FE9
034D0:  MOVLW  00
034D2:  ADDWFC x40,W
034D4:  MOVWF  FEA
034D6:  BSF    FEF.2
....................       } 
034D8:  BRA    34E2
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
034DA:  MOVLB  0
034DC:  CALL   1736
034E0:  MOVLB  9
....................       } 
....................       goto SendTCPControlPacket; 
034E2:  BRA    3B76
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
034E4:  MOVFF  93F,FE9
034E8:  MOVFF  940,FEA
034EC:  MOVF   FEF,F
034EE:  BTFSS  FD8.2
034F0:  BRA    3666
....................    { 
....................       MACDiscardRx(); 
034F2:  MOVLB  0
034F4:  CALL   1736
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
034F8:  MOVLW  0D
034FA:  MOVLB  9
034FC:  ADDWF  x2B,W
034FE:  MOVWF  FE9
03500:  MOVLW  00
03502:  ADDWFC x2C,W
03504:  MOVWF  FEA
03506:  BTFSC  FEF.1
03508:  BRA    3510
....................       { 
....................          flags = RST; 
0350A:  MOVLW  04
0350C:  MOVWF  x41
....................          goto SendTCPControlPacket; 
0350E:  BRA    3B76
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
03510:  MOVLW  1A
03512:  ADDWF  x3F,W
03514:  MOVWF  01
03516:  MOVLW  00
03518:  ADDWFC x40,W
0351A:  MOVFF  01,946
0351E:  MOVWF  x47
03520:  MOVLW  04
03522:  ADDWF  x2B,W
03524:  MOVWF  FE9
03526:  MOVLW  00
03528:  ADDWFC x2C,W
0352A:  MOVWF  FEA
0352C:  MOVFF  FEF,948
03530:  MOVFF  FEC,949
03534:  MOVFF  FEC,94A
03538:  MOVFF  FEC,94B
0353C:  MOVF   x2D,W
0353E:  ADDWF  x48,F
03540:  MOVF   x2E,W
03542:  ADDWFC x49,F
03544:  MOVLW  00
03546:  ADDWFC x4A,F
03548:  ADDWFC x4B,F
0354A:  MOVLW  01
0354C:  ADDWF  x48,W
0354E:  MOVWF  00
03550:  MOVLW  00
03552:  ADDWFC x49,W
03554:  MOVWF  01
03556:  MOVLW  00
03558:  ADDWFC x4A,W
0355A:  MOVWF  02
0355C:  MOVLW  00
0355E:  ADDWFC x4B,W
03560:  MOVFF  947,FEA
03564:  MOVFF  946,FE9
03568:  MOVFF  00,FEF
0356C:  MOVFF  01,FEC
03570:  MOVFF  02,FEC
03574:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
03576:  MOVLW  14
03578:  ADDWF  x3F,W
0357A:  MOVWF  01
0357C:  MOVLW  00
0357E:  ADDWFC x40,W
03580:  MOVWF  03
03582:  MOVWF  x47
03584:  MOVLW  0E
03586:  ADDWF  x2B,W
03588:  MOVWF  FE9
0358A:  MOVLW  00
0358C:  ADDWFC x2C,W
0358E:  MOVWF  FEA
03590:  MOVFF  FEC,03
03594:  MOVF   FED,F
03596:  MOVFF  FEF,948
0359A:  MOVFF  947,FEA
0359E:  MOVFF  01,FE9
035A2:  MOVFF  03,FEC
035A6:  MOVF   FED,F
035A8:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
035AC:  MOVLW  01
035AE:  ADDWF  x3F,W
035B0:  MOVWF  01
035B2:  MOVLW  00
035B4:  ADDWFC x40,W
035B6:  MOVWF  03
035B8:  MOVFF  01,946
035BC:  MOVWF  x47
035BE:  MOVWF  FEA
035C0:  MOVFF  01,FE9
035C4:  MOVFF  92A,FE2
035C8:  MOVFF  929,FE1
035CC:  MOVLW  0A
035CE:  MOVWF  01
035D0:  MOVFF  FE6,FEE
035D4:  DECFSZ 01,F
035D6:  BRA    35D0
....................       ps->remotePort = h->SourcePort; 
035D8:  MOVLW  0D
035DA:  ADDWF  x3F,W
035DC:  MOVWF  01
035DE:  MOVLW  00
035E0:  ADDWFC x40,W
035E2:  MOVFF  92B,FE9
035E6:  MOVFF  92C,FEA
035EA:  MOVFF  FEC,03
035EE:  MOVF   FED,F
035F0:  MOVFF  FEF,948
035F4:  MOVWF  FEA
035F6:  MOVFF  01,FE9
035FA:  MOVFF  03,FEC
035FE:  MOVF   FED,F
03600:  MOVFF  948,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
03604:  MOVFF  93F,FE9
03608:  MOVFF  940,FEA
0360C:  MOVLW  02
0360E:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
03610:  MOVLW  16
03612:  ADDWF  x3F,W
03614:  MOVWF  FE9
03616:  MOVLW  00
03618:  ADDWFC x40,W
0361A:  MOVWF  FEA
0361C:  MOVFF  FEF,933
03620:  MOVFF  FEC,934
03624:  MOVFF  FEC,935
03628:  MOVFF  FEC,936
....................       ps->SND_SEQ++; 
0362C:  MOVLW  16
0362E:  ADDWF  x3F,W
03630:  MOVWF  FE9
03632:  MOVLW  00
03634:  ADDWFC x40,W
03636:  MOVWF  FEA
03638:  MOVLW  01
0363A:  ADDWF  FEE,F
0363C:  MOVLW  00
0363E:  ADDWFC FEE,F
03640:  ADDWFC FEE,F
03642:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
03644:  MOVLW  1A
03646:  ADDWF  x3F,W
03648:  MOVWF  FE9
0364A:  MOVLW  00
0364C:  ADDWFC x40,W
0364E:  MOVWF  FEA
03650:  MOVFF  FEF,92F
03654:  MOVFF  FEC,930
03658:  MOVFF  FEC,931
0365C:  MOVFF  FEC,932
....................       flags = SYN | ACK; 
03660:  MOVLW  12
03662:  MOVWF  x41
....................       goto SendTCPControlPacket; 
03664:  BRA    3B76
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
03666:  MOVLW  1A
03668:  ADDWF  x3F,W
0366A:  MOVWF  FE9
0366C:  MOVLW  00
0366E:  ADDWFC x40,W
03670:  MOVWF  FEA
03672:  MOVFF  FEF,937
03676:  MOVFF  FEC,938
0367A:  MOVFF  FEC,939
0367E:  MOVFF  FEC,93A
....................    prevSeq = ps->SND_SEQ; 
03682:  MOVLW  16
03684:  ADDWF  x3F,W
03686:  MOVWF  FE9
03688:  MOVLW  00
0368A:  ADDWFC x40,W
0368C:  MOVWF  FEA
0368E:  MOVFF  FEF,93B
03692:  MOVFF  FEC,93C
03696:  MOVFF  FEC,93D
0369A:  MOVFF  FEC,93E
....................  
....................    ack = h->SeqNumber; 
0369E:  MOVLW  04
036A0:  ADDWF  x2B,W
036A2:  MOVWF  FE9
036A4:  MOVLW  00
036A6:  ADDWFC x2C,W
036A8:  MOVWF  FEA
036AA:  MOVFF  FEF,92F
036AE:  MOVFF  FEC,930
036B2:  MOVFF  FEC,931
036B6:  MOVFF  FEC,932
....................    ack += (DWORD)len; 
036BA:  CLRF   02
036BC:  CLRF   03
036BE:  MOVF   x2D,W
036C0:  ADDWF  x2F,F
036C2:  MOVF   x2E,W
036C4:  ADDWFC x30,F
036C6:  MOVF   02,W
036C8:  ADDWFC x31,F
036CA:  MOVF   03,W
036CC:  ADDWFC x32,F
....................    seq = ps->SND_SEQ; 
036CE:  MOVLW  16
036D0:  ADDWF  x3F,W
036D2:  MOVWF  FE9
036D4:  MOVLW  00
036D6:  ADDWFC x40,W
036D8:  MOVWF  FEA
036DA:  MOVFF  FEF,933
036DE:  MOVFF  FEC,934
036E2:  MOVFF  FEC,935
036E6:  MOVFF  FEC,936
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
036EA:  MOVLW  04
036EC:  ADDWF  x2B,W
036EE:  MOVWF  FE9
036F0:  MOVLW  00
036F2:  ADDWFC x2C,W
036F4:  MOVWF  FEA
036F6:  MOVFF  FEF,946
036FA:  MOVFF  FEC,947
036FE:  MOVFF  FEC,948
03702:  MOVFF  FEC,949
03706:  MOVF   x37,W
03708:  SUBWF  x46,W
0370A:  BTFSS  FD8.2
0370C:  BRA    3B5A
0370E:  MOVF   x38,W
03710:  SUBWF  x47,W
03712:  BTFSS  FD8.2
03714:  BRA    3B5A
03716:  MOVF   x39,W
03718:  SUBWF  x48,W
0371A:  BTFSS  FD8.2
0371C:  BRA    3B5A
0371E:  MOVF   x3A,W
03720:  SUBWF  x49,W
03722:  BTFSS  FD8.2
03724:  BRA    3B5A
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
03726:  MOVFF  93F,FE9
0372A:  MOVFF  940,FEA
0372E:  MOVF   FEF,W
03730:  SUBLW  02
03732:  BNZ   37BA
....................          { 
....................             if(h->Flags.bits.flagACK) 
03734:  MOVLW  0D
03736:  ADDWF  x2B,W
03738:  MOVWF  FE9
0373A:  MOVLW  00
0373C:  ADDWFC x2C,W
0373E:  MOVWF  FEA
03740:  BTFSS  FEF.4
03742:  BRA    37B0
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
03744:  MOVLW  1A
03746:  ADDWF  x3F,W
03748:  MOVWF  FE9
0374A:  MOVLW  00
0374C:  ADDWFC x40,W
0374E:  MOVWF  FEA
03750:  MOVFF  92F,FEF
03754:  MOVFF  930,FEC
03758:  MOVFF  931,FEC
0375C:  MOVFF  932,FEC
....................                ps->smState = TCP_ESTABLISHED; 
03760:  MOVFF  93F,FE9
03764:  MOVFF  940,FEA
03768:  MOVLW  03
0376A:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
0376C:  MOVF   x2D,W
0376E:  IORWF  x2E,W
03770:  BZ    37A6
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
03772:  MOVLW  23
03774:  ADDWF  x3F,W
03776:  MOVWF  FE9
03778:  MOVLW  00
0377A:  ADDWFC x40,W
0377C:  MOVWF  FEA
0377E:  BSF    FEF.3
....................                   ps->RxCount             = len; 
03780:  MOVLW  12
03782:  ADDWF  x3F,W
03784:  MOVWF  FE9
03786:  MOVLW  00
03788:  ADDWFC x40,W
0378A:  MOVWF  FEA
0378C:  MOVFF  92E,FEC
03790:  MOVF   FED,F
03792:  MOVFF  92D,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
03796:  MOVLW  23
03798:  ADDWF  x3F,W
0379A:  MOVWF  FE9
0379C:  MOVLW  00
0379E:  ADDWFC x40,W
037A0:  MOVWF  FEA
037A2:  BSF    FEF.2
....................                } 
037A4:  BRA    37AE
....................                else 
....................                   MACDiscardRx(); 
037A6:  MOVLB  0
037A8:  CALL   1736
037AC:  MOVLB  9
....................             } 
037AE:  BRA    37B8
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
037B0:  MOVLB  0
037B2:  CALL   1736
037B6:  MOVLB  9
....................             } 
....................          } 
037B8:  BRA    3B58
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
037BA:  MOVLW  1A
037BC:  ADDWF  x3F,W
037BE:  MOVWF  FE9
037C0:  MOVLW  00
037C2:  ADDWFC x40,W
037C4:  MOVWF  FEA
037C6:  MOVFF  92F,FEF
037CA:  MOVFF  930,FEC
037CE:  MOVFF  931,FEC
037D2:  MOVFF  932,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
037D6:  MOVFF  93F,FE9
037DA:  MOVFF  940,FEA
037DE:  MOVF   FEF,W
037E0:  SUBLW  03
037E2:  BTFSS  FD8.2
037E4:  BRA    398A
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
037E6:  MOVLW  0D
037E8:  ADDWF  x2B,W
037EA:  MOVWF  FE9
037EC:  MOVLW  00
037EE:  ADDWFC x2C,W
037F0:  MOVWF  FEA
037F2:  BTFSS  FEF.4
037F4:  BRA    384C
037F6:  MOVLW  23
037F8:  ADDWF  x3F,W
037FA:  MOVWF  FE9
037FC:  MOVLW  00
037FE:  ADDWFC x40,W
03800:  MOVWF  FEA
03802:  BTFSC  FEF.1
03804:  BRA    384C
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
03806:  MOVLW  0F
03808:  ADDWF  x3F,W
0380A:  MOVWF  FE9
0380C:  MOVLW  00
0380E:  ADDWFC x40,W
03810:  MOVWF  FEA
03812:  INCFSZ FEF,W
03814:  BRA    3818
03816:  BRA    384C
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
03818:  MOVLW  0F
0381A:  ADDWF  x3F,W
0381C:  MOVWF  FE9
0381E:  MOVLW  00
03820:  ADDWFC x40,W
03822:  MOVWF  FEA
03824:  MOVFF  FEF,949
03828:  MOVLB  0
0382A:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
0382E:  MOVLW  0F
03830:  MOVLB  9
03832:  ADDWF  x3F,W
03834:  MOVWF  FE9
03836:  MOVLW  00
03838:  ADDWFC x40,W
0383A:  MOVWF  FEA
0383C:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
0383E:  MOVLW  23
03840:  ADDWF  x3F,W
03842:  MOVWF  FE9
03844:  MOVLW  00
03846:  ADDWFC x40,W
03848:  MOVWF  FEA
0384A:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
0384C:  MOVLW  0D
0384E:  ADDWF  x2B,W
03850:  MOVWF  FE9
03852:  MOVLW  00
03854:  ADDWFC x2C,W
03856:  MOVWF  FEA
03858:  BTFSS  FEF.0
0385A:  BRA    38F2
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
0385C:  MOVLW  11
0385E:  MOVWF  x41
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
03860:  MOVLW  16
03862:  ADDWF  x3F,W
03864:  MOVWF  FE9
03866:  MOVLW  00
03868:  ADDWFC x40,W
0386A:  MOVWF  FEA
0386C:  MOVFF  FEF,933
03870:  MOVFF  FEC,934
03874:  MOVFF  FEC,935
03878:  MOVFF  FEC,936
....................                   ps->SND_SEQ++; 
0387C:  MOVLW  16
0387E:  ADDWF  x3F,W
03880:  MOVWF  FE9
03882:  MOVLW  00
03884:  ADDWFC x40,W
03886:  MOVWF  FEA
03888:  MOVLW  01
0388A:  ADDWF  FEE,F
0388C:  MOVLW  00
0388E:  ADDWFC FEE,F
03890:  ADDWFC FEE,F
03892:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03894:  MOVLW  1A
03896:  ADDWF  x3F,W
03898:  MOVWF  FE9
0389A:  MOVLW  00
0389C:  ADDWFC x40,W
0389E:  MOVWF  FEA
038A0:  MOVLW  01
038A2:  ADDWF  FEF,W
038A4:  MOVWF  00
038A6:  MOVLW  00
038A8:  ADDWFC FEC,W
038AA:  MOVWF  01
038AC:  MOVLW  00
038AE:  ADDWFC FEC,W
038B0:  MOVWF  02
038B2:  MOVLW  00
038B4:  ADDWFC FEC,W
038B6:  MOVF   FED,F
038B8:  MOVF   FED,F
038BA:  MOVF   FED,F
038BC:  MOVFF  00,FEF
038C0:  MOVFF  01,FEC
038C4:  MOVFF  02,FEC
038C8:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
038CA:  MOVLW  1A
038CC:  ADDWF  x3F,W
038CE:  MOVWF  FE9
038D0:  MOVLW  00
038D2:  ADDWFC x40,W
038D4:  MOVWF  FEA
038D6:  MOVFF  FEF,92F
038DA:  MOVFF  FEC,930
038DE:  MOVFF  FEC,931
038E2:  MOVFF  FEC,932
....................                   ps->smState = TCP_LAST_ACK; 
038E6:  MOVFF  93F,FE9
038EA:  MOVFF  940,FEA
038EE:  MOVLW  09
038F0:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
038F2:  MOVF   x2D,W
038F4:  IORWF  x2E,W
038F6:  BZ    3980
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
038F8:  MOVLW  23
038FA:  ADDWF  x3F,W
038FC:  MOVWF  FE9
038FE:  MOVLW  00
03900:  ADDWFC x40,W
03902:  MOVWF  FEA
03904:  BTFSC  FEF.3
03906:  BRA    393E
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
03908:  MOVLW  23
0390A:  ADDWF  x3F,W
0390C:  MOVWF  FE9
0390E:  MOVLW  00
03910:  ADDWFC x40,W
03912:  MOVWF  FEA
03914:  BSF    FEF.3
....................                      ps->RxCount             = len; 
03916:  MOVLW  12
03918:  ADDWF  x3F,W
0391A:  MOVWF  FE9
0391C:  MOVLW  00
0391E:  ADDWFC x40,W
03920:  MOVWF  FEA
03922:  MOVFF  92E,FEC
03926:  MOVF   FED,F
03928:  MOVFF  92D,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
0392C:  MOVLW  23
0392E:  ADDWF  x3F,W
03930:  MOVWF  FE9
03932:  MOVLW  00
03934:  ADDWFC x40,W
03936:  MOVWF  FEA
03938:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
0393A:  BSF    x41.4
....................                   } 
0393C:  BRA    397E
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
0393E:  MOVLW  16
03940:  ADDWF  x3F,W
03942:  MOVWF  FE9
03944:  MOVLW  00
03946:  ADDWFC x40,W
03948:  MOVWF  FEA
0394A:  MOVFF  93B,FEF
0394E:  MOVFF  93C,FEC
03952:  MOVFF  93D,FEC
03956:  MOVFF  93E,FEC
....................                      ps->SND_ACK = prevAck; 
0395A:  MOVLW  1A
0395C:  ADDWF  x3F,W
0395E:  MOVWF  FE9
03960:  MOVLW  00
03962:  ADDWFC x40,W
03964:  MOVWF  FEA
03966:  MOVFF  937,FEF
0396A:  MOVFF  938,FEC
0396E:  MOVFF  939,FEC
03972:  MOVFF  93A,FEC
....................  
....................                      MACDiscardRx(); 
03976:  MOVLB  0
03978:  CALL   1736
0397C:  MOVLB  9
....................                   } 
....................                } 
0397E:  BRA    3988
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
03980:  MOVLB  0
03982:  CALL   1736
03986:  MOVLB  9
....................                } 
....................             } 
03988:  BRA    3B58
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
0398A:  MOVFF  93F,FE9
0398E:  MOVFF  940,FEA
03992:  MOVF   FEF,W
03994:  SUBLW  09
03996:  BNZ   39C2
....................             { 
....................                MACDiscardRx(); 
03998:  MOVLB  0
0399A:  CALL   1736
....................  
....................                if(h->Flags.bits.flagACK) 
0399E:  MOVLW  0D
039A0:  MOVLB  9
039A2:  ADDWF  x2B,W
039A4:  MOVWF  FE9
039A6:  MOVLW  00
039A8:  ADDWFC x2C,W
039AA:  MOVWF  FEA
039AC:  BTFSS  FEF.4
039AE:  BRA    39C0
....................                { 
....................                   CloseSocket(ps); 
039B0:  MOVFF  940,947
039B4:  MOVFF  93F,946
039B8:  MOVLB  0
039BA:  CALL   2B6C
039BE:  MOVLB  9
....................                } 
....................             } 
039C0:  BRA    3B58
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
039C2:  MOVFF  93F,FE9
039C6:  MOVFF  940,FEA
039CA:  MOVF   FEF,W
039CC:  SUBLW  04
039CE:  BNZ   3A94
....................             { 
....................                MACDiscardRx(); 
039D0:  MOVLB  0
039D2:  CALL   1736
....................  
....................                if(h->Flags.bits.flagFIN) 
039D6:  MOVLW  0D
039D8:  MOVLB  9
039DA:  ADDWF  x2B,W
039DC:  MOVWF  FE9
039DE:  MOVLW  00
039E0:  ADDWFC x2C,W
039E2:  MOVWF  FEA
039E4:  BTFSS  FEF.0
039E6:  BRA    3A72
....................                { 
....................                   flags = ACK; 
039E8:  MOVLW  10
039EA:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
039EC:  MOVLW  1A
039EE:  ADDWF  x3F,W
039F0:  MOVWF  FE9
039F2:  MOVLW  00
039F4:  ADDWFC x40,W
039F6:  MOVWF  FEA
039F8:  MOVLW  01
039FA:  ADDWF  FEF,W
039FC:  MOVWF  00
039FE:  MOVLW  00
03A00:  ADDWFC FEC,W
03A02:  MOVWF  01
03A04:  MOVLW  00
03A06:  ADDWFC FEC,W
03A08:  MOVWF  02
03A0A:  MOVLW  00
03A0C:  ADDWFC FEC,W
03A0E:  MOVF   FED,F
03A10:  MOVF   FED,F
03A12:  MOVF   FED,F
03A14:  MOVFF  00,FEF
03A18:  MOVFF  01,FEC
03A1C:  MOVFF  02,FEC
03A20:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03A22:  MOVLW  1A
03A24:  ADDWF  x3F,W
03A26:  MOVWF  FE9
03A28:  MOVLW  00
03A2A:  ADDWFC x40,W
03A2C:  MOVWF  FEA
03A2E:  MOVFF  FEF,92F
03A32:  MOVFF  FEC,930
03A36:  MOVFF  FEC,931
03A3A:  MOVFF  FEC,932
....................                   if(h->Flags.bits.flagACK) 
03A3E:  MOVLW  0D
03A40:  ADDWF  x2B,W
03A42:  MOVWF  FE9
03A44:  MOVLW  00
03A46:  ADDWFC x2C,W
03A48:  MOVWF  FEA
03A4A:  BTFSS  FEF.4
03A4C:  BRA    3A60
....................                   { 
....................                      CloseSocket(ps); 
03A4E:  MOVFF  940,947
03A52:  MOVFF  93F,946
03A56:  MOVLB  0
03A58:  CALL   2B6C
....................                   } 
03A5C:  BRA    3A6E
03A5E:  MOVLB  9
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
03A60:  MOVFF  93F,FE9
03A64:  MOVFF  940,FEA
03A68:  MOVLW  06
03A6A:  MOVWF  FEF
03A6C:  MOVLB  0
....................                   } 
....................                } 
03A6E:  BRA    3A90
03A70:  MOVLB  9
....................                else if(h->Flags.bits.flagACK) 
03A72:  MOVLW  0D
03A74:  ADDWF  x2B,W
03A76:  MOVWF  FE9
03A78:  MOVLW  00
03A7A:  ADDWFC x2C,W
03A7C:  MOVWF  FEA
03A7E:  BTFSS  FEF.4
03A80:  BRA    3A8E
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
03A82:  MOVFF  93F,FE9
03A86:  MOVFF  940,FEA
03A8A:  MOVLW  05
03A8C:  MOVWF  FEF
03A8E:  MOVLB  0
....................                } 
....................             } 
03A90:  BRA    3B56
03A92:  MOVLB  9
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
03A94:  MOVFF  93F,FE9
03A98:  MOVFF  940,FEA
03A9C:  MOVF   FEF,W
03A9E:  SUBLW  05
03AA0:  BNZ   3B22
....................             { 
....................                MACDiscardRx(); 
03AA2:  MOVLB  0
03AA4:  CALL   1736
....................  
....................                if(h->Flags.bits.flagFIN) 
03AA8:  MOVLW  0D
03AAA:  MOVLB  9
03AAC:  ADDWF  x2B,W
03AAE:  MOVWF  FE9
03AB0:  MOVLW  00
03AB2:  ADDWFC x2C,W
03AB4:  MOVWF  FEA
03AB6:  BTFSS  FEF.0
03AB8:  BRA    3B20
....................                { 
....................                   flags = ACK; 
03ABA:  MOVLW  10
03ABC:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03ABE:  MOVLW  1A
03AC0:  ADDWF  x3F,W
03AC2:  MOVWF  FE9
03AC4:  MOVLW  00
03AC6:  ADDWFC x40,W
03AC8:  MOVWF  FEA
03ACA:  MOVLW  01
03ACC:  ADDWF  FEF,W
03ACE:  MOVWF  00
03AD0:  MOVLW  00
03AD2:  ADDWFC FEC,W
03AD4:  MOVWF  01
03AD6:  MOVLW  00
03AD8:  ADDWFC FEC,W
03ADA:  MOVWF  02
03ADC:  MOVLW  00
03ADE:  ADDWFC FEC,W
03AE0:  MOVF   FED,F
03AE2:  MOVF   FED,F
03AE4:  MOVF   FED,F
03AE6:  MOVFF  00,FEF
03AEA:  MOVFF  01,FEC
03AEE:  MOVFF  02,FEC
03AF2:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03AF4:  MOVLW  1A
03AF6:  ADDWF  x3F,W
03AF8:  MOVWF  FE9
03AFA:  MOVLW  00
03AFC:  ADDWFC x40,W
03AFE:  MOVWF  FEA
03B00:  MOVFF  FEF,92F
03B04:  MOVFF  FEC,930
03B08:  MOVFF  FEC,931
03B0C:  MOVFF  FEC,932
....................                   CloseSocket(ps); 
03B10:  MOVFF  940,947
03B14:  MOVFF  93F,946
03B18:  MOVLB  0
03B1A:  CALL   2B6C
03B1E:  MOVLB  9
....................                } 
....................             } 
03B20:  BRA    3B58
....................             else if ( ps->smState == TCP_CLOSING ) 
03B22:  MOVFF  93F,FE9
03B26:  MOVFF  940,FEA
03B2A:  MOVF   FEF,W
03B2C:  SUBLW  06
03B2E:  BNZ   3B58
....................             { 
....................                MACDiscardRx(); 
03B30:  MOVLB  0
03B32:  CALL   1736
....................  
....................                if ( h->Flags.bits.flagACK ) 
03B36:  MOVLW  0D
03B38:  MOVLB  9
03B3A:  ADDWF  x2B,W
03B3C:  MOVWF  FE9
03B3E:  MOVLW  00
03B40:  ADDWFC x2C,W
03B42:  MOVWF  FEA
03B44:  BTFSS  FEF.4
03B46:  BRA    3B58
....................                { 
....................                   CloseSocket(ps); 
03B48:  MOVFF  940,947
03B4C:  MOVFF  93F,946
03B50:  MOVLB  0
03B52:  CALL   2B6C
03B56:  MOVLB  9
....................                } 
....................             } 
....................          } 
....................       } 
03B58:  BRA    3B76
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
03B5A:  MOVLB  0
03B5C:  CALL   1736
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
03B60:  MOVLW  10
03B62:  MOVLB  9
03B64:  MOVWF  x41
....................          ack = prevAck; 
03B66:  MOVFF  93A,932
03B6A:  MOVFF  939,931
03B6E:  MOVFF  938,930
03B72:  MOVFF  937,92F
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
03B76:  MOVF   x41,F
03B78:  BZ    3BDC
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
03B7A:  MOVLW  02
03B7C:  ADDWF  x2B,W
03B7E:  MOVWF  FE9
03B80:  MOVLW  00
03B82:  ADDWFC x2C,W
03B84:  MOVWF  FEA
03B86:  MOVFF  FEC,94D
03B8A:  MOVF   FED,F
03B8C:  MOVFF  FEF,94C
03B90:  MOVFF  92B,FE9
03B94:  MOVFF  92C,FEA
03B98:  MOVFF  FEC,94F
03B9C:  MOVF   FED,F
03B9E:  MOVFF  FEF,94E
03BA2:  MOVFF  92A,94B
03BA6:  MOVFF  929,94A
03BAA:  MOVFF  936,953
03BAE:  MOVFF  935,952
03BB2:  MOVFF  934,951
03BB6:  MOVFF  933,950
03BBA:  MOVFF  932,957
03BBE:  MOVFF  931,956
03BC2:  MOVFF  930,955
03BC6:  MOVFF  92F,954
03BCA:  MOVFF  941,958
03BCE:  SETF   x59
03BD0:  CLRF   x5B
03BD2:  CLRF   x5A
03BD4:  MOVLB  0
03BD6:  CALL   2FA8
03BDA:  MOVLB  9
....................    } 
03BDC:  MOVLB  0
03BDE:  GOTO   3D60 (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
03E3A:  MOVLW  09
03E3C:  MOVLB  9
03E3E:  MOVWF  x55
03E40:  MOVLW  08
03E42:  MOVWF  x54
03E44:  MOVFF  955,991
03E48:  MOVWF  x90
03E4A:  CLRF   x93
03E4C:  MOVWF  x92
03E4E:  MOVLB  0
03E50:  CALL   17AC
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
03E54:  MOVLB  9
03E56:  CLRF   x53
03E58:  CLRF   x52
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
03E5A:  MOVFF  903,03
03E5E:  MOVFF  902,FE9
03E62:  MOVFF  903,FEA
03E66:  MOVFF  FEF,959
03E6A:  CLRF   x58
03E6C:  MOVLW  14
03E6E:  MOVWF  x57
03E70:  CLRF   x5A
03E72:  MOVLB  0
03E74:  CALL   2176
03E78:  MOVFF  02,951
03E7C:  MOVFF  01,950
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
03E80:  MOVLB  9
03E82:  MOVFF  902,FE9
03E86:  MOVFF  903,FEA
03E8A:  MOVLW  08
03E8C:  SUBWF  FEF,W
03E8E:  MOVWF  FEF
....................     MACGetArray(data, *len); 
03E90:  MOVFF  903,03
03E94:  MOVFF  902,FE9
03E98:  MOVFF  903,FEA
03E9C:  MOVFF  FEF,992
03EA0:  MOVFF  901,991
03EA4:  MOVFF  900,990
03EA8:  CLRF   x93
03EAA:  MOVLB  0
03EAC:  CALL   17AC
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
03EB0:  MOVLW  09
03EB2:  MOVLB  9
03EB4:  MOVWF  x57
03EB6:  MOVLW  08
03EB8:  MOVWF  x56
03EBA:  MOVLB  0
03EBC:  RCALL  3D72
....................  
....................     *code = packet.Type; 
03EBE:  MOVLB  8
03EC0:  MOVFF  8FE,FE9
03EC4:  MOVFF  8FF,FEA
03EC8:  MOVFF  908,FEF
....................     *id = packet.Identifier; 
03ECC:  MOVLB  9
03ECE:  MOVFF  904,FE9
03ED2:  MOVFF  905,FEA
03ED6:  MOVFF  90D,FEC
03EDA:  MOVF   FED,F
03EDC:  MOVFF  90C,FEF
....................     *seq = packet.SequenceNumber; 
03EE0:  MOVFF  906,FE9
03EE4:  MOVFF  907,FEA
03EE8:  MOVFF  90F,FEC
03EEC:  MOVF   FED,F
03EEE:  MOVFF  90E,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
03EF2:  MOVF   x52,W
03EF4:  SUBWF  x50,W
03EF6:  BNZ   3EFE
03EF8:  MOVF   x53,W
03EFA:  SUBWF  x51,W
03EFC:  BZ    3F02
03EFE:  MOVLW  00
03F00:  BRA    3F04
03F02:  MOVLW  01
03F04:  MOVWF  01
03F06:  MOVLB  0
03F08:  GOTO   4610 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
03F0C:  MOVLW  01
03F0E:  MOVLB  9
03F10:  MOVWF  x82
03F12:  MOVLB  0
03F14:  CALL   1B28
03F18:  MOVFF  01,950
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
03F1C:  MOVLB  9
03F1E:  INCFSZ x50,W
03F20:  BRA    3F24
....................       return; 
03F22:  BRA    401C
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
03F24:  MOVFF  950,99B
03F28:  CLRF   x9D
03F2A:  MOVLW  14
03F2C:  MOVWF  x9C
03F2E:  MOVLB  0
03F30:  CALL   1B50
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
03F34:  CLRF   03
03F36:  MOVLB  9
03F38:  MOVF   x01,W
03F3A:  ADDLW  08
03F3C:  MOVWF  x4E
03F3E:  MOVLW  00
03F40:  ADDWFC 03,W
03F42:  MOVWF  x4F
....................  
....................     packet.Code             = 0; 
03F44:  CLRF   x07
....................     packet.Type             = code; 
03F46:  MOVFF  8FE,906
....................     packet.Checksum         = 0; 
03F4A:  CLRF   x09
03F4C:  CLRF   x08
....................     packet.Identifier       = id; 
03F4E:  MOVFF  903,90B
03F52:  MOVFF  902,90A
....................     packet.SequenceNumber   = seq; 
03F56:  MOVFF  905,90D
03F5A:  MOVFF  904,90C
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
03F5E:  MOVLW  09
03F60:  MOVWF  FEA
03F62:  MOVLW  0E
03F64:  MOVWF  FE9
03F66:  MOVFF  900,FE2
03F6A:  MOVFF  8FF,FE1
03F6E:  MOVF   x01,W
03F70:  MOVWF  01
03F72:  BZ    3F7C
03F74:  MOVFF  FE6,FEE
03F78:  DECFSZ 01,F
03F7A:  BRA    3F74
....................  
....................     SwapICMPPacket(&packet); 
03F7C:  MOVLW  09
03F7E:  MOVWF  x57
03F80:  MOVLW  06
03F82:  MOVWF  x56
03F84:  MOVLB  0
03F86:  RCALL  3D72
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
03F88:  MOVLW  08
03F8A:  MOVLB  9
03F8C:  ADDWF  x01,W
03F8E:  CLRF   x52
03F90:  MOVWF  x51
03F92:  MOVFF  8FD,983
03F96:  MOVFF  8FC,982
03F9A:  MOVLW  01
03F9C:  MOVWF  x84
03F9E:  MOVFF  952,986
03FA2:  MOVFF  951,985
03FA6:  MOVLB  0
03FA8:  CALL   2E82
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
03FAC:  MOVLW  09
03FAE:  MOVLB  9
03FB0:  MOVWF  x52
03FB2:  MOVLW  06
03FB4:  MOVWF  x51
03FB6:  MOVFF  952,9A7
03FBA:  MOVWF  xA6
03FBC:  MOVFF  94F,9A9
03FC0:  MOVFF  94E,9A8
03FC4:  MOVLB  0
03FC6:  CALL   1C0C
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
03FCA:  MOVLB  9
03FCC:  CLRF   x9C
03FCE:  MOVLW  14
03FD0:  MOVWF  x9B
03FD2:  MOVFF  94F,99E
03FD6:  MOVFF  94E,99D
03FDA:  MOVLB  0
03FDC:  CALL   2DAA
03FE0:  MOVFF  02,909
03FE4:  MOVFF  01,908
....................    IPSetTxBuffer(MyTxBuffer, 2); 
03FE8:  MOVFF  950,99B
03FEC:  MOVLB  9
03FEE:  CLRF   x9D
03FF0:  MOVLW  16
03FF2:  MOVWF  x9C
03FF4:  MOVLB  0
03FF6:  CALL   1B50
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
03FFA:  MOVLW  09
03FFC:  MOVLB  9
03FFE:  MOVWF  x52
04000:  MOVLW  08
04002:  MOVWF  x51
04004:  MOVFF  952,9A7
04008:  MOVWF  xA6
0400A:  CLRF   xA9
0400C:  MOVLW  02
0400E:  MOVWF  xA8
04010:  MOVLB  0
04012:  CALL   1C0C
.................... #endif 
....................  
....................  
....................     MACFlush(); 
04016:  CALL   1D24
0401A:  MOVLB  9
0401C:  MOVLB  0
0401E:  GOTO   466C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
03D72:  MOVLW  04
03D74:  MOVLB  9
03D76:  ADDWF  x56,W
03D78:  MOVWF  01
03D7A:  MOVLW  00
03D7C:  ADDWFC x57,W
03D7E:  MOVWF  03
03D80:  MOVFF  01,958
03D84:  MOVWF  x59
03D86:  MOVLW  04
03D88:  ADDWF  x56,W
03D8A:  MOVWF  FE9
03D8C:  MOVLW  00
03D8E:  ADDWFC x57,W
03D90:  MOVWF  FEA
03D92:  MOVFF  FEC,9A2
03D96:  MOVF   FED,F
03D98:  MOVFF  FEF,9A1
03D9C:  MOVLB  0
03D9E:  CALL   1810
03DA2:  MOVFF  959,FEA
03DA6:  MOVFF  958,FE9
03DAA:  MOVFF  02,FEC
03DAE:  MOVF   FED,F
03DB0:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
03DB4:  MOVLW  06
03DB6:  MOVLB  9
03DB8:  ADDWF  x56,W
03DBA:  MOVWF  01
03DBC:  MOVLW  00
03DBE:  ADDWFC x57,W
03DC0:  MOVWF  03
03DC2:  MOVFF  01,958
03DC6:  MOVWF  x59
03DC8:  MOVLW  06
03DCA:  ADDWF  x56,W
03DCC:  MOVWF  FE9
03DCE:  MOVLW  00
03DD0:  ADDWFC x57,W
03DD2:  MOVWF  FEA
03DD4:  MOVFF  FEC,9A2
03DD8:  MOVF   FED,F
03DDA:  MOVFF  FEF,9A1
03DDE:  MOVLB  0
03DE0:  CALL   1810
03DE4:  MOVFF  959,FEA
03DE8:  MOVFF  958,FE9
03DEC:  MOVFF  02,FEC
03DF0:  MOVF   FED,F
03DF2:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
03DF6:  MOVLW  02
03DF8:  MOVLB  9
03DFA:  ADDWF  x56,W
03DFC:  MOVWF  01
03DFE:  MOVLW  00
03E00:  ADDWFC x57,W
03E02:  MOVWF  03
03E04:  MOVFF  01,958
03E08:  MOVWF  x59
03E0A:  MOVLW  02
03E0C:  ADDWF  x56,W
03E0E:  MOVWF  FE9
03E10:  MOVLW  00
03E12:  ADDWFC x57,W
03E14:  MOVWF  FEA
03E16:  MOVFF  FEC,9A2
03E1A:  MOVF   FED,F
03E1C:  MOVFF  FEF,9A1
03E20:  MOVLB  0
03E22:  CALL   1810
03E26:  MOVFF  959,FEA
03E2A:  MOVFF  958,FE9
03E2E:  MOVFF  02,FEC
03E32:  MOVF   FED,F
03E34:  MOVFF  01,FEF
03E38:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
00F9C:  MOVLB  3
00F9E:  BCF    x90.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
00FA0:  MOVLB  8
00FA2:  SETF   x85
....................     Cache.MACAddr.v[1] = 0xff; 
00FA4:  SETF   x86
....................     Cache.MACAddr.v[2] = 0xff; 
00FA6:  SETF   x87
....................     Cache.MACAddr.v[3] = 0xff; 
00FA8:  SETF   x88
....................     Cache.MACAddr.v[4] = 0xff; 
00FAA:  SETF   x89
....................     Cache.MACAddr.v[5] = 0xff; 
00FAC:  SETF   x8A
....................  
....................     Cache.IPAddr.Val = 0x0; 
00FAE:  CLRF   x8E
00FB0:  CLRF   x8D
00FB2:  CLRF   x8C
00FB4:  CLRF   x8B
00FB6:  MOVLB  0
00FB8:  GOTO   1278 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
020D8:  MOVLW  00
020DA:  MOVLB  3
020DC:  BTFSC  x90.1
020DE:  MOVLW  01
020E0:  XORLW  00
020E2:  MOVLB  0
020E4:  BZ    20E8
020E6:  BRA    2148
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
020E8:  MOVLW  08
020EA:  MOVLB  9
020EC:  MOVWF  x08
020EE:  MOVLW  FC
020F0:  MOVWF  x07
020F2:  MOVLW  09
020F4:  MOVWF  x0A
020F6:  MOVLW  06
020F8:  MOVWF  x09
020FA:  MOVLB  0
020FC:  BRA    1A30
020FE:  MOVF   01,F
02100:  BNZ   2104
....................             break; 
02102:  BRA    216E
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
02104:  CALL   1736
....................  
....................         if ( opCode == ARP_REPLY ) 
02108:  MOVLB  9
0210A:  MOVF   x06,F
0210C:  BNZ   2142
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
0210E:  MOVLW  08
02110:  MOVWF  FEA
02112:  MOVLW  85
02114:  MOVWF  FE9
02116:  MOVLW  08
02118:  MOVWF  FE2
0211A:  MOVLW  FC
0211C:  MOVWF  FE1
0211E:  MOVLW  06
02120:  MOVWF  01
02122:  MOVFF  FE6,FEE
02126:  DECFSZ 01,F
02128:  BRA    2122
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
0212A:  MOVFF  905,88E
0212E:  MOVFF  904,88D
02132:  MOVFF  903,88C
02136:  MOVFF  902,88B
....................             break; 
0213A:  MOVLB  0
0213C:  BRA    216E
....................         } 
0213E:  BRA    2148
02140:  MOVLB  9
....................         else 
....................             smARP = SM_ARP_REPLY; 
02142:  MOVLB  3
02144:  BSF    x90.1
02146:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
02148:  MOVLW  08
0214A:  MOVLB  9
0214C:  MOVWF  x08
0214E:  MOVLW  FC
02150:  MOVWF  x07
02152:  CLRF   x09
02154:  MOVLB  0
02156:  RCALL  1F54
02158:  MOVF   01,F
0215A:  BZ    2164
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
0215C:  MOVLB  3
0215E:  BCF    x90.1
.................... 		} 
02160:  BRA    216C
02162:  MOVLB  0
....................         else 
....................             return FALSE; 
02164:  MOVLW  00
02166:  MOVWF  01
02168:  BRA    2172
0216A:  MOVLB  3
....................         break; 
0216C:  MOVLB  0
....................  
....................     } 
....................     return TRUE; 
0216E:  MOVLW  01
02170:  MOVWF  01
02172:  GOTO   452E (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
046AA:  MOVLB  8
046AC:  MOVFF  8F9,FE9
046B0:  MOVFF  8FA,FEA
046B4:  MOVFF  FEF,901
046B8:  MOVFF  FEC,902
046BC:  MOVFF  FEC,903
046C0:  MOVFF  FEC,904
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
046C4:  MOVLW  08
046C6:  MOVLB  9
046C8:  MOVWF  x08
046CA:  MOVLW  FB
046CC:  MOVWF  x07
046CE:  MOVLW  01
046D0:  MOVWF  x09
046D2:  MOVLB  0
046D4:  CALL   1F54
046D8:  GOTO   537E (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
046DC:  MOVLB  8
046DE:  MOVFF  8F9,FE9
046E2:  MOVFF  8FA,FEA
046E6:  MOVFF  FEF,00
046EA:  MOVFF  FEC,01
046EE:  MOVFF  FEC,02
046F2:  MOVFF  FEC,03
046F6:  MOVF   00,W
046F8:  SUBWF  x8B,W
046FA:  BNZ   470E
046FC:  MOVF   01,W
046FE:  SUBWF  x8C,W
04700:  BNZ   470E
04702:  MOVF   02,W
04704:  SUBWF  x8D,W
04706:  BNZ   470E
04708:  MOVF   03,W
0470A:  SUBWF  x8E,W
0470C:  BZ    4736
0470E:  MOVLB  3
04710:  MOVF   x5E,W
04712:  MOVLB  8
04714:  SUBWF  x8B,W
04716:  BNZ   475C
04718:  MOVLB  3
0471A:  MOVF   x5F,W
0471C:  MOVLB  8
0471E:  SUBWF  x8C,W
04720:  BNZ   475C
04722:  MOVLB  3
04724:  MOVF   x60,W
04726:  MOVLB  8
04728:  SUBWF  x8D,W
0472A:  BNZ   475C
0472C:  MOVLB  3
0472E:  MOVF   x61,W
04730:  MOVLB  8
04732:  SUBWF  x8E,W
04734:  BNZ   475C
....................     { 
....................         *MACAddr = Cache.MACAddr; 
04736:  MOVFF  8FC,03
0473A:  MOVFF  8FB,FE9
0473E:  MOVFF  8FC,FEA
04742:  MOVLW  08
04744:  MOVWF  FE2
04746:  MOVLW  85
04748:  MOVWF  FE1
0474A:  MOVLW  06
0474C:  MOVWF  01
0474E:  MOVFF  FE6,FEE
04752:  DECFSZ 01,F
04754:  BRA    474E
....................         return TRUE; 
04756:  MOVLW  01
04758:  MOVWF  01
0475A:  BRA    4760
....................     } 
....................     return FALSE; 
0475C:  MOVLW  00
0475E:  MOVWF  01
04760:  MOVLB  0
04762:  GOTO   53AA (RETURN)
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
01A30:  MOVLW  09
01A32:  MOVLB  9
01A34:  MOVWF  x91
01A36:  MOVLW  0B
01A38:  MOVWF  x90
01A3A:  CLRF   x93
01A3C:  MOVLW  1C
01A3E:  MOVWF  x92
01A40:  MOVLB  0
01A42:  RCALL  17AC
....................  
....................     MACDiscardRx(); 
01A44:  RCALL  1736
....................  
....................     SwapARPPacket(&packet); 
01A46:  MOVLW  09
01A48:  MOVLB  9
01A4A:  MOVWF  x28
01A4C:  MOVLW  0B
01A4E:  MOVWF  x27
01A50:  MOVLB  0
01A52:  RCALL  1974
....................  
....................    debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
01A54:  MOVLB  9
01A56:  DECFSZ x0B,W
01A58:  BRA    1A6A
01A5A:  MOVF   x0C,F
01A5C:  BNZ   1A6A
01A5E:  MOVF   x0F,W
01A60:  SUBLW  06
01A62:  BNZ   1A6A
01A64:  MOVF   x10,W
01A66:  SUBLW  04
01A68:  BZ    1A70
....................          return FALSE; 
01A6A:  MOVLW  00
01A6C:  MOVWF  01
01A6E:  BRA    1B22
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
01A70:  MOVF   x11,W
01A72:  SUBLW  02
01A74:  BNZ   1A8A
01A76:  MOVF   x12,F
01A78:  BNZ   1A8A
....................         *opCode = ARP_REPLY; 
01A7A:  MOVFF  90A,03
01A7E:  MOVFF  909,FE9
01A82:  MOVFF  90A,FEA
01A86:  CLRF   FEF
01A88:  BRA    1AB6
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
01A8A:  DECFSZ x11,W
01A8C:  BRA    1AA4
01A8E:  MOVF   x12,F
01A90:  BNZ   1AA4
....................         *opCode = ARP_REQUEST; 
01A92:  MOVFF  90A,03
01A96:  MOVFF  909,FE9
01A9A:  MOVFF  90A,FEA
01A9E:  MOVLW  01
01AA0:  MOVWF  FEF
01AA2:  BRA    1AB6
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
01AA4:  MOVFF  909,FE9
01AA8:  MOVFF  90A,FEA
01AAC:  MOVLW  02
01AAE:  MOVWF  FEF
....................         return FALSE; 
01AB0:  MOVLW  00
01AB2:  MOVWF  01
01AB4:  BRA    1B22
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
01AB6:  MOVLB  3
01AB8:  MOVF   x50,W
01ABA:  MOVLB  9
01ABC:  SUBWF  x23,W
01ABE:  BNZ   1B1E
01AC0:  MOVLB  3
01AC2:  MOVF   x51,W
01AC4:  MOVLB  9
01AC6:  SUBWF  x24,W
01AC8:  BNZ   1B1E
01ACA:  MOVLB  3
01ACC:  MOVF   x52,W
01ACE:  MOVLB  9
01AD0:  SUBWF  x25,W
01AD2:  BNZ   1B1E
01AD4:  MOVLB  3
01AD6:  MOVF   x53,W
01AD8:  MOVLB  9
01ADA:  SUBWF  x26,W
01ADC:  BNZ   1B1E
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
01ADE:  MOVFF  907,FE9
01AE2:  MOVFF  908,FEA
01AE6:  MOVLW  09
01AE8:  MOVWF  FE2
01AEA:  MOVLW  13
01AEC:  MOVWF  FE1
01AEE:  MOVLW  06
01AF0:  MOVWF  01
01AF2:  MOVFF  FE6,FEE
01AF6:  DECFSZ 01,F
01AF8:  BRA    1AF2
....................         remote->IPAddr      = packet.SenderIPAddr; 
01AFA:  MOVLW  06
01AFC:  ADDWF  x07,W
01AFE:  MOVWF  FE9
01B00:  MOVLW  00
01B02:  ADDWFC x08,W
01B04:  MOVWF  FEA
01B06:  MOVFF  919,FEF
01B0A:  MOVFF  91A,FEC
01B0E:  MOVFF  91B,FEC
01B12:  MOVFF  91C,FEC
....................         return TRUE; 
01B16:  MOVLW  01
01B18:  MOVWF  01
01B1A:  BRA    1B22
....................     } 
01B1C:  BRA    1B22
....................     else 
....................         return FALSE; 
01B1E:  MOVLW  00
01B20:  MOVWF  01
01B22:  MOVLB  0
01B24:  GOTO   20FE (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
01F54:  MOVLW  01
01F56:  MOVLB  9
01F58:  MOVWF  x82
01F5A:  MOVLB  0
01F5C:  RCALL  1B28
01F5E:  MOVFF  01,926
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
01F62:  MOVLB  9
01F64:  INCFSZ x26,W
01F66:  BRA    1F6E
....................       return FALSE; 
01F68:  MOVLW  00
01F6A:  MOVWF  01
01F6C:  BRA    20D4
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
01F6E:  MOVFF  926,99B
01F72:  CLRF   x9D
01F74:  CLRF   x9C
01F76:  MOVLB  0
01F78:  RCALL  1B50
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
01F7A:  MOVLB  9
01F7C:  CLRF   x0B
01F7E:  MOVLW  01
01F80:  MOVWF  x0A
....................     packet.Protocol                 = ARP_IP; 
01F82:  MOVLW  08
01F84:  MOVWF  x0D
01F86:  CLRF   x0C
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
01F88:  MOVLW  06
01F8A:  MOVWF  x0E
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
01F8C:  MOVLW  04
01F8E:  MOVWF  x0F
....................  
....................     if ( opCode == ARP_REQUEST ) 
01F90:  DECFSZ x09,W
01F92:  BRA    1FA8
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
01F94:  CLRF   x11
01F96:  MOVLW  01
01F98:  MOVWF  x10
....................         packet.TargetMACAddr.v[0]   = 0xff; 
01F9A:  SETF   x1C
....................         packet.TargetMACAddr.v[1]   = 0xff; 
01F9C:  SETF   x1D
....................         packet.TargetMACAddr.v[2]   = 0xff; 
01F9E:  SETF   x1E
....................         packet.TargetMACAddr.v[3]   = 0xff; 
01FA0:  SETF   x1F
....................         packet.TargetMACAddr.v[4]   = 0xff; 
01FA2:  SETF   x20
....................         packet.TargetMACAddr.v[5]   = 0xff; 
01FA4:  SETF   x21
....................     } 
01FA6:  BRA    1FCA
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
01FA8:  CLRF   x11
01FAA:  MOVLW  02
01FAC:  MOVWF  x10
....................         packet.TargetMACAddr        = remote->MACAddr; 
01FAE:  MOVFF  907,FE1
01FB2:  MOVFF  908,FE2
01FB6:  MOVLW  09
01FB8:  MOVWF  FEA
01FBA:  MOVLW  1C
01FBC:  MOVWF  FE9
01FBE:  MOVLW  06
01FC0:  MOVWF  01
01FC2:  MOVFF  FE6,FEE
01FC6:  DECFSZ 01,F
01FC8:  BRA    1FC2
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
01FCA:  MOVLW  09
01FCC:  MOVWF  FEA
01FCE:  MOVLW  12
01FD0:  MOVWF  FE9
01FD2:  MOVLW  03
01FD4:  MOVWF  FE2
01FD6:  MOVLW  54
01FD8:  MOVWF  FE1
01FDA:  MOVLW  06
01FDC:  MOVWF  01
01FDE:  MOVFF  FE6,FEE
01FE2:  DECFSZ 01,F
01FE4:  BRA    1FDE
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
01FE6:  MOVFF  353,91B
01FEA:  MOVFF  352,91A
01FEE:  MOVFF  351,919
01FF2:  MOVFF  350,918
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
01FF6:  MOVLW  06
01FF8:  ADDWF  x07,W
01FFA:  MOVWF  FE9
01FFC:  MOVLW  00
01FFE:  ADDWFC x08,W
02000:  MOVWF  FEA
02002:  MOVFF  FEF,00
02006:  MOVFF  FEC,01
0200A:  MOVFF  FEC,02
0200E:  MOVFF  FEC,03
02012:  MOVF   00,W
02014:  XORWF  x18,W
02016:  MOVWF  x27
02018:  MOVF   01,W
0201A:  XORWF  x19,W
0201C:  MOVWF  x28
0201E:  MOVF   02,W
02020:  XORWF  x1A,W
02022:  MOVWF  x29
02024:  MOVF   03,W
02026:  XORWF  x1B,W
02028:  MOVWF  x2A
0202A:  MOVF   x27,W
0202C:  MOVLB  3
0202E:  ANDWF  x5A,W
02030:  MOVWF  00
02032:  MOVLB  9
02034:  MOVF   x28,W
02036:  MOVLB  3
02038:  ANDWF  x5B,W
0203A:  MOVWF  01
0203C:  MOVLB  9
0203E:  MOVF   x29,W
02040:  MOVLB  3
02042:  ANDWF  x5C,W
02044:  MOVWF  02
02046:  MOVLB  9
02048:  MOVF   x2A,W
0204A:  MOVLB  3
0204C:  ANDWF  x5D,W
0204E:  MOVWF  03
02050:  MOVF   00,F
02052:  BNZ   2060
02054:  MOVF   01,F
02056:  BNZ   2060
02058:  MOVF   02,F
0205A:  BNZ   2060
0205C:  MOVF   03,F
0205E:  BZ    2072
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
02060:  MOVFF  361,925
02064:  MOVFF  360,924
02068:  MOVFF  35F,923
0206C:  MOVFF  35E,922
....................     } 
02070:  BRA    2092
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
02072:  MOVLW  06
02074:  MOVLB  9
02076:  ADDWF  x07,W
02078:  MOVWF  FE9
0207A:  MOVLW  00
0207C:  ADDWFC x08,W
0207E:  MOVWF  FEA
02080:  MOVFF  FEF,922
02084:  MOVFF  FEC,923
02088:  MOVFF  FEC,924
0208C:  MOVFF  FEC,925
02090:  MOVLB  3
....................  
....................     SwapARPPacket(&packet); 
02092:  MOVLW  09
02094:  MOVLB  9
02096:  MOVWF  x28
02098:  MOVLW  0A
0209A:  MOVWF  x27
0209C:  MOVLB  0
0209E:  RCALL  1974
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
020A0:  MOVLW  09
020A2:  MOVLB  9
020A4:  MOVWF  xA0
020A6:  MOVLW  1C
020A8:  MOVWF  x9F
020AA:  MOVLW  06
020AC:  MOVWF  xA1
020AE:  CLRF   xA3
020B0:  MOVLW  1C
020B2:  MOVWF  xA2
020B4:  MOVLB  0
020B6:  RCALL  1C56
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
020B8:  MOVLW  09
020BA:  MOVLB  9
020BC:  MOVWF  xA7
020BE:  MOVLW  0A
020C0:  MOVWF  xA6
020C2:  CLRF   xA9
020C4:  MOVLW  1C
020C6:  MOVWF  xA8
020C8:  MOVLB  0
020CA:  RCALL  1C0C
....................  
....................     MACFlush(); 
020CC:  RCALL  1D24
....................     
....................    return TRUE; 
020CE:  MOVLW  01
020D0:  MOVWF  01
020D2:  MOVLB  9
020D4:  MOVLB  0
020D6:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
01974:  MOVLB  9
01976:  MOVFF  927,01
0197A:  MOVFF  928,03
0197E:  MOVFF  927,929
01982:  MOVFF  928,92A
01986:  MOVFF  927,FE9
0198A:  MOVFF  928,FEA
0198E:  MOVFF  FEC,9A2
01992:  MOVF   FED,F
01994:  MOVFF  FEF,9A1
01998:  MOVLB  0
0199A:  RCALL  1810
0199C:  MOVFF  92A,FEA
019A0:  MOVFF  929,FE9
019A4:  MOVFF  02,FEC
019A8:  MOVF   FED,F
019AA:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
019AE:  MOVLW  02
019B0:  MOVLB  9
019B2:  ADDWF  x27,W
019B4:  MOVWF  01
019B6:  MOVLW  00
019B8:  ADDWFC x28,W
019BA:  MOVWF  03
019BC:  MOVFF  01,929
019C0:  MOVWF  x2A
019C2:  MOVLW  02
019C4:  ADDWF  x27,W
019C6:  MOVWF  FE9
019C8:  MOVLW  00
019CA:  ADDWFC x28,W
019CC:  MOVWF  FEA
019CE:  MOVFF  FEC,9A2
019D2:  MOVF   FED,F
019D4:  MOVFF  FEF,9A1
019D8:  MOVLB  0
019DA:  RCALL  1810
019DC:  MOVFF  92A,FEA
019E0:  MOVFF  929,FE9
019E4:  MOVFF  02,FEC
019E8:  MOVF   FED,F
019EA:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
019EE:  MOVLW  06
019F0:  MOVLB  9
019F2:  ADDWF  x27,W
019F4:  MOVWF  01
019F6:  MOVLW  00
019F8:  ADDWFC x28,W
019FA:  MOVWF  03
019FC:  MOVFF  01,929
01A00:  MOVWF  x2A
01A02:  MOVLW  06
01A04:  ADDWF  x27,W
01A06:  MOVWF  FE9
01A08:  MOVLW  00
01A0A:  ADDWFC x28,W
01A0C:  MOVWF  FEA
01A0E:  MOVFF  FEC,9A2
01A12:  MOVF   FED,F
01A14:  MOVFF  FEF,9A1
01A18:  MOVLB  0
01A1A:  RCALL  1810
01A1C:  MOVFF  92A,FEA
01A20:  MOVFF  929,FE9
01A24:  MOVFF  02,FEC
01A28:  MOVF   FED,F
01A2A:  MOVFF  01,FEF
01A2E:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
0126C:  MOVLB  8
0126E:  CLRF   x8F
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
01270:  MOVLB  0
01272:  BRA    0A9E
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
01274:  BRA    0DCA
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
01276:  BRA    0F9C
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
01278:  BRA    111A
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
0127A:  GOTO   6C48 (RETURN)
....................    TFTPInit(); 
.................... #endif 
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
044CE:  MOVLB  8
044D0:  BCF    xFB.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
044D2:  BCF    xFB.0
....................         switch(smStack) 
044D4:  MOVF   x8F,W
044D6:  ADDLW  F9
044D8:  BTFSC  FD8.0
044DA:  BRA    4678
044DC:  ADDLW  07
044DE:  MOVLB  0
044E0:  GOTO   4682
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
044E4:  MOVLW  08
044E6:  MOVLB  8
044E8:  MOVWF  xFD
044EA:  MOVLW  90
044EC:  MOVWF  xFC
044EE:  MOVLW  08
044F0:  MOVWF  xFF
044F2:  MOVLW  FA
044F4:  MOVWF  xFE
044F6:  MOVLB  0
044F8:  GOTO   1826
044FC:  MOVF   01,F
044FE:  BNZ   4506
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
04500:  MOVLB  8
04502:  BRA    4678
04504:  MOVLB  0
....................             } 
....................  
....................             debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
04506:  MOVLB  8
04508:  BSF    xFB.0
....................             if ( type.MACFrameType == MAC_IP ) { 
0450A:  MOVF   xFA,F
0450C:  BNZ   4514
....................                 smStack = SM_STACK_IP; 
0450E:  MOVLW  02
04510:  MOVWF  x8F
....................                 debug_stack(debug_putc, "IP "); 
....................             } 
04512:  BRA    4528
....................             else if ( type.MACFrameType == MAC_ARP ) { 
04514:  MOVF   xFA,W
04516:  SUBLW  06
04518:  BNZ   4520
....................                 smStack = SM_STACK_ARP; 
0451A:  MOVLW  05
0451C:  MOVWF  x8F
....................                 debug_stack(debug_putc, "ARP "); 
....................             } 
0451E:  BRA    4528
....................             else { 
....................                 MACDiscardRx(); 
04520:  MOVLB  0
04522:  CALL   1736
04526:  MOVLB  8
....................                 debug_stack(debug_putc, "DISCARD"); 
....................             } 
....................             break; 
04528:  BRA    4678
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
0452A:  GOTO   20D8
0452E:  MOVF   01,F
04530:  BZ    4538
....................                 smStack = SM_STACK_IDLE; 
04532:  MOVLB  8
04534:  CLRF   x8F
04536:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
04538:  MOVLB  8
0453A:  BRA    4678
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
0453C:  MOVLW  08
0453E:  MOVLB  8
04540:  MOVWF  xFD
04542:  MOVLW  F6
04544:  MOVWF  xFC
04546:  MOVLW  08
04548:  MOVWF  xFF
0454A:  MOVLW  90
0454C:  MOVWF  xFE
0454E:  MOVLW  08
04550:  MOVLB  9
04552:  MOVWF  x01
04554:  MOVLW  FA
04556:  MOVWF  x00
04558:  MOVLW  08
0455A:  MOVWF  x03
0455C:  MOVLW  9A
0455E:  MOVWF  x02
04560:  MOVLB  0
04562:  GOTO   23CE
04566:  MOVF   01,F
04568:  BZ    4594
....................             { 
....................                 lbContinue = TRUE; 
0456A:  MOVLB  8
0456C:  BSF    xFB.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
0456E:  DECFSZ xFA,W
04570:  BRA    4578
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
04572:  MOVLW  03
04574:  MOVWF  x8F
....................                     debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
04576:  BRA    4590
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
04578:  MOVF   xFA,W
0457A:  SUBLW  06
0457C:  BNZ   4584
....................                     smStack = SM_STACK_TCP; 
0457E:  MOVLW  06
04580:  MOVWF  x8F
....................                     debug_stack(debug_putc, "TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
04582:  BRA    4590
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack(debug_putc, "UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
04584:  BCF    xFB.0
....................                     MACDiscardRx(); 
04586:  MOVLB  0
04588:  CALL   1736
....................  
....................                     smStack = SM_STACK_IDLE; 
0458C:  MOVLB  8
0458E:  CLRF   x8F
....................                     debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................                 } 
....................             } 
04590:  BRA    459C
04592:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
04594:  CALL   1736
....................                 smStack = SM_STACK_IDLE; 
04598:  MOVLB  8
0459A:  CLRF   x8F
....................                 debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................             } 
....................             break; 
0459C:  BRA    4678
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
0459E:  MOVLW  08
045A0:  MOVLB  8
045A2:  MOVWF  xFD
045A4:  MOVLW  90
045A6:  MOVWF  xFC
045A8:  MOVLW  08
045AA:  MOVWF  xFF
045AC:  MOVLW  F6
045AE:  MOVWF  xFE
045B0:  MOVFF  89B,901
045B4:  MOVFF  89A,900
045B8:  MOVLB  0
045BA:  GOTO   3BE2
045BE:  MOVF   01,F
045C0:  BZ    45C8
....................             { 
....................                 debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
045C2:  MOVLB  8
045C4:  CLRF   x8F
045C6:  MOVLB  0
....................             } 
....................             break; 
045C8:  MOVLB  8
045CA:  BRA    4678
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
045CC:  MOVLB  8
045CE:  CLRF   x8F
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
045D0:  MOVF   x9B,F
045D2:  BNZ   4622
045D4:  MOVF   x9A,W
045D6:  SUBLW  48
045D8:  BNC   4622
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
045DA:  MOVLW  08
045DC:  MOVWF  xFD
045DE:  MOVLW  9A
045E0:  MOVWF  xFC
045E2:  MOVLW  08
045E4:  MOVWF  xFF
045E6:  MOVLW  FA
045E8:  MOVWF  xFE
045EA:  MOVLW  08
045EC:  MOVLB  9
045EE:  MOVWF  x01
045F0:  MOVLW  9C
045F2:  MOVWF  x00
045F4:  MOVFF  8FD,903
045F8:  MOVFF  8FC,902
045FC:  MOVLW  08
045FE:  MOVWF  x05
04600:  MOVLW  DC
04602:  MOVWF  x04
04604:  MOVLW  08
04606:  MOVWF  x07
04608:  MOVLW  DE
0460A:  MOVWF  x06
0460C:  MOVLB  0
0460E:  BRA    3E3A
04610:  MOVF   01,F
04612:  BZ    4624
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
04614:  MOVLB  8
04616:  MOVF   xFA,W
04618:  SUBLW  08
0461A:  BNZ   4622
....................                     { 
....................                         debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
0461C:  BSF    xFB.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
0461E:  MOVLW  04
04620:  MOVWF  x8F
04622:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
04624:  CALL   1736
....................             break; 
04628:  MOVLB  8
0462A:  BRA    4678
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
0462C:  MOVLW  01
0462E:  MOVLB  9
04630:  MOVWF  x82
04632:  MOVLB  0
04634:  CALL   2C6A
04638:  MOVF   01,F
0463A:  BZ    4672
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
0463C:  MOVLW  08
0463E:  MOVLB  8
04640:  MOVWF  xFD
04642:  MOVLW  90
04644:  MOVWF  xFC
04646:  CLRF   xFE
04648:  MOVLW  08
0464A:  MOVLB  9
0464C:  MOVWF  x00
0464E:  MOVLW  9C
04650:  MOVLB  8
04652:  MOVWF  xFF
04654:  MOVFF  89A,901
04658:  MOVFF  8DD,903
0465C:  MOVFF  8DC,902
04660:  MOVFF  8DF,905
04664:  MOVFF  8DE,904
04668:  MOVLB  0
0466A:  BRA    3F0C
....................  
....................                 debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0466C:  MOVLB  8
0466E:  CLRF   x8F
04670:  MOVLB  0
....................             } 
....................             break; 
04672:  MOVLB  8
04674:  BRA    4678
04676:  MOVLB  8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
04678:  BTFSC  xFB.0
0467A:  BRA    44D2
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
0467C:  MOVLB  0
0467E:  BRA    4022
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
04680:  RETURN 0
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
....................  
....................  
.................... // Dirección IP de la PC (destino). 
.................... IP_ADDR server; 
.................... // Puerto TCP. 
.................... #define EXAMPLE_TCP_PORT   (int16)7654 
.................... //int reintento_envio; 
.................... // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX. 
....................  
.................... void MACAddrInit(void) 
.................... { 
....................    MY_MAC_BYTE1=0x00; 
*
00A3C:  MOVLB  3
00A3E:  CLRF   x54
....................    MY_MAC_BYTE2=0x04; 
00A40:  MOVLW  04
00A42:  MOVWF  x55
....................    MY_MAC_BYTE3=0xA3; 
00A44:  MOVLW  A3
00A46:  MOVWF  x56
....................    MY_MAC_BYTE4=0x00; 
00A48:  CLRF   x57
....................    MY_MAC_BYTE5=0x00; 
00A4A:  CLRF   x58
....................    MY_MAC_BYTE6=0x22; 
00A4C:  MOVLW  22
00A4E:  MOVWF  x59
00A50:  MOVLB  0
00A52:  GOTO   6C3C (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    // IP del dispositivo. 
....................    MY_IP_BYTE1=192; 
00A56:  MOVLW  C0
00A58:  MOVLB  3
00A5A:  MOVWF  x50
....................    MY_IP_BYTE2=168; 
00A5C:  MOVLW  A8
00A5E:  MOVWF  x51
....................    MY_IP_BYTE3=1; 
00A60:  MOVLW  01
00A62:  MOVWF  x52
....................    MY_IP_BYTE4=152; 
00A64:  MOVLW  98
00A66:  MOVWF  x53
....................  
....................    // Puerta de enlace. 
....................    MY_GATE_BYTE1=192; 
00A68:  MOVLW  C0
00A6A:  MOVWF  x5E
....................    MY_GATE_BYTE2=168; 
00A6C:  MOVLW  A8
00A6E:  MOVWF  x5F
....................    MY_GATE_BYTE3=1; 
00A70:  MOVLW  01
00A72:  MOVWF  x60
....................    MY_GATE_BYTE4=254; 
00A74:  MOVLW  FE
00A76:  MOVWF  x61
....................  
....................    // Máscara de Subred. 
....................    MY_MASK_BYTE1=255; 
00A78:  SETF   x5A
....................    MY_MASK_BYTE2=255; 
00A7A:  SETF   x5B
....................    MY_MASK_BYTE3=255; 
00A7C:  SETF   x5C
....................    MY_MASK_BYTE4=0; 
00A7E:  CLRF   x5D
00A80:  MOVLB  0
00A82:  GOTO   6C40 (RETURN)
.................... } 
....................  
.................... void ServerAddrInit(void) { 
....................    // IP del servidor.. 
....................    server.v[0]=192; 
00A86:  MOVLW  C0
00A88:  MOVLB  8
00A8A:  MOVWF  xE0
....................    server.v[1]=168; 
00A8C:  MOVLW  A8
00A8E:  MOVWF  xE1
....................    server.v[2]=1; 
00A90:  MOVLW  01
00A92:  MOVWF  xE2
....................    server.v[3]=150; 
00A94:  MOVLW  96
00A96:  MOVWF  xE3
00A98:  MOVLB  0
00A9A:  GOTO   6C44 (RETURN)
.................... } 
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
....................  
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    //static int8 counter; 
....................    //char str[20]; 
....................    static int8 button1_held; 
....................     
....................    if (TCPIsGetReady(socket)) {//ESCUCHA PUERTO TCP 
*
051F8:  MOVFF  8F9,8FB
051FC:  GOTO   49B8
05200:  MOVF   01,F
05202:  BZ    5286
....................       //fprintf(DEBUG,"\r\nLEE SOCKET"); 
.................... //   if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      lcd_putc("LEE SOCKET          ");         } 
....................       edo_str=1;//bandera de dato recibido en socket actual 
05204:  MOVLW  01
05206:  MOVWF  4E
....................       i=0; 
05208:  CLRF   41
0520A:  CLRF   40
....................       while ( TCPGet(socket, &c) ) { 
0520C:  MOVFF  8F9,8FB
05210:  MOVLW  08
05212:  MOVLB  8
05214:  MOVWF  xFD
05216:  MOVLW  FA
05218:  MOVWF  xFC
0521A:  MOVLB  0
0521C:  GOTO   49F8
05220:  MOVF   01,F
05222:  BZ    5286
....................          rxtcp[i++]=c; 
05224:  MOVFF  41,03
05228:  MOVF   40,W
0522A:  INCF   40,F
0522C:  BTFSC  FD8.2
0522E:  INCF   41,F
05230:  MOVLB  8
05232:  MOVWF  xFB
05234:  MOVLW  60
05236:  ADDWF  xFB,W
05238:  MOVWF  FE9
0523A:  MOVLW  01
0523C:  ADDWFC 03,W
0523E:  MOVWF  FEA
05240:  MOVFF  8FA,FEF
....................          if (c=='@') { 
05244:  MOVF   xFA,W
05246:  SUBLW  40
05248:  BNZ   5264
....................             edo_str=0; 
0524A:  CLRF   4E
....................             lcd_gotoxy(20,4); 
0524C:  MOVLW  14
0524E:  MOVWF  xFD
05250:  MOVLW  04
05252:  MOVWF  xFE
05254:  MOVLB  0
05256:  CALL   05DC
....................             printf(lcd_putc,"%c",c); 
0525A:  MOVFF  8FA,8FC
0525E:  CALL   0630
05262:  MOVLB  8
....................          } 
....................          if (i>port_size) {i=port_size;} 
05264:  MOVF   41,F
05266:  BNZ   526E
05268:  MOVF   40,W
0526A:  SUBLW  5A
0526C:  BC    5274
0526E:  CLRF   41
05270:  MOVLW  5A
05272:  MOVWF  40
....................          rxtcp[i]=0; 
05274:  MOVLW  60
05276:  ADDWF  40,W
05278:  MOVWF  FE9
0527A:  MOVLW  01
0527C:  ADDWFC 41,W
0527E:  MOVWF  FEA
05280:  CLRF   FEF
05282:  MOVLB  0
05284:  BRA    520C
....................       } 
....................    } 
....................  
.................... //send message over TCP 
....................    //if(envia_pc) fprintf(DEBUG,"envia_pc:%u !button1_held:%u TCPIsPutReady(socket):%u\r\n",envia_pc,button1_held, TCPIsPutReady(socket) ); 
....................    if (envia_pc && !button1_held && TCPIsPutReady(socket)) {//ENVIA MENSAJE POR TCP 
05286:  MOVF   1A,F
05288:  BZ    52C8
0528A:  MOVLB  8
0528C:  MOVF   xE4,F
0528E:  BTFSC  FD8.2
05290:  BRA    5296
05292:  MOVLB  0
05294:  BRA    52C8
05296:  MOVFF  8F9,909
0529A:  MOVLB  0
0529C:  RCALL  4AE4
0529E:  MOVF   01,F
052A0:  BZ    52C8
....................       button1_held=TRUE; 
052A2:  MOVLW  01
052A4:  MOVLB  8
052A6:  MOVWF  xE4
....................       TCPPutArray(socket,txtcp,size_tx_tcp);//SOCKET,DATO,NO.BYTES 
052A8:  MOVFF  8F9,8FB
052AC:  MOVWF  xFD
052AE:  MOVLW  06
052B0:  MOVWF  xFC
052B2:  CLRF   xFF
052B4:  MOVFF  48,8FE
052B8:  MOVLB  0
052BA:  BRA    4E90
....................       TCPFlush(socket); 
052BC:  MOVFF  8F9,904
052C0:  RCALL  4CF0
....................       reintento_envio=0; 
052C2:  CLRF   4F
....................       envia_pc=0; 
052C4:  CLRF   1A
....................       //fprintf(DEBUG,"Envio:%s\r\n",txtcp); 
.................... //      if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      printf(lcd_putc,"Envio:%s       ",txtcp);} 
....................    }////////////////// 
052C6:  BRA    52F2
....................    else if (envia_pc && !button1_held && !TCPIsPutReady(socket)) {//SI NO PUEDE VACIAR DATOS ROMPE CONEXION 
052C8:  MOVF   1A,F
052CA:  BZ    52F2
052CC:  MOVLB  8
052CE:  MOVF   xE4,F
052D0:  BTFSC  FD8.2
052D2:  BRA    52D8
052D4:  MOVLB  0
052D6:  BRA    52F2
052D8:  MOVFF  8F9,909
052DC:  MOVLB  0
052DE:  RCALL  4AE4
052E0:  MOVF   01,F
052E2:  BNZ   52F2
....................       reintento_envio++; 
052E4:  INCF   4F,F
....................       if(reintento_envio>=10) TCPDisconnect(socket); 
052E6:  MOVF   4F,W
052E8:  SUBLW  09
052EA:  BC    52F2
052EC:  MOVFF  8F9,8FB
052F0:  RCALL  50D6
....................    }/////////////////// 
....................     
....................    if (!envia_pc) { 
052F2:  MOVF   1A,F
052F4:  BNZ   52FC
....................       button1_held=FALSE; 
052F6:  MOVLB  8
052F8:  CLRF   xE4
052FA:  MOVLB  0
....................    } 
....................     
....................    //#if defined(ESTADO_entrada04)//CIERRA LAS CONEXIONES 
....................    //if (ESTADO_entrada04) { 
....................      // return(TRUE); 
....................    //} 
....................   //#endif 
....................  
....................    return(TRUE); 
052FC:  MOVLW  01
052FE:  MOVWF  01
05300:  GOTO   554E (RETURN)
.................... } 
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_ARP_REQ=1, MYTCP_STATE_ARP_WAIT=2, 
....................       MYTCP_STATE_CONNECT=3, MYTCP_STATE_CONNECT_WAIT=4, 
....................       MYTCP_STATE_CONNECTED=5, MYTCP_STATE_DISCONNECT=6, 
....................       MYTCP_STATE_FORCE_DISCONNECT=7 
....................    } state=0; 
....................    static NODE_INFO remote; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................  
....................    currTick=TickGet(); 
05304:  CALL   2B52
05308:  MOVFF  02,8F7
0530C:  MOVFF  01,8F6
....................  
....................    switch (state) { 
05310:  MOVLB  8
05312:  MOVF   xE8,W
05314:  ADDLW  F8
05316:  BTFSC  FD8.0
05318:  BRA    5642
0531A:  ADDLW  08
0531C:  MOVLB  0
0531E:  GOTO   5646
....................       case MYTCP_STATE_NEW: 
....................          memcpy(&remote.IPAddr, &server, sizeof(IP_ADDR)); 
05322:  MOVFF  8E0,8EF
05326:  MOVFF  8E1,8F0
0532A:  MOVFF  8E2,8F1
0532E:  MOVFF  8E3,8F2
....................          //fprintf(DEBUG,"\n Solicitud ARP."); 
....................          if(!espera)   { 
05332:  MOVLB  2
05334:  MOVF   x7D,F
05336:  BNZ   5356
....................          lcd_gotoxy(1,4); 
05338:  MOVLW  01
0533A:  MOVLB  8
0533C:  MOVWF  xFD
0533E:  MOVLW  04
05340:  MOVWF  xFE
05342:  MOVLB  0
05344:  CALL   05DC
....................          lcd_putc("Solicitud ARP.      ");} 
05348:  MOVLW  2A
0534A:  MOVWF  FF6
0534C:  MOVLW  01
0534E:  MOVWF  FF7
05350:  CALL   0694
05354:  MOVLB  2
....................          state=MYTCP_STATE_ARP_REQ; 
05356:  MOVLW  01
05358:  MOVLB  8
0535A:  MOVWF  xE8
0535C:  MOVLB  0
....................  
....................       case MYTCP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
0535E:  MOVLW  01
05360:  MOVLB  9
05362:  MOVWF  x82
05364:  MOVLB  0
05366:  CALL   2C6A
0536A:  MOVF   01,F
0536C:  BZ    538E
....................             ARPResolve(&remote.IPAddr); 
0536E:  MOVLW  08
05370:  MOVLB  8
05372:  MOVWF  xFA
05374:  MOVLW  EF
05376:  MOVWF  xF9
05378:  MOVLB  0
0537A:  GOTO   46AA
....................             lastTick=currTick; 
0537E:  MOVFF  8F7,8E6
05382:  MOVFF  8F6,8E5
....................             state=MYTCP_STATE_ARP_WAIT; 
05386:  MOVLW  02
05388:  MOVLB  8
0538A:  MOVWF  xE8
0538C:  MOVLB  0
....................          } 
....................          break; 
0538E:  MOVLB  8
05390:  BRA    5642
....................  
....................       case MYTCP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) { 
05392:  MOVLW  08
05394:  MOVLB  8
05396:  MOVWF  xFA
05398:  MOVLW  EF
0539A:  MOVWF  xF9
0539C:  MOVLW  08
0539E:  MOVWF  xFC
053A0:  MOVLW  E9
053A2:  MOVWF  xFB
053A4:  MOVLB  0
053A6:  GOTO   46DC
053AA:  MOVF   01,F
053AC:  BZ    53DA
....................             state=MYTCP_STATE_CONNECT; 
053AE:  MOVLW  03
053B0:  MOVLB  8
053B2:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTANDO...      "); 
....................             if(!espera)   { 
053B4:  MOVLB  2
053B6:  MOVF   x7D,F
053B8:  BNZ   53D8
....................             lcd_gotoxy(1,4); 
053BA:  MOVLW  01
053BC:  MOVLB  8
053BE:  MOVWF  xFD
053C0:  MOVLW  04
053C2:  MOVWF  xFE
053C4:  MOVLB  0
053C6:  CALL   05DC
....................             lcd_putc("CONECTANDO...       ");} 
053CA:  MOVLW  40
053CC:  MOVWF  FF6
053CE:  MOVLW  01
053D0:  MOVWF  FF7
053D2:  CALL   0694
053D6:  MOVLB  2
....................          } 
053D8:  BRA    5434
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) { 
053DA:  MOVLB  8
053DC:  MOVF   xF7,W
053DE:  SUBWF  xE6,W
053E0:  BNC   53EA
053E2:  BNZ   53EE
053E4:  MOVF   xE5,W
053E6:  SUBWF  xF6,W
053E8:  BNC   53EE
053EA:  MOVLW  00
053EC:  BRA    53F0
053EE:  MOVLW  01
053F0:  CLRF   03
053F2:  IORWF  03,W
053F4:  BZ    541C
053F6:  MOVLW  FF
053F8:  BSF    FD8.0
053FA:  SUBFWB xE5,W
053FC:  MOVWF  xF9
053FE:  MOVLW  FF
05400:  SUBFWB xE6,W
05402:  MOVWF  xFA
05404:  MOVF   xF6,W
05406:  ADDWF  xF9,F
05408:  MOVF   xF7,W
0540A:  ADDWFC xFA,F
0540C:  MOVLW  01
0540E:  ADDWF  xF9,W
05410:  MOVWF  01
05412:  MOVLW  00
05414:  ADDWFC xFA,W
05416:  MOVWF  03
05418:  MOVF   01,W
0541A:  BRA    542A
0541C:  MOVF   xE5,W
0541E:  SUBWF  xF6,W
05420:  MOVWF  00
05422:  MOVF   xE6,W
05424:  SUBWFB xF7,W
05426:  MOVWF  03
05428:  MOVF   00,W
0542A:  SUBLW  18
0542C:  BC    5432
....................             state=MYTCP_STATE_ARP_REQ; 
0542E:  MOVLW  01
05430:  MOVWF  xE8
05432:  MOVLB  2
....................          } 
....................          break; 
05434:  MOVLB  8
05436:  BRA    5642
....................  
....................       case MYTCP_STATE_CONNECT: 
....................          socket2=socket=TCPConnect(&remote, EXAMPLE_TCP_PORT); 
05438:  MOVLW  08
0543A:  MOVLB  8
0543C:  MOVWF  xFA
0543E:  MOVLW  E9
05440:  MOVWF  xF9
05442:  MOVLW  1D
05444:  MOVWF  xFC
05446:  MOVLW  E6
05448:  MOVWF  xFB
0544A:  MOVLB  0
0544C:  GOTO   4766
05450:  MOVFF  01,8E7
05454:  MOVFF  8E7,51
....................          if (socket!=INVALID_SOCKET) { 
05458:  MOVLB  8
0545A:  MOVF   xE7,W
0545C:  SUBLW  FE
0545E:  BZ    5476
....................             lastTick=TickGet(); 
05460:  MOVLB  0
05462:  CALL   2B52
05466:  MOVFF  02,8E6
0546A:  MOVFF  01,8E5
....................             state=MYTCP_STATE_CONNECT_WAIT; 
0546E:  MOVLW  04
05470:  MOVLB  8
05472:  MOVWF  xE8
....................          } 
05474:  BRA    549C
....................          else { 
....................             //fprintf(DEBUG,"\nError en el socket."); 
....................             if(!espera)   { 
05476:  MOVLB  2
05478:  MOVF   x7D,F
0547A:  BNZ   549A
....................                lcd_gotoxy(1,4);  
0547C:  MOVLW  01
0547E:  MOVLB  8
05480:  MOVWF  xFD
05482:  MOVLW  04
05484:  MOVWF  xFE
05486:  MOVLB  0
05488:  CALL   05DC
....................                lcd_putc("Error en el socket. ");} 
0548C:  MOVLW  56
0548E:  MOVWF  FF6
05490:  MOVLW  01
05492:  MOVWF  FF7
05494:  CALL   0694
05498:  MOVLB  2
0549A:  MOVLB  8
....................          } 
....................          break; 
0549C:  BRA    5642
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(socket)) { 
0549E:  MOVFF  8E7,8F9
054A2:  CALL   497C
054A6:  MOVF   01,F
054A8:  BZ    54DE
....................             state=MYTCP_STATE_CONNECTED; 
054AA:  MOVLW  05
054AC:  MOVLB  8
054AE:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTADO! "); 
....................             if(!espera)   { 
054B0:  MOVLB  2
054B2:  MOVF   x7D,F
054B4:  BNZ   54D4
....................                lcd_gotoxy(1,4); 
054B6:  MOVLW  01
054B8:  MOVLB  8
054BA:  MOVWF  xFD
054BC:  MOVLW  04
054BE:  MOVWF  xFE
054C0:  MOVLB  0
054C2:  CALL   05DC
....................                lcd_putc("CONECTADO           ");} 
054C6:  MOVLW  6C
054C8:  MOVWF  FF6
054CA:  MOVLW  01
054CC:  MOVWF  FF7
054CE:  CALL   0694
054D2:  MOVLB  2
....................             output_high(salida06); 
054D4:  BCF    F94.2
054D6:  BSF    F8B.2
....................             inicializado=1; 
054D8:  MOVLW  01
054DA:  MOVWF  50
....................          } 
054DC:  BRA    5538
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
054DE:  MOVLB  8
054E0:  MOVF   xF7,W
054E2:  SUBWF  xE6,W
054E4:  BNC   54EE
054E6:  BNZ   54F2
054E8:  MOVF   xE5,W
054EA:  SUBWF  xF6,W
054EC:  BNC   54F2
054EE:  MOVLW  00
054F0:  BRA    54F4
054F2:  MOVLW  01
054F4:  CLRF   03
054F6:  IORWF  03,W
054F8:  BZ    5520
054FA:  MOVLW  FF
054FC:  BSF    FD8.0
054FE:  SUBFWB xE5,W
05500:  MOVWF  xF9
05502:  MOVLW  FF
05504:  SUBFWB xE6,W
05506:  MOVWF  xFA
05508:  MOVF   xF6,W
0550A:  ADDWF  xF9,F
0550C:  MOVF   xF7,W
0550E:  ADDWFC xFA,F
05510:  MOVLW  01
05512:  ADDWF  xF9,W
05514:  MOVWF  01
05516:  MOVLW  00
05518:  ADDWFC xFA,W
0551A:  MOVWF  03
0551C:  MOVF   01,W
0551E:  BRA    552E
05520:  MOVF   xE5,W
05522:  SUBWF  xF6,W
05524:  MOVWF  00
05526:  MOVF   xE6,W
05528:  SUBWFB xF7,W
0552A:  MOVWF  03
0552C:  MOVF   00,W
0552E:  SUBLW  78
05530:  BC    5536
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
05532:  MOVLW  07
05534:  MOVWF  xE8
05536:  MOVLB  2
....................          } 
....................          break; 
05538:  MOVLB  8
0553A:  BRA    5642
....................  
....................       case MYTCP_STATE_CONNECTED: 
....................          if (TCPIsConnected(socket)) { 
0553C:  MOVFF  8E7,8F9
05540:  CALL   497C
05544:  MOVF   01,F
05546:  BZ    5564
....................             dis=TCPConnectedTask(socket); 
05548:  MOVFF  8E7,8F9
0554C:  BRA    51F8
0554E:  MOVFF  01,8F8
....................             //fprintf(DEBUG,"\ndis:%u ",dis); 
....................             if (dis) { 
05552:  MOVLB  8
05554:  MOVF   xF8,F
05556:  BZ    5560
....................                //state=MYTCP_STATE_DISCONNECT; 
....................                lastTick=currTick; 
05558:  MOVFF  8F7,8E6
0555C:  MOVFF  8F6,8E5
....................             } 
....................          } 
05560:  BRA    556A
05562:  MOVLB  0
....................          else { 
....................             //fprintf(DEBUG,"\nDESCONECTADO.   "); 
....................             //state=MYTCP_STATE_CONNECT; 
....................             state=MYTCP_STATE_DISCONNECT; 
05564:  MOVLW  06
05566:  MOVLB  8
05568:  MOVWF  xE8
....................             //output_low(salida06); 
....................          } 
....................          break; 
0556A:  BRA    5642
....................  
....................       case MYTCP_STATE_DISCONNECT: 
....................          //fprintf(DEBUG,"\nDESCONECTANDO.   "); 
....................          if(!espera)   { 
0556C:  MOVLB  2
0556E:  MOVF   x7D,F
05570:  BNZ   5590
....................             lcd_gotoxy(1,4); 
05572:  MOVLW  01
05574:  MOVLB  8
05576:  MOVWF  xFD
05578:  MOVLW  04
0557A:  MOVWF  xFE
0557C:  MOVLB  0
0557E:  CALL   05DC
....................             lcd_putc("DESCONECTADO       ");} 
05582:  MOVLW  82
05584:  MOVWF  FF6
05586:  MOVLW  01
05588:  MOVWF  FF7
0558A:  CALL   0694
0558E:  MOVLB  2
....................          output_low(salida06); 
05590:  BCF    F94.2
05592:  BCF    F8B.2
....................          inicializado=0; 
05594:  CLRF   50
....................          if (TCPIsPutReady(socket)) { 
05596:  MOVFF  8E7,909
0559A:  MOVLB  0
0559C:  CALL   4AE4
055A0:  MOVF   01,F
055A2:  BZ    55AC
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
055A4:  MOVLW  07
055A6:  MOVLB  8
055A8:  MOVWF  xE8
....................          } 
055AA:  BRA    5604
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
055AC:  MOVLB  8
055AE:  MOVF   xF7,W
055B0:  SUBWF  xE6,W
055B2:  BNC   55BC
055B4:  BNZ   55C0
055B6:  MOVF   xE5,W
055B8:  SUBWF  xF6,W
055BA:  BNC   55C0
055BC:  MOVLW  00
055BE:  BRA    55C2
055C0:  MOVLW  01
055C2:  CLRF   03
055C4:  IORWF  03,W
055C6:  BZ    55EE
055C8:  MOVLW  FF
055CA:  BSF    FD8.0
055CC:  SUBFWB xE5,W
055CE:  MOVWF  xF9
055D0:  MOVLW  FF
055D2:  SUBFWB xE6,W
055D4:  MOVWF  xFA
055D6:  MOVF   xF6,W
055D8:  ADDWF  xF9,F
055DA:  MOVF   xF7,W
055DC:  ADDWFC xFA,F
055DE:  MOVLW  01
055E0:  ADDWF  xF9,W
055E2:  MOVWF  01
055E4:  MOVLW  00
055E6:  ADDWFC xFA,W
055E8:  MOVWF  03
055EA:  MOVF   01,W
055EC:  BRA    55FC
055EE:  MOVF   xE5,W
055F0:  SUBWF  xF6,W
055F2:  MOVWF  00
055F4:  MOVF   xE6,W
055F6:  SUBWFB xF7,W
055F8:  MOVWF  03
055FA:  MOVF   00,W
055FC:  SUBLW  78
055FE:  BC    5604
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
05600:  MOVLW  07
05602:  MOVWF  xE8
....................          } 
....................          break; 
05604:  BRA    5642
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
....................          TCPDisconnect(socket); 
05606:  MOVFF  8E7,8FB
0560A:  RCALL  50D6
....................          state=MYTCP_STATE_CONNECT; 
0560C:  MOVLW  03
0560E:  MOVLB  8
05610:  MOVWF  xE8
....................          if(!espera)   { 
05612:  MOVLB  2
05614:  MOVF   x7D,F
05616:  BNZ   5636
....................             lcd_gotoxy(1,4); 
05618:  MOVLW  01
0561A:  MOVLB  8
0561C:  MOVWF  xFD
0561E:  MOVLW  04
05620:  MOVWF  xFE
05622:  MOVLB  0
05624:  CALL   05DC
....................             lcd_putc("DESCONECTADO       ");} 
05628:  MOVLW  96
0562A:  MOVWF  FF6
0562C:  MOVLW  01
0562E:  MOVWF  FF7
05630:  CALL   0694
05634:  MOVLB  2
....................          output_low(salida06); 
05636:  BCF    F94.2
05638:  BCF    F8B.2
....................          inicializado=0; 
0563A:  CLRF   50
....................          break; 
0563C:  MOVLB  8
0563E:  BRA    5642
05640:  MOVLB  8
....................    } 
05642:  MOVLB  0
05644:  RETURN 0
.................... } 
....................  
.................... ////wiegand/// 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... wiegand_cuenta++; 
*
001AA:  MOVLB  2
001AC:  INCF   x11,F
.................... time_relay1++; 
001AE:  INCF   1F,F
.................... time_boleto++; 
001B0:  INCF   x89,F
.................... cuenta++; 
001B2:  INCF   x7C,F
.................... cta_lcd++; 
001B4:  INCF   x8B,F
.................... set_timer1(3036); //50 ms 
001B6:  MOVLW  0B
001B8:  MOVWF  FCF
001BA:  MOVLW  DC
001BC:  MOVWF  FCE
.................... } 
....................  
001BE:  BCF    F9E.0
001C0:  MOVLB  0
001C2:  GOTO   0084
.................... #int_ext 
.................... void EXT_isr(void){//data1 
....................    while (!input(PIN_B0) ) {} 
001C6:  BSF    F93.0
001C8:  BTFSS  F81.0
001CA:  BRA    01C6
....................    wiegand_cuenta=0; 
001CC:  MOVLB  2
001CE:  CLRF   x11
....................    wieg=1; 
001D0:  MOVLW  01
001D2:  MOVWF  x0C
....................    data[sub_indice]=1; 
001D4:  CLRF   03
001D6:  MOVF   x0F,W
001D8:  ADDLW  16
001DA:  MOVWF  FE9
001DC:  MOVLW  02
001DE:  ADDWFC 03,W
001E0:  MOVWF  FEA
001E2:  MOVLW  01
001E4:  MOVWF  FEF
....................    sub_indice++; 
001E6:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
001E8:  MOVF   x0F,W
001EA:  SUBLW  1A
001EC:  BNZ   01F2
....................       wieg_full=1; 
001EE:  MOVLW  01
001F0:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
.................... } 
....................  
001F2:  BCF    FF2.1
001F4:  MOVLB  0
001F6:  GOTO   0084
.................... #int_ext1 
.................... void EXT1_isr(void){//data0 
....................    while (!input(PIN_B1) ) {} 
001FA:  BSF    F93.1
001FC:  BTFSS  F81.1
001FE:  BRA    01FA
....................    wiegand_cuenta=0; 
00200:  MOVLB  2
00202:  CLRF   x11
....................    wieg=1; 
00204:  MOVLW  01
00206:  MOVWF  x0C
....................    data[sub_indice]=0; 
00208:  CLRF   03
0020A:  MOVF   x0F,W
0020C:  ADDLW  16
0020E:  MOVWF  FE9
00210:  MOVLW  02
00212:  ADDWFC 03,W
00214:  MOVWF  FEA
00216:  CLRF   FEF
....................    sub_indice++; 
00218:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
0021A:  MOVF   x0F,W
0021C:  SUBLW  1A
0021E:  BNZ   0224
....................       wieg_full=1; 
00220:  MOVLW  01
00222:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
00224:  BCF    FF0.0
00226:  MOVLB  0
00228:  GOTO   0084
.................... } 
.................... /////////////////////// 
.................... //funciones extra 
.................... void wiegand_read_card(); 
.................... void enviar_tcp(); 
.................... /////////boleto//////////////////// 
.................... void reset(); 
.................... void encri(); 
.................... void barra1(); 
.................... void barra2(); 
.................... void CR(); 
.................... void LF(); 
.................... void ticket(); 
.................... void sensores(); 
.................... void llaves(); 
.................... void rd_eeprom(); 
.................... void zeller(); 
.................... void horario(); 
.................... void fecha(); 
....................  
.................... void main(void) { 
*
06A92:  CLRF   FF8
06A94:  BCF    FD0.7
06A96:  BSF    07.7
06A98:  CLRF   19
06A9A:  BCF    FB8.3
06A9C:  MOVLW  40
06A9E:  MOVWF  FAF
06AA0:  MOVLW  A6
06AA2:  MOVWF  FAC
06AA4:  MOVLW  90
06AA6:  MOVWF  FAB
06AA8:  MOVLB  2
06AAA:  CLRF   x0F
06AAC:  CLRF   x10
06AAE:  MOVLB  3
06AB0:  CLRF   x89
06AB2:  CLRF   x88
06AB4:  CLRF   x8A
06AB6:  CLRF   x8B
06AB8:  CLRF   x93
06ABA:  CLRF   x92
06ABC:  MOVLW  04
06ABE:  MOVWF  x96
06AC0:  CLRF   x95
06AC2:  MOVLW  FE
06AC4:  MOVLB  8
06AC6:  MOVWF  xE7
06AC8:  CLRF   xE8
06ACA:  CLRF   xF4
06ACC:  CLRF   xF3
06ACE:  MOVF   FC1,W
06AD0:  ANDLW  C0
06AD2:  IORLW  0F
06AD4:  MOVWF  FC1
06AD6:  MOVLW  07
06AD8:  MOVWF  FB4
06ADA:  MOVLB  3
06ADC:  BCF    x90.1
06ADE:  BRA    6BD6
06AE0:  DATA 0B,02
06AE2:  DATA 8D,42
06AE4:  DATA 4F,4C
06AE6:  DATA 45,54
06AE8:  DATA 4F,5F
06AEA:  DATA 46,4F
06AEC:  DATA 4C,00
06AEE:  DATA 0B,02
06AF0:  DATA 99,42
06AF2:  DATA 4F,52
06AF4:  DATA 52,41
06AF6:  DATA 52,54
06AF8:  DATA 4F,44
06AFA:  DATA 4F,00
06AFC:  DATA 0B,02
06AFE:  DATA A5,42
06B00:  DATA 4F,52
06B02:  DATA 52,41
06B04:  DATA 52,5F
06B06:  DATA 54,41
06B08:  DATA 47,00
06B0A:  DATA 0B,02
06B0C:  DATA B1,41
06B0E:  DATA 42,52
06B10:  DATA 49,52
06B12:  DATA 5F,53
06B14:  DATA 41,4C
06B16:  DATA 49,00
06B18:  DATA 0B,02
06B1A:  DATA BD,43
06B1C:  DATA 55,50
06B1E:  DATA 4F,5F
06B20:  DATA 4C,4C
06B22:  DATA 45,4E
06B24:  DATA 4F,00
06B26:  DATA 0B,02
06B28:  DATA C9,43
06B2A:  DATA 55,50
06B2C:  DATA 4F,5F
06B2E:  DATA 44,49
06B30:  DATA 53,50
06B32:  DATA 4F,00
06B34:  DATA 0B,02
06B36:  DATA D5,4D
06B38:  DATA 45,4E
06B3A:  DATA 53,41
06B3C:  DATA 4A,45
06B3E:  DATA 45,4E
06B40:  DATA 31,00
06B42:  DATA 0A,42
06B44:  DATA E1,20
06B46:  DATA 01,80
06B48:  DATA 00,0B
06B4A:  DATA 02,ED
06B4C:  DATA 43,4F
06B4E:  DATA 4E,53
06B50:  DATA 55,4C
06B52:  DATA 54,41
06B54:  DATA 30,31
06B56:  DATA 00,0B
06B58:  DATA 02,F9
06B5A:  DATA 43,4F
06B5C:  DATA 4E,46
06B5E:  DATA 49,47
06B60:  DATA 44,41
06B62:  DATA 54,45
06B64:  DATA 00,0B
06B66:  DATA 03,05
06B68:  DATA 43,4F
06B6A:  DATA 4E,46
06B6C:  DATA 49,47
06B6E:  DATA 55,52
06B70:  DATA 41,42
06B72:  DATA 00,0B
06B74:  DATA 03,11
06B76:  DATA 42,4F
06B78:  DATA 52,52
06B7A:  DATA 41,5F
06B7C:  DATA 43,4F
06B7E:  DATA 4E,31
06B80:  DATA 00,0B
06B82:  DATA 03,1D
06B84:  DATA 46,4F
06B86:  DATA 4C,49
06B88:  DATA 4F,52
06B8A:  DATA 45,53
06B8C:  DATA 45,54
06B8E:  DATA 00,06
06B90:  DATA 03,29
06B92:  DATA 50,41
06B94:  DATA 47,41
06B96:  DATA 44,4F
06B98:  DATA 04,C0
06B9A:  DATA 30,01
06B9C:  DATA 80,00
06B9E:  DATA 18,03
06BA0:  DATA 35,42
06BA2:  DATA 4F,4C
06BA4:  DATA 45,54
06BA6:  DATA 4F,00
06BA8:  DATA 42,41
06BAA:  DATA 52,52
06BAC:  DATA 45,52
06BAE:  DATA 41,41
06BB0:  DATA 42,49
06BB2:  DATA 45,52
06BB4:  DATA 54,41
06BB6:  DATA 45,31
06BB8:  DATA 00,02
06BBA:  DATA 03,81
06BBC:  DATA 00,00
06BBE:  DATA 01,03
06BC0:  DATA 94,00
06BC2:  DATA 0A,48
06BC4:  DATA 85,00
06BC6:  DATA 46,48
06BC8:  DATA 9A,00
06BCA:  DATA 03,08
06BCC:  DATA E4,00
06BCE:  DATA 00,00
06BD0:  DATA 0A,48
06BD2:  DATA E9,00
06BD4:  DATA 00,00
06BD6:  MOVLW  00
06BD8:  MOVWF  FF8
06BDA:  MOVLW  6A
06BDC:  MOVWF  FF7
06BDE:  MOVLW  E0
06BE0:  MOVWF  FF6
06BE2:  TBLRD*+
06BE4:  MOVF   FF5,W
06BE6:  MOVWF  00
06BE8:  XORLW  00
06BEA:  BZ    6C12
06BEC:  TBLRD*+
06BEE:  MOVF   FF5,W
06BF0:  MOVWF  01
06BF2:  BTFSC  FE8.7
06BF4:  BRA    6C00
06BF6:  ANDLW  0F
06BF8:  MOVWF  FEA
06BFA:  TBLRD*+
06BFC:  MOVFF  FF5,FE9
06C00:  BTFSC  01.6
06C02:  TBLRD*+
06C04:  BTFSS  01.6
06C06:  TBLRD*+
06C08:  MOVFF  FF5,FEE
06C0C:  DCFSNZ 00,F
06C0E:  BRA    6BE2
06C10:  BRA    6C04
06C12:  CLRF   FF8
....................    //fprintf(DEBUG,"\r\n\nCLIENTE TCP/IP\r\n"); 
....................    lcd_putc("\fINICIANDO"); 
06C14:  MOVLW  2C
06C16:  MOVWF  FF6
06C18:  MOVLW  02
06C1A:  MOVWF  FF7
06C1C:  MOVLB  0
06C1E:  CALL   0694
....................    setup_adc_ports(NO_ANALOGS); 
06C22:  MOVF   FC1,W
06C24:  ANDLW  C0
06C26:  IORLW  0F
06C28:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
06C2A:  BCF    FC2.0
....................     
....................    init_ext_eeprom();//iniciar memoria 
06C2C:  GOTO   06B4
....................    lcd_init();//iniciar LCD 
06C30:  GOTO   06BC
....................    llaves(); 
06C34:  GOTO   0738
....................     
....................    MACAddrInit(); 
06C38:  GOTO   0A3C
....................    IPAddrInit(); 
06C3C:  GOTO   0A56
....................    ServerAddrInit(); 
06C40:  GOTO   0A86
....................    StackInit(); 
06C44:  GOTO   126C
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
06C48:  MOVLW  B5
06C4A:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);//Habilito interrupción particular del TIMER1 
06C4C:  BSF    F9D.0
....................    set_timer1(3036);//Carga del TMR1 
06C4E:  MOVLW  0B
06C50:  MOVWF  FCF
06C52:  MOVLW  DC
06C54:  MOVWF  FCE
....................    ext_int_edge(0,L_TO_H);       //Asigno flancos de subida 
06C56:  BSF    FF1.6
....................    ext_int_edge(1,L_TO_H);       //Asigno flancos de subida 
06C58:  BSF    FF1.5
....................    enable_interrupts(INT_EXT1); 
06C5A:  BSF    FF0.3
....................    enable_interrupts(INT_EXT); 
06C5C:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);//Habilito interrupciones globales 
06C5E:  MOVLW  C0
06C60:  IORWF  FF2,F
....................  
....................    envia_pc=0; 
06C62:  CLRF   1A
....................    //int linked_out=0; 
....................    edo_str=envia_pc=0; 
06C64:  CLRF   1A
06C66:  MOVFF  1A,4E
....................    re_bol=0; 
06C6A:  MOVLB  2
06C6C:  CLRF   x8A
....................    //leyendo validacion de pago 
....................    int vigencia; 
....................    vigencia=read_ext_eeprom(10); 
06C6E:  MOVLB  9
06C70:  CLRF   x07
06C72:  MOVLW  0A
06C74:  MOVWF  x06
06C76:  MOVLB  0
06C78:  CALL   1360
06C7C:  MOVFF  01,8F5
....................    if(vigencia!=1) { 
06C80:  MOVLB  8
06C82:  DECFSZ xF5,W
06C84:  BRA    6C88
06C86:  BRA    6CCC
....................       write_ext_eeprom(10,1); 
06C88:  MOVLB  9
06C8A:  CLRF   x07
06C8C:  MOVLW  0A
06C8E:  MOVWF  x06
06C90:  MOVLW  01
06C92:  MOVWF  x08
06C94:  MOVLB  0
06C96:  CALL   1408
....................       write_ext_eeprom(11,0); 
06C9A:  MOVLB  9
06C9C:  CLRF   x07
06C9E:  MOVLW  0B
06CA0:  MOVWF  x06
06CA2:  CLRF   x08
06CA4:  MOVLB  0
06CA6:  CALL   1408
....................       write_ext_eeprom(12,0); 
06CAA:  MOVLB  9
06CAC:  CLRF   x07
06CAE:  MOVLW  0C
06CB0:  MOVWF  x06
06CB2:  CLRF   x08
06CB4:  MOVLB  0
06CB6:  CALL   1408
....................       write_ext_eeprom(13,0); 
06CBA:  MOVLB  9
06CBC:  CLRF   x07
06CBE:  MOVLW  0D
06CC0:  MOVWF  x06
06CC2:  CLRF   x08
06CC4:  MOVLB  0
06CC6:  CALL   1408
06CCA:  MOVLB  8
....................    } 
....................    pago=read_ext_eeprom(11);// 
06CCC:  MOVLB  9
06CCE:  CLRF   x07
06CD0:  MOVLW  0B
06CD2:  MOVWF  x06
06CD4:  MOVLB  0
06CD6:  CALL   1360
06CDA:  MOVFF  01,27B
....................    dias_prueba=read_ext_eeprom(12);//dias de prueba 
06CDE:  MOVLB  9
06CE0:  CLRF   x07
06CE2:  MOVLW  0C
06CE4:  MOVWF  x06
06CE6:  MOVLB  0
06CE8:  CALL   1360
06CEC:  MOVFF  01,279
....................    dia_temp=read_ext_eeprom(13);// 
06CF0:  MOVLB  9
06CF2:  CLRF   x07
06CF4:  MOVLW  0D
06CF6:  MOVWF  x06
06CF8:  MOVLB  0
06CFA:  CALL   1360
06CFE:  MOVFF  01,27A
....................    lcd_gotoxy(1,1); 
06D02:  MOVLW  01
06D04:  MOVLB  8
06D06:  MOVWF  xFD
06D08:  MOVWF  xFE
06D0A:  MOVLB  0
06D0C:  CALL   05DC
....................    printf(lcd_putc,"Dias:%u PAGO:%d",dias_prueba,pago); 
06D10:  MOVLW  38
06D12:  MOVWF  FF6
06D14:  MOVLW  02
06D16:  MOVWF  FF7
06D18:  MOVLW  05
06D1A:  MOVLB  8
06D1C:  MOVWF  xF7
06D1E:  MOVLB  0
06D20:  CALL   150E
06D24:  MOVFF  279,8F7
06D28:  MOVLW  1B
06D2A:  MOVLB  8
06D2C:  MOVWF  xF8
06D2E:  MOVLB  0
06D30:  CALL   1564
06D34:  MOVLW  3F
06D36:  MOVWF  FF6
06D38:  MOVLW  02
06D3A:  MOVWF  FF7
06D3C:  MOVLW  06
06D3E:  MOVLB  8
06D40:  MOVWF  xF7
06D42:  MOVLB  0
06D44:  CALL   150E
06D48:  MOVFF  27B,8F6
06D4C:  MOVLW  18
06D4E:  MOVLB  8
06D50:  MOVWF  xF7
06D52:  MOVLB  0
06D54:  GOTO   15E6
....................    lcd_gotoxy(1,2); 
06D58:  MOVLW  01
06D5A:  MOVLB  8
06D5C:  MOVWF  xFD
06D5E:  MOVLW  02
06D60:  MOVWF  xFE
06D62:  MOVLB  0
06D64:  CALL   05DC
....................    printf(lcd_putc,"Restan:%u ",(dia_limite-dias_prueba) ); 
06D68:  MOVLW  5A
06D6A:  BSF    FD8.0
06D6C:  MOVLB  2
06D6E:  SUBFWB x79,W
06D70:  MOVLB  8
06D72:  MOVWF  xF6
06D74:  MOVLW  48
06D76:  MOVWF  FF6
06D78:  MOVLW  02
06D7A:  MOVWF  FF7
06D7C:  MOVLW  07
06D7E:  MOVWF  xF7
06D80:  MOVLB  0
06D82:  CALL   150E
06D86:  MOVFF  8F6,8F7
06D8A:  MOVLW  1B
06D8C:  MOVLB  8
06D8E:  MOVWF  xF8
06D90:  MOVLB  0
06D92:  CALL   1564
06D96:  MOVLW  20
06D98:  MOVLB  8
06D9A:  MOVWF  xFC
06D9C:  MOVLB  0
06D9E:  CALL   0630
....................    delay_ms(1000); 
06DA2:  MOVLW  04
06DA4:  MOVLB  8
06DA6:  MOVWF  xF6
06DA8:  MOVLW  FA
06DAA:  MOVWF  xFD
06DAC:  MOVLB  0
06DAE:  CALL   05B2
06DB2:  MOVLB  8
06DB4:  DECFSZ xF6,F
06DB6:  BRA    6DA8
....................    setup_wdt(WDT_ON); 
06DB8:  BSF    FD1.0
....................    ////////////////// 
....................    hrs2=espera=fmensaje=0; 
06DBA:  MOVLB  3
06DBC:  CLRF   x4D
06DBE:  MOVFF  34D,27D
06DC2:  MOVFF  27D,27E
....................    reset(); 
06DC6:  MOVLB  0
06DC8:  GOTO   16E0
....................    while(TRUE) { 
....................       restart_wdt(); 
06DCC:  CLRWDT
....................       StackTask(); 
06DCE:  CALL   44CE
....................       MyTCPTask(); 
06DD2:  CALL   5304
....................       if( (dias_prueba>dia_limite)&&(pago!=1) ){//pruebas 
06DD6:  MOVLB  2
06DD8:  MOVF   x79,W
06DDA:  SUBLW  5A
06DDC:  BC    6EAA
06DDE:  DECFSZ x7B,W
06DE0:  BRA    6DE4
06DE2:  BRA    6EAA
....................          lcd_gotoxy(1,1); 
06DE4:  MOVLW  01
06DE6:  MOVLB  8
06DE8:  MOVWF  xFD
06DEA:  MOVWF  xFE
06DEC:  MOVLB  0
06DEE:  CALL   05DC
....................          lcd_putc("TIEMPO DE PRUEBA"); 
06DF2:  MOVLW  54
06DF4:  MOVWF  FF6
06DF6:  MOVLW  02
06DF8:  MOVWF  FF7
06DFA:  CALL   0694
....................          lcd_gotoxy(1,2); 
06DFE:  MOVLW  01
06E00:  MOVLB  8
06E02:  MOVWF  xFD
06E04:  MOVLW  02
06E06:  MOVWF  xFE
06E08:  MOVLB  0
06E0A:  CALL   05DC
....................          lcd_putc("  HA EXPIRADO   "); 
06E0E:  MOVLW  66
06E10:  MOVWF  FF6
06E12:  MOVLW  02
06E14:  MOVWF  FF7
06E16:  CALL   0694
....................          if(edo_str){ 
06E1A:  MOVF   4E,F
06E1C:  BZ    6EA4
....................             edo_str=0; 
06E1E:  CLRF   4E
....................             strcpy(XX,rxtcp); 
06E20:  CLRF   FEA
06E22:  MOVLW  52
06E24:  MOVWF  FE9
06E26:  MOVLW  01
06E28:  MOVWF  FE2
06E2A:  MOVLW  60
06E2C:  MOVWF  FE1
06E2E:  MOVF   FE7,F
06E30:  MOVFF  FE6,FEE
06E34:  BNZ   6E2E
....................             if( (XX[0]=='P')&&(XX[1]=='A')&&(XX[2]=='G')&&(XX[3]=='A')&&(XX[4]=='D')&&(XX[5]=='O') ){ 
06E36:  MOVF   52,W
06E38:  SUBLW  50
06E3A:  BNZ   6EA4
06E3C:  MOVF   53,W
06E3E:  SUBLW  41
06E40:  BNZ   6EA4
06E42:  MOVF   54,W
06E44:  SUBLW  47
06E46:  BNZ   6EA4
06E48:  MOVF   55,W
06E4A:  SUBLW  41
06E4C:  BNZ   6EA4
06E4E:  MOVF   56,W
06E50:  SUBLW  44
06E52:  BNZ   6EA4
06E54:  MOVF   57,W
06E56:  SUBLW  4F
06E58:  BNZ   6EA4
....................                pago=1; 
06E5A:  MOVLW  01
06E5C:  MOVLB  2
06E5E:  MOVWF  x7B
....................                write_ext_eeprom(11,pago);// 
06E60:  MOVLB  9
06E62:  CLRF   x07
06E64:  MOVLW  0B
06E66:  MOVWF  x06
06E68:  MOVFF  27B,908
06E6C:  MOVLB  0
06E6E:  CALL   1408
....................                strcpy (txtcp, "BOLETERA_PAGADO"); 
06E72:  MOVLW  01
06E74:  MOVWF  FEA
06E76:  MOVLW  06
06E78:  MOVWF  FE9
06E7A:  MOVLW  00
06E7C:  CALL   00E6
06E80:  TBLRD*-
06E82:  TBLRD*+
06E84:  MOVF   FF5,W
06E86:  MOVWF  FEE
06E88:  IORLW  00
06E8A:  BNZ   6E82
....................                size_tx_tcp=strlen(txtcp); 
06E8C:  MOVLW  01
06E8E:  MOVLB  9
06E90:  MOVWF  x0C
06E92:  MOVLW  06
06E94:  MOVWF  x0B
06E96:  MOVLB  0
06E98:  CALL   5670
06E9C:  MOVFF  01,48
....................                enviar_tcp(); 
06EA0:  CALL   56AC
....................             } 
....................          } 
....................       } 
06EA4:  GOTO   75B2
06EA8:  MOVLB  2
....................       else{ 
....................          wiegand_read_card(); 
06EAA:  MOVLB  0
06EAC:  GOTO   5762
....................          //sensores(); 
....................          if(edo_str){//bandera de dato recibido en socket actual 
06EB0:  MOVF   4E,F
06EB2:  BTFSC  FD8.2
06EB4:  BRA    714E
....................             edo_str=0; 
06EB6:  CLRF   4E
....................             //fprintf(DEBUG,"\r\nrxtcp:%s",rxtcp); 
....................             //printf(lcd_putc,"\frxtcp:%s",rxtcp); 
....................             strcpy(XX,rxtcp); 
06EB8:  CLRF   FEA
06EBA:  MOVLW  52
06EBC:  MOVWF  FE9
06EBE:  MOVLW  01
06EC0:  MOVWF  FE2
06EC2:  MOVLW  60
06EC4:  MOVWF  FE1
06EC6:  MOVF   FE7,F
06EC8:  MOVFF  FE6,FEE
06ECC:  BNZ   6EC6
....................             //fprintf(U1PRINTER,"\frxtcp:%s",XX); 
....................             rd_eeprom(); 
06ECE:  GOTO   58E6
....................             //lcd_gotoxy(1,3); 
....................             //printf(lcd_putc,"rxtcp:%s",rxtcp); 
....................             //lcd_gotoxy(1,4); 
....................             //printf(lcd_putc,"b:%Ld                ",b); 
....................             switch (b) { 
06ED2:  MOVFF  44,00
06ED6:  MOVF   45,W
06ED8:  MOVWF  03
06EDA:  BNZ   6EE2
06EDC:  MOVLW  01
06EDE:  SUBWF  00,W
06EE0:  BZ    6F6A
06EE2:  MOVF   03,W
06EE4:  BNZ   6EEE
06EE6:  MOVLW  02
06EE8:  SUBWF  00,W
06EEA:  BTFSC  FD8.2
06EEC:  BRA    6F9C
06EEE:  MOVF   03,W
06EF0:  BNZ   6EF8
06EF2:  MOVLW  03
06EF4:  SUBWF  00,W
06EF6:  BZ    6F9E
06EF8:  MOVF   03,W
06EFA:  BNZ   6F02
06EFC:  MOVLW  04
06EFE:  SUBWF  00,W
06F00:  BZ    6FA0
06F02:  MOVF   03,W
06F04:  BNZ   6F0C
06F06:  MOVLW  05
06F08:  SUBWF  00,W
06F0A:  BZ    6FBA
06F0C:  MOVF   03,W
06F0E:  BNZ   6F16
06F10:  MOVLW  06
06F12:  SUBWF  00,W
06F14:  BZ    6FBC
06F16:  MOVF   03,W
06F18:  BNZ   6F20
06F1A:  MOVLW  07
06F1C:  SUBWF  00,W
06F1E:  BZ    6FBE
06F20:  MOVF   03,W
06F22:  BNZ   6F2C
06F24:  MOVLW  08
06F26:  SUBWF  00,W
06F28:  BTFSC  FD8.2
06F2A:  BRA    70F6
06F2C:  MOVF   03,W
06F2E:  BNZ   6F38
06F30:  MOVLW  09
06F32:  SUBWF  00,W
06F34:  BTFSC  FD8.2
06F36:  BRA    70F8
06F38:  MOVF   03,W
06F3A:  BNZ   6F44
06F3C:  MOVLW  0A
06F3E:  SUBWF  00,W
06F40:  BTFSC  FD8.2
06F42:  BRA    70FA
06F44:  MOVF   03,W
06F46:  BNZ   6F50
06F48:  MOVLW  0B
06F4A:  SUBWF  00,W
06F4C:  BTFSC  FD8.2
06F4E:  BRA    7100
06F50:  MOVF   03,W
06F52:  BNZ   6F5C
06F54:  MOVLW  0D
06F56:  SUBWF  00,W
06F58:  BTFSC  FD8.2
06F5A:  BRA    7102
06F5C:  MOVF   03,W
06F5E:  BNZ   6F68
06F60:  MOVLW  0E
06F62:  SUBWF  00,W
06F64:  BTFSC  FD8.2
06F66:  BRA    7104
06F68:  BRA    714E
....................               case 1: {//IMPRIMIR BOLETO 
....................                   espera=1; 
06F6A:  MOVLW  01
06F6C:  MOVLB  2
06F6E:  MOVWF  x7D
....................                   printf(lcd_putc,"\f\n   TOME SU BOLETO\n Y AVANCE POR FAVOR"); 
06F70:  MOVLW  78
06F72:  MOVWF  FF6
06F74:  MOVLW  02
06F76:  MOVWF  FF7
06F78:  MOVLB  0
06F7A:  CALL   0694
....................                   ticket(); 
06F7E:  GOTO   5D4C
....................                   output_high(salida01);//abre entrada 
06F82:  BCF    F92.5
06F84:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
06F86:  BCF    F96.0
06F88:  BSF    F8D.0
....................                   relay1=1; 
06F8A:  MOVLW  01
06F8C:  MOVWF  1D
....................                   time_relay1=0; 
06F8E:  CLRF   1F
....................                   flag_pluma=1; 
06F90:  MOVLB  2
06F92:  MOVWF  x88
....................                   //sprintf(txtcp,barra_codi);//CONFIRMACION DE BOLETO IMPRESO 
....................                   //size_tx_tcp=strlen(txtcp); 
....................                   //enviar_tcp(); 
....................                   cta_lcd=0; 
06F94:  CLRF   x8B
....................                   re_bol=1; 
06F96:  MOVWF  x8A
....................                   break;} 
06F98:  MOVLB  0
06F9A:  BRA    714E
....................               case 2: {//VIGENCIA POR VENCER O VENCIDA 
....................                   break;} 
06F9C:  BRA    714E
....................               case 3: {//no activa en entrada 
....................                   break;} 
06F9E:  BRA    714E
....................               case 4: {//ABRIR ENTRADA 
....................                   //lcd_putc("\f\n     BIENVENIDO"); 
....................                   output_high(salida01);//abre entrada 
06FA0:  BCF    F92.5
06FA2:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
06FA4:  BCF    F96.0
06FA6:  BSF    F8D.0
....................                   flag_pluma=1; 
06FA8:  MOVLW  01
06FAA:  MOVLB  2
06FAC:  MOVWF  x88
....................                   relay1=1; 
06FAE:  MOVWF  1D
....................                   time_relay1=0; 
06FB0:  CLRF   1F
....................                   b=0; 
06FB2:  CLRF   45
06FB4:  CLRF   44
....................                   break;} 
06FB6:  MOVLB  0
06FB8:  BRA    714E
....................               case 5: {//CUPO LLENO 
....................                   break;} 
06FBA:  BRA    714E
....................               case 6: {//ACTIVA BOLETOS 
....................                   break;} 
06FBC:  BRA    714E
....................               case 7: {//MENSAJES DE LCD 
....................                      memset(lcd_men, 0, sizeof(lcd_men) ); 
06FBE:  MOVLW  01
06FC0:  MOVWF  FEA
06FC2:  MOVLW  BA
06FC4:  MOVWF  FE9
06FC6:  CLRF   00
06FC8:  CLRF   02
06FCA:  MOVLW  50
06FCC:  MOVWF  01
06FCE:  CALL   5748
....................                      for(i=0;i<strlen(XX);i++) lcd_men[i]=XX[instruccion_size+i]; 
06FD2:  CLRF   41
06FD4:  CLRF   40
06FD6:  MOVLB  9
06FD8:  CLRF   x0C
06FDA:  MOVLW  52
06FDC:  MOVWF  x0B
06FDE:  MOVLB  0
06FE0:  CALL   5670
06FE4:  MOVFF  02,03
06FE8:  MOVF   41,W
06FEA:  SUBWF  02,W
06FEC:  BNC   7030
06FEE:  BNZ   6FF6
06FF0:  MOVF   01,W
06FF2:  SUBWF  40,W
06FF4:  BC    7030
06FF6:  MOVLW  BA
06FF8:  ADDWF  40,W
06FFA:  MOVWF  01
06FFC:  MOVLW  01
06FFE:  ADDWFC 41,W
07000:  MOVWF  03
07002:  MOVFF  01,8F6
07006:  MOVLB  8
07008:  MOVWF  xF7
0700A:  MOVLW  5C
0700C:  ADDWF  40,W
0700E:  MOVWF  FE9
07010:  MOVLW  00
07012:  ADDWFC 41,W
07014:  MOVWF  FEA
07016:  MOVFF  FEF,8FA
0701A:  MOVFF  03,FEA
0701E:  MOVFF  01,FE9
07022:  MOVFF  8FA,FEF
07026:  INCF   40,F
07028:  BTFSC  FD8.2
0702A:  INCF   41,F
0702C:  MOVLB  0
0702E:  BRA    6FD6
....................                      lcd_putc("\f"); 
07030:  MOVLW  A0
07032:  MOVWF  FF6
07034:  MOVLW  02
07036:  MOVWF  FF7
07038:  CALL   0694
....................                      for(i=0;i<strlen(lcd_men);i++){ 
0703C:  CLRF   41
0703E:  CLRF   40
07040:  MOVLW  01
07042:  MOVLB  9
07044:  MOVWF  x0C
07046:  MOVLW  BA
07048:  MOVWF  x0B
0704A:  MOVLB  0
0704C:  CALL   5670
07050:  MOVFF  02,03
07054:  MOVF   41,W
07056:  SUBWF  02,W
07058:  BNC   70EA
0705A:  BNZ   7062
0705C:  MOVF   01,W
0705E:  SUBWF  40,W
07060:  BC    70EA
....................                         if(i==0)lcd_gotoxy(1,1); 
07062:  MOVF   40,F
07064:  BTFSS  FD8.2
07066:  BRA    707C
07068:  MOVF   41,F
0706A:  BNZ   707C
0706C:  MOVLW  01
0706E:  MOVLB  8
07070:  MOVWF  xFD
07072:  MOVWF  xFE
07074:  MOVLB  0
07076:  CALL   05DC
0707A:  BRA    70CE
....................                         else if(i==20) lcd_gotoxy(1,2); 
0707C:  MOVF   40,W
0707E:  SUBLW  14
07080:  BNZ   7098
07082:  MOVF   41,F
07084:  BNZ   7098
07086:  MOVLW  01
07088:  MOVLB  8
0708A:  MOVWF  xFD
0708C:  MOVLW  02
0708E:  MOVWF  xFE
07090:  MOVLB  0
07092:  CALL   05DC
07096:  BRA    70CE
....................                         else if(i==40) lcd_gotoxy(1,3); 
07098:  MOVF   40,W
0709A:  SUBLW  28
0709C:  BNZ   70B4
0709E:  MOVF   41,F
070A0:  BNZ   70B4
070A2:  MOVLW  01
070A4:  MOVLB  8
070A6:  MOVWF  xFD
070A8:  MOVLW  03
070AA:  MOVWF  xFE
070AC:  MOVLB  0
070AE:  CALL   05DC
070B2:  BRA    70CE
....................                         else if(i==60) lcd_gotoxy(1,4); 
070B4:  MOVF   40,W
070B6:  SUBLW  3C
070B8:  BNZ   70CE
070BA:  MOVF   41,F
070BC:  BNZ   70CE
070BE:  MOVLW  01
070C0:  MOVLB  8
070C2:  MOVWF  xFD
070C4:  MOVLW  04
070C6:  MOVWF  xFE
070C8:  MOVLB  0
070CA:  CALL   05DC
....................                         printf(lcd_putc,"%c",lcd_men[i]); 
070CE:  MOVLW  BA
070D0:  ADDWF  40,W
070D2:  MOVWF  FE9
070D4:  MOVLW  01
070D6:  ADDWFC 41,W
070D8:  MOVWF  FEA
070DA:  MOVFF  FEF,8FC
070DE:  CALL   0630
070E2:  INCF   40,F
070E4:  BTFSC  FD8.2
070E6:  INCF   41,F
070E8:  BRA    7040
....................                      } 
....................                      espera=1; 
070EA:  MOVLW  01
070EC:  MOVLB  2
070EE:  MOVWF  x7D
....................                      cta_lcd=0; 
070F0:  CLRF   x8B
....................                      break;}// 
070F2:  MOVLB  0
070F4:  BRA    714E
....................               case 8: {//MOITOREO DESACTIVADO 
....................                      break;}// 
070F6:  BRA    714E
....................               case 9: {//CONSULTA ENTRADAS SIN CONEXION 
....................                   break;} 
070F8:  BRA    714E
....................               case 10:{//CONFIGURA FECHA Y HORA 
....................                   fecha(); 
070FA:  GOTO   6468
....................                   break;} 
070FE:  BRA    714E
....................               case 11:{//ultima conexion 
....................                   break;} 
07100:  BRA    714E
....................               case 13:{//RESET DE FOLIOS 
....................                   break;} 
07102:  BRA    714E
....................               case 14:{//PAGO EFECTUADO 
....................                   pago=1; 
07104:  MOVLW  01
07106:  MOVLB  2
07108:  MOVWF  x7B
....................                   write_ext_eeprom(11,pago);// 
0710A:  MOVLB  9
0710C:  CLRF   x07
0710E:  MOVLW  0B
07110:  MOVWF  x06
07112:  MOVFF  27B,908
07116:  MOVLB  0
07118:  CALL   1408
....................                   strcpy (txtcp, "BOLETERA_PAGADO"); 
0711C:  MOVLW  01
0711E:  MOVWF  FEA
07120:  MOVLW  06
07122:  MOVWF  FE9
07124:  MOVLW  00
07126:  CALL   00E6
0712A:  TBLRD*-
0712C:  TBLRD*+
0712E:  MOVF   FF5,W
07130:  MOVWF  FEE
07132:  IORLW  00
07134:  BNZ   712C
....................                   size_tx_tcp=strlen(txtcp); 
07136:  MOVLW  01
07138:  MOVLB  9
0713A:  MOVWF  x0C
0713C:  MOVLW  06
0713E:  MOVWF  x0B
07140:  MOVLB  0
07142:  CALL   5670
07146:  MOVFF  01,48
....................                   enviar_tcp(); 
0714A:  CALL   56AC
....................                   break;} 
....................             }//end switch 
....................          }//end dato recibido tcp 
....................          ////////////////////////////////////// 
....................          if( (relay1)&&(time_relay1>=21) ){ 
0714E:  MOVF   1D,F
07150:  BZ    7162
07152:  MOVF   1F,W
07154:  SUBLW  14
07156:  BC    7162
....................             relay1=0; 
07158:  CLRF   1D
....................             output_low(salida01); 
0715A:  BCF    F92.5
0715C:  BCF    F89.5
....................             output_low(salida02); 
0715E:  BCF    F96.0
07160:  BCF    F8D.0
....................          } 
....................          //if( (time_boleto>60)&&(re_bol) )  re_bol=0; 
....................           
....................          if( (espera)&&(cta_lcd>=100) ) espera=0; 
07162:  MOVLB  2
07164:  MOVF   x7D,F
07166:  BZ    7170
07168:  MOVF   x8B,W
0716A:  SUBLW  63
0716C:  BC    7170
0716E:  CLRF   x7D
....................           
....................          if( (cuenta>=20)&&(espera==0) ){//CADA 2 SEGUNDOS VERIFICA FECHA Y HORA 
07170:  MOVF   x7C,W
07172:  SUBLW  13
07174:  BTFSC  FD8.0
07176:  BRA    75B0
07178:  MOVF   x7D,F
0717A:  BTFSS  FD8.2
0717C:  BRA    75B0
....................              ds1307_get_time(hrs,min,sec); 
....................              ds1307_get_date(day,month,yr,dow); 
....................              if(hrs2!=hrs){ 
*
07358:  MOVLB  2
0735A:  MOVF   x73,W
0735C:  SUBWF  x7E,W
0735E:  BZ    73B0
....................                dia=31;//ultimo dia del mes 
07360:  CLRF   x82
07362:  MOVLW  1F
07364:  MOVWF  x81
....................                mes2=10;//octubre, mes en el que cambia horario invierno 
07366:  CLRF   x80
07368:  MOVLW  0A
0736A:  MOVWF  x7F
....................                zeller(); 
0736C:  MOVLB  0
0736E:  GOTO   65D4
....................                hrs2=hrs; 
07372:  MOVFF  273,27E
....................                if( (dia_temp!=day)&&(pago!=1) ){ 
07376:  MOVLB  2
07378:  MOVF   x70,W
0737A:  SUBWF  x7A,W
0737C:  BZ    73B0
0737E:  DECFSZ x7B,W
07380:  BRA    7384
07382:  BRA    73B0
....................                   dia_temp=day; 
07384:  MOVFF  270,27A
....................                   dias_prueba++; 
07388:  INCF   x79,F
....................                   write_ext_eeprom(12,dias_prueba);//dias de prueba 
0738A:  MOVLB  9
0738C:  CLRF   x07
0738E:  MOVLW  0C
07390:  MOVWF  x06
07392:  MOVFF  279,908
07396:  MOVLB  0
07398:  CALL   1408
....................                   write_ext_eeprom(13,dia_temp);// 
0739C:  MOVLB  9
0739E:  CLRF   x07
073A0:  MOVLW  0D
073A2:  MOVWF  x06
073A4:  MOVFF  27A,908
073A8:  MOVLB  0
073AA:  CALL   1408
073AE:  MOVLB  2
....................                } 
....................              }//FIN CONFIGURA AUTMATICO FECHA Y HORA 
....................              //cuenta_lcd=0; 
....................              puntos=!puntos; 
073B0:  MOVF   x77,F
073B2:  BZ    73B8
073B4:  MOVLW  00
073B6:  BRA    73BA
073B8:  MOVLW  01
073BA:  MOVWF  x77
....................              if( (!espera)&&(!en1) ){ 
073BC:  MOVF   x7D,F
073BE:  BTFSS  FD8.2
073C0:  BRA    75AE
073C2:  MOVF   x83,F
073C4:  BTFSS  FD8.2
073C6:  BRA    75AE
....................                lcd_gotoxy(1,1); 
073C8:  MOVLW  01
073CA:  MOVLB  8
073CC:  MOVWF  xFD
073CE:  MOVWF  xFE
073D0:  MOVLB  0
073D2:  CALL   05DC
....................                lcd_putc("                    "); 
073D6:  MOVLW  A2
073D8:  MOVWF  FF6
073DA:  MOVLW  02
073DC:  MOVWF  FF7
073DE:  CALL   0694
....................                lcd_gotoxy(1,2);//printf(lcd_putc,"  %02d %02d %02d %02d/%02d/%02d   ",hrs_e,min_e,sec_e,day_e,month,yr); 
073E2:  MOVLW  01
073E4:  MOVLB  8
073E6:  MOVWF  xFD
073E8:  MOVLW  02
073EA:  MOVWF  xFE
073EC:  MOVLB  0
073EE:  CALL   05DC
....................                if(puntos==0)   printf(lcd_putc,"   %02d %02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
073F2:  MOVLB  2
073F4:  MOVF   x77,F
073F6:  BNZ   74A4
073F8:  MOVLW  B8
073FA:  MOVWF  FF6
073FC:  MOVLW  02
073FE:  MOVWF  FF7
07400:  MOVLW  03
07402:  MOVLB  8
07404:  MOVWF  xF7
07406:  MOVLB  0
07408:  CALL   150E
0740C:  MOVFF  273,8F6
07410:  MOVLW  01
07412:  MOVLB  8
07414:  MOVWF  xF7
07416:  MOVLB  0
07418:  CALL   69A6
0741C:  MOVLW  20
0741E:  MOVLB  8
07420:  MOVWF  xFC
07422:  MOVLB  0
07424:  CALL   0630
07428:  MOVFF  274,8F6
0742C:  MOVLW  01
0742E:  MOVLB  8
07430:  MOVWF  xF7
07432:  MOVLB  0
07434:  CALL   69A6
07438:  MOVLW  20
0743A:  MOVLB  8
0743C:  MOVWF  xFC
0743E:  MOVLB  0
07440:  CALL   0630
07444:  MOVFF  270,8F6
07448:  MOVLW  01
0744A:  MOVLB  8
0744C:  MOVWF  xF7
0744E:  MOVLB  0
07450:  CALL   69A6
07454:  MOVLW  2F
07456:  MOVLB  8
07458:  MOVWF  xFC
0745A:  MOVLB  0
0745C:  CALL   0630
07460:  MOVFF  271,8F6
07464:  MOVLW  01
07466:  MOVLB  8
07468:  MOVWF  xF7
0746A:  MOVLB  0
0746C:  CALL   69A6
07470:  MOVLW  2F
07472:  MOVLB  8
07474:  MOVWF  xFC
07476:  MOVLB  0
07478:  CALL   0630
0747C:  MOVFF  272,8F6
07480:  MOVLW  01
07482:  MOVLB  8
07484:  MOVWF  xF7
07486:  MOVLB  0
07488:  CALL   69A6
0748C:  MOVLW  D3
0748E:  MOVWF  FF6
07490:  MOVLW  02
07492:  MOVWF  FF7
07494:  MOVLW  04
07496:  MOVLB  8
07498:  MOVWF  xF7
0749A:  MOVLB  0
0749C:  CALL   150E
074A0:  BRA    754C
074A2:  MOVLB  2
....................                else   printf(lcd_putc,"   %02d:%02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
074A4:  MOVLW  D8
074A6:  MOVWF  FF6
074A8:  MOVLW  02
074AA:  MOVWF  FF7
074AC:  MOVLW  03
074AE:  MOVLB  8
074B0:  MOVWF  xF7
074B2:  MOVLB  0
074B4:  CALL   150E
074B8:  MOVFF  273,8F6
074BC:  MOVLW  01
074BE:  MOVLB  8
074C0:  MOVWF  xF7
074C2:  MOVLB  0
074C4:  CALL   69A6
074C8:  MOVLW  3A
074CA:  MOVLB  8
074CC:  MOVWF  xFC
074CE:  MOVLB  0
074D0:  CALL   0630
074D4:  MOVFF  274,8F6
074D8:  MOVLW  01
074DA:  MOVLB  8
074DC:  MOVWF  xF7
074DE:  MOVLB  0
074E0:  CALL   69A6
074E4:  MOVLW  20
074E6:  MOVLB  8
074E8:  MOVWF  xFC
074EA:  MOVLB  0
074EC:  CALL   0630
074F0:  MOVFF  270,8F6
074F4:  MOVLW  01
074F6:  MOVLB  8
074F8:  MOVWF  xF7
074FA:  MOVLB  0
074FC:  CALL   69A6
07500:  MOVLW  2F
07502:  MOVLB  8
07504:  MOVWF  xFC
07506:  MOVLB  0
07508:  CALL   0630
0750C:  MOVFF  271,8F6
07510:  MOVLW  01
07512:  MOVLB  8
07514:  MOVWF  xF7
07516:  MOVLB  0
07518:  CALL   69A6
0751C:  MOVLW  2F
0751E:  MOVLB  8
07520:  MOVWF  xFC
07522:  MOVLB  0
07524:  CALL   0630
07528:  MOVFF  272,8F6
0752C:  MOVLW  01
0752E:  MOVLB  8
07530:  MOVWF  xF7
07532:  MOVLB  0
07534:  CALL   69A6
07538:  MOVLW  F3
0753A:  MOVWF  FF6
0753C:  MOVLW  02
0753E:  MOVWF  FF7
07540:  MOVLW  04
07542:  MOVLB  8
07544:  MOVWF  xF7
07546:  MOVLB  0
07548:  CALL   150E
....................                cambio_msj++; 
0754C:  MOVLB  2
0754E:  INCF   x78,F
....................                lcd_gotoxy(1,3); 
07550:  MOVLW  01
07552:  MOVLB  8
07554:  MOVWF  xFD
07556:  MOVLW  03
07558:  MOVWF  xFE
0755A:  MOVLB  0
0755C:  CALL   05DC
....................                if(cambio_msj>=10) lcd_putc("   WWW.ACCESA.ME    ");//COMPLEJO CITY ANGELÓPOLIS   
07560:  MOVLB  2
07562:  MOVF   x78,W
07564:  SUBLW  09
07566:  BC    757A
07568:  MOVLW  F8
0756A:  MOVWF  FF6
0756C:  MOVLW  02
0756E:  MOVWF  FF7
07570:  MOVLB  0
07572:  CALL   0694
07576:  BRA    7588
07578:  MOVLB  2
....................                else lcd_putc("       ACCESA       "); 
0757A:  MOVLW  0E
0757C:  MOVWF  FF6
0757E:  MOVLW  03
07580:  MOVWF  FF7
07582:  MOVLB  0
07584:  CALL   0694
....................                lcd_gotoxy(1,4); 
07588:  MOVLW  01
0758A:  MOVLB  8
0758C:  MOVWF  xFD
0758E:  MOVLW  04
07590:  MOVWF  xFE
07592:  MOVLB  0
07594:  CALL   05DC
....................                lcd_putc("                    "); 
07598:  MOVLW  24
0759A:  MOVWF  FF6
0759C:  MOVLW  03
0759E:  MOVWF  FF7
075A0:  CALL   0694
....................                if(cambio_msj>=20) cambio_msj=0; 
075A4:  MOVLB  2
075A6:  MOVF   x78,W
075A8:  SUBLW  13
075AA:  BC    75AE
075AC:  CLRF   x78
....................              } 
....................              cuenta=0; 
075AE:  CLRF   x7C
075B0:  MOVLB  0
....................          }//END SEGUNDO 
....................       } 
....................       //if( (MACIsLinked()==0)&&(inicializado)&&(linked_out==0) ){//cable off 
....................       if( (MACIsLinked()==0)&&(inicializado) ){//cable off 
075B2:  GOTO   6A72
075B6:  MOVF   01,F
075B8:  BNZ   75C6
075BA:  MOVF   50,F
075BC:  BZ    75C6
....................          //linked_out=1; 
....................          TCPDisconnect(socket2); 
075BE:  MOVFF  51,8FB
075C2:  CALL   50D6
....................       } 
075C6:  BRA    6DCC
....................       ////////////////////////////////////// 
....................    }//end true 
.................... }//end main 
....................  
075C8:  SLEEP 
.................... int convertir_to_entero(char *cadena){ 
*
062AC:  MOVLB  8
062AE:  CLRF   xF9
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
062B0:  MOVF   xF7,W
062B2:  SUBLW  30
062B4:  BNZ   62BE
062B6:  MOVF   xF8,F
062B8:  BNZ   62BE
062BA:  CLRF   xF9
062BC:  BRA    634C
....................    else if(cadena=='1') valor=1; 
062BE:  MOVF   xF7,W
062C0:  SUBLW  31
062C2:  BNZ   62CE
062C4:  MOVF   xF8,F
062C6:  BNZ   62CE
062C8:  MOVLW  01
062CA:  MOVWF  xF9
062CC:  BRA    634C
....................    else if(cadena=='2') valor=2; 
062CE:  MOVF   xF7,W
062D0:  SUBLW  32
062D2:  BNZ   62DE
062D4:  MOVF   xF8,F
062D6:  BNZ   62DE
062D8:  MOVLW  02
062DA:  MOVWF  xF9
062DC:  BRA    634C
....................    else if(cadena=='3') valor=3; 
062DE:  MOVF   xF7,W
062E0:  SUBLW  33
062E2:  BNZ   62EE
062E4:  MOVF   xF8,F
062E6:  BNZ   62EE
062E8:  MOVLW  03
062EA:  MOVWF  xF9
062EC:  BRA    634C
....................    else if(cadena=='4') valor=4; 
062EE:  MOVF   xF7,W
062F0:  SUBLW  34
062F2:  BNZ   62FE
062F4:  MOVF   xF8,F
062F6:  BNZ   62FE
062F8:  MOVLW  04
062FA:  MOVWF  xF9
062FC:  BRA    634C
....................    else if(cadena=='5') valor=5; 
062FE:  MOVF   xF7,W
06300:  SUBLW  35
06302:  BNZ   630E
06304:  MOVF   xF8,F
06306:  BNZ   630E
06308:  MOVLW  05
0630A:  MOVWF  xF9
0630C:  BRA    634C
....................    else if(cadena=='6') valor=6; 
0630E:  MOVF   xF7,W
06310:  SUBLW  36
06312:  BNZ   631E
06314:  MOVF   xF8,F
06316:  BNZ   631E
06318:  MOVLW  06
0631A:  MOVWF  xF9
0631C:  BRA    634C
....................    else if(cadena=='7') valor=7; 
0631E:  MOVF   xF7,W
06320:  SUBLW  37
06322:  BNZ   632E
06324:  MOVF   xF8,F
06326:  BNZ   632E
06328:  MOVLW  07
0632A:  MOVWF  xF9
0632C:  BRA    634C
....................    else if(cadena=='8') valor=8; 
0632E:  MOVF   xF7,W
06330:  SUBLW  38
06332:  BNZ   633E
06334:  MOVF   xF8,F
06336:  BNZ   633E
06338:  MOVLW  08
0633A:  MOVWF  xF9
0633C:  BRA    634C
....................    else if(cadena=='9') valor=9; 
0633E:  MOVF   xF7,W
06340:  SUBLW  39
06342:  BNZ   634C
06344:  MOVF   xF8,F
06346:  BNZ   634C
06348:  MOVLW  09
0634A:  MOVWF  xF9
....................    return valor; 
0634C:  MOVFF  8F9,01
06350:  MOVLB  0
06352:  RETURN 0
.................... } 
....................  
.................... void fecha(){//falta revisar si se deshabilitan las int globales 
....................    disable_interrupts(INT_RDA); 
*
06468:  BCF    F9D.5
....................    //delay_ms(1000); 
.................... //   lcd_gotoxy(1,2); 
.................... //   lcd_putc("\f     CONFIGURA      ");// 
.................... //   lcd_gotoxy(1,3); 
.................... //   lcd_putc("     FECHA/HORA     "); 
....................     
....................    setup_wdt(WDT_ON); 
0646A:  BSF    FD1.0
....................    restart_wdt(); 
0646C:  CLRWDT
....................     
....................    day=(convertir_to_entero(XX[instruccion_size])*10)+convertir_to_entero(XX[instruccion_size+1]); 
0646E:  MOVLB  8
06470:  CLRF   xF8
06472:  MOVFF  5C,8F7
06476:  MOVLB  0
06478:  RCALL  62AC
0647A:  MOVF   01,W
0647C:  MULLW  0A
0647E:  MOVFF  FF3,8F6
06482:  MOVLB  8
06484:  CLRF   xF8
06486:  MOVFF  5D,8F7
0648A:  MOVLB  0
0648C:  RCALL  62AC
0648E:  MOVF   01,W
06490:  MOVLB  8
06492:  ADDWF  xF6,W
06494:  MOVLB  2
06496:  MOVWF  x70
....................    hrs=(convertir_to_entero(XX[instruccion_size+7])*10)+convertir_to_entero(XX[instruccion_size+8]); 
06498:  MOVLB  8
0649A:  CLRF   xF8
0649C:  MOVFF  63,8F7
064A0:  MOVLB  0
064A2:  RCALL  62AC
064A4:  MOVF   01,W
064A6:  MULLW  0A
064A8:  MOVFF  FF3,8F6
064AC:  MOVLB  8
064AE:  CLRF   xF8
064B0:  MOVFF  64,8F7
064B4:  MOVLB  0
064B6:  RCALL  62AC
064B8:  MOVF   01,W
064BA:  MOVLB  8
064BC:  ADDWF  xF6,W
064BE:  MOVLB  2
064C0:  MOVWF  x73
....................    min=(convertir_to_entero(XX[instruccion_size+9])*10)+convertir_to_entero(XX[instruccion_size+10]); 
064C2:  MOVLB  8
064C4:  CLRF   xF8
064C6:  MOVFF  65,8F7
064CA:  MOVLB  0
064CC:  RCALL  62AC
064CE:  MOVF   01,W
064D0:  MULLW  0A
064D2:  MOVFF  FF3,8F6
064D6:  MOVLB  8
064D8:  CLRF   xF8
064DA:  MOVFF  66,8F7
064DE:  MOVLB  0
064E0:  RCALL  62AC
064E2:  MOVF   01,W
064E4:  MOVLB  8
064E6:  ADDWF  xF6,W
064E8:  MOVLB  2
064EA:  MOVWF  x74
....................    sec=(convertir_to_entero(XX[instruccion_size+11])*10)+convertir_to_entero(XX[instruccion_size+12]); 
064EC:  MOVLB  8
064EE:  CLRF   xF8
064F0:  MOVFF  67,8F7
064F4:  MOVLB  0
064F6:  RCALL  62AC
064F8:  MOVF   01,W
064FA:  MULLW  0A
064FC:  MOVFF  FF3,8F6
06500:  MOVLB  8
06502:  CLRF   xF8
06504:  MOVFF  68,8F7
06508:  MOVLB  0
0650A:  RCALL  62AC
0650C:  MOVF   01,W
0650E:  MOVLB  8
06510:  ADDWF  xF6,W
06512:  MOVLB  2
06514:  MOVWF  x75
....................     
....................    month=(convertir_to_entero(XX[instruccion_size+2])*10)+convertir_to_entero(XX[instruccion_size+3]); 
06516:  MOVLB  8
06518:  CLRF   xF8
0651A:  MOVFF  5E,8F7
0651E:  MOVLB  0
06520:  RCALL  62AC
06522:  MOVF   01,W
06524:  MULLW  0A
06526:  MOVFF  FF3,8F6
0652A:  MOVLB  8
0652C:  CLRF   xF8
0652E:  MOVFF  5F,8F7
06532:  MOVLB  0
06534:  RCALL  62AC
06536:  MOVF   01,W
06538:  MOVLB  8
0653A:  ADDWF  xF6,W
0653C:  MOVLB  2
0653E:  MOVWF  x71
....................    yr= (convertir_to_entero(XX[instruccion_size+4])*10)+convertir_to_entero(XX[instruccion_size+5]); 
06540:  MOVLB  8
06542:  CLRF   xF8
06544:  MOVFF  60,8F7
06548:  MOVLB  0
0654A:  RCALL  62AC
0654C:  MOVF   01,W
0654E:  MULLW  0A
06550:  MOVFF  FF3,8F6
06554:  MOVLB  8
06556:  CLRF   xF8
06558:  MOVFF  61,8F7
0655C:  MOVLB  0
0655E:  RCALL  62AC
06560:  MOVF   01,W
06562:  MOVLB  8
06564:  ADDWF  xF6,W
06566:  MOVLB  2
06568:  MOVWF  x72
....................    dow= convertir_to_entero(XX[instruccion_size+6]); 
0656A:  MOVLB  8
0656C:  CLRF   xF8
0656E:  MOVFF  62,8F7
06572:  MOVLB  0
06574:  RCALL  62AC
06576:  MOVFF  01,276
....................    ///////////////////// 
....................    ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos), ,hora,min,seg 
0657A:  MOVFF  270,906
0657E:  MOVFF  271,907
06582:  MOVFF  272,908
06586:  MOVFF  276,909
0658A:  MOVFF  273,90A
0658E:  MOVFF  274,90B
06592:  MOVFF  275,90C
06596:  RCALL  637C
....................    //lcd_gotoxy(1,1); 
....................    //printf(lcd_putc,"      %02d:%02d:%02d      ",hrs,min,sec); 
....................    //lcd_gotoxy(1,2); 
....................    //printf (lcd_putc,"     %02d/%02d/2%03d     ",day,month,yr); 
....................    //lcd_gotoxy(1,3); 
....................    //lcd_putc("  DATOS GUARDADOS   "); 
....................    lcd_gotoxy(1,4); 
06598:  MOVLW  01
0659A:  MOVLB  8
0659C:  MOVWF  xFD
0659E:  MOVLW  04
065A0:  MOVWF  xFE
065A2:  MOVLB  0
065A4:  CALL   05DC
....................    lcd_putc("  Hora Actualizada  "); 
065A8:  MOVLW  3A
065AA:  MOVWF  FF6
065AC:  MOVLW  03
065AE:  MOVWF  FF7
065B0:  CALL   0694
....................    delay_ms(2500); 
065B4:  MOVLW  0A
065B6:  MOVLB  8
065B8:  MOVWF  xF6
065BA:  MOVLW  FA
065BC:  MOVWF  xFD
065BE:  MOVLB  0
065C0:  CALL   05B2
065C4:  MOVLB  8
065C6:  DECFSZ xF6,F
065C8:  BRA    65BA
....................    restart_wdt(); 
065CA:  CLRWDT
....................    //if(demo==1) printf("\r\nXX:%s",XX); 
....................    enable_interrupts(INT_RDA); 
065CC:  BSF    F9D.5
065CE:  MOVLB  0
065D0:  GOTO   714E (RETURN)
.................... } 
....................  
.................... void wiegand_read_card(){ 
....................  if(wieg_full){ 
*
05762:  MOVLB  2
05764:  MOVF   x10,F
05766:  BTFSC  FD8.2
05768:  BRA    5894
....................    //disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
....................    deci=0; 
0576A:  CLRF   x15
0576C:  CLRF   x14
0576E:  CLRF   x13
05770:  CLRF   x12
....................    for(i=1;i<sub_indice-1;i++) deci = (deci<<1)|data[i]; 
05772:  CLRF   41
05774:  MOVLW  01
05776:  MOVWF  40
05778:  MOVLW  01
0577A:  SUBWF  x0F,W
0577C:  MOVF   41,F
0577E:  BNZ   57CE
05780:  SUBWF  40,W
05782:  BC    57CE
05784:  BCF    FD8.0
05786:  RLCF   x12,W
05788:  MOVLB  8
0578A:  MOVWF  xF7
0578C:  MOVLB  2
0578E:  RLCF   x13,W
05790:  MOVLB  8
05792:  MOVWF  xF8
05794:  MOVLB  2
05796:  RLCF   x14,W
05798:  MOVLB  8
0579A:  MOVWF  xF9
0579C:  MOVLB  2
0579E:  RLCF   x15,W
057A0:  MOVLB  8
057A2:  MOVWF  xFA
057A4:  MOVLW  16
057A6:  ADDWF  40,W
057A8:  MOVWF  FE9
057AA:  MOVLW  02
057AC:  ADDWFC 41,W
057AE:  MOVWF  FEA
057B0:  MOVF   FEF,W
057B2:  IORWF  xF7,W
057B4:  MOVLB  2
057B6:  MOVWF  x12
057B8:  MOVFF  8F8,213
057BC:  MOVFF  8F9,214
057C0:  MOVFF  8FA,215
057C4:  MOVLB  2
057C6:  INCF   40,F
057C8:  BTFSC  FD8.2
057CA:  INCF   41,F
057CC:  BRA    5778
....................    sprintf(YY,"%08LX",deci);// imprime en un arreglo (printf en ram) 
057CE:  MOVLB  8
057D0:  CLRF   xF4
057D2:  MOVLW  AC
057D4:  MOVWF  xF3
057D6:  MOVFF  215,8F6
057DA:  MOVLW  37
057DC:  MOVWF  xF7
057DE:  MOVLB  0
057E0:  RCALL  56D8
057E2:  MOVFF  214,8F6
057E6:  MOVLW  37
057E8:  MOVLB  8
057EA:  MOVWF  xF7
057EC:  MOVLB  0
057EE:  RCALL  56D8
057F0:  MOVFF  213,8F6
057F4:  MOVLW  37
057F6:  MOVLB  8
057F8:  MOVWF  xF7
057FA:  MOVLB  0
057FC:  RCALL  56D8
057FE:  MOVFF  212,8F6
05802:  MOVLW  37
05804:  MOVLB  8
05806:  MOVWF  xF7
05808:  MOVLB  0
0580A:  RCALL  56D8
....................    sprintf(txtcp,"SA1-%08LX",deci);// imprime en un arreglo (printf en ram) 
0580C:  MOVLW  01
0580E:  MOVLB  8
05810:  MOVWF  xF4
05812:  MOVLW  06
05814:  MOVWF  xF3
05816:  MOVLW  50
05818:  MOVWF  FF6
0581A:  MOVLW  03
0581C:  MOVWF  FF7
0581E:  MOVLW  04
05820:  MOVWF  xF6
05822:  MOVLB  0
05824:  BRA    571E
05826:  MOVFF  215,8F6
0582A:  MOVLW  37
0582C:  MOVLB  8
0582E:  MOVWF  xF7
05830:  MOVLB  0
05832:  RCALL  56D8
05834:  MOVFF  214,8F6
05838:  MOVLW  37
0583A:  MOVLB  8
0583C:  MOVWF  xF7
0583E:  MOVLB  0
05840:  RCALL  56D8
05842:  MOVFF  213,8F6
05846:  MOVLW  37
05848:  MOVLB  8
0584A:  MOVWF  xF7
0584C:  MOVLB  0
0584E:  RCALL  56D8
05850:  MOVFF  212,8F6
05854:  MOVLW  37
05856:  MOVLB  8
05858:  MOVWF  xF7
0585A:  MOVLB  0
0585C:  RCALL  56D8
....................    //fprintf(DEBUG,"TA:%s\r\n",txtcp); 
....................    //lcd_gotoxy(1,3); 
....................    //printf(lcd_putc,"TA:%s",txtcp); 
....................    size_tx_tcp=strlen(txtcp); 
0585E:  MOVLW  01
05860:  MOVLB  9
05862:  MOVWF  x0C
05864:  MOVLW  06
05866:  MOVWF  x0B
05868:  MOVLB  0
0586A:  RCALL  5670
0586C:  MOVFF  01,48
....................    enviar_tcp(); 
05870:  RCALL  56AC
....................    //validar_tag_salida();//FUNCION PARA ABRIR AUTOMATICAMENTE Y GUARDAR ESTADO DE ANTIPASS 
....................    wieg_full=0; 
05872:  MOVLB  2
05874:  CLRF   x10
....................    wieg=sub_indice=0; 
05876:  CLRF   x0F
05878:  MOVFF  20F,20C
....................    wiegand_cuenta=0; 
0587C:  CLRF   x11
....................    memset(data, 0, sizeof(data) ); 
0587E:  MOVLW  02
05880:  MOVWF  FEA
05882:  MOVLW  16
05884:  MOVWF  FE9
05886:  CLRF   00
05888:  CLRF   02
0588A:  MOVLW  1A
0588C:  MOVWF  01
0588E:  MOVLB  0
05890:  RCALL  5748
05892:  MOVLB  2
....................  }//END TARJETA LEIDA 
....................  if( (wieg==1)&&(wiegand_cuenta>=3) ) { 
05894:  DECFSZ x0C,W
05896:  BRA    58E0
05898:  MOVF   x11,W
0589A:  SUBLW  02
0589C:  BC    58E0
....................       wigmal++; 
0589E:  INCF   x0D,F
....................       //fprintf(DEBUG,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_gotoxy(1,4); 
....................       //printf(lcd_putc,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_putc("CAPTURA INCOMPLETA  "); 
....................       wieg_full=0; 
058A0:  CLRF   x10
....................       deci=0; 
058A2:  CLRF   x15
058A4:  CLRF   x14
058A6:  CLRF   x13
058A8:  CLRF   x12
....................       ///////////UNIFICANDO EL TAMAÑO DEL DATO LEIDO///////////////// 
....................       deteccion_nulo=0; 
058AA:  CLRF   x0A
....................       pre_cuenta=0; 
058AC:  CLRF   x0B
....................       ////////////////////// 
....................       wieg=sub_indice=i=0; 
058AE:  CLRF   41
058B0:  CLRF   40
058B2:  MOVFF  40,20F
058B6:  MOVFF  20F,20C
....................       wiegand_cuenta=0; 
058BA:  CLRF   x11
....................       for(i=0;i<wieg_size;i++) data[i]=0; 
058BC:  CLRF   41
058BE:  CLRF   40
058C0:  MOVF   41,F
058C2:  BNZ   58E0
058C4:  MOVF   40,W
058C6:  SUBLW  19
058C8:  BNC   58E0
058CA:  MOVLW  16
058CC:  ADDWF  40,W
058CE:  MOVWF  FE9
058D0:  MOVLW  02
058D2:  ADDWFC 41,W
058D4:  MOVWF  FEA
058D6:  CLRF   FEF
058D8:  INCF   40,F
058DA:  BTFSC  FD8.2
058DC:  INCF   41,F
058DE:  BRA    58C0
....................  } 
058E0:  MOVLB  0
058E2:  GOTO   6EB0 (RETURN)
.................... } 
....................  
.................... void enviar_tcp(){ 
....................    envia_pc=1; 
*
056AC:  MOVLW  01
056AE:  MOVWF  1A
....................    StackTask(); 
056B0:  CALL   44CE
....................    MyTCPTask(); 
056B4:  RCALL  5304
056B6:  RETURN 0
.................... } 
.................... //////////////////// 
.................... void zeller(){ 
.................... int16 dia_s1,dia_s2,dia_s3,diac,mesc,dia_fecha;//(day,month,yr,dow,hrs,min,sec 
....................    int siglo,asiglo,resultado,di2; 
....................    diac=31; 
*
065D4:  MOVLB  8
065D6:  CLRF   xFD
065D8:  MOVLW  1F
065DA:  MOVWF  xFC
....................    mesc=10; 
065DC:  CLRF   xFF
065DE:  MOVLW  0A
065E0:  MOVWF  xFE
....................    siglo=20; 
065E2:  MOVLW  14
065E4:  MOVLB  9
065E6:  MOVWF  x02
....................    asiglo=yr; 
065E8:  MOVFF  272,903
....................    //fprintf(U1PRINTER,"Dia:%Ld mes:%Ld año:%d siglo:%d asiglo:%d\r\n",diac,mesc,asiglo,siglo,asiglo); 
....................    if(mesc<3){ 
065EC:  MOVLB  8
065EE:  MOVF   xFF,F
065F0:  BNZ   6606
065F2:  MOVF   xFE,W
065F4:  SUBLW  02
065F6:  BNC   6606
....................       mesc+=12; 
065F8:  MOVLW  0C
065FA:  ADDWF  xFE,F
065FC:  MOVLW  00
065FE:  ADDWFC xFF,F
....................       asiglo--; 
06600:  MOVLB  9
06602:  DECF   x03,F
06604:  MOVLB  8
....................    } 
....................    dia_s1=(siglo/4)+5*siglo; 
06606:  MOVLB  9
06608:  RRCF   x02,W
0660A:  MOVWF  x06
0660C:  RRCF   x06,F
0660E:  MOVLW  3F
06610:  ANDWF  x06,F
06612:  MOVF   x02,W
06614:  MULLW  05
06616:  MOVF   FF3,W
06618:  ADDWF  x06,W
0661A:  MOVLB  8
0661C:  MOVWF  xF6
0661E:  CLRF   xF7
....................    dia_s2=dia_s1+asiglo+(asiglo/4); 
06620:  MOVLB  9
06622:  MOVF   x03,W
06624:  MOVLB  8
06626:  ADDWF  xF6,W
06628:  MOVLB  9
0662A:  MOVWF  x06
0662C:  MOVLW  00
0662E:  MOVLB  8
06630:  ADDWFC xF7,W
06632:  MOVLB  9
06634:  MOVWF  x07
06636:  RRCF   x03,W
06638:  MOVWF  00
0663A:  RRCF   00,F
0663C:  MOVLW  3F
0663E:  ANDWF  00,F
06640:  MOVF   00,W
06642:  ADDWF  x06,W
06644:  MOVLB  8
06646:  MOVWF  xF8
06648:  MOVLW  00
0664A:  MOVLB  9
0664C:  ADDWFC x07,W
0664E:  MOVLB  8
06650:  MOVWF  xF9
....................    dia_s3=dia_s2+((mesc+1)*26)/10; 
06652:  MOVLW  01
06654:  ADDWF  xFE,W
06656:  MOVLB  9
06658:  MOVWF  x06
0665A:  MOVLW  00
0665C:  MOVLB  8
0665E:  ADDWFC xFF,W
06660:  MOVLB  9
06662:  MOVWF  x07
06664:  MOVWF  x47
06666:  MOVFF  906,946
0666A:  CLRF   x49
0666C:  MOVLW  1A
0666E:  MOVWF  x48
06670:  MOVLB  0
06672:  CALL   0FBC
06676:  MOVFF  02,907
0667A:  MOVFF  01,906
0667E:  MOVFF  02,909
06682:  MOVFF  01,908
06686:  MOVLB  9
06688:  CLRF   x0B
0668A:  MOVLW  0A
0668C:  MOVWF  x0A
0668E:  MOVLB  0
06690:  CALL   1050
06694:  MOVF   01,W
06696:  MOVLB  8
06698:  ADDWF  xF8,W
0669A:  MOVWF  xFA
0669C:  MOVF   02,W
0669E:  ADDWFC xF9,W
066A0:  MOVWF  xFB
....................    dia_fecha=(dia_s3+diac)%7;//dia de fin de mes 
066A2:  MOVF   xFC,W
066A4:  ADDWF  xFA,W
066A6:  MOVLB  9
066A8:  MOVWF  x06
066AA:  MOVLB  8
066AC:  MOVF   xFD,W
066AE:  ADDWFC xFB,W
066B0:  MOVLB  9
066B2:  MOVWF  x07
066B4:  MOVWF  x09
066B6:  MOVFF  906,908
066BA:  CLRF   x0B
066BC:  MOVLW  07
066BE:  MOVWF  x0A
066C0:  MOVLB  0
066C2:  CALL   1050
066C6:  MOVFF  00,900
066CA:  MOVLB  9
066CC:  MOVFF  03,901
....................    if(dia_fecha==0) dia_fecha=7; 
066D0:  MOVF   x00,F
066D2:  BNZ   66DE
066D4:  MOVF   x01,F
066D6:  BNZ   66DE
066D8:  CLRF   x01
066DA:  MOVLW  07
066DC:  MOVWF  x00
....................    //fprintf(U1PRINTER,"Dia:%Ld ",dia_fecha); 
....................    resultado=31-(dia_fecha-1); 
066DE:  MOVLW  01
066E0:  SUBWF  x00,W
066E2:  MOVWF  00
066E4:  MOVLW  00
066E6:  SUBWFB x01,W
066E8:  MOVF   00,W
066EA:  XORLW  FF
066EC:  ADDLW  20
066EE:  MOVWF  x04
....................    //fprintf(U1PRINTER,"Dia:%d ",resultado); 
.................... ///////////revisar cambio de horario//////////// 
.................... ds1307_get_date(day,month,yr,dow); 
.................... ds1307_get_time(hrs,min,sec); 
.................... di2=read_ext_eeprom(14); 
*
068C8:  MOVLB  9
068CA:  CLRF   x07
068CC:  MOVLW  0E
068CE:  MOVWF  x06
068D0:  MOVLB  0
068D2:  CALL   1360
068D6:  MOVFF  01,905
.................... if((month==4)&&(dow==1)&&(hrs>=2)&&(di2!=1)){//cambia a horario de verano 
068DA:  MOVLB  2
068DC:  MOVF   x71,W
068DE:  SUBLW  04
068E0:  BNZ   6938
068E2:  DECFSZ x76,W
068E4:  BRA    6938
068E6:  MOVF   x73,W
068E8:  SUBLW  01
068EA:  BC    6938
068EC:  MOVLB  9
068EE:  DECFSZ x05,W
068F0:  BRA    68F8
068F2:  MOVLB  2
068F4:  BRA    6938
068F6:  MOVLB  9
....................  hrs=hrs+1; 
068F8:  MOVLW  01
068FA:  MOVLB  2
068FC:  ADDWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
068FE:  MOVFF  270,906
06902:  MOVFF  271,907
06906:  MOVFF  272,908
0690A:  MOVFF  276,909
0690E:  MOVFF  273,90A
06912:  MOVFF  274,90B
06916:  MOVFF  275,90C
0691A:  MOVLB  0
0691C:  RCALL  637C
....................  di2=1; 
0691E:  MOVLW  01
06920:  MOVLB  9
06922:  MOVWF  x05
....................  write_ext_eeprom(14,di2);//(1,0)horario de invierno 
06924:  CLRF   x07
06926:  MOVLW  0E
06928:  MOVWF  x06
0692A:  MOVFF  905,908
0692E:  MOVLB  0
06930:  CALL   1408
.................... } 
06934:  BRA    699E
06936:  MOVLB  2
.................... //if((month==10)&&(dow==1)&&(day==resultado)&&(hrs==3)&&(di2!=day)){//cambia a horario de invierno 
.................... else if((month==10)&&(day==resultado)&&(hrs>=3)&&(hrs<=5)&&(di2!=day)){//cambia a horario de invierno 
06938:  MOVF   x71,W
0693A:  SUBLW  0A
0693C:  BNZ   69A0
0693E:  MOVLB  9
06940:  MOVF   x04,W
06942:  MOVLB  2
06944:  SUBWF  x70,W
06946:  BNZ   69A0
06948:  MOVF   x73,W
0694A:  SUBLW  02
0694C:  BC    69A0
0694E:  MOVF   x73,W
06950:  SUBLW  05
06952:  BNC   69A0
06954:  MOVF   x70,W
06956:  MOVLB  9
06958:  SUBWF  x05,W
0695A:  BTFSS  FD8.2
0695C:  BRA    6962
0695E:  MOVLB  2
06960:  BRA    69A0
....................  hrs=hrs-1; 
06962:  MOVLW  01
06964:  MOVLB  2
06966:  SUBWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
06968:  MOVFF  270,906
0696C:  MOVFF  271,907
06970:  MOVFF  272,908
06974:  MOVFF  276,909
06978:  MOVFF  273,90A
0697C:  MOVFF  274,90B
06980:  MOVFF  275,90C
06984:  MOVLB  0
06986:  RCALL  637C
....................  di2=day; 
06988:  MOVFF  270,905
....................  write_ext_eeprom(14,di2); 
0698C:  MOVLB  9
0698E:  CLRF   x07
06990:  MOVLW  0E
06992:  MOVWF  x06
06994:  MOVFF  905,908
06998:  MOVLB  0
0699A:  CALL   1408
0699E:  MOVLB  2
....................  } 
069A0:  MOVLB  0
069A2:  GOTO   7372 (RETURN)
.................... } 
.................... //////////////////// 
.................... void sensores(){ 
.................... if(en1!=input(entrada01) ){//SENSOR 1 bobina DE ENTRADA 
....................    delay_ms(200); 
....................    if(en1!=input(entrada01)){ 
....................       en1=input(entrada01); 
....................       //fen4=0; 
....................       if(en1==1){ 
....................          //lcd_putc("\fEN1-ENTRADA"); 
....................          re_bol=0; 
....................          //strcpy(txtcp,"EN1-ENTRADA"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................       else { 
....................          output_low(salida04); 
....................          re_bol=0; 
....................          //lcd_putc("\fEN1-SINDETECCION"); 
....................          //strcpy(txtcp,"EN1-SINDETECCION"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................    } 
.................... }//end S1 
....................  
.................... if(en4!=input(entrada04) ){//BOTON DE TICKET 
....................    //delay_ms(10); 
....................    if(en4!=input(entrada04)){ 
....................       en4=input(entrada04); 
....................       //printf(lcd_putc,"\fbot:%d au:%d hbot:%d cpo:%d "en3,en1,fen3,cupo ); 
....................       //if( (en4)&&(en1)&&(fen4!=1)&&(cupo!=1) ){ 
....................       if( (en4)&&(en1)&&(!re_bol) ){ 
....................       //if( (en4)&&(en1) ){ 
....................          time_boleto=0; 
....................          //re_bol=1; 
....................          sprintf(txtcp,"BOTON_BOLETO");//01-id de camion  
....................          size_tx_tcp=strlen(txtcp); 
....................          enviar_tcp(); 
....................       }//end boton activado 
....................       /*else if( (en4==1)&&(cupo) ){ 
....................             lcd_gotoxy(1,2); 
....................             lcd_putc("     CUPO LLENO     "); 
....................       }*/ 
....................    }//verificacion boton 
.................... }//en boton ticket 
.................... ///////////////////// 
.................... /*if(en5!=input(entrada05) ){//SENSOR DE BARRERA ENTRADA 
....................    delay_ms(200); 
....................    if(en5!=input(entrada05) ){ 
....................       en5=input(entrada05); 
....................       if( (en5==0)&&(flag_pluma==0) ){ 
....................          espera_tcp(); 
....................          for(i=0;i<16;i++) tcp_XX[i]=barrera[i];//BARRERAABIERTAS2 
....................          size_tx_tcp=i; 
....................          enviar_tcp();//enviar a pc//avisar por tcp 
....................       } 
....................       else if(en5==1) flag_pluma=0; 
....................    } 
.................... }*/ 
.................... ///////////////////// 
.................... } 
.................... //EPSON 
.................... void ticket(){//U1PRINTER //HHMMSSFFFFFFFFZ 
....................    // 1-Direccion1 para Folio 
....................    // 2-Direccion2 para Folio 
....................    // 3-Direccion3 para Folio 
....................    //int cta_l,cta_m,cta_h; 
....................    char fol_bol[20]; 
....................    /*//leer 
....................    cta_l=read_ext_eeprom(3); 
....................    cta_m=read_ext_eeprom(2); 
....................    cta_h=read_ext_eeprom(1); 
....................    folio=0;//24bits 16,777,215 
....................    folio=cta_h;// 
....................    folio=(folio<<8)|cta_m; 
....................    folio=(folio<<8)|cta_l; 
....................    //fin de leer 
....................    folio++; 
....................    //printf("Total:%Ld\r\n",folio); 
....................    write_ext_eeprom(3,folio);//graba 
....................    write_ext_eeprom(2,folio>>8);//graba 
....................    write_ext_eeprom(1,folio>>16);//graba 
....................    */ 
....................    //////////////////////////////// 
....................    ds1307_get_date(day,month,yr,dow); 
....................    ds1307_get_time(hrs,min,sec); 
....................    ////////texto////// 
....................    //inicializa el envio de codigos esc/pos 
....................    fputc(27, U1PRINTER); 
*
05EFE:  MOVLW  1B
05F00:  MOVLB  9
05F02:  MOVWF  x10
05F04:  MOVLB  0
05F06:  CALL   16B0
....................    fputc('@', U1PRINTER); 
05F0A:  MOVLW  40
05F0C:  MOVLB  9
05F0E:  MOVWF  x10
05F10:  MOVLB  0
05F12:  CALL   16B0
....................    //linea de justificacion 1B "a" 0izquierda 1centrado 2derecha 
....................    fputc(27, U1PRINTER); 
05F16:  MOVLW  1B
05F18:  MOVLB  9
05F1A:  MOVWF  x10
05F1C:  MOVLB  0
05F1E:  CALL   16B0
....................    fputc(97, U1PRINTER); 
05F22:  MOVLW  61
05F24:  MOVLB  9
05F26:  MOVWF  x10
05F28:  MOVLB  0
05F2A:  CALL   16B0
....................    fputc(1, U1PRINTER); 
05F2E:  MOVLW  01
05F30:  MOVLB  9
05F32:  MOVWF  x10
05F34:  MOVLB  0
05F36:  CALL   16B0
....................    //////interlineado//////// 
....................    //fprintf(U1PRINTER,"\x1B"); 
....................    //fprintf(U1PRINTER,"3"); 
....................    fputc(27, U1PRINTER); 
05F3A:  MOVLW  1B
05F3C:  MOVLB  9
05F3E:  MOVWF  x10
05F40:  MOVLB  0
05F42:  CALL   16B0
....................    fputc(51, U1PRINTER); 
05F46:  MOVLW  33
05F48:  MOVLB  9
05F4A:  MOVWF  x10
05F4C:  MOVLB  0
05F4E:  CALL   16B0
....................    fputc(40, U1PRINTER); 
05F52:  MOVLW  28
05F54:  MOVLB  9
05F56:  MOVWF  x10
05F58:  MOVLB  0
05F5A:  CALL   16B0
....................    //////////// 
....................    /////negritas activas 
....................    fprintf(U1PRINTER,"\x1B"); 
05F5E:  MOVLW  1B
05F60:  MOVLB  9
05F62:  MOVWF  x10
05F64:  MOVLB  0
05F66:  CALL   16B0
....................    fprintf(U1PRINTER,"G"); 
05F6A:  MOVLW  47
05F6C:  MOVLB  9
05F6E:  MOVWF  x10
05F70:  MOVLB  0
05F72:  CALL   16B0
....................    fprintf(U1PRINTER,"\x01"); 
05F76:  MOVLW  01
05F78:  MOVLB  9
05F7A:  MOVWF  x10
05F7C:  MOVLB  0
05F7E:  CALL   16B0
....................    /////Tipo de fuente 
....................    fprintf(U1PRINTER,"\x1B"); 
05F82:  MOVLW  1B
05F84:  MOVLB  9
05F86:  MOVWF  x10
05F88:  MOVLB  0
05F8A:  CALL   16B0
....................    fprintf(U1PRINTER,"!"); 
05F8E:  MOVLW  21
05F90:  MOVLB  9
05F92:  MOVWF  x10
05F94:  MOVLB  0
05F96:  CALL   16B0
....................    fputc(1, U1PRINTER); 
05F9A:  MOVLW  01
05F9C:  MOVLB  9
05F9E:  MOVWF  x10
05FA0:  MOVLB  0
05FA2:  CALL   16B0
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
05FA6:  MOVLW  1D
05FA8:  MOVLB  9
05FAA:  MOVWF  x10
05FAC:  MOVLB  0
05FAE:  CALL   16B0
....................    fprintf(U1PRINTER,"!"); 
05FB2:  MOVLW  21
05FB4:  MOVLB  9
05FB6:  MOVWF  x10
05FB8:  MOVLB  0
05FBA:  CALL   16B0
....................    fputc(17, U1PRINTER); 
05FBE:  MOVLW  11
05FC0:  MOVLB  9
05FC2:  MOVWF  x10
05FC4:  MOVLB  0
05FC6:  CALL   16B0
....................    //printf("\x0A");//limpia la justificación 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    memset(fol_bol, 0, sizeof(fol_bol)); 
05FCA:  MOVLW  08
05FCC:  MOVWF  FEA
05FCE:  MOVLW  F6
05FD0:  MOVWF  FE9
05FD2:  CLRF   00
05FD4:  CLRF   02
05FD6:  MOVLW  14
05FD8:  MOVWF  01
05FDA:  CALL   5748
....................    for(i=0;i<strlen(XX);i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
05FDE:  CLRF   41
05FE0:  CLRF   40
05FE2:  MOVLB  9
05FE4:  CLRF   x0C
05FE6:  MOVLW  52
05FE8:  MOVWF  x0B
05FEA:  MOVLB  0
05FEC:  CALL   5670
05FF0:  MOVFF  02,03
05FF4:  MOVF   41,W
05FF6:  SUBWF  02,W
05FF8:  BNC   603C
05FFA:  BNZ   6002
05FFC:  MOVF   01,W
05FFE:  SUBWF  40,W
06000:  BC    603C
06002:  MOVLW  F6
06004:  ADDWF  40,W
06006:  MOVWF  01
06008:  MOVLW  08
0600A:  ADDWFC 41,W
0600C:  MOVWF  03
0600E:  MOVFF  01,90A
06012:  MOVLB  9
06014:  MOVWF  x0B
06016:  MOVLW  5C
06018:  ADDWF  40,W
0601A:  MOVWF  FE9
0601C:  MOVLW  00
0601E:  ADDWFC 41,W
06020:  MOVWF  FEA
06022:  MOVFF  FEF,90E
06026:  MOVFF  03,FEA
0602A:  MOVFF  01,FE9
0602E:  MOVFF  90E,FEF
06032:  INCF   40,F
06034:  BTFSC  FD8.2
06036:  INCF   41,F
06038:  BRA    5FE4
0603A:  MOVLB  0
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //folio = atoi32(fol_bol); 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    fprintf(U1PRINTER,"Folio:%s",fol_bol); 
0603C:  MOVLW  68
0603E:  MOVWF  FF6
06040:  MOVLW  03
06042:  MOVWF  FF7
06044:  MOVLW  06
06046:  MOVLB  9
06048:  MOVWF  x0A
0604A:  MOVLB  0
0604C:  RCALL  5AB0
0604E:  MOVLW  08
06050:  MOVWF  FEA
06052:  MOVLW  F6
06054:  MOVWF  FE9
06056:  RCALL  5ADA
....................    strcpy(barra_codi,fol_bol); 
06058:  MOVLW  02
0605A:  MOVWF  FEA
0605C:  MOVLW  4E
0605E:  MOVWF  FE9
06060:  MOVLW  08
06062:  MOVWF  FE2
06064:  MOVLW  F6
06066:  MOVWF  FE1
06068:  MOVF   FE7,F
0606A:  MOVFF  FE6,FEE
0606E:  BNZ   6068
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06070:  MOVLW  0A
06072:  MOVLB  9
06074:  MOVWF  x10
06076:  MOVLB  0
06078:  CALL   16B0
....................    LF(); 
0607C:  RCALL  5B00
....................    /////////////////////////////////////////////////////////// 
....................    fprintf(U1PRINTER,"MARIA TERESA BAEZ MONROY"); 
0607E:  MOVLW  72
06080:  MOVWF  FF6
06082:  MOVLW  03
06084:  MOVWF  FF7
06086:  CALL   16C0
....................    //printf("\x0A");//limpia la justificación  
....................    ////desactiva negritas 
....................    fprintf(U1PRINTER,"\x1B"); 
0608A:  MOVLW  1B
0608C:  MOVLB  9
0608E:  MOVWF  x10
06090:  MOVLB  0
06092:  CALL   16B0
....................    fprintf(U1PRINTER,"G"); 
06096:  MOVLW  47
06098:  MOVLB  9
0609A:  MOVWF  x10
0609C:  MOVLB  0
0609E:  CALL   16B0
....................    fprintf(U1PRINTER,"\x00"); 
....................    /////////////////////////////////////////////////////////// 
....................    LF(); 
060A2:  RCALL  5B00
....................    LF(); 
060A4:  RCALL  5B00
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
060A6:  MOVLW  1D
060A8:  MOVLB  9
060AA:  MOVWF  x10
060AC:  MOVLB  0
060AE:  CALL   16B0
....................    fprintf(U1PRINTER,"!"); 
060B2:  MOVLW  21
060B4:  MOVLB  9
060B6:  MOVWF  x10
060B8:  MOVLB  0
060BA:  CALL   16B0
....................    fputc(0, U1PRINTER); 
060BE:  MOVLB  9
060C0:  CLRF   x10
060C2:  MOVLB  0
060C4:  CALL   16B0
....................    ///// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060C8:  MOVLW  0A
060CA:  MOVLB  9
060CC:  MOVWF  x10
060CE:  MOVLB  0
060D0:  CALL   16B0
....................    fprintf(U1PRINTER,"RFC:BAMT97052884A\x0A"); 
060D4:  MOVLW  8C
060D6:  MOVWF  FF6
060D8:  MOVLW  03
060DA:  MOVWF  FF7
060DC:  CALL   16C0
....................    fprintf(U1PRINTER,"4 poniente 1302, colonia Centro  CP 72000\x0APuebla, Puebla\x0A"); 
060E0:  MOVLW  A0
060E2:  MOVWF  FF6
060E4:  MOVLW  03
060E6:  MOVWF  FF7
060E8:  CALL   16C0
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
060EC:  MOVLW  1D
060EE:  MOVLB  9
060F0:  MOVWF  x10
060F2:  MOVLB  0
060F4:  CALL   16B0
....................    fprintf(U1PRINTER,"!"); 
060F8:  MOVLW  21
060FA:  MOVLB  9
060FC:  MOVWF  x10
060FE:  MOVLB  0
06100:  CALL   16B0
....................    fputc(17, U1PRINTER); 
06104:  MOVLW  11
06106:  MOVLB  9
06108:  MOVWF  x10
0610A:  MOVLB  0
0610C:  CALL   16B0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06110:  MOVLW  0A
06112:  MOVLB  9
06114:  MOVWF  x10
06116:  MOVLB  0
06118:  CALL   16B0
....................    fprintf(U1PRINTER,"%02d/%02d/20%02d %02d:%02d:%02d",day,month,yr,hrs,min,sec); 
0611C:  MOVFF  270,90A
06120:  MOVLW  01
06122:  MOVLB  9
06124:  MOVWF  x0B
06126:  MOVLB  0
06128:  RCALL  5B0E
0612A:  MOVLW  2F
0612C:  MOVLB  9
0612E:  MOVWF  x10
06130:  MOVLB  0
06132:  CALL   16B0
06136:  MOVFF  271,90A
0613A:  MOVLW  01
0613C:  MOVLB  9
0613E:  MOVWF  x0B
06140:  MOVLB  0
06142:  RCALL  5B0E
06144:  MOVLW  E3
06146:  MOVWF  FF6
06148:  MOVLW  03
0614A:  MOVWF  FF7
0614C:  MOVLW  03
0614E:  MOVLB  9
06150:  MOVWF  x0A
06152:  MOVLB  0
06154:  RCALL  5AB0
06156:  MOVFF  272,90A
0615A:  MOVLW  01
0615C:  MOVLB  9
0615E:  MOVWF  x0B
06160:  MOVLB  0
06162:  RCALL  5B0E
06164:  MOVLW  20
06166:  MOVLB  9
06168:  MOVWF  x10
0616A:  MOVLB  0
0616C:  CALL   16B0
06170:  MOVFF  273,90A
06174:  MOVLW  01
06176:  MOVLB  9
06178:  MOVWF  x0B
0617A:  MOVLB  0
0617C:  RCALL  5B0E
0617E:  MOVLW  3A
06180:  MOVLB  9
06182:  MOVWF  x10
06184:  MOVLB  0
06186:  CALL   16B0
0618A:  MOVFF  274,90A
0618E:  MOVLW  01
06190:  MOVLB  9
06192:  MOVWF  x0B
06194:  MOVLB  0
06196:  RCALL  5B0E
06198:  MOVLW  3A
0619A:  MOVLB  9
0619C:  MOVWF  x10
0619E:  MOVLB  0
061A0:  CALL   16B0
061A4:  MOVFF  275,90A
061A8:  MOVLW  01
061AA:  MOVLB  9
061AC:  MOVWF  x0B
061AE:  MOVLB  0
061B0:  RCALL  5B0E
....................    LF(); 
061B2:  RCALL  5B00
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
061B4:  MOVLW  1D
061B6:  MOVLB  9
061B8:  MOVWF  x10
061BA:  MOVLB  0
061BC:  CALL   16B0
....................    fprintf(U1PRINTER,"!"); 
061C0:  MOVLW  21
061C2:  MOVLB  9
061C4:  MOVWF  x10
061C6:  MOVLB  0
061C8:  CALL   16B0
....................    fputc(0, U1PRINTER); 
061CC:  MOVLB  9
061CE:  CLRF   x10
061D0:  MOVLB  0
061D2:  CALL   16B0
....................    ///// 
....................    //memset(barra_codi, 0, sizeof(barra_codi));// 
....................    barra1(); 
061D6:  BRA    5BD6
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
061D8:  MOVLW  0A
061DA:  MOVLB  9
061DC:  MOVWF  x10
061DE:  MOVLB  0
061E0:  CALL   16B0
....................    fprintf(U1PRINTER,"TARIFA:$15 Hora o Fraccion, TOLERANCIA:5 min.  \x0A"); 
061E4:  MOVLW  FA
061E6:  MOVWF  FF6
061E8:  MOVLW  03
061EA:  MOVWF  FF7
061EC:  CALL   16C0
....................    fprintf(U1PRINTER,"Horarios:de 8:00 a 21:00hrs. de lunes a viernes\x0A"); 
061F0:  MOVLW  2C
061F2:  MOVWF  FF6
061F4:  MOVLW  04
061F6:  MOVWF  FF7
061F8:  CALL   16C0
....................    fprintf(U1PRINTER,"Sabados de 8:00 a 14:00hrs.                    \x0A"); 
061FC:  MOVLW  5E
061FE:  MOVWF  FF6
06200:  MOVLW  04
06202:  MOVWF  FF7
06204:  CALL   16C0
....................    //fprintf(U1PRINTER,"ESTA  EMPRESA  Y SUS TRABAJADORES  NO SE  HACEN\x0A"); 
....................    //fprintf(U1PRINTER,"RESPONSABLES  POR  LOS OBJETOS  NO DECLARADOS Y\x0A"); 
....................    //fprintf(U1PRINTER,"MOSTRADOS  PARA  CUSTODIAR  AL  RESPONSABLE  DE\x0A"); 
....................    //fprintf(U1PRINTER,"ELABORAR  EL  BOLETO, Y  NO  SE  ENTREGUE  ESTE\x0A"); 
....................    //fprintf(U1PRINTER,"BOLETO  HASTA  QUE  RECIBA  SU  VEHICULO  A  SU\x0A"); 
....................    //fprintf(U1PRINTER,"ENTERA  SATISFACCION  IMPORTANTE LEA AL REVERSO\x0A"); 
....................    //fprintf(U1PRINTER,"DE ESTE  BOLETO  YA  QUE INDICA  LOS LIMITES DE\x0A"); 
....................    //fprintf(U1PRINTER,"NUESTRA RESPONSABILIDAD                        \x0A"); 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06208:  MOVLW  0A
0620A:  MOVLB  9
0620C:  MOVWF  x10
0620E:  MOVLB  0
06210:  CALL   16B0
....................    //////////////////// 
....................    barra2(); 
06214:  BRA    5CA0
....................    //////////////////// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06216:  MOVLW  0A
06218:  MOVLB  9
0621A:  MOVWF  x10
0621C:  MOVLB  0
0621E:  CALL   16B0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06222:  MOVLW  0A
06224:  MOVLB  9
06226:  MOVWF  x10
06228:  MOVLB  0
0622A:  CALL   16B0
....................    fprintf(U1PRINTER,"\"ACCESA\" automatizacion "); 
0622E:  MOVLW  90
06230:  MOVWF  FF6
06232:  MOVLW  04
06234:  MOVWF  FF7
06236:  CALL   16C0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0623A:  MOVLW  0A
0623C:  MOVLB  9
0623E:  MOVWF  x10
06240:  MOVLB  0
06242:  CALL   16B0
....................    fprintf(U1PRINTER,"www.accesa.me  automatizacion@accesa.me"); 
06246:  MOVLW  AA
06248:  MOVWF  FF6
0624A:  MOVLW  04
0624C:  MOVWF  FF7
0624E:  CALL   16C0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06252:  MOVLW  0A
06254:  MOVLB  9
06256:  MOVWF  x10
06258:  MOVLB  0
0625A:  CALL   16B0
....................    /////////feed para corte de papel////////////// 
....................    fprintf(U1PRINTER,"\x1B"); 
0625E:  MOVLW  1B
06260:  MOVLB  9
06262:  MOVWF  x10
06264:  MOVLB  0
06266:  CALL   16B0
....................    fprintf(U1PRINTER,"J"); 
0626A:  MOVLW  4A
0626C:  MOVLB  9
0626E:  MOVWF  x10
06270:  MOVLB  0
06272:  CALL   16B0
....................    //fputc(190, U1PRINTER); 
....................    fputc(250, U1PRINTER); 
06276:  MOVLW  FA
06278:  MOVLB  9
0627A:  MOVWF  x10
0627C:  MOVLB  0
0627E:  CALL   16B0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación  
06282:  MOVLW  0A
06284:  MOVLB  9
06286:  MOVWF  x10
06288:  MOVLB  0
0628A:  CALL   16B0
....................    LF(); 
0628E:  RCALL  5B00
....................    ///////// 
....................    //ESC i 69 Corte total de papel 
....................    //ESC m 6D Corte parcial de papel 
....................    fprintf(U1PRINTER,"\x1B"); 
06290:  MOVLW  1B
06292:  MOVLB  9
06294:  MOVWF  x10
06296:  MOVLB  0
06298:  CALL   16B0
....................    fprintf(U1PRINTER,"m"); 
0629C:  MOVLW  6D
0629E:  MOVLB  9
062A0:  MOVWF  x10
062A2:  MOVLB  0
062A4:  CALL   16B0
062A8:  GOTO   6F82 (RETURN)
....................    //////////////////////////////////////// 
.................... } 
....................  
.................... void LF(){ 
.................... fprintf(U1PRINTER,"\x0A"); 
*
05B00:  MOVLW  0A
05B02:  MOVLB  9
05B04:  MOVWF  x10
05B06:  MOVLB  0
05B08:  CALL   16B0
05B0C:  RETURN 0
.................... } 
....................  
.................... void CR(){ 
.................... fprintf(U1PRINTER,"\x0D");//enter 
.................... } 
....................  
.................... void barra1(){ 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d",folio,yr,month,day,hrs,min,sec);// 
....................    //sprintf(con_barra,"%08Ld%d",folio,idbar);//01-id de camion 
....................     
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //fprintf(U1PRINTER,"%08Ld/%02d/%02d/%02d/%02d/%02d/%02d/%d/",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi)+2; 
*
05BD6:  MOVLW  02
05BD8:  MOVLB  9
05BDA:  MOVWF  x0C
05BDC:  MOVLW  4E
05BDE:  MOVWF  x0B
05BE0:  MOVLB  0
05BE2:  RCALL  5670
05BE4:  MOVLW  02
05BE6:  MOVLB  9
05BE8:  ADDWF  01,W
05BEA:  MOVWF  x0A
....................    //printf (lcd_putc,"\fsize_bar:%u",size_bar); 
....................    //delay_ms(2000); 
.................... //////bar code/////// 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05BEC:  MOVLW  D2
05BEE:  MOVWF  FF6
05BF0:  MOVLW  04
05BF2:  MOVWF  FF7
05BF4:  MOVLB  0
05BF6:  CALL   16C0
....................    fprintf(U1PRINTER,"\x1D\x77\x01");// 
05BFA:  MOVLW  D6
05BFC:  MOVWF  FF6
05BFE:  MOVLW  04
05C00:  MOVWF  FF7
05C02:  CALL   16C0
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05C06:  MOVLW  1D
05C08:  MOVLB  9
05C0A:  MOVWF  x10
05C0C:  MOVLB  0
05C0E:  CALL   16B0
....................    fputc(72,U1PRINTER);// 
05C12:  MOVLW  48
05C14:  MOVLB  9
05C16:  MOVWF  x10
05C18:  MOVLB  0
05C1A:  CALL   16B0
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05C1E:  MOVLW  02
05C20:  MOVLB  9
05C22:  MOVWF  x10
05C24:  MOVLB  0
05C26:  CALL   16B0
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05C2A:  MOVLW  1D
05C2C:  MOVLB  9
05C2E:  MOVWF  x10
05C30:  MOVLB  0
05C32:  CALL   16B0
....................    fputc(102,U1PRINTER);// 
05C36:  MOVLW  66
05C38:  MOVLB  9
05C3A:  MOVWF  x10
05C3C:  MOVLB  0
05C3E:  CALL   16B0
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05C42:  MOVLW  01
05C44:  MOVLB  9
05C46:  MOVWF  x10
05C48:  MOVLB  0
05C4A:  CALL   16B0
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05C4E:  MOVLW  1D
05C50:  MOVLB  9
05C52:  MOVWF  x10
05C54:  MOVLB  0
05C56:  CALL   16B0
....................    fputc('k',U1PRINTER); 
05C5A:  MOVLW  6B
05C5C:  MOVLB  9
05C5E:  MOVWF  x10
05C60:  MOVLB  0
05C62:  CALL   16B0
....................    fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
05C66:  MOVLW  49
05C68:  MOVLB  9
05C6A:  MOVWF  x10
05C6C:  MOVLB  0
05C6E:  CALL   16B0
....................    //fputc(23,U1PRINTER); //numero de caracteres+2 (solo code128) 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05C72:  MOVFF  90A,910
05C76:  CALL   16B0
....................    fputc(123,U1PRINTER);// d1 (solo code128) 
05C7A:  MOVLW  7B
05C7C:  MOVLB  9
05C7E:  MOVWF  x10
05C80:  MOVLB  0
05C82:  CALL   16B0
....................    fputc(65,U1PRINTER); // d2 (solo code128) 
05C86:  MOVLW  41
05C88:  MOVLB  9
05C8A:  MOVWF  x10
05C8C:  MOVLB  0
05C8E:  CALL   16B0
....................     
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05C92:  MOVLW  02
05C94:  MOVWF  FEA
05C96:  MOVLW  4E
05C98:  MOVWF  FE9
05C9A:  RCALL  5ADA
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05C9C:  GOTO   61D8 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void barra2(){ 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi); 
05CA0:  MOVLW  02
05CA2:  MOVLB  9
05CA4:  MOVWF  x0C
05CA6:  MOVLW  4E
05CA8:  MOVWF  x0B
05CAA:  MOVLB  0
05CAC:  RCALL  5670
05CAE:  MOVFF  01,90A
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    //CODIGO DE BARRAS 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05CB2:  MOVLW  DA
05CB4:  MOVWF  FF6
05CB6:  MOVLW  04
05CB8:  MOVWF  FF7
05CBA:  CALL   16C0
....................    fprintf(U1PRINTER,"\x1D\x77\x01");//setea ancho 
05CBE:  MOVLW  DE
05CC0:  MOVWF  FF6
05CC2:  MOVLW  04
05CC4:  MOVWF  FF7
05CC6:  CALL   16C0
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05CCA:  MOVLW  1D
05CCC:  MOVLB  9
05CCE:  MOVWF  x10
05CD0:  MOVLB  0
05CD2:  CALL   16B0
....................    fputc(72,U1PRINTER);// 
05CD6:  MOVLW  48
05CD8:  MOVLB  9
05CDA:  MOVWF  x10
05CDC:  MOVLB  0
05CDE:  CALL   16B0
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05CE2:  MOVLW  02
05CE4:  MOVLB  9
05CE6:  MOVWF  x10
05CE8:  MOVLB  0
05CEA:  CALL   16B0
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05CEE:  MOVLW  1D
05CF0:  MOVLB  9
05CF2:  MOVWF  x10
05CF4:  MOVLB  0
05CF6:  CALL   16B0
....................    fputc(102,U1PRINTER);// 
05CFA:  MOVLW  66
05CFC:  MOVLB  9
05CFE:  MOVWF  x10
05D00:  MOVLB  0
05D02:  CALL   16B0
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05D06:  MOVLW  01
05D08:  MOVLB  9
05D0A:  MOVWF  x10
05D0C:  MOVLB  0
05D0E:  CALL   16B0
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05D12:  MOVLW  1D
05D14:  MOVLB  9
05D16:  MOVWF  x10
05D18:  MOVLB  0
05D1A:  CALL   16B0
....................    fputc('k',U1PRINTER); 
05D1E:  MOVLW  6B
05D20:  MOVLB  9
05D22:  MOVWF  x10
05D24:  MOVLB  0
05D26:  CALL   16B0
....................    fputc(69,U1PRINTER);//69=code39//72=code93//73=code128//70=ITF(solo cantidades pares)// 
05D2A:  MOVLW  45
05D2C:  MOVLB  9
05D2E:  MOVWF  x10
05D30:  MOVLB  0
05D32:  CALL   16B0
....................    //fputc(21,U1PRINTER);//numero de caracteres 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05D36:  MOVFF  90A,910
05D3A:  CALL   16B0
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05D3E:  MOVLW  02
05D40:  MOVWF  FEA
05D42:  MOVLW  4E
05D44:  MOVWF  FE9
05D46:  RCALL  5ADA
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05D48:  GOTO   6216 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void encri(){ 
....................  int tem; 
....................  //fprintf(U1PRINTER,"con_barra:%Lu\r\n",strlen(con_barra)); 
....................   
....................  for(tem=0;tem<=strlen(con_barra);tem++){ 
....................          if(con_barra[tem]=='0') barra_codi[tem]='5'; 
....................     else if(con_barra[tem]=='1') barra_codi[tem]='7'; 
....................     else if(con_barra[tem]=='2') barra_codi[tem]='8'; 
....................     else if(con_barra[tem]=='3') barra_codi[tem]='2'; 
....................     else if(con_barra[tem]=='4') barra_codi[tem]='9'; 
....................     else if(con_barra[tem]=='5') barra_codi[tem]='0'; 
....................     else if(con_barra[tem]=='6') barra_codi[tem]='6'; 
....................     else if(con_barra[tem]=='7') barra_codi[tem]='4'; 
....................     else if(con_barra[tem]=='8') barra_codi[tem]='1'; 
....................     else if(con_barra[tem]=='9') barra_codi[tem]='3'; 
....................  }//end for 
.................... } 
....................  
.................... ///////////////////// 
.................... void llaves(){ 
....................    int tem; 
....................    char texto[12]; 
....................    ////////////////llaves//////////// 
....................    ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
*
00738:  MOVLW  01
0073A:  MOVLB  8
0073C:  MOVWF  xF6
0073E:  MOVF   xF6,W
00740:  SUBLW  0E
00742:  BTFSS  FD8.0
00744:  BRA    0A00
....................       switch (tem) { 
00746:  MOVLW  01
00748:  SUBWF  xF6,W
0074A:  ADDLW  F2
0074C:  BTFSC  FD8.0
0074E:  BRA    08FE
00750:  ADDLW  0E
00752:  MOVLB  0
00754:  GOTO   0A06
....................            case 1: {// 
....................                strcpy(texto,texto1); 
00758:  MOVLW  08
0075A:  MOVWF  FEA
0075C:  MOVLW  F7
0075E:  MOVWF  FE9
00760:  MOVLW  02
00762:  MOVWF  FE2
00764:  MOVLW  8D
00766:  MOVWF  FE1
00768:  MOVF   FE7,F
0076A:  MOVFF  FE6,FEE
0076E:  BNZ   0768
....................                break;} 
00770:  MOVLB  8
00772:  BRA    08FE
00774:  MOVLB  0
....................            case 2: {// 
....................                strcpy(texto,texto2); 
00776:  MOVLW  08
00778:  MOVWF  FEA
0077A:  MOVLW  F7
0077C:  MOVWF  FE9
0077E:  MOVLW  02
00780:  MOVWF  FE2
00782:  MOVLW  99
00784:  MOVWF  FE1
00786:  MOVF   FE7,F
00788:  MOVFF  FE6,FEE
0078C:  BNZ   0786
....................                break;} 
0078E:  MOVLB  8
00790:  BRA    08FE
00792:  MOVLB  0
....................            case 3: {// 
....................                strcpy(texto,texto3); 
00794:  MOVLW  08
00796:  MOVWF  FEA
00798:  MOVLW  F7
0079A:  MOVWF  FE9
0079C:  MOVLW  02
0079E:  MOVWF  FE2
007A0:  MOVLW  A5
007A2:  MOVWF  FE1
007A4:  MOVF   FE7,F
007A6:  MOVFF  FE6,FEE
007AA:  BNZ   07A4
....................                break;} 
007AC:  MOVLB  8
007AE:  BRA    08FE
007B0:  MOVLB  0
....................            case 4: {// 
....................                strcpy(texto,texto4); 
007B2:  MOVLW  08
007B4:  MOVWF  FEA
007B6:  MOVLW  F7
007B8:  MOVWF  FE9
007BA:  MOVLW  02
007BC:  MOVWF  FE2
007BE:  MOVLW  B1
007C0:  MOVWF  FE1
007C2:  MOVF   FE7,F
007C4:  MOVFF  FE6,FEE
007C8:  BNZ   07C2
....................                break;} 
007CA:  MOVLB  8
007CC:  BRA    08FE
007CE:  MOVLB  0
....................            case 5: {// 
....................                strcpy(texto,texto5); 
007D0:  MOVLW  08
007D2:  MOVWF  FEA
007D4:  MOVLW  F7
007D6:  MOVWF  FE9
007D8:  MOVLW  02
007DA:  MOVWF  FE2
007DC:  MOVLW  BD
007DE:  MOVWF  FE1
007E0:  MOVF   FE7,F
007E2:  MOVFF  FE6,FEE
007E6:  BNZ   07E0
....................                break;} 
007E8:  MOVLB  8
007EA:  BRA    08FE
007EC:  MOVLB  0
....................            case 6: {// 
....................                strcpy(texto,texto6); 
007EE:  MOVLW  08
007F0:  MOVWF  FEA
007F2:  MOVLW  F7
007F4:  MOVWF  FE9
007F6:  MOVLW  02
007F8:  MOVWF  FE2
007FA:  MOVLW  C9
007FC:  MOVWF  FE1
007FE:  MOVF   FE7,F
00800:  MOVFF  FE6,FEE
00804:  BNZ   07FE
....................                break;} 
00806:  MOVLB  8
00808:  BRA    08FE
0080A:  MOVLB  0
....................            case 7: {// 
....................                strcpy(texto,texto7); 
0080C:  MOVLW  08
0080E:  MOVWF  FEA
00810:  MOVLW  F7
00812:  MOVWF  FE9
00814:  MOVLW  02
00816:  MOVWF  FE2
00818:  MOVLW  D5
0081A:  MOVWF  FE1
0081C:  MOVF   FE7,F
0081E:  MOVFF  FE6,FEE
00822:  BNZ   081C
....................                break;} 
00824:  MOVLB  8
00826:  BRA    08FE
00828:  MOVLB  0
....................            case 8: {// 
....................                strcpy(texto,texto8); 
0082A:  MOVLW  08
0082C:  MOVWF  FEA
0082E:  MOVLW  F7
00830:  MOVWF  FE9
00832:  MOVLW  02
00834:  MOVWF  FE2
00836:  MOVLW  E1
00838:  MOVWF  FE1
0083A:  MOVF   FE7,F
0083C:  MOVFF  FE6,FEE
00840:  BNZ   083A
....................                break;} 
00842:  MOVLB  8
00844:  BRA    08FE
00846:  MOVLB  0
....................            case 9: {// 
....................                strcpy(texto,texto9); 
00848:  MOVLW  08
0084A:  MOVWF  FEA
0084C:  MOVLW  F7
0084E:  MOVWF  FE9
00850:  MOVLW  02
00852:  MOVWF  FE2
00854:  MOVLW  ED
00856:  MOVWF  FE1
00858:  MOVF   FE7,F
0085A:  MOVFF  FE6,FEE
0085E:  BNZ   0858
....................                break;} 
00860:  MOVLB  8
00862:  BRA    08FE
00864:  MOVLB  0
....................            case 10: {// 
....................                strcpy(texto,texto10); 
00866:  MOVLW  08
00868:  MOVWF  FEA
0086A:  MOVLW  F7
0086C:  MOVWF  FE9
0086E:  MOVLW  02
00870:  MOVWF  FE2
00872:  MOVLW  F9
00874:  MOVWF  FE1
00876:  MOVF   FE7,F
00878:  MOVFF  FE6,FEE
0087C:  BNZ   0876
....................                break;} 
0087E:  MOVLB  8
00880:  BRA    08FE
00882:  MOVLB  0
....................            case 11: {// 
....................                strcpy(texto,texto11); 
00884:  MOVLW  08
00886:  MOVWF  FEA
00888:  MOVLW  F7
0088A:  MOVWF  FE9
0088C:  MOVLW  03
0088E:  MOVWF  FE2
00890:  MOVLW  05
00892:  MOVWF  FE1
00894:  MOVF   FE7,F
00896:  MOVFF  FE6,FEE
0089A:  BNZ   0894
....................                break;} 
0089C:  MOVLB  8
0089E:  BRA    08FE
008A0:  MOVLB  0
....................            case 12: {// 
....................                strcpy(texto,texto12); 
008A2:  MOVLW  08
008A4:  MOVWF  FEA
008A6:  MOVLW  F7
008A8:  MOVWF  FE9
008AA:  MOVLW  03
008AC:  MOVWF  FE2
008AE:  MOVLW  11
008B0:  MOVWF  FE1
008B2:  MOVF   FE7,F
008B4:  MOVFF  FE6,FEE
008B8:  BNZ   08B2
....................                break;} 
008BA:  MOVLB  8
008BC:  BRA    08FE
008BE:  MOVLB  0
....................            case 13: {// 
....................                strcpy(texto,texto13); 
008C0:  MOVLW  08
008C2:  MOVWF  FEA
008C4:  MOVLW  F7
008C6:  MOVWF  FE9
008C8:  MOVLW  03
008CA:  MOVWF  FE2
008CC:  MOVLW  1D
008CE:  MOVWF  FE1
008D0:  MOVF   FE7,F
008D2:  MOVFF  FE6,FEE
008D6:  BNZ   08D0
....................                break;} 
008D8:  MOVLB  8
008DA:  BRA    08FE
008DC:  MOVLB  0
....................            case 14: {// 
....................                strcpy(texto,texto14); 
008DE:  MOVLW  08
008E0:  MOVWF  FEA
008E2:  MOVLW  F7
008E4:  MOVWF  FE9
008E6:  MOVLW  03
008E8:  MOVWF  FE2
008EA:  MOVLW  29
008EC:  MOVWF  FE1
008EE:  MOVF   FE7,F
008F0:  MOVFF  FE6,FEE
008F4:  BNZ   08EE
....................                break;} 
008F6:  MOVLB  8
008F8:  BRA    08FE
008FA:  MOVLB  0
008FC:  MOVLB  8
....................       } 
....................       a=i=0; 
008FE:  CLRF   41
00900:  CLRF   40
00902:  MOVFF  40,1B
....................       while (i < instruccion_size) {  //word_size=8 
00906:  MOVF   41,F
00908:  BNZ   098A
0090A:  MOVF   40,W
0090C:  SUBLW  09
0090E:  BNC   098A
....................            memory[i] = read_eeprom( (tem*instruccion_size)+i); 
00910:  MOVLW  22
00912:  ADDWF  40,W
00914:  MOVWF  FE9
00916:  MOVLW  00
00918:  ADDWFC 41,W
0091A:  MOVWF  FEA
0091C:  MOVF   xF6,W
0091E:  MULLW  0A
00920:  MOVF   FF3,W
00922:  ADDWF  40,W
00924:  MOVLB  9
00926:  MOVWF  x05
00928:  MOVLW  00
0092A:  ADDWFC 41,W
0092C:  MOVWF  x06
0092E:  MOVFF  FF2,907
00932:  BCF    FF2.7
00934:  MOVFF  906,FAA
00938:  MOVFF  905,FA9
0093C:  BCF    FA6.6
0093E:  BCF    FA6.7
00940:  BSF    FA6.0
00942:  MOVF   FA8,W
00944:  BTFSC  x07.7
00946:  BSF    FF2.7
00948:  MOVWF  FEF
....................            if (memory[i] != texto[i])  break; 
0094A:  MOVLW  22
0094C:  ADDWF  40,W
0094E:  MOVWF  FE9
00950:  MOVLW  00
00952:  ADDWFC 41,W
00954:  MOVWF  FEA
00956:  MOVFF  FEF,903
0095A:  MOVLW  F7
0095C:  ADDWF  40,W
0095E:  MOVWF  FE9
00960:  MOVLW  08
00962:  ADDWFC 41,W
00964:  MOVWF  FEA
00966:  MOVF   FEF,W
00968:  SUBWF  x03,W
0096A:  BZ    0972
0096C:  MOVLB  8
0096E:  BRA    098A
00970:  MOVLB  9
....................            i++; 
00972:  INCF   40,F
00974:  BTFSC  FD8.2
00976:  INCF   41,F
....................            if (i==instruccion_size) a=1; 
00978:  MOVF   40,W
0097A:  SUBLW  0A
0097C:  BNZ   0986
0097E:  MOVF   41,F
00980:  BNZ   0986
00982:  MOVLW  01
00984:  MOVWF  1B
00986:  MOVLB  8
00988:  BRA    0906
....................       } 
....................       //fprintf(U1PRINTER,"\r\n"); 
....................       if (a==0){ 
0098A:  MOVF   1B,F
0098C:  BNZ   09FC
....................          i=0; 
0098E:  CLRF   41
00990:  CLRF   40
....................          while (texto[i] != 0x00){ 
00992:  MOVLW  F7
00994:  ADDWF  40,W
00996:  MOVWF  FE9
00998:  MOVLW  08
0099A:  ADDWFC 41,W
0099C:  MOVWF  FEA
0099E:  MOVF   FEF,F
009A0:  BZ    09FC
....................             write_eeprom(i+(tem*instruccion_size),texto[i]); 
009A2:  MOVF   xF6,W
009A4:  MULLW  0A
009A6:  MOVF   FF3,W
009A8:  ADDWF  40,W
009AA:  MOVLB  9
009AC:  MOVWF  x03
009AE:  MOVLW  00
009B0:  ADDWFC 41,W
009B2:  MOVWF  x04
009B4:  MOVLW  F7
009B6:  ADDWF  40,W
009B8:  MOVWF  FE9
009BA:  MOVLW  08
009BC:  ADDWFC 41,W
009BE:  MOVWF  FEA
009C0:  MOVFF  FEF,905
009C4:  MOVF   FF2,W
009C6:  MOVWF  00
009C8:  BCF    FF2.7
009CA:  MOVFF  904,FAA
009CE:  MOVFF  903,FA9
009D2:  MOVFF  905,FA8
009D6:  BCF    FA6.6
009D8:  BCF    FA6.7
009DA:  BSF    FA6.2
009DC:  MOVLB  F
009DE:  MOVLW  55
009E0:  MOVWF  FA7
009E2:  MOVLW  AA
009E4:  MOVWF  FA7
009E6:  BSF    FA6.1
009E8:  BTFSC  FA6.1
009EA:  BRA    09E8
009EC:  BCF    FA6.2
009EE:  MOVF   00,W
009F0:  IORWF  FF2,F
....................             //fprintf(U1PRINTER,"%c",texto[i]); 
....................             i++; 
009F2:  INCF   40,F
009F4:  BTFSC  FD8.2
009F6:  INCF   41,F
009F8:  MOVLB  8
009FA:  BRA    0992
....................          }//end grabar 
....................       }//END a 
009FC:  INCF   xF6,F
009FE:  BRA    073E
....................    }//end for 
00A00:  MOVLB  0
00A02:  GOTO   6C38 (RETURN)
.................... } 
....................  
.................... void rd_eeprom(){ 
.................... n=a=b=0; 
*
058E6:  CLRF   45
058E8:  CLRF   44
058EA:  MOVFF  44,1B
058EE:  CLRF   43
058F0:  MOVFF  1B,42
.................... n=instruccion_size;// 
058F4:  CLRF   43
058F6:  MOVLW  0A
058F8:  MOVWF  42
.................... i=0; 
058FA:  CLRF   41
058FC:  CLRF   40
.................... while ((b <=data_numbers)&&(a==0)){//NUMERO TOTAL DE TARJETAS 
058FE:  MOVF   45,F
05900:  BNZ   59A2
05902:  MOVF   44,W
05904:  SUBLW  0E
05906:  BNC   59A2
05908:  MOVF   1B,F
0590A:  BNZ   59A2
....................     i=0; 
0590C:  CLRF   41
0590E:  CLRF   40
....................     b++; 
05910:  INCF   44,F
05912:  BTFSC  FD8.2
05914:  INCF   45,F
....................     while (i < instruccion_size) {//WORD_SIZE_2=10 
05916:  MOVF   41,F
05918:  BNZ   5996
0591A:  MOVF   40,W
0591C:  SUBLW  09
0591E:  BNC   5996
....................         memory[i] = read_eeprom(n+i); 
05920:  MOVLW  22
05922:  ADDWF  40,W
05924:  MOVWF  FE9
05926:  MOVLW  00
05928:  ADDWFC 41,W
0592A:  MOVWF  FEA
0592C:  MOVF   40,W
0592E:  ADDWF  42,W
05930:  MOVLB  8
05932:  MOVWF  xF8
05934:  MOVF   41,W
05936:  ADDWFC 43,W
05938:  MOVWF  xF9
0593A:  MOVFF  FF2,8FA
0593E:  BCF    FF2.7
05940:  MOVFF  8F9,FAA
05944:  MOVFF  8F8,FA9
05948:  BCF    FA6.6
0594A:  BCF    FA6.7
0594C:  BSF    FA6.0
0594E:  MOVF   FA8,W
05950:  BTFSC  xFA.7
05952:  BSF    FF2.7
05954:  MOVWF  FEF
....................         //fprintf(U1PRINTER,"m[%Ld]=%c",i,memory[i]); 
....................         //fprintf(U1PRINTER,"X[%Ld]=%c",i,XX[i]); 
....................         if (memory[i] != XX[i]) 
05956:  MOVLW  22
05958:  ADDWF  40,W
0595A:  MOVWF  FE9
0595C:  MOVLW  00
0595E:  ADDWFC 41,W
05960:  MOVWF  FEA
05962:  MOVFF  FEF,8F6
05966:  MOVLW  52
05968:  ADDWF  40,W
0596A:  MOVWF  FE9
0596C:  MOVLW  00
0596E:  ADDWFC 41,W
05970:  MOVWF  FEA
05972:  MOVF   FEF,W
05974:  SUBWF  xF6,W
05976:  BZ    597E
....................             break; 
05978:  MOVLB  0
0597A:  BRA    5996
0597C:  MOVLB  8
....................         i++; 
0597E:  INCF   40,F
05980:  BTFSC  FD8.2
05982:  INCF   41,F
....................         if (i==instruccion_size) a=1; 
05984:  MOVF   40,W
05986:  SUBLW  0A
05988:  BNZ   5992
0598A:  MOVF   41,F
0598C:  BNZ   5992
0598E:  MOVLW  01
05990:  MOVWF  1B
05992:  MOVLB  0
05994:  BRA    5916
....................     } 
....................     //fprintf(PRINTER," \r\n"); 
....................     //fprintf(PRINTER," n=%Ld ",n); 
....................     n=n+instruccion_size;//WORD_SIZE=30 
05996:  MOVLW  0A
05998:  ADDWF  42,F
0599A:  MOVLW  00
0599C:  ADDWFC 43,F
....................     restart_wdt(); 
0599E:  CLRWDT
059A0:  BRA    58FE
....................     //fprintf(U1PRINTER," \r\n"); 
....................     //fprintf(U1PRINTER,"b=%Ld",b); 
....................     } 
059A2:  GOTO   6ED2 (RETURN)
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) 
*
016E0:  MOVF   FD0,W
016E2:  ANDLW  0F
016E4:  BTFSS  FD0.4
016E6:  MOVLW  00
016E8:  BSF    FD0.0
016EA:  BSF    FD0.1
016EC:  BSF    FD0.4
016EE:  BSF    FD8.3
016F0:  BSF    FD8.4
016F2:  XORLW  07
016F4:  BZ    1704
016F6:  XORLW  08
016F8:  BZ    1710
016FA:  XORLW  01
016FC:  BZ    171C
016FE:  XORLW  02
01700:  BZ    1728
01702:  BRA    1732
....................    { 
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          fprintf(U1PRINTER,"\r\nREINICIO-WD"); 
01704:  MOVLW  E2
01706:  MOVWF  FF6
01708:  MOVLW  04
0170A:  MOVWF  FF7
0170C:  RCALL  16C0
....................          break;} 
0170E:  BRA    1732
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          fprintf(U1PRINTER,"\r\nREINICIO-MCLR"); 
01710:  MOVLW  F0
01712:  MOVWF  FF6
01714:  MOVLW  04
01716:  MOVWF  FF7
01718:  RCALL  16C0
....................          break;} 
0171A:  BRA    1732
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          fprintf(U1PRINTER,"\r\nREINICIO-VOLTAJE_BAJO"); 
0171C:  MOVLW  00
0171E:  MOVWF  FF6
01720:  MOVLW  05
01722:  MOVWF  FF7
01724:  RCALL  16C0
....................          break; 
01726:  BRA    1732
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          fprintf(U1PRINTER,"\r\nPOWER_UP"); 
01728:  MOVLW  18
0172A:  MOVWF  FF6
0172C:  MOVLW  05
0172E:  MOVWF  FF7
01730:  RCALL  16C0
....................          /* 
....................          #define WDT_TIMEOUT       7      
....................          #define MCLR_FROM_SLEEP  11      
....................          #define MCLR_FROM_RUN    15      
....................          #define NORMAL_POWER_UP  12      
....................          #define BROWNOUT_RESTART 14      
....................          #define WDT_FROM_SLEEP    3      
....................          #define RESET_INSTRUCTION 0     */ 
....................          break; 
....................       } 
....................    } 
01732:  GOTO   6DCC (RETURN)
.................... } 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1918   PUT NOBROWNOUT BORV21 WDT WDT4096
   Word  3: 8000   NOPBADEN NOLPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
