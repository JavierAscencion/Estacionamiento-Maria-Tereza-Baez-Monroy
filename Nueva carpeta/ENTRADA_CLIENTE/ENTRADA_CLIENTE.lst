CCS PCH C Compiler, Version 5.070, 56587               21-jun.-18 15:21

               Filename:   E:\Google Drive\01 ESTACIONAMIENTOS\MARIA TERESA BAEZ MONROY(matanzo)\ENTRADA_CLIENTE\ENTRADA_CLIENTE.lst

               ROM used:   30162 bytes (46%)
                           Largest free fragment is 35372
               RAM used:   2299 (69%) at main() level
                           2481 (75%) worst case
               Stack used: 10 locations (9 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   6A96
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0106
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   01AA
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   01C6
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   01FA
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... //2018/06/21 //Version 1.2- serie MATE11.2 Se disminuyo tiempo de rebotes de auto 
.................... //2018/06/21 //Version 1.1- serie MATE11.1 Se modifico boleto, se agrego tolerancia y cambio hora de apertura 
.................... //2018/06/19 //Version 1- serie MATE11, 3 primeras letras de estacion, numero de entrada/cambios realizados 
.................... // Basado en: Programa de ejemplo 10 para comunicarme con el módulo ENC28J60. 
.................... // Cliente TCP. 
.................... // Incluimos las definiciones necesarias de la placa utilizada. 
.................... #include "Plantilla_Inicio.c" 
.................... // Controlador ETHERNET 
.................... // Fecha: 2018/02/19. 
.................... // Versión del compilador: v5.070 
.................... // Versión del programa: v0.1 
.................... // Revisión del programa: 0.00 
.................... // Definimos el microcontrolador utilizado. 
.................... #include <18F4680.h> // Definición de registros internos del PIC18F4520. 
.................... //////////// Standard Header file for the PIC18F4680 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4680 
000D2:  CLRF   FF7
000D4:  ADDLW  E2
000D6:  MOVWF  FF6
000D8:  MOVLW  00
000DA:  ADDWFC FF7,F
000DC:  TBLRD*+
000DE:  MOVF   FF5,W
000E0:  RETURN 0
000E2:  DATA 28,0C
000E4:  DATA 01,06
000E6:  CLRF   FF7
000E8:  ADDLW  F6
000EA:  MOVWF  FF6
000EC:  MOVLW  00
000EE:  ADDWFC FF7,F
000F0:  TBLRD*+
000F2:  MOVF   FF5,W
000F4:  RETURN 0
000F6:  DATA 42,4F
000F8:  DATA 4C,45
000FA:  DATA 54,45
000FC:  DATA 52,41
000FE:  DATA 5F,50
00100:  DATA 41,47
00102:  DATA 41,44
00104:  DATA 4F,00
*
0012A:  DATA 53,6F
0012C:  DATA 6C,69
0012E:  DATA 63,69
00130:  DATA 74,75
00132:  DATA 64,20
00134:  DATA 41,52
00136:  DATA 50,2E
00138:  DATA 20,20
0013A:  DATA 20,20
0013C:  DATA 20,20
0013E:  DATA 00,00
00140:  DATA 43,4F
00142:  DATA 4E,45
00144:  DATA 43,54
00146:  DATA 41,4E
00148:  DATA 44,4F
0014A:  DATA 2E,2E
0014C:  DATA 2E,20
0014E:  DATA 20,20
00150:  DATA 20,20
00152:  DATA 20,20
00154:  DATA 00,00
00156:  DATA 45,72
00158:  DATA 72,6F
0015A:  DATA 72,20
0015C:  DATA 65,6E
0015E:  DATA 20,65
00160:  DATA 6C,20
00162:  DATA 73,6F
00164:  DATA 63,6B
00166:  DATA 65,74
00168:  DATA 2E,20
0016A:  DATA 00,00
0016C:  DATA 43,4F
0016E:  DATA 4E,45
00170:  DATA 43,54
00172:  DATA 41,44
00174:  DATA 4F,20
00176:  DATA 20,20
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 20,20
00180:  DATA 00,00
00182:  DATA 44,45
00184:  DATA 53,43
00186:  DATA 4F,4E
00188:  DATA 45,43
0018A:  DATA 54,41
0018C:  DATA 44,4F
0018E:  DATA 20,20
00190:  DATA 20,20
00192:  DATA 20,20
00194:  DATA 20,00
00196:  DATA 44,45
00198:  DATA 53,43
0019A:  DATA 4F,4E
0019C:  DATA 45,43
0019E:  DATA 54,41
001A0:  DATA 44,4F
001A2:  DATA 20,20
001A4:  DATA 20,20
001A6:  DATA 20,20
001A8:  DATA 20,00
*
0022C:  DATA 0C,49
0022E:  DATA 4E,49
00230:  DATA 43,49
00232:  DATA 41,4E
00234:  DATA 44,4F
00236:  DATA 00,00
00238:  DATA 44,69
0023A:  DATA 61,73
0023C:  DATA 3A,25
0023E:  DATA 75,20
00240:  DATA 50,41
00242:  DATA 47,4F
00244:  DATA 3A,25
00246:  DATA 64,00
00248:  DATA 52,65
0024A:  DATA 73,74
0024C:  DATA 61,6E
0024E:  DATA 3A,25
00250:  DATA 75,20
00252:  DATA 00,00
00254:  DATA 54,49
00256:  DATA 45,4D
00258:  DATA 50,4F
0025A:  DATA 20,44
0025C:  DATA 45,20
0025E:  DATA 50,52
00260:  DATA 55,45
00262:  DATA 42,41
00264:  DATA 00,00
00266:  DATA 20,20
00268:  DATA 48,41
0026A:  DATA 20,45
0026C:  DATA 58,50
0026E:  DATA 49,52
00270:  DATA 41,44
00272:  DATA 4F,20
00274:  DATA 20,20
00276:  DATA 00,00
00278:  DATA 0C,0A
0027A:  DATA 20,20
0027C:  DATA 20,54
0027E:  DATA 4F,4D
00280:  DATA 45,20
00282:  DATA 53,55
00284:  DATA 20,42
00286:  DATA 4F,4C
00288:  DATA 45,54
0028A:  DATA 4F,0A
0028C:  DATA 20,59
0028E:  DATA 20,41
00290:  DATA 56,41
00292:  DATA 4E,43
00294:  DATA 45,20
00296:  DATA 50,4F
00298:  DATA 52,20
0029A:  DATA 46,41
0029C:  DATA 56,4F
0029E:  DATA 52,00
002A0:  DATA 0C,00
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 20,20
002B2:  DATA 20,20
002B4:  DATA 20,20
002B6:  DATA 00,00
002B8:  DATA 20,20
002BA:  DATA 20,25
002BC:  DATA 30,32
002BE:  DATA 64,20
002C0:  DATA 25,30
002C2:  DATA 32,64
002C4:  DATA 20,25
002C6:  DATA 30,32
002C8:  DATA 64,2F
002CA:  DATA 25,30
002CC:  DATA 32,64
002CE:  DATA 2F,25
002D0:  DATA 30,32
002D2:  DATA 64,20
002D4:  DATA 20,20
002D6:  DATA 20,00
002D8:  DATA 20,20
002DA:  DATA 20,25
002DC:  DATA 30,32
002DE:  DATA 64,3A
002E0:  DATA 25,30
002E2:  DATA 32,64
002E4:  DATA 20,25
002E6:  DATA 30,32
002E8:  DATA 64,2F
002EA:  DATA 25,30
002EC:  DATA 32,64
002EE:  DATA 2F,25
002F0:  DATA 30,32
002F2:  DATA 64,20
002F4:  DATA 20,20
002F6:  DATA 20,00
002F8:  DATA 20,20
002FA:  DATA 20,57
002FC:  DATA 57,57
002FE:  DATA 2E,41
00300:  DATA 43,43
00302:  DATA 45,53
00304:  DATA 41,2E
00306:  DATA 4D,45
00308:  DATA 20,20
0030A:  DATA 20,20
0030C:  DATA 00,00
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,41
00316:  DATA 43,43
00318:  DATA 45,53
0031A:  DATA 41,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 20,20
0032A:  DATA 20,20
0032C:  DATA 20,20
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 00,00
0033A:  DATA 20,20
0033C:  DATA 48,6F
0033E:  DATA 72,61
00340:  DATA 20,41
00342:  DATA 63,74
00344:  DATA 75,61
00346:  DATA 6C,69
00348:  DATA 7A,61
0034A:  DATA 64,61
0034C:  DATA 20,20
0034E:  DATA 00,00
00350:  DATA 45,4E
00352:  DATA 31,2D
00354:  DATA 25,30
00356:  DATA 38,4C
00358:  DATA 58,00
0035A:  DATA 0C,0A
0035C:  DATA 20,20
0035E:  DATA 20,20
00360:  DATA 20,42
00362:  DATA 49,45
00364:  DATA 4E,56
00366:  DATA 45,4E
00368:  DATA 49,44
0036A:  DATA 4F,00
0036C:  DATA 42,4F
0036E:  DATA 54,4F
00370:  DATA 4E,5F
00372:  DATA 42,4F
00374:  DATA 4C,45
00376:  DATA 54,4F
00378:  DATA 00,00
0037A:  DATA 46,6F
0037C:  DATA 6C,69
0037E:  DATA 6F,3A
00380:  DATA 25,73
00382:  DATA 00,00
00384:  DATA 4D,41
00386:  DATA 52,49
00388:  DATA 41,20
0038A:  DATA 54,45
0038C:  DATA 52,45
0038E:  DATA 53,41
00390:  DATA 20,42
00392:  DATA 41,45
00394:  DATA 5A,20
00396:  DATA 4D,4F
00398:  DATA 4E,52
0039A:  DATA 4F,59
0039C:  DATA 00,00
0039E:  DATA 52,46
003A0:  DATA 43,3A
003A2:  DATA 42,41
003A4:  DATA 4D,54
003A6:  DATA 39,37
003A8:  DATA 30,35
003AA:  DATA 32,38
003AC:  DATA 38,34
003AE:  DATA 41,0A
003B0:  DATA 00,00
003B2:  DATA 34,20
003B4:  DATA 70,6F
003B6:  DATA 6E,69
003B8:  DATA 65,6E
003BA:  DATA 74,65
003BC:  DATA 20,31
003BE:  DATA 33,30
003C0:  DATA 32,2C
003C2:  DATA 20,63
003C4:  DATA 6F,6C
003C6:  DATA 6F,6E
003C8:  DATA 69,61
003CA:  DATA 20,43
003CC:  DATA 65,6E
003CE:  DATA 74,72
003D0:  DATA 6F,20
003D2:  DATA 20,43
003D4:  DATA 50,20
003D6:  DATA 37,32
003D8:  DATA 30,30
003DA:  DATA 30,0A
003DC:  DATA 50,75
003DE:  DATA 65,62
003E0:  DATA 6C,61
003E2:  DATA 2C,20
003E4:  DATA 50,75
003E6:  DATA 65,62
003E8:  DATA 6C,61
003EA:  DATA 0A,00
003EC:  DATA 25,30
003EE:  DATA 32,64
003F0:  DATA 2F,25
003F2:  DATA 30,32
003F4:  DATA 64,2F
003F6:  DATA 32,30
003F8:  DATA 25,30
003FA:  DATA 32,64
003FC:  DATA 20,25
003FE:  DATA 30,32
00400:  DATA 64,3A
00402:  DATA 25,30
00404:  DATA 32,64
00406:  DATA 3A,25
00408:  DATA 30,32
0040A:  DATA 64,00
0040C:  DATA 54,41
0040E:  DATA 52,49
00410:  DATA 46,41
00412:  DATA 3A,24
00414:  DATA 31,35
00416:  DATA 20,48
00418:  DATA 6F,72
0041A:  DATA 61,20
0041C:  DATA 6F,20
0041E:  DATA 46,72
00420:  DATA 61,63
00422:  DATA 63,69
00424:  DATA 6F,6E
00426:  DATA 20,20
00428:  DATA 20,20
0042A:  DATA 20,20
0042C:  DATA 20,20
0042E:  DATA 20,20
00430:  DATA 20,20
00432:  DATA 20,20
00434:  DATA 20,20
00436:  DATA 20,20
00438:  DATA 20,20
0043A:  DATA 20,0A
0043C:  DATA 00,00
0043E:  DATA 54,4F
00440:  DATA 4C,45
00442:  DATA 52,41
00444:  DATA 4E,43
00446:  DATA 49,41
00448:  DATA 3A,35
0044A:  DATA 20,6D
0044C:  DATA 69,6E
0044E:  DATA 2E,20
00450:  DATA 6C,61
00452:  DATA 20,70
00454:  DATA 72,69
00456:  DATA 6D,65
00458:  DATA 72,61
0045A:  DATA 20,68
0045C:  DATA 6F,72
0045E:  DATA 61,20
00460:  DATA 20,20
00462:  DATA 20,20
00464:  DATA 20,20
00466:  DATA 20,20
00468:  DATA 20,20
0046A:  DATA 20,20
0046C:  DATA 20,0A
0046E:  DATA 00,00
00470:  DATA 48,6F
00472:  DATA 72,61
00474:  DATA 72,69
00476:  DATA 6F,73
00478:  DATA 3A,64
0047A:  DATA 65,20
0047C:  DATA 37,3A
0047E:  DATA 30,30
00480:  DATA 20,61
00482:  DATA 20,32
00484:  DATA 31,3A
00486:  DATA 30,30
00488:  DATA 68,72
0048A:  DATA 73,2E
0048C:  DATA 20,64
0048E:  DATA 65,20
00490:  DATA 6C,75
00492:  DATA 6E,65
00494:  DATA 73,20
00496:  DATA 61,20
00498:  DATA 76,69
0049A:  DATA 65,72
0049C:  DATA 6E,65
0049E:  DATA 73,0A
004A0:  DATA 00,00
004A2:  DATA 53,61
004A4:  DATA 62,61
004A6:  DATA 64,6F
004A8:  DATA 73,20
004AA:  DATA 20,64
004AC:  DATA 65,20
004AE:  DATA 37,3A
004B0:  DATA 30,30
004B2:  DATA 20,61
004B4:  DATA 20,31
004B6:  DATA 34,3A
004B8:  DATA 30,30
004BA:  DATA 68,72
004BC:  DATA 73,2E
004BE:  DATA 20,20
004C0:  DATA 20,20
004C2:  DATA 20,20
004C4:  DATA 20,20
004C6:  DATA 20,20
004C8:  DATA 20,20
004CA:  DATA 20,20
004CC:  DATA 20,20
004CE:  DATA 20,20
004D0:  DATA 20,0A
004D2:  DATA 00,00
004D4:  DATA 22,41
004D6:  DATA 43,43
004D8:  DATA 45,53
004DA:  DATA 41,22
004DC:  DATA 20,61
004DE:  DATA 75,74
004E0:  DATA 6F,6D
004E2:  DATA 61,74
004E4:  DATA 69,7A
004E6:  DATA 61,63
004E8:  DATA 69,6F
004EA:  DATA 6E,20
004EC:  DATA 00,00
004EE:  DATA 77,77
004F0:  DATA 77,2E
004F2:  DATA 61,63
004F4:  DATA 63,65
004F6:  DATA 73,61
004F8:  DATA 2E,6D
004FA:  DATA 65,20
004FC:  DATA 20,61
004FE:  DATA 75,74
00500:  DATA 6F,6D
00502:  DATA 61,74
00504:  DATA 69,7A
00506:  DATA 61,63
00508:  DATA 69,6F
0050A:  DATA 6E,40
0050C:  DATA 61,63
0050E:  DATA 63,65
00510:  DATA 73,61
00512:  DATA 2E,6D
00514:  DATA 65,00
00516:  DATA 1D,68
00518:  DATA 8C,00
0051A:  DATA 1D,77
0051C:  DATA 01,00
0051E:  DATA 1D,68
00520:  DATA 8C,00
00522:  DATA 1D,77
00524:  DATA 01,00
*
00696:  TBLRD*+
00698:  MOVF   FF5,F
0069A:  BZ    06B4
0069C:  MOVFF  FF6,8F9
006A0:  MOVFF  FF7,8FA
006A4:  MOVFF  FF5,8FC
006A8:  RCALL  0632
006AA:  MOVFF  8F9,FF6
006AE:  MOVFF  8FA,FF7
006B2:  BRA    0696
006B4:  RETURN 0
*
00A08:  ADDWF  FE8,W
00A0A:  CLRF   FF7
00A0C:  RLCF   FF7,F
00A0E:  ADDLW  23
00A10:  MOVWF  FF6
00A12:  MOVLW  0A
00A14:  ADDWFC FF7,F
00A16:  TBLRD*-
00A18:  MOVF   FF5,W
00A1A:  MOVWF  FFA
00A1C:  TBLRD*
00A1E:  MOVF   FF5,W
00A20:  MOVWF  FF9
00A22:  DATA 5A,07
00A24:  DATA 78,07
00A26:  DATA 96,07
00A28:  DATA B4,07
00A2A:  DATA D2,07
00A2C:  DATA F0,07
00A2E:  DATA 0E,08
00A30:  DATA 2C,08
00A32:  DATA 4A,08
00A34:  DATA 68,08
00A36:  DATA 86,08
00A38:  DATA A4,08
00A3A:  DATA C2,08
00A3C:  DATA E0,08
*
00FBE:  MOVLB  9
00FC0:  MOVF   x46,W
00FC2:  MULWF  x48
00FC4:  MOVFF  FF3,01
00FC8:  MOVFF  FF4,00
00FCC:  MULWF  x49
00FCE:  MOVF   FF3,W
00FD0:  ADDWF  00,F
00FD2:  MOVF   x47,W
00FD4:  MULWF  x48
00FD6:  MOVF   FF3,W
00FD8:  ADDWFC 00,W
00FDA:  MOVWF  02
00FDC:  MOVLB  0
00FDE:  RETURN 0
*
00FF4:  MOVLB  9
00FF6:  CLRF   x01
00FF8:  CLRF   x02
00FFA:  MOVLW  01
00FFC:  MOVWF  x03
00FFE:  CLRF   FDA
01000:  CLRF   FD9
01002:  MOVLW  08
01004:  MOVWF  x06
01006:  MOVLW  F9
01008:  MOVWF  x05
0100A:  MOVLW  08
0100C:  MOVWF  FEA
0100E:  MOVLW  FD
01010:  MOVWF  FE9
01012:  MOVFF  906,FE2
01016:  MOVFF  905,FE1
0101A:  MOVFF  903,904
0101E:  BCF    FD8.0
01020:  MOVF   FE5,W
01022:  MULWF  FEE
01024:  MOVF   FF3,W
01026:  ADDWFC x01,F
01028:  MOVF   FF4,W
0102A:  ADDWFC x02,F
0102C:  DECFSZ x04,F
0102E:  BRA    101E
01030:  MOVFF  901,FDE
01034:  MOVFF  902,901
01038:  CLRF   x02
0103A:  BTFSC  FD8.0
0103C:  INCF   x02,F
0103E:  INCF   x05,F
01040:  BTFSC  FD8.2
01042:  INCF   x06,F
01044:  INCF   x03,F
01046:  MOVF   x03,W
01048:  SUBLW  05
0104A:  BNZ   100A
0104C:  MOVLB  0
0104E:  GOTO   10C0 (RETURN)
01052:  CLRF   01
01054:  CLRF   02
01056:  CLRF   00
01058:  CLRF   03
0105A:  MOVLB  9
0105C:  MOVF   x0B,W
0105E:  BNZ   1064
01060:  MOVF   x0A,W
01062:  BZ    1094
01064:  MOVLW  10
01066:  MOVWF  x0C
01068:  BCF    FD8.0
0106A:  RLCF   x08,F
0106C:  RLCF   x09,F
0106E:  RLCF   00,F
01070:  RLCF   03,F
01072:  MOVF   x0B,W
01074:  SUBWF  03,W
01076:  BNZ   107C
01078:  MOVF   x0A,W
0107A:  SUBWF  00,W
0107C:  BNC   108C
0107E:  MOVF   x0A,W
01080:  SUBWF  00,F
01082:  BTFSS  FD8.0
01084:  DECF   03,F
01086:  MOVF   x0B,W
01088:  SUBWF  03,F
0108A:  BSF    FD8.0
0108C:  RLCF   01,F
0108E:  RLCF   02,F
01090:  DECFSZ x0C,F
01092:  BRA    1068
01094:  MOVLB  0
01096:  RETURN 0
*
01510:  TBLRD*+
01512:  MOVFF  FF6,8F8
01516:  MOVFF  FF7,8F9
0151A:  MOVFF  FF5,8FC
0151E:  CALL   0632
01522:  MOVFF  8F8,FF6
01526:  MOVFF  8F9,FF7
0152A:  MOVLB  8
0152C:  DECFSZ xF7,F
0152E:  BRA    1532
01530:  BRA    1536
01532:  MOVLB  0
01534:  BRA    1510
01536:  MOVLB  0
01538:  RETURN 0
0153A:  MOVLB  9
0153C:  MOVF   x11,W
0153E:  CLRF   01
01540:  SUBWF  x10,W
01542:  BC    154A
01544:  MOVFF  910,00
01548:  BRA    1562
0154A:  CLRF   00
0154C:  MOVLW  08
0154E:  MOVWF  x12
01550:  RLCF   x10,F
01552:  RLCF   00,F
01554:  MOVF   x11,W
01556:  SUBWF  00,W
01558:  BTFSC  FD8.0
0155A:  MOVWF  00
0155C:  RLCF   01,F
0155E:  DECFSZ x12,F
01560:  BRA    1550
01562:  MOVLB  0
01564:  RETURN 0
01566:  MOVF   01,W
01568:  MOVFF  8F7,910
0156C:  MOVLW  64
0156E:  MOVLB  9
01570:  MOVWF  x11
01572:  MOVLB  0
01574:  RCALL  153A
01576:  MOVFF  00,8F7
0157A:  MOVF   01,W
0157C:  MOVLW  30
0157E:  BNZ   1590
01580:  MOVLB  8
01582:  BTFSS  xF8.1
01584:  BRA    15A4
01586:  BTFSC  xF8.3
01588:  BRA    15A4
0158A:  BTFSC  xF8.4
0158C:  MOVLW  20
0158E:  BRA    1598
01590:  MOVLB  8
01592:  BCF    xF8.3
01594:  BCF    xF8.4
01596:  BSF    xF8.0
01598:  ADDWF  01,F
0159A:  MOVFF  01,8FC
0159E:  MOVLB  0
015A0:  CALL   0632
015A4:  MOVFF  8F7,910
015A8:  MOVLW  0A
015AA:  MOVLB  9
015AC:  MOVWF  x11
015AE:  MOVLB  0
015B0:  RCALL  153A
015B2:  MOVFF  00,8F7
015B6:  MOVF   01,W
015B8:  MOVLW  30
015BA:  BNZ   15CC
015BC:  MOVLB  8
015BE:  BTFSC  xF8.3
015C0:  BRA    15D8
015C2:  BTFSS  xF8.0
015C4:  BRA    15D8
015C6:  BTFSC  xF8.4
015C8:  MOVLW  20
015CA:  MOVLB  0
015CC:  ADDWF  01,F
015CE:  MOVFF  01,8FC
015D2:  CALL   0632
015D6:  MOVLB  8
015D8:  MOVLW  30
015DA:  ADDWF  xF7,F
015DC:  MOVFF  8F7,8FC
015E0:  MOVLB  0
015E2:  CALL   0632
015E6:  RETURN 0
015E8:  MOVLW  20
015EA:  MOVLB  8
015EC:  BTFSS  xF7.4
015EE:  MOVLW  30
015F0:  MOVWF  xF8
015F2:  MOVFF  8F6,00
015F6:  BTFSS  xF6.7
015F8:  BRA    160A
015FA:  COMF   00,F
015FC:  INCF   00,F
015FE:  MOVFF  00,8F6
01602:  MOVLW  2D
01604:  MOVWF  xF8
01606:  BSF    xF7.7
01608:  BSF    xF7.0
0160A:  MOVF   01,W
0160C:  MOVFF  8F6,910
01610:  MOVLW  64
01612:  MOVLB  9
01614:  MOVWF  x11
01616:  MOVLB  0
01618:  RCALL  153A
0161A:  MOVFF  00,8F6
0161E:  MOVLW  30
01620:  ADDWF  01,W
01622:  MOVLB  8
01624:  MOVWF  xF9
01626:  MOVFF  8F6,910
0162A:  MOVLW  0A
0162C:  MOVLB  9
0162E:  MOVWF  x11
01630:  MOVLB  0
01632:  RCALL  153A
01634:  MOVLW  30
01636:  ADDWF  00,W
01638:  MOVLB  8
0163A:  MOVWF  xFB
0163C:  MOVLW  30
0163E:  ADDWF  01,W
01640:  MOVWF  xFA
01642:  MOVFF  8F8,00
01646:  MOVLW  30
01648:  SUBWF  xF9,W
0164A:  BZ    1654
0164C:  BSF    xF7.1
0164E:  BTFSC  xF7.7
01650:  BSF    xF7.2
01652:  BRA    1678
01654:  MOVFF  8F8,8F9
01658:  MOVLW  20
0165A:  MOVWF  xF8
0165C:  MOVLW  30
0165E:  SUBWF  xFA,W
01660:  BZ    166A
01662:  BSF    xF7.0
01664:  BTFSC  xF7.7
01666:  BSF    xF7.1
01668:  BRA    1678
0166A:  BTFSS  FD8.2
0166C:  BSF    xF7.0
0166E:  BNZ   1678
01670:  MOVFF  8F9,8FA
01674:  MOVLW  20
01676:  MOVWF  xF9
01678:  BTFSC  xF7.2
0167A:  BRA    1686
0167C:  BTFSC  xF7.1
0167E:  BRA    1690
01680:  BTFSC  xF7.0
01682:  BRA    169A
01684:  BRA    16A4
01686:  MOVFF  8F8,8FC
0168A:  MOVLB  0
0168C:  CALL   0632
01690:  MOVFF  8F9,8FC
01694:  MOVLB  0
01696:  CALL   0632
0169A:  MOVFF  8FA,8FC
0169E:  MOVLB  0
016A0:  CALL   0632
016A4:  MOVFF  8FB,8FC
016A8:  MOVLB  0
016AA:  CALL   0632
016AE:  GOTO   6D5C (RETURN)
*
0444C:  ADDWF  FE8,W
0444E:  CLRF   FF7
04450:  RLCF   FF7,F
04452:  ADDLW  67
04454:  MOVWF  FF6
04456:  MOVLW  44
04458:  ADDWFC FF7,F
0445A:  TBLRD*-
0445C:  MOVF   FF5,W
0445E:  MOVWF  FFA
04460:  TBLRD*
04462:  MOVF   FF5,W
04464:  MOVWF  FF9
04466:  DATA E4,41
04468:  DATA EC,41
0446A:  DATA 34,42
0446C:  DATA D4,42
0446E:  DATA 00,43
04470:  DATA 00,43
04472:  DATA 10,43
04474:  DATA 20,43
04476:  DATA 34,43
*
0462C:  ADDWF  FE8,W
0462E:  CLRF   FF7
04630:  RLCF   FF7,F
04632:  ADDLW  47
04634:  MOVWF  FF6
04636:  MOVLW  46
04638:  ADDWFC FF7,F
0463A:  TBLRD*-
0463C:  MOVF   FF5,W
0463E:  MOVWF  FFA
04640:  TBLRD*
04642:  MOVF   FF5,W
04644:  MOVWF  FF9
04646:  DATA 8E,44
04648:  DATA 8E,44
0464A:  DATA E6,44
0464C:  DATA 76,45
0464E:  DATA D6,45
04650:  DATA D4,44
04652:  DATA 48,45
*
055F0:  ADDWF  FE8,W
055F2:  CLRF   FF7
055F4:  RLCF   FF7,F
055F6:  ADDLW  0B
055F8:  MOVWF  FF6
055FA:  MOVLW  56
055FC:  ADDWFC FF7,F
055FE:  TBLRD*-
05600:  MOVF   FF5,W
05602:  MOVWF  FFA
05604:  TBLRD*
05606:  MOVF   FF5,W
05608:  MOVWF  FF9
0560A:  DATA CC,52
0560C:  DATA 08,53
0560E:  DATA 3C,53
05610:  DATA E2,53
05612:  DATA 48,54
05614:  DATA E6,54
05616:  DATA 16,55
05618:  DATA B0,55
*
05662:  MOVFF  8F4,FEA
05666:  MOVFF  8F3,FE9
0566A:  MOVLB  8
0566C:  MOVFF  8F9,FEF
05670:  INCF   FE9,F
05672:  BTFSC  FD8.2
05674:  INCF   FEA,F
05676:  CLRF   FEF
05678:  INCF   xF3,F
0567A:  BTFSC  FD8.2
0567C:  INCF   xF4,F
0567E:  MOVLB  0
05680:  RETURN 0
05682:  MOVLB  8
05684:  BTFSC  xF7.7
05686:  BRA    56AA
05688:  MOVLW  0F
0568A:  MOVWF  00
0568C:  SWAPF  xF6,W
0568E:  ANDWF  00,F
05690:  MOVLW  0A
05692:  SUBWF  00,W
05694:  BC    569C
05696:  MOVLW  30
05698:  ADDWF  00,F
0569A:  BRA    56A0
0569C:  MOVF   xF7,W
0569E:  ADDWF  00,F
056A0:  MOVFF  00,8F9
056A4:  MOVLB  0
056A6:  RCALL  5662
056A8:  MOVLB  8
056AA:  MOVLW  0F
056AC:  ANDWF  xF6,F
056AE:  MOVLW  0A
056B0:  SUBWF  xF6,W
056B2:  BC    56B8
056B4:  MOVLW  30
056B6:  BRA    56BC
056B8:  BCF    xF7.7
056BA:  MOVF   xF7,W
056BC:  ADDWF  xF6,F
056BE:  MOVFF  8F6,8F9
056C2:  MOVLB  0
056C4:  RCALL  5662
056C6:  RETURN 0
056C8:  TBLRD*+
056CA:  MOVFF  FF6,8F7
056CE:  MOVFF  FF7,8F8
056D2:  MOVFF  FF5,8F9
056D6:  RCALL  5662
056D8:  MOVFF  8F7,FF6
056DC:  MOVFF  8F8,FF7
056E0:  MOVLB  8
056E2:  DECFSZ xF6,F
056E4:  BRA    56E8
056E6:  BRA    56EC
056E8:  MOVLB  0
056EA:  BRA    56C8
056EC:  MOVLB  0
056EE:  GOTO   57D0 (RETURN)
056F2:  TSTFSZ 01
056F4:  BRA    56FC
056F6:  TSTFSZ 02
056F8:  BRA    56FE
056FA:  BRA    570A
056FC:  INCF   02,F
056FE:  MOVFF  00,FEE
05702:  DECFSZ 01,F
05704:  BRA    56FE
05706:  DECFSZ 02,F
05708:  BRA    56FE
0570A:  RETURN 0
*
05890:  TBLRD*+
05892:  MOVF   FF5,F
05894:  BZ    58AE
05896:  MOVFF  FF6,8F6
0589A:  MOVFF  FF7,8F7
0589E:  MOVFF  FF5,8F9
058A2:  RCALL  5662
058A4:  MOVFF  8F6,FF6
058A8:  MOVFF  8F7,FF7
058AC:  BRA    5890
058AE:  GOTO   5944 (RETURN)
*
05B3A:  TBLRD*+
05B3C:  MOVFF  FF6,90B
05B40:  MOVFF  FF7,90C
05B44:  MOVFF  FF5,910
05B48:  RCALL  5B2A
05B4A:  MOVFF  90B,FF6
05B4E:  MOVFF  90C,FF7
05B52:  MOVLB  9
05B54:  DECFSZ x0A,F
05B56:  BRA    5B5A
05B58:  BRA    5B5E
05B5A:  MOVLB  0
05B5C:  BRA    5B3A
05B5E:  MOVLB  0
05B60:  RETURN 0
05B62:  MOVF   FEF,F
05B64:  BZ    5B84
05B66:  MOVFF  FEA,90C
05B6A:  MOVFF  FE9,90B
05B6E:  MOVFF  FEF,910
05B72:  RCALL  5B2A
05B74:  MOVFF  90C,FEA
05B78:  MOVFF  90B,FE9
05B7C:  INCF   FE9,F
05B7E:  BTFSC  FD8.2
05B80:  INCF   FEA,F
05B82:  BRA    5B62
05B84:  RETURN 0
*
05B92:  TBLRD*+
05B94:  MOVF   FF5,F
05B96:  BZ    5BB0
05B98:  MOVFF  FF6,90B
05B9C:  MOVFF  FF7,90C
05BA0:  MOVFF  FF5,910
05BA4:  RCALL  5B2A
05BA6:  MOVFF  90B,FF6
05BAA:  MOVFF  90C,FF7
05BAE:  BRA    5B92
05BB0:  RETURN 0
05BB2:  MOVLW  20
05BB4:  MOVLB  9
05BB6:  BTFSS  x0B.4
05BB8:  MOVLW  30
05BBA:  MOVWF  x0C
05BBC:  MOVFF  90A,00
05BC0:  BTFSS  x0A.7
05BC2:  BRA    5BD4
05BC4:  COMF   00,F
05BC6:  INCF   00,F
05BC8:  MOVFF  00,90A
05BCC:  MOVLW  2D
05BCE:  MOVWF  x0C
05BD0:  BSF    x0B.7
05BD2:  BSF    x0B.0
05BD4:  MOVF   01,W
05BD6:  MOVFF  90A,910
05BDA:  MOVLW  64
05BDC:  MOVWF  x11
05BDE:  MOVLB  0
05BE0:  CALL   153A
05BE4:  MOVFF  00,90A
05BE8:  MOVLW  30
05BEA:  ADDWF  01,W
05BEC:  MOVLB  9
05BEE:  MOVWF  x0D
05BF0:  MOVFF  90A,910
05BF4:  MOVLW  0A
05BF6:  MOVWF  x11
05BF8:  MOVLB  0
05BFA:  CALL   153A
05BFE:  MOVLW  30
05C00:  ADDWF  00,W
05C02:  MOVLB  9
05C04:  MOVWF  x0F
05C06:  MOVLW  30
05C08:  ADDWF  01,W
05C0A:  MOVWF  x0E
05C0C:  MOVFF  90C,00
05C10:  MOVLW  30
05C12:  SUBWF  x0D,W
05C14:  BZ    5C1E
05C16:  BSF    x0B.1
05C18:  BTFSC  x0B.7
05C1A:  BSF    x0B.2
05C1C:  BRA    5C42
05C1E:  BTFSC  x0B.2
05C20:  BRA    5C42
05C22:  MOVFF  90C,90D
05C26:  BTFSC  x0B.1
05C28:  BRA    5C32
05C2A:  MOVLW  30
05C2C:  SUBWF  x0E,W
05C2E:  BZ    5C38
05C30:  BSF    x0B.0
05C32:  BTFSC  x0B.7
05C34:  BSF    x0B.1
05C36:  BRA    5C42
05C38:  BTFSS  FD8.2
05C3A:  BSF    x0B.0
05C3C:  BTFSC  FD8.2
05C3E:  MOVFF  90D,90E
05C42:  BTFSC  x0B.2
05C44:  BRA    5C50
05C46:  BTFSC  x0B.1
05C48:  BRA    5C58
05C4A:  BTFSC  x0B.0
05C4C:  BRA    5C60
05C4E:  BRA    5C68
05C50:  MOVFF  90C,910
05C54:  MOVLB  0
05C56:  RCALL  5B2A
05C58:  MOVFF  90D,910
05C5C:  MOVLB  0
05C5E:  RCALL  5B2A
05C60:  MOVFF  90E,910
05C64:  MOVLB  0
05C66:  RCALL  5B2A
05C68:  MOVFF  90F,910
05C6C:  MOVLB  0
05C6E:  RCALL  5B2A
05C70:  RETURN 0
*
069AA:  MOVLW  20
069AC:  MOVLB  8
069AE:  BTFSS  xF7.4
069B0:  MOVLW  30
069B2:  MOVWF  xF8
069B4:  MOVFF  8F6,00
069B8:  BTFSS  xF6.7
069BA:  BRA    69CC
069BC:  COMF   00,F
069BE:  INCF   00,F
069C0:  MOVFF  00,8F6
069C4:  MOVLW  2D
069C6:  MOVWF  xF8
069C8:  BSF    xF7.7
069CA:  BSF    xF7.0
069CC:  MOVF   01,W
069CE:  MOVFF  8F6,910
069D2:  MOVLW  64
069D4:  MOVLB  9
069D6:  MOVWF  x11
069D8:  MOVLB  0
069DA:  CALL   153A
069DE:  MOVFF  00,8F6
069E2:  MOVLW  30
069E4:  ADDWF  01,W
069E6:  MOVLB  8
069E8:  MOVWF  xF9
069EA:  MOVFF  8F6,910
069EE:  MOVLW  0A
069F0:  MOVLB  9
069F2:  MOVWF  x11
069F4:  MOVLB  0
069F6:  CALL   153A
069FA:  MOVLW  30
069FC:  ADDWF  00,W
069FE:  MOVLB  8
06A00:  MOVWF  xFB
06A02:  MOVLW  30
06A04:  ADDWF  01,W
06A06:  MOVWF  xFA
06A08:  MOVFF  8F8,00
06A0C:  MOVLW  30
06A0E:  SUBWF  xF9,W
06A10:  BZ    6A1A
06A12:  BSF    xF7.1
06A14:  BTFSC  xF7.7
06A16:  BSF    xF7.2
06A18:  BRA    6A3E
06A1A:  BTFSC  xF7.2
06A1C:  BRA    6A3E
06A1E:  MOVFF  8F8,8F9
06A22:  BTFSC  xF7.1
06A24:  BRA    6A2E
06A26:  MOVLW  30
06A28:  SUBWF  xFA,W
06A2A:  BZ    6A34
06A2C:  BSF    xF7.0
06A2E:  BTFSC  xF7.7
06A30:  BSF    xF7.1
06A32:  BRA    6A3E
06A34:  BTFSS  FD8.2
06A36:  BSF    xF7.0
06A38:  BTFSC  FD8.2
06A3A:  MOVFF  8F9,8FA
06A3E:  BTFSC  xF7.2
06A40:  BRA    6A4C
06A42:  BTFSC  xF7.1
06A44:  BRA    6A56
06A46:  BTFSC  xF7.0
06A48:  BRA    6A60
06A4A:  BRA    6A6A
06A4C:  MOVFF  8F8,8FC
06A50:  MOVLB  0
06A52:  CALL   0632
06A56:  MOVFF  8F9,8FC
06A5A:  MOVLB  0
06A5C:  CALL   0632
06A60:  MOVFF  8FA,8FC
06A64:  MOVLB  0
06A66:  CALL   0632
06A6A:  MOVFF  8FB,8FC
06A6E:  MOVLB  0
06A70:  CALL   0632
06A74:  RETURN 0
....................  
.................... #list 
....................  
.................... // Conversor de 10 bits con justificación a la derecha. 
.................... //#device ADC=10 
.................... // Configuramos velocidad de operación. 
.................... #use delay(clock=40000000) // Trabajamos a 20.00Mhz.  
*
005B4:  MOVLW  08
005B6:  MOVWF  FEA
005B8:  MOVLW  FD
005BA:  MOVWF  FE9
005BC:  MOVF   FEF,W
005BE:  BZ    05DC
005C0:  MOVLW  0C
005C2:  MOVWF  01
005C4:  CLRF   00
005C6:  DECFSZ 00,F
005C8:  BRA    05C6
005CA:  DECFSZ 01,F
005CC:  BRA    05C4
005CE:  MOVLW  F7
005D0:  MOVWF  00
005D2:  DECFSZ 00,F
005D4:  BRA    05D2
005D6:  BRA    05D8
005D8:  DECFSZ FEF,F
005DA:  BRA    05C0
005DC:  RETURN 0
.................... // Configuramos fusibles de programación. 
.................... //#FUSES NOWDT                    // No utilizamos el perro guardían. 
.................... #FUSES WDT4096 
.................... #FUSES H4                       // Oscilador de alta velocidad 40Mhz. 
.................... #FUSES FCMEN                    // Monitor de reloj activado. 
.................... #FUSES PUT                      // Temporizador de encendido. 
.................... #FUSES NOBROWNOUT               // No activamos el reset por bajo voltaje. 
.................... #FUSES NOPBADEN                 // Deshabilitamos el módulo conversor ADC del puerto B. 
.................... #FUSES NOLPT1OSC                // Timer 1 configurado para una alta potencia de operación. 
.................... //#FUSES NOMCLR                   // Pin Master Clear deshabilitado. 
.................... #FUSES MCLR                     // Pin Master Clear habilitado. 
.................... #FUSES STVREN                   // Si se rebalsa o llena el stack el microcontrolador se resetea. 
.................... #FUSES NOLVP                    // No utilizamos bajo voltaje para programación. 
.................... #FUSES NOXINST                  // Set de instruccciones ampliado, desactivado. 
.................... #FUSES NODEBUG                  // No utilizamos código para debug. 
.................... #FUSES PROTECT                  // Código protejido contra lecturas. 
.................... #FUSES NOCPB                    // Sector de booteo no protejido. 
.................... #FUSES NOCPD                    // Sin protección de código en la EEPROM. 
.................... #FUSES NOWRT                    // Memoria de programa no protejida contra escrituras. 
.................... #FUSES NOWRTC                   // Registros de configuración no protegido contra escritura. 
.................... #FUSES NOWRTB                   // Bloque de booteo no protejido contra escritura. 
.................... #FUSES NOWRTD                   // Memoria EEPROM no protejida contra escritura. 
.................... #FUSES NOEBTR                   // Memoria no protejida contra lectuas de tablas de memoria. 
.................... #FUSES NOEBTRB                  // Bloque de booteo no protejido contra lectura de tablas de memoria. 
....................  
.................... // Configuramos los puertos RS232 utilizados. 
.................... #use RS232(uart1, baud=38400,RESTART_WDT,stream=U1PRINTER,TIMEOUT=40,DISABLE_INTS) 
*
05B2A:  CLRWDT
05B2C:  BTFSS  F9E.4
05B2E:  BRA    5B2A
05B30:  MOVLB  9
05B32:  MOVFF  910,FAD
05B36:  MOVLB  0
05B38:  RETURN 0
....................  
.................... const int data_set=14;//CANTIDAD DE INSTRUCCIONES GRABADAS 
.................... const int port_size=90; 
.................... const int tag_size = 8; 
.................... const int word_size_reg =12;//TAMAÑO DE REGISTRO 
.................... const int16 lim_reg=300; 
.................... const int16 data_numbers_ext=2000;//maximo de tags en eeprom 
.................... const int instruccion_size = 10; 
....................  
.................... int envia_pc,a,b2,relay1,tcp_recibe,time_relay1,falla_grabar,f_graba; 
.................... char memory[30]; 
.................... int16 i,n,b,c_envia; 
.................... int size_tx_tcp,con_activas; 
.................... unsigned int16 m,dir; 
....................  
.................... int edo_str, reintento_envio,inicializado,socket2; 
.................... char XX[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RECIBIDOS DE TCP) 
.................... char YY[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RESPALDO EN RAM) 
.................... char txtcp[port_size];//ARREGLO DE TRANSMICION 
.................... char rxtcp[port_size];//1536->112 tags,se direcciona mal la ram con valores mas grandes 
.................... //500-alcanza para 54 tags, mas no alcanza la ram, 700au cabe 
.................... char lcd_men[port_size-10]; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size=26;//34;// 
.................... int deteccion_nulo,pre_cuenta; 
.................... int wieg,wigmal,tecla; 
.................... int sub_indice=0; 
.................... int wieg_full=0; 
.................... int wiegand_cuenta; 
.................... unsigned int32 deci; 
.................... char data[wieg_size]; 
.................... char con_barra[30],barra_codi[30]; 
.................... int32 folio; 
.................... const int idbar=1; 
.................... const int data_numbers=14; 
.................... //RELOJ/CALENDARIO 
.................... int day,month,yr,hrs,min,sec,dow,puntos,cambio_msj; 
.................... int dias_prueba,dia_temp,pago,cuenta,espera,hrs2; 
.................... int16 mes2,dia; 
.................... const int dia_limite=90; 
.................... //variables de entradas 
.................... int en1,en2,en3,en4,en5,flag_pluma; 
.................... //boleto 
.................... int time_boleto,re_bol,cta_lcd; 
.................... // Definimos macros hardware: 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00526:  MOVLB  9
00528:  BTFSC  x04.0
0052A:  BRA    0530
0052C:  BCF    F89.4
0052E:  BRA    0532
00530:  BSF    F89.4
00532:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00534:  BTFSC  x04.1
00536:  BRA    053C
00538:  BCF    F89.2
0053A:  BRA    053E
0053C:  BSF    F89.2
0053E:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
00540:  BTFSC  x04.2
00542:  BRA    0548
00544:  BCF    F89.1
00546:  BRA    054A
00548:  BSF    F89.1
0054A:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
0054C:  BTFSC  x04.3
0054E:  BRA    0554
00550:  BCF    F89.0
00552:  BRA    0556
00554:  BSF    F89.0
00556:  BCF    F92.0
....................  
....................  delay_cycles(1);  
00558:  NOP   
....................  output_high(LCD_E);  
0055A:  BCF    F92.3
0055C:  BSF    F89.3
....................  delay_us(2);  
0055E:  MOVLW  06
00560:  MOVWF  00
00562:  DECFSZ 00,F
00564:  BRA    0562
00566:  NOP   
....................  output_low(LCD_E);  
00568:  BCF    F92.3
0056A:  BCF    F89.3
0056C:  MOVLB  0
0056E:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
00570:  BCF    F96.2
00572:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
00574:  MOVLW  C7
00576:  MOVWF  00
00578:  DECFSZ 00,F
0057A:  BRA    0578
0057C:  BRA    057E
.................... #endif  
....................  
.................... if(address)  
0057E:  MOVLB  9
00580:  MOVF   x01,F
00582:  BZ    058A
....................    output_high(LCD_RS);  
00584:  BCF    F96.2
00586:  BSF    F8D.2
00588:  BRA    058E
.................... else  
....................    output_low(LCD_RS);  
0058A:  BCF    F96.2
0058C:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
0058E:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
00590:  BCF    F92.3
00592:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
00594:  SWAPF  x02,W
00596:  MOVWF  x03
00598:  MOVLW  0F
0059A:  ANDWF  x03,F
0059C:  MOVFF  903,904
005A0:  MOVLB  0
005A2:  RCALL  0526
.................... lcd_send_nibble(n & 0xf);  
005A4:  MOVLB  9
005A6:  MOVF   x02,W
005A8:  ANDLW  0F
005AA:  MOVWF  x03
005AC:  MOVWF  x04
005AE:  MOVLB  0
005B0:  RCALL  0526
005B2:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
*
006BE:  MOVLW  01
006C0:  MOVLB  2
006C2:  MOVWF  x8C
....................  
....................    output_low(LCD_RS);  
006C4:  BCF    F96.2
006C6:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
006C8:  BCF    F92.3
006CA:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
006CC:  MOVLW  23
006CE:  MOVLB  8
006D0:  MOVWF  xFD
006D2:  MOVLB  0
006D4:  RCALL  05B4
....................  
....................    for(i=0 ;i < 3; i++)  
006D6:  MOVLB  8
006D8:  CLRF   xF6
006DA:  MOVF   xF6,W
006DC:  SUBLW  02
006DE:  BNC   06FA
....................    {  
....................       lcd_send_nibble(0x03);  
006E0:  MOVLW  03
006E2:  MOVLB  9
006E4:  MOVWF  x04
006E6:  MOVLB  0
006E8:  RCALL  0526
....................       delay_ms(5);  
006EA:  MOVLW  05
006EC:  MOVLB  8
006EE:  MOVWF  xFD
006F0:  MOVLB  0
006F2:  RCALL  05B4
006F4:  MOVLB  8
006F6:  INCF   xF6,F
006F8:  BRA    06DA
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
006FA:  MOVLW  02
006FC:  MOVLB  9
006FE:  MOVWF  x04
00700:  MOVLB  0
00702:  RCALL  0526
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
00704:  MOVLB  8
00706:  CLRF   xF6
00708:  MOVF   xF6,W
0070A:  SUBLW  03
0070C:  BNC   0734
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
0070E:  CLRF   03
00710:  MOVF   xF6,W
00712:  MOVLB  0
00714:  RCALL  00D2
00716:  MOVLB  8
00718:  MOVWF  xF7
0071A:  MOVLB  9
0071C:  CLRF   x01
0071E:  MOVWF  x02
00720:  MOVLB  0
00722:  RCALL  0570
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
00724:  MOVLW  05
00726:  MOVLB  8
00728:  MOVWF  xFD
0072A:  MOVLB  0
0072C:  RCALL  05B4
....................       #endif  
0072E:  MOVLB  8
00730:  INCF   xF6,F
00732:  BRA    0708
....................    }  
00734:  MOVLB  0
00736:  GOTO   6C38 (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
005DE:  MOVLB  8
005E0:  MOVF   xFE,W
005E2:  XORLW  01
005E4:  MOVLB  0
005E6:  BZ    05F6
005E8:  XORLW  03
005EA:  BZ    05FC
005EC:  XORLW  01
005EE:  BZ    0604
005F0:  XORLW  07
005F2:  BZ    060C
005F4:  BRA    0616
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
005F6:  MOVLB  8
005F8:  CLRF   xFF
....................      break;  
005FA:  BRA    061A
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
005FC:  MOVLW  40
005FE:  MOVLB  8
00600:  MOVWF  xFF
....................      break;  
00602:  BRA    061A
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
00604:  MOVLW  14
00606:  MOVLB  8
00608:  MOVWF  xFF
....................      break;  
0060A:  BRA    061A
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
0060C:  MOVLW  54
0060E:  MOVLB  8
00610:  MOVWF  xFF
....................      break;  
00612:  BRA    061A
00614:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
00616:  MOVLB  8
00618:  CLRF   xFF
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
0061A:  MOVLW  01
0061C:  SUBWF  xFD,W
0061E:  ADDWF  xFF,F
.................... lcd_send_byte(0, 0x80 | address);  
00620:  MOVF   xFF,W
00622:  IORLW  80
00624:  MOVLB  9
00626:  MOVWF  x00
00628:  CLRF   x01
0062A:  MOVWF  x02
0062C:  MOVLB  0
0062E:  RCALL  0570
00630:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
00632:  MOVLB  8
00634:  MOVF   xFC,W
00636:  XORLW  0C
00638:  MOVLB  0
0063A:  BZ    0646
0063C:  XORLW  06
0063E:  BZ    0664
00640:  XORLW  02
00642:  BZ    0678
00644:  BRA    0686
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
00646:  MOVLB  9
00648:  CLRF   x01
0064A:  MOVLW  01
0064C:  MOVWF  x02
0064E:  MOVLB  0
00650:  RCALL  0570
....................       lcd_line = 1;  
00652:  MOVLW  01
00654:  MOVLB  2
00656:  MOVWF  x8C
....................       delay_ms(2);  
00658:  MOVLW  02
0065A:  MOVLB  8
0065C:  MOVWF  xFD
0065E:  MOVLB  0
00660:  RCALL  05B4
....................       break;  
00662:  BRA    0694
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
00664:  MOVLB  2
00666:  INCF   x8C,F
00668:  MOVLW  01
0066A:  MOVLB  8
0066C:  MOVWF  xFD
0066E:  MOVFF  28C,8FE
00672:  MOVLB  0
00674:  RCALL  05DE
....................        break;  
00676:  BRA    0694
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
00678:  MOVLB  9
0067A:  CLRF   x01
0067C:  MOVLW  10
0067E:  MOVWF  x02
00680:  MOVLB  0
00682:  RCALL  0570
....................        break;  
00684:  BRA    0694
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
00686:  MOVLW  01
00688:  MOVLB  9
0068A:  MOVWF  x01
0068C:  MOVFF  8FC,902
00690:  MOVLB  0
00692:  RCALL  0570
....................        break;  
....................    }  
00694:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_SEGUINT.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B5//PIN_B7 
.................... #define EEPROM_SCL  PIN_B4//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
01280:  MOVLW  08
01282:  MOVWF  01
01284:  MOVLW  0E
01286:  MOVWF  00
01288:  DECFSZ 00,F
0128A:  BRA    1288
0128C:  BCF    F8A.4
0128E:  BCF    F93.4
01290:  MOVLW  0E
01292:  MOVWF  00
01294:  DECFSZ 00,F
01296:  BRA    1294
01298:  MOVLB  9
0129A:  RLCF   x0C,F
0129C:  BCF    F8A.5
0129E:  BTFSC  FD8.0
012A0:  BSF    F93.5
012A2:  BTFSS  FD8.0
012A4:  BCF    F93.5
012A6:  BSF    F93.4
012A8:  BTFSS  F81.4
012AA:  BRA    12A8
012AC:  DECFSZ 01,F
012AE:  BRA    12B2
012B0:  BRA    12B6
012B2:  MOVLB  0
012B4:  BRA    1284
012B6:  MOVLW  0E
012B8:  MOVWF  00
012BA:  DECFSZ 00,F
012BC:  BRA    12BA
012BE:  BCF    F8A.4
012C0:  BCF    F93.4
012C2:  NOP   
012C4:  BSF    F93.5
012C6:  MOVLW  0E
012C8:  MOVWF  00
012CA:  DECFSZ 00,F
012CC:  BRA    12CA
012CE:  MOVLW  0E
012D0:  MOVWF  00
012D2:  DECFSZ 00,F
012D4:  BRA    12D2
012D6:  BSF    F93.4
012D8:  BTFSS  F81.4
012DA:  BRA    12D8
012DC:  CLRF   01
012DE:  MOVLW  0E
012E0:  MOVWF  00
012E2:  DECFSZ 00,F
012E4:  BRA    12E2
012E6:  BTFSC  F81.5
012E8:  BSF    01.0
012EA:  BCF    F8A.4
012EC:  BCF    F93.4
012EE:  BCF    F8A.5
012F0:  BCF    F93.5
012F2:  MOVLB  0
012F4:  RETURN 0
012F6:  MOVLW  08
012F8:  MOVLB  9
012FA:  MOVWF  x0A
012FC:  MOVFF  00,90B
01300:  BSF    F93.5
01302:  MOVLW  0E
01304:  MOVWF  00
01306:  DECFSZ 00,F
01308:  BRA    1306
0130A:  BSF    F93.4
0130C:  BTFSS  F81.4
0130E:  BRA    130C
01310:  BTFSC  F81.5
01312:  BSF    FD8.0
01314:  BTFSS  F81.5
01316:  BCF    FD8.0
01318:  RLCF   01,F
0131A:  MOVLW  0E
0131C:  MOVWF  00
0131E:  DECFSZ 00,F
01320:  BRA    131E
01322:  BCF    F93.4
01324:  BCF    F8A.4
01326:  DECFSZ x0A,F
01328:  BRA    1300
0132A:  BSF    F93.5
0132C:  MOVLW  0E
0132E:  MOVWF  00
01330:  DECFSZ 00,F
01332:  BRA    1330
01334:  BCF    F8A.5
01336:  MOVF   x0B,W
01338:  BTFSS  FD8.2
0133A:  BCF    F93.5
0133C:  NOP   
0133E:  BSF    F93.4
01340:  BTFSS  F81.4
01342:  BRA    1340
01344:  MOVLW  0E
01346:  MOVWF  00
01348:  DECFSZ 00,F
0134A:  BRA    1348
0134C:  BCF    F8A.4
0134E:  BCF    F93.4
01350:  MOVLW  0E
01352:  MOVWF  00
01354:  DECFSZ 00,F
01356:  BRA    1354
01358:  BCF    F8A.5
0135A:  BCF    F93.5
0135C:  MOVLB  0
0135E:  GOTO   13DC (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
006B6:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
006B8:  BSF    F93.5
006BA:  GOTO   6C34 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data){ 
....................    short int status; 
....................    i2c_start(); 
*
0140A:  BSF    F93.5
0140C:  MOVLW  0E
0140E:  MOVWF  00
01410:  DECFSZ 00,F
01412:  BRA    1410
01414:  BSF    F93.4
01416:  MOVLW  0E
01418:  MOVWF  00
0141A:  DECFSZ 00,F
0141C:  BRA    141A
0141E:  BCF    F8A.5
01420:  BCF    F93.5
01422:  MOVLW  0E
01424:  MOVWF  00
01426:  DECFSZ 00,F
01428:  BRA    1426
0142A:  BCF    F8A.4
0142C:  BCF    F93.4
....................    i2c_write(0xa0); 
0142E:  MOVLW  A0
01430:  MOVLB  9
01432:  MOVWF  x0C
01434:  MOVLB  0
01436:  RCALL  1280
....................    i2c_write(address>>8); 
01438:  MOVFF  907,90A
0143C:  MOVLB  9
0143E:  CLRF   x0B
01440:  MOVFF  907,90C
01444:  MOVLB  0
01446:  RCALL  1280
....................    i2c_write(address); 
01448:  MOVFF  906,90C
0144C:  RCALL  1280
....................    i2c_write(data); 
0144E:  MOVFF  908,90C
01452:  RCALL  1280
....................    i2c_stop(); 
01454:  BCF    F93.5
01456:  NOP   
01458:  BSF    F93.4
0145A:  BTFSS  F81.4
0145C:  BRA    145A
0145E:  MOVLW  0E
01460:  MOVWF  00
01462:  DECFSZ 00,F
01464:  BRA    1462
01466:  BRA    1468
01468:  NOP   
0146A:  BSF    F93.5
0146C:  MOVLW  0E
0146E:  MOVWF  00
01470:  DECFSZ 00,F
01472:  BRA    1470
....................    i2c_start(); 
01474:  BSF    F93.5
01476:  MOVLW  0E
01478:  MOVWF  00
0147A:  DECFSZ 00,F
0147C:  BRA    147A
0147E:  BSF    F93.4
01480:  MOVLW  0E
01482:  MOVWF  00
01484:  DECFSZ 00,F
01486:  BRA    1484
01488:  BCF    F8A.5
0148A:  BCF    F93.5
0148C:  MOVLW  0E
0148E:  MOVWF  00
01490:  DECFSZ 00,F
01492:  BRA    1490
01494:  BCF    F8A.4
01496:  BCF    F93.4
....................    status=i2c_write(0xa0); 
01498:  MOVLW  A0
0149A:  MOVLB  9
0149C:  MOVWF  x0C
0149E:  MOVLB  0
014A0:  RCALL  1280
014A2:  MOVF   01,W
014A4:  MOVLB  9
014A6:  BCF    x09.0
014A8:  BTFSC  01.0
014AA:  BSF    x09.0
....................    while(status==1) 
014AC:  BTFSS  x09.0
014AE:  BRA    14EC
....................    { 
....................    i2c_start(); 
014B0:  BSF    F93.5
014B2:  MOVLW  0E
014B4:  MOVWF  00
014B6:  DECFSZ 00,F
014B8:  BRA    14B6
014BA:  BSF    F93.4
014BC:  MOVLW  0E
014BE:  MOVWF  00
014C0:  DECFSZ 00,F
014C2:  BRA    14C0
014C4:  BTFSS  F81.4
014C6:  BRA    14C4
014C8:  BCF    F8A.5
014CA:  BCF    F93.5
014CC:  MOVLW  0E
014CE:  MOVWF  00
014D0:  DECFSZ 00,F
014D2:  BRA    14D0
014D4:  BCF    F8A.4
014D6:  BCF    F93.4
....................    status=i2c_write(0xa0); 
014D8:  MOVLW  A0
014DA:  MOVWF  x0C
014DC:  MOVLB  0
014DE:  RCALL  1280
014E0:  MOVF   01,W
014E2:  MOVLB  9
014E4:  BCF    x09.0
014E6:  BTFSC  01.0
014E8:  BSF    x09.0
014EA:  BRA    14AC
....................    } 
....................    i2c_stop(); 
014EC:  BCF    F93.5
014EE:  NOP   
014F0:  BSF    F93.4
014F2:  BTFSS  F81.4
014F4:  BRA    14F2
014F6:  MOVLW  0E
014F8:  MOVWF  00
014FA:  DECFSZ 00,F
014FC:  BRA    14FA
014FE:  BRA    1500
01500:  NOP   
01502:  BSF    F93.5
01504:  MOVLW  0E
01506:  MOVWF  00
01508:  DECFSZ 00,F
0150A:  BRA    1508
0150C:  MOVLB  0
0150E:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
01362:  BSF    F93.5
01364:  MOVLW  0E
01366:  MOVWF  00
01368:  DECFSZ 00,F
0136A:  BRA    1368
0136C:  BSF    F93.4
0136E:  MOVLW  0E
01370:  MOVWF  00
01372:  DECFSZ 00,F
01374:  BRA    1372
01376:  BCF    F8A.5
01378:  BCF    F93.5
0137A:  MOVLW  0E
0137C:  MOVWF  00
0137E:  DECFSZ 00,F
01380:  BRA    137E
01382:  BCF    F8A.4
01384:  BCF    F93.4
....................    i2c_write(0xa0); 
01386:  MOVLW  A0
01388:  MOVLB  9
0138A:  MOVWF  x0C
0138C:  MOVLB  0
0138E:  RCALL  1280
....................    i2c_write(address>>8); 
01390:  MOVFF  907,909
01394:  MOVLB  9
01396:  CLRF   x0A
01398:  MOVFF  907,90C
0139C:  MOVLB  0
0139E:  RCALL  1280
....................    i2c_write(address); 
013A0:  MOVFF  906,90C
013A4:  RCALL  1280
....................    i2c_start(); 
013A6:  BSF    F93.5
013A8:  MOVLW  0E
013AA:  MOVWF  00
013AC:  DECFSZ 00,F
013AE:  BRA    13AC
013B0:  BSF    F93.4
013B2:  MOVLW  0E
013B4:  MOVWF  00
013B6:  DECFSZ 00,F
013B8:  BRA    13B6
013BA:  BTFSS  F81.4
013BC:  BRA    13BA
013BE:  BCF    F8A.5
013C0:  BCF    F93.5
013C2:  MOVLW  0E
013C4:  MOVWF  00
013C6:  DECFSZ 00,F
013C8:  BRA    13C6
013CA:  BCF    F8A.4
013CC:  BCF    F93.4
....................    i2c_write(0xa1); 
013CE:  MOVLW  A1
013D0:  MOVLB  9
013D2:  MOVWF  x0C
013D4:  MOVLB  0
013D6:  RCALL  1280
....................    data=i2c_read(0); 
013D8:  CLRF   00
013DA:  BRA    12F6
013DC:  MOVFF  01,908
....................    i2c_stop(); 
013E0:  BCF    F93.5
013E2:  NOP   
013E4:  BSF    F93.4
013E6:  BTFSS  F81.4
013E8:  BRA    13E6
013EA:  MOVLW  0E
013EC:  MOVWF  00
013EE:  DECFSZ 00,F
013F0:  BRA    13EE
013F2:  BRA    13F4
013F4:  NOP   
013F6:  BSF    F93.5
013F8:  MOVLW  0E
013FA:  MOVWF  00
013FC:  DECFSZ 00,F
013FE:  BRA    13FC
....................    return(data); 
01400:  MOVLB  9
01402:  MOVFF  908,01
01406:  MOVLB  0
01408:  RETURN 0
.................... } 
....................  
.................... #include "ds1307_3.c" //reloj 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_D6 
.................... #define RTC_SCL  PIN_E1 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
05A20:  MOVLW  08
05A22:  MOVWF  01
05A24:  MOVLW  0E
05A26:  MOVWF  00
05A28:  DECFSZ 00,F
05A2A:  BRA    5A28
05A2C:  BCF    F8D.1
05A2E:  BCF    F96.1
05A30:  MOVLW  0E
05A32:  MOVWF  00
05A34:  DECFSZ 00,F
05A36:  BRA    5A34
05A38:  MOVLB  9
05A3A:  RLCF   x0E,F
05A3C:  BCF    F8C.6
05A3E:  BTFSC  FD8.0
05A40:  BSF    F95.6
05A42:  BTFSS  FD8.0
05A44:  BCF    F95.6
05A46:  BSF    F96.1
05A48:  BTFSS  F84.1
05A4A:  BRA    5A48
05A4C:  DECFSZ 01,F
05A4E:  BRA    5A52
05A50:  BRA    5A56
05A52:  MOVLB  0
05A54:  BRA    5A24
05A56:  MOVLW  0E
05A58:  MOVWF  00
05A5A:  DECFSZ 00,F
05A5C:  BRA    5A5A
05A5E:  BCF    F8D.1
05A60:  BCF    F96.1
05A62:  NOP   
05A64:  BSF    F95.6
05A66:  MOVLW  0E
05A68:  MOVWF  00
05A6A:  DECFSZ 00,F
05A6C:  BRA    5A6A
05A6E:  MOVLW  0E
05A70:  MOVWF  00
05A72:  DECFSZ 00,F
05A74:  BRA    5A72
05A76:  BSF    F96.1
05A78:  BTFSS  F84.1
05A7A:  BRA    5A78
05A7C:  CLRF   01
05A7E:  MOVLW  0E
05A80:  MOVWF  00
05A82:  DECFSZ 00,F
05A84:  BRA    5A82
05A86:  BTFSC  F83.6
05A88:  BSF    01.0
05A8A:  BCF    F8D.1
05A8C:  BCF    F96.1
05A8E:  BCF    F8C.6
05A90:  BCF    F95.6
05A92:  MOVLB  0
05A94:  RETURN 0
05A96:  MOVLW  08
05A98:  MOVLB  9
05A9A:  MOVWF  x0F
05A9C:  MOVFF  00,910
05AA0:  BSF    F95.6
05AA2:  MOVLW  0E
05AA4:  MOVWF  00
05AA6:  DECFSZ 00,F
05AA8:  BRA    5AA6
05AAA:  BSF    F96.1
05AAC:  BTFSS  F84.1
05AAE:  BRA    5AAC
05AB0:  BTFSC  F83.6
05AB2:  BSF    FD8.0
05AB4:  BTFSS  F83.6
05AB6:  BCF    FD8.0
05AB8:  RLCF   01,F
05ABA:  MOVLW  0E
05ABC:  MOVWF  00
05ABE:  DECFSZ 00,F
05AC0:  BRA    5ABE
05AC2:  BCF    F96.1
05AC4:  BCF    F8D.1
05AC6:  DECFSZ x0F,F
05AC8:  BRA    5AA0
05ACA:  BSF    F95.6
05ACC:  MOVLW  0E
05ACE:  MOVWF  00
05AD0:  DECFSZ 00,F
05AD2:  BRA    5AD0
05AD4:  BCF    F8C.6
05AD6:  MOVF   x10,W
05AD8:  BTFSS  FD8.2
05ADA:  BCF    F95.6
05ADC:  NOP   
05ADE:  BSF    F96.1
05AE0:  BTFSS  F84.1
05AE2:  BRA    5AE0
05AE4:  MOVLW  0E
05AE6:  MOVWF  00
05AE8:  DECFSZ 00,F
05AEA:  BRA    5AE8
05AEC:  BCF    F8D.1
05AEE:  BCF    F96.1
05AF0:  MOVLW  0E
05AF2:  MOVWF  00
05AF4:  DECFSZ 00,F
05AF6:  BRA    5AF4
05AF8:  BCF    F8C.6
05AFA:  BCF    F95.6
05AFC:  MOVLB  0
05AFE:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    BYTE seconds = 0;  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
....................  
.................... }  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... {  
....................   sec &= 0x7F;  
*
06380:  MOVLB  9
06382:  BCF    x0C.7
....................   hr &= 0x3F;  
06384:  MOVLW  3F
06386:  ANDWF  x0A,F
....................  
....................   i2c_start();  
06388:  BSF    F95.6
0638A:  MOVLW  0E
0638C:  MOVWF  00
0638E:  DECFSZ 00,F
06390:  BRA    638E
06392:  BSF    F96.1
06394:  MOVLW  0E
06396:  MOVWF  00
06398:  DECFSZ 00,F
0639A:  BRA    6398
0639C:  BCF    F8C.6
0639E:  BCF    F95.6
063A0:  MOVLW  0E
063A2:  MOVWF  00
063A4:  DECFSZ 00,F
063A6:  BRA    63A4
063A8:  BCF    F8D.1
063AA:  BCF    F96.1
....................   i2c_write(0xD0);            // I2C write address  
063AC:  MOVLW  D0
063AE:  MOVWF  x0E
063B0:  MOVLB  0
063B2:  CALL   5A20
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
063B6:  MOVLB  9
063B8:  CLRF   x0E
063BA:  MOVLB  0
063BC:  CALL   5A20
....................   i2c_write(bin2bcd(sec));      // REG 0  
063C0:  MOVFF  90C,90D
063C4:  RCALL  6358
063C6:  MOVFF  01,90D
063CA:  MOVFF  01,90E
063CE:  CALL   5A20
....................   i2c_write(bin2bcd(min));      // REG 1  
063D2:  MOVFF  90B,90D
063D6:  RCALL  6358
063D8:  MOVFF  01,90D
063DC:  MOVFF  01,90E
063E0:  CALL   5A20
....................   i2c_write(bin2bcd(hr));      // REG 2  
063E4:  MOVFF  90A,90D
063E8:  RCALL  6358
063EA:  MOVFF  01,90D
063EE:  MOVFF  01,90E
063F2:  CALL   5A20
....................   i2c_write(bin2bcd(dow));      // REG 3  
063F6:  MOVFF  909,90D
063FA:  RCALL  6358
063FC:  MOVFF  01,90D
06400:  MOVFF  01,90E
06404:  CALL   5A20
....................   i2c_write(bin2bcd(day));      // REG 4  
06408:  MOVFF  906,90D
0640C:  RCALL  6358
0640E:  MOVFF  01,90D
06412:  MOVFF  01,90E
06416:  CALL   5A20
....................   i2c_write(bin2bcd(mth));      // REG 5  
0641A:  MOVFF  907,90D
0641E:  RCALL  6358
06420:  MOVFF  01,90D
06424:  MOVFF  01,90E
06428:  CALL   5A20
....................   i2c_write(bin2bcd(year));      // REG 6  
0642C:  MOVFF  908,90D
06430:  RCALL  6358
06432:  MOVFF  01,90D
06436:  MOVFF  01,90E
0643A:  CALL   5A20
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
0643E:  MOVLW  80
06440:  MOVLB  9
06442:  MOVWF  x0E
06444:  MOVLB  0
06446:  CALL   5A20
....................   i2c_stop();  
0644A:  BCF    F95.6
0644C:  NOP   
0644E:  BSF    F96.1
06450:  BTFSS  F84.1
06452:  BRA    6450
06454:  MOVLW  0E
06456:  MOVWF  00
06458:  DECFSZ 00,F
0645A:  BRA    6458
0645C:  BRA    645E
0645E:  NOP   
06460:  BSF    F95.6
06462:  MOVLW  0E
06464:  MOVWF  00
06466:  DECFSZ 00,F
06468:  BRA    6466
0646A:  RETURN 0
.................... }  
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   i2c_start();  
*
05DB4:  BSF    F95.6
05DB6:  MOVLW  0E
05DB8:  MOVWF  00
05DBA:  DECFSZ 00,F
05DBC:  BRA    5DBA
05DBE:  BSF    F96.1
05DC0:  MOVLW  0E
05DC2:  MOVWF  00
05DC4:  DECFSZ 00,F
05DC6:  BRA    5DC4
05DC8:  BCF    F8C.6
05DCA:  BCF    F95.6
05DCC:  MOVLW  0E
05DCE:  MOVWF  00
05DD0:  DECFSZ 00,F
05DD2:  BRA    5DD0
05DD4:  BCF    F8D.1
05DD6:  BCF    F96.1
*
066F4:  BSF    F95.6
066F6:  MOVLW  0E
066F8:  MOVWF  00
066FA:  DECFSZ 00,F
066FC:  BRA    66FA
066FE:  BSF    F96.1
06700:  MOVLW  0E
06702:  MOVWF  00
06704:  DECFSZ 00,F
06706:  BRA    6704
06708:  BCF    F8C.6
0670A:  BCF    F95.6
0670C:  MOVLW  0E
0670E:  MOVWF  00
06710:  DECFSZ 00,F
06712:  BRA    6710
06714:  BCF    F8D.1
06716:  BCF    F96.1
*
07266:  BSF    F95.6
07268:  MOVLW  0E
0726A:  MOVWF  00
0726C:  DECFSZ 00,F
0726E:  BRA    726C
07270:  BSF    F96.1
07272:  MOVLW  0E
07274:  MOVWF  00
07276:  DECFSZ 00,F
07278:  BRA    7276
0727A:  BCF    F8C.6
0727C:  BCF    F95.6
0727E:  MOVLW  0E
07280:  MOVWF  00
07282:  DECFSZ 00,F
07284:  BRA    7282
07286:  BCF    F8D.1
07288:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05DD8:  MOVLW  D0
05DDA:  MOVLB  9
05DDC:  MOVWF  x0E
05DDE:  MOVLB  0
05DE0:  RCALL  5A20
*
06718:  MOVLW  D0
0671A:  MOVWF  x0E
0671C:  MOVLB  0
0671E:  CALL   5A20
*
0728A:  MOVLW  D0
0728C:  MOVLB  9
0728E:  MOVWF  x0E
07290:  MOVLB  0
07292:  CALL   5A20
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
*
05DE2:  MOVLW  03
05DE4:  MOVLB  9
05DE6:  MOVWF  x0E
05DE8:  MOVLB  0
05DEA:  RCALL  5A20
*
06722:  MOVLW  03
06724:  MOVLB  9
06726:  MOVWF  x0E
06728:  MOVLB  0
0672A:  CALL   5A20
*
07296:  MOVLW  03
07298:  MOVLB  9
0729A:  MOVWF  x0E
0729C:  MOVLB  0
0729E:  CALL   5A20
....................   i2c_start();  
*
05DEC:  BSF    F95.6
05DEE:  MOVLW  0E
05DF0:  MOVWF  00
05DF2:  DECFSZ 00,F
05DF4:  BRA    5DF2
05DF6:  BSF    F96.1
05DF8:  MOVLW  0E
05DFA:  MOVWF  00
05DFC:  DECFSZ 00,F
05DFE:  BRA    5DFC
05E00:  BTFSS  F84.1
05E02:  BRA    5E00
05E04:  BCF    F8C.6
05E06:  BCF    F95.6
05E08:  MOVLW  0E
05E0A:  MOVWF  00
05E0C:  DECFSZ 00,F
05E0E:  BRA    5E0C
05E10:  BCF    F8D.1
05E12:  BCF    F96.1
*
0672E:  BSF    F95.6
06730:  MOVLW  0E
06732:  MOVWF  00
06734:  DECFSZ 00,F
06736:  BRA    6734
06738:  BSF    F96.1
0673A:  MOVLW  0E
0673C:  MOVWF  00
0673E:  DECFSZ 00,F
06740:  BRA    673E
06742:  BTFSS  F84.1
06744:  BRA    6742
06746:  BCF    F8C.6
06748:  BCF    F95.6
0674A:  MOVLW  0E
0674C:  MOVWF  00
0674E:  DECFSZ 00,F
06750:  BRA    674E
06752:  BCF    F8D.1
06754:  BCF    F96.1
*
072A2:  BSF    F95.6
072A4:  MOVLW  0E
072A6:  MOVWF  00
072A8:  DECFSZ 00,F
072AA:  BRA    72A8
072AC:  BSF    F96.1
072AE:  MOVLW  0E
072B0:  MOVWF  00
072B2:  DECFSZ 00,F
072B4:  BRA    72B2
072B6:  BTFSS  F84.1
072B8:  BRA    72B6
072BA:  BCF    F8C.6
072BC:  BCF    F95.6
072BE:  MOVLW  0E
072C0:  MOVWF  00
072C2:  DECFSZ 00,F
072C4:  BRA    72C2
072C6:  BCF    F8D.1
072C8:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05E14:  MOVLW  D1
05E16:  MOVLB  9
05E18:  MOVWF  x0E
05E1A:  MOVLB  0
05E1C:  RCALL  5A20
*
06756:  MOVLW  D1
06758:  MOVLB  9
0675A:  MOVWF  x0E
0675C:  MOVLB  0
0675E:  CALL   5A20
*
072CA:  MOVLW  D1
072CC:  MOVLB  9
072CE:  MOVWF  x0E
072D0:  MOVLB  0
072D2:  CALL   5A20
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
*
05E1E:  MOVLW  01
05E20:  MOVWF  00
05E22:  RCALL  5A96
05E24:  MOVF   01,W
05E26:  ANDLW  7F
05E28:  MOVLB  9
05E2A:  MOVWF  x0A
05E2C:  MOVWF  x0F
05E2E:  MOVLB  0
05E30:  RCALL  5B00
05E32:  MOVFF  01,276
*
06762:  MOVLW  01
06764:  MOVWF  00
06766:  CALL   5A96
0676A:  MOVF   01,W
0676C:  ANDLW  7F
0676E:  MOVLB  9
06770:  MOVWF  x0A
06772:  MOVWF  x0F
06774:  MOVLB  0
06776:  CALL   5B00
0677A:  MOVFF  01,276
*
072D6:  MOVLW  01
072D8:  MOVWF  00
072DA:  CALL   5A96
072DE:  MOVF   01,W
072E0:  ANDLW  7F
072E2:  MOVLB  9
072E4:  MOVWF  x0A
072E6:  MOVWF  x0F
072E8:  MOVLB  0
072EA:  CALL   5B00
072EE:  MOVFF  01,276
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
*
05E36:  MOVLW  01
05E38:  MOVWF  00
05E3A:  RCALL  5A96
05E3C:  MOVF   01,W
05E3E:  ANDLW  3F
05E40:  MOVLB  9
05E42:  MOVWF  x0A
05E44:  MOVWF  x0F
05E46:  MOVLB  0
05E48:  RCALL  5B00
05E4A:  MOVFF  01,270
*
0677E:  MOVLW  01
06780:  MOVWF  00
06782:  CALL   5A96
06786:  MOVF   01,W
06788:  ANDLW  3F
0678A:  MOVLB  9
0678C:  MOVWF  x0A
0678E:  MOVWF  x0F
06790:  MOVLB  0
06792:  CALL   5B00
06796:  MOVFF  01,270
*
072F2:  MOVLW  01
072F4:  MOVWF  00
072F6:  CALL   5A96
072FA:  MOVF   01,W
072FC:  ANDLW  3F
072FE:  MOVLB  9
07300:  MOVWF  x0A
07302:  MOVWF  x0F
07304:  MOVLB  0
07306:  CALL   5B00
0730A:  MOVFF  01,270
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
*
05E4E:  MOVLW  01
05E50:  MOVWF  00
05E52:  RCALL  5A96
05E54:  MOVF   01,W
05E56:  ANDLW  1F
05E58:  MOVLB  9
05E5A:  MOVWF  x0A
05E5C:  MOVWF  x0F
05E5E:  MOVLB  0
05E60:  RCALL  5B00
05E62:  MOVFF  01,271
*
0679A:  MOVLW  01
0679C:  MOVWF  00
0679E:  CALL   5A96
067A2:  MOVF   01,W
067A4:  ANDLW  1F
067A6:  MOVLB  9
067A8:  MOVWF  x0A
067AA:  MOVWF  x0F
067AC:  MOVLB  0
067AE:  CALL   5B00
067B2:  MOVFF  01,271
*
0730E:  MOVLW  01
07310:  MOVWF  00
07312:  CALL   5A96
07316:  MOVF   01,W
07318:  ANDLW  1F
0731A:  MOVLB  9
0731C:  MOVWF  x0A
0731E:  MOVWF  x0F
07320:  MOVLB  0
07322:  CALL   5B00
07326:  MOVFF  01,271
....................   year = bcd2bin(i2c_read(0));            // REG 6  
*
05E66:  CLRF   00
05E68:  RCALL  5A96
05E6A:  MOVFF  01,90A
05E6E:  MOVFF  01,90F
05E72:  RCALL  5B00
05E74:  MOVFF  01,272
*
067B6:  CLRF   00
067B8:  CALL   5A96
067BC:  MOVFF  01,90A
067C0:  MOVFF  01,90F
067C4:  CALL   5B00
067C8:  MOVFF  01,272
*
0732A:  CLRF   00
0732C:  CALL   5A96
07330:  MOVFF  01,90A
07334:  MOVFF  01,90F
07338:  CALL   5B00
0733C:  MOVFF  01,272
....................   i2c_stop();  
*
05E78:  BCF    F95.6
05E7A:  NOP   
05E7C:  BSF    F96.1
05E7E:  BTFSS  F84.1
05E80:  BRA    5E7E
05E82:  MOVLW  0E
05E84:  MOVWF  00
05E86:  DECFSZ 00,F
05E88:  BRA    5E86
05E8A:  BRA    5E8C
05E8C:  NOP   
05E8E:  BSF    F95.6
05E90:  MOVLW  0E
05E92:  MOVWF  00
05E94:  DECFSZ 00,F
05E96:  BRA    5E94
*
067CC:  BCF    F95.6
067CE:  NOP   
067D0:  BSF    F96.1
067D2:  BTFSS  F84.1
067D4:  BRA    67D2
067D6:  MOVLW  0E
067D8:  MOVWF  00
067DA:  DECFSZ 00,F
067DC:  BRA    67DA
067DE:  BRA    67E0
067E0:  NOP   
067E2:  BSF    F95.6
067E4:  MOVLW  0E
067E6:  MOVWF  00
067E8:  DECFSZ 00,F
067EA:  BRA    67E8
*
07340:  BCF    F95.6
07342:  NOP   
07344:  BSF    F96.1
07346:  BTFSS  F84.1
07348:  BRA    7346
0734A:  MOVLW  0E
0734C:  MOVWF  00
0734E:  DECFSZ 00,F
07350:  BRA    734E
07352:  BRA    7354
07354:  NOP   
07356:  BSF    F95.6
07358:  MOVLW  0E
0735A:  MOVWF  00
0735C:  DECFSZ 00,F
0735E:  BRA    735C
.................... }  
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   i2c_start();  
*
05E98:  BSF    F95.6
05E9A:  MOVLW  0E
05E9C:  MOVWF  00
05E9E:  DECFSZ 00,F
05EA0:  BRA    5E9E
05EA2:  BSF    F96.1
05EA4:  MOVLW  0E
05EA6:  MOVWF  00
05EA8:  DECFSZ 00,F
05EAA:  BRA    5EA8
05EAC:  BCF    F8C.6
05EAE:  BCF    F95.6
05EB0:  MOVLW  0E
05EB2:  MOVWF  00
05EB4:  DECFSZ 00,F
05EB6:  BRA    5EB4
05EB8:  BCF    F8D.1
05EBA:  BCF    F96.1
*
067EC:  BSF    F95.6
067EE:  MOVLW  0E
067F0:  MOVWF  00
067F2:  DECFSZ 00,F
067F4:  BRA    67F2
067F6:  BSF    F96.1
067F8:  MOVLW  0E
067FA:  MOVWF  00
067FC:  DECFSZ 00,F
067FE:  BRA    67FC
06800:  BCF    F8C.6
06802:  BCF    F95.6
06804:  MOVLW  0E
06806:  MOVWF  00
06808:  DECFSZ 00,F
0680A:  BRA    6808
0680C:  BCF    F8D.1
0680E:  BCF    F96.1
*
07186:  BSF    F95.6
07188:  MOVLW  0E
0718A:  MOVWF  00
0718C:  DECFSZ 00,F
0718E:  BRA    718C
07190:  BSF    F96.1
07192:  MOVLW  0E
07194:  MOVWF  00
07196:  DECFSZ 00,F
07198:  BRA    7196
0719A:  BCF    F8C.6
0719C:  BCF    F95.6
0719E:  MOVLW  0E
071A0:  MOVWF  00
071A2:  DECFSZ 00,F
071A4:  BRA    71A2
071A6:  BCF    F8D.1
071A8:  BCF    F96.1
....................   i2c_write(0xD0);  
*
05EBC:  MOVLW  D0
05EBE:  MOVLB  9
05EC0:  MOVWF  x0E
05EC2:  MOVLB  0
05EC4:  RCALL  5A20
*
06810:  MOVLW  D0
06812:  MOVLB  9
06814:  MOVWF  x0E
06816:  MOVLB  0
06818:  CALL   5A20
*
071AA:  MOVLW  D0
071AC:  MOVLB  9
071AE:  MOVWF  x0E
071B0:  MOVLB  0
071B2:  CALL   5A20
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
*
05EC6:  MOVLB  9
05EC8:  CLRF   x0E
05ECA:  MOVLB  0
05ECC:  RCALL  5A20
*
0681C:  MOVLB  9
0681E:  CLRF   x0E
06820:  MOVLB  0
06822:  CALL   5A20
*
071B6:  MOVLB  9
071B8:  CLRF   x0E
071BA:  MOVLB  0
071BC:  CALL   5A20
....................   i2c_start();  
*
05ECE:  BSF    F95.6
05ED0:  MOVLW  0E
05ED2:  MOVWF  00
05ED4:  DECFSZ 00,F
05ED6:  BRA    5ED4
05ED8:  BSF    F96.1
05EDA:  MOVLW  0E
05EDC:  MOVWF  00
05EDE:  DECFSZ 00,F
05EE0:  BRA    5EDE
05EE2:  BTFSS  F84.1
05EE4:  BRA    5EE2
05EE6:  BCF    F8C.6
05EE8:  BCF    F95.6
05EEA:  MOVLW  0E
05EEC:  MOVWF  00
05EEE:  DECFSZ 00,F
05EF0:  BRA    5EEE
05EF2:  BCF    F8D.1
05EF4:  BCF    F96.1
*
06826:  BSF    F95.6
06828:  MOVLW  0E
0682A:  MOVWF  00
0682C:  DECFSZ 00,F
0682E:  BRA    682C
06830:  BSF    F96.1
06832:  MOVLW  0E
06834:  MOVWF  00
06836:  DECFSZ 00,F
06838:  BRA    6836
0683A:  BTFSS  F84.1
0683C:  BRA    683A
0683E:  BCF    F8C.6
06840:  BCF    F95.6
06842:  MOVLW  0E
06844:  MOVWF  00
06846:  DECFSZ 00,F
06848:  BRA    6846
0684A:  BCF    F8D.1
0684C:  BCF    F96.1
*
071C0:  BSF    F95.6
071C2:  MOVLW  0E
071C4:  MOVWF  00
071C6:  DECFSZ 00,F
071C8:  BRA    71C6
071CA:  BSF    F96.1
071CC:  MOVLW  0E
071CE:  MOVWF  00
071D0:  DECFSZ 00,F
071D2:  BRA    71D0
071D4:  BTFSS  F84.1
071D6:  BRA    71D4
071D8:  BCF    F8C.6
071DA:  BCF    F95.6
071DC:  MOVLW  0E
071DE:  MOVWF  00
071E0:  DECFSZ 00,F
071E2:  BRA    71E0
071E4:  BCF    F8D.1
071E6:  BCF    F96.1
....................   i2c_write(0xD1);  
*
05EF6:  MOVLW  D1
05EF8:  MOVLB  9
05EFA:  MOVWF  x0E
05EFC:  MOVLB  0
05EFE:  RCALL  5A20
*
0684E:  MOVLW  D1
06850:  MOVLB  9
06852:  MOVWF  x0E
06854:  MOVLB  0
06856:  CALL   5A20
*
071E8:  MOVLW  D1
071EA:  MOVLB  9
071EC:  MOVWF  x0E
071EE:  MOVLB  0
071F0:  CALL   5A20
....................   sec = bcd2bin(i2c_read() & 0x7f);  
*
05F00:  MOVLW  01
05F02:  MOVWF  00
05F04:  RCALL  5A96
05F06:  MOVF   01,W
05F08:  ANDLW  7F
05F0A:  MOVLB  9
05F0C:  MOVWF  x0A
05F0E:  MOVWF  x0F
05F10:  MOVLB  0
05F12:  RCALL  5B00
05F14:  MOVFF  01,275
*
0685A:  MOVLW  01
0685C:  MOVWF  00
0685E:  CALL   5A96
06862:  MOVF   01,W
06864:  ANDLW  7F
06866:  MOVLB  9
06868:  MOVWF  x0A
0686A:  MOVWF  x0F
0686C:  MOVLB  0
0686E:  CALL   5B00
06872:  MOVFF  01,275
*
071F4:  MOVLW  01
071F6:  MOVWF  00
071F8:  CALL   5A96
071FC:  MOVF   01,W
071FE:  ANDLW  7F
07200:  MOVLB  9
07202:  MOVWF  x0A
07204:  MOVWF  x0F
07206:  MOVLB  0
07208:  CALL   5B00
0720C:  MOVFF  01,275
....................   min = bcd2bin(i2c_read() & 0x7f);  
*
05F18:  MOVLW  01
05F1A:  MOVWF  00
05F1C:  RCALL  5A96
05F1E:  MOVF   01,W
05F20:  ANDLW  7F
05F22:  MOVLB  9
05F24:  MOVWF  x0A
05F26:  MOVWF  x0F
05F28:  MOVLB  0
05F2A:  RCALL  5B00
05F2C:  MOVFF  01,274
*
06876:  MOVLW  01
06878:  MOVWF  00
0687A:  CALL   5A96
0687E:  MOVF   01,W
06880:  ANDLW  7F
06882:  MOVLB  9
06884:  MOVWF  x0A
06886:  MOVWF  x0F
06888:  MOVLB  0
0688A:  CALL   5B00
0688E:  MOVFF  01,274
*
07210:  MOVLW  01
07212:  MOVWF  00
07214:  CALL   5A96
07218:  MOVF   01,W
0721A:  ANDLW  7F
0721C:  MOVLB  9
0721E:  MOVWF  x0A
07220:  MOVWF  x0F
07222:  MOVLB  0
07224:  CALL   5B00
07228:  MOVFF  01,274
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
*
05F30:  CLRF   00
05F32:  RCALL  5A96
05F34:  MOVF   01,W
05F36:  ANDLW  3F
05F38:  MOVLB  9
05F3A:  MOVWF  x0A
05F3C:  MOVWF  x0F
05F3E:  MOVLB  0
05F40:  RCALL  5B00
05F42:  MOVFF  01,273
*
06892:  CLRF   00
06894:  CALL   5A96
06898:  MOVF   01,W
0689A:  ANDLW  3F
0689C:  MOVLB  9
0689E:  MOVWF  x0A
068A0:  MOVWF  x0F
068A2:  MOVLB  0
068A4:  CALL   5B00
068A8:  MOVFF  01,273
*
0722C:  CLRF   00
0722E:  CALL   5A96
07232:  MOVF   01,W
07234:  ANDLW  3F
07236:  MOVLB  9
07238:  MOVWF  x0A
0723A:  MOVWF  x0F
0723C:  MOVLB  0
0723E:  CALL   5B00
07242:  MOVFF  01,273
....................   i2c_stop();  
*
05F46:  BCF    F95.6
05F48:  NOP   
05F4A:  BSF    F96.1
05F4C:  BTFSS  F84.1
05F4E:  BRA    5F4C
05F50:  MOVLW  0E
05F52:  MOVWF  00
05F54:  DECFSZ 00,F
05F56:  BRA    5F54
05F58:  BRA    5F5A
05F5A:  NOP   
05F5C:  BSF    F95.6
05F5E:  MOVLW  0E
05F60:  MOVWF  00
05F62:  DECFSZ 00,F
05F64:  BRA    5F62
*
068AC:  BCF    F95.6
068AE:  NOP   
068B0:  BSF    F96.1
068B2:  BTFSS  F84.1
068B4:  BRA    68B2
068B6:  MOVLW  0E
068B8:  MOVWF  00
068BA:  DECFSZ 00,F
068BC:  BRA    68BA
068BE:  BRA    68C0
068C0:  NOP   
068C2:  BSF    F95.6
068C4:  MOVLW  0E
068C6:  MOVWF  00
068C8:  DECFSZ 00,F
068CA:  BRA    68C8
*
07246:  BCF    F95.6
07248:  NOP   
0724A:  BSF    F96.1
0724C:  BTFSS  F84.1
0724E:  BRA    724C
07250:  MOVLW  0E
07252:  MOVWF  00
07254:  DECFSZ 00,F
07256:  BRA    7254
07258:  BRA    725A
0725A:  NOP   
0725C:  BSF    F95.6
0725E:  MOVLW  0E
07260:  MOVWF  00
07262:  DECFSZ 00,F
07264:  BRA    7262
....................  
.................... }  
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................   BYTE temp;  
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
06358:  MOVFF  90D,90E
....................   retval = 0;  
0635C:  MOVLB  9
0635E:  CLRF   x0F
....................  
....................   while(TRUE)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
06360:  MOVF   x0E,W
06362:  SUBLW  09
06364:  BC    6370
....................     {  
....................       temp -= 10;  
06366:  MOVLW  0A
06368:  SUBWF  x0E,F
....................       retval += 0x10;  
0636A:  MOVLW  10
0636C:  ADDWF  x0F,F
....................     }  
0636E:  BRA    6376
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
06370:  MOVF   x0E,W
06372:  ADDWF  x0F,F
....................       break;  
06374:  BRA    6378
....................     }  
06376:  BRA    6360
....................   }  
....................  
....................   return(retval);  
06378:  MOVFF  90F,01
0637C:  MOVLB  0
0637E:  RETURN 0
.................... }  
....................  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp;  
....................  
....................   temp = bcd_value;  
*
05B00:  MOVFF  90F,910
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
05B04:  BCF    FD8.0
05B06:  MOVLB  9
05B08:  RRCF   x10,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
05B0A:  MOVLW  78
05B0C:  ANDWF  x10,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f));  
05B0E:  RRCF   x10,W
05B10:  MOVWF  00
05B12:  RRCF   00,F
05B14:  MOVLW  3F
05B16:  ANDWF  00,F
05B18:  MOVF   00,W
05B1A:  ADDWF  x10,W
05B1C:  MOVWF  x11
05B1E:  MOVF   x0F,W
05B20:  ANDLW  0F
05B22:  ADDWF  x11,W
05B24:  MOVWF  01
05B26:  MOVLB  0
05B28:  RETURN 0
.................... } 
....................  
.................... // Entradas. 
.................... #define entrada01 PIN_D4// 
.................... #define entrada02 PIN_B0//DATA1  
.................... #define entrada03 PIN_B1//DATA0 
.................... #define entrada04 PIN_D0// 
.................... #define entrada05 PIN_D1//SENSOR BARRERA 
....................  
.................... // Salidas. 
.................... #define salida01 PIN_A5//abre entrada 
.................... #define salida02 PIN_E0//abre entrada 
.................... #define salida03 PIN_D2//abre salida 
.................... #define salida04 PIN_D3//indicador de cupo lleno 
.................... #define salida05 PIN_D7// 
.................... #define salida06 PIN_C2//indicador de conexion 
.................... // Macros de entrada: 
.................... char texto1[12]= "BOLETO_FOL";// 
.................... char texto2[12]= "BORRARTODO";// 
.................... char texto3[12]= "BORRAR_TAG";// 
.................... char texto4[12]= "ABRIR_ENTR";// 
.................... char texto5[12]= "CUPO_LLENO";//CANCELA BOLETOS 
.................... char texto6[12]= "CUPO_DISPO";//ACTIVA BOLETOS 
.................... char texto7[12]= "MENSAJEEN1";// 
.................... char texto8[12]= "          ";// 
.................... char texto9[12]= "CONSULTA01";// 
.................... char texto10[12]="CONFIGDATE";// 
.................... char texto11[12]="CONFIGURAB";// 
.................... char texto12[12]="BORRA_CON1";// 
.................... char texto13[12]="FOLIORESET";//REINICIAR FOLIOS 
.................... char texto14[12]="PAGADO0000";// 
.................... char boleto[]= "BOLETO"; // 
.................... char barrera[] ="BARRERAABIERTAE1"; 
.................... int fmensaje; 
.................... int16 time_lcd; 
.................... //int en5,flag_pluma; 
....................  
....................  
.................... // Define el stack usado: ENC28J60. 
.................... #define STACK_USE_CCS_PICENS   1 
.................... // Utilizamos el stack para el protocolo ICPM. 
.................... #define STACK_USE_ICMP  1 
.................... // Utilizamos el stack para el protocolo ARP. 
.................... #define STACK_USE_ARP 1 
.................... // Utilizamos el stack para el protocolo TCP. 
.................... #define STACK_USE_TCP 1 
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... // Definimos los pines utilizados. 
.................... #define  PIN_ENC_MAC_SO    PIN_C4 
.................... #define  PIN_ENC_MAC_SI    PIN_C5 
.................... #define  PIN_ENC_MAC_CLK   PIN_C3 
....................  
.................... #define  PIN_ENC_MAC_CS    PIN_C1 
.................... #define  PIN_ENC_MAC_RST   PIN_C0 
.................... #define  PIN_ENC_MAC_INT   PIN_D2 
.................... #define  PIN_ENC_MAC_WOL   PIN_D3 
....................  
.................... // Incluimos las definiciones necesarias para utilizar el stack TCP/IP. 
.................... #include "tcpip/stacktsk.c"  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_C0 
....................       #define PIN_ENC_MAC_RST PIN_C1 
....................       #define PIN_ENC_MAC_INT PIN_C6 
....................       #define PIN_ENC_MAC_WOL PIN_C7 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................       
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_MCPENC 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
.................... */ 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     35 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
0561A:  MOVFF  90C,90E
0561E:  MOVFF  90B,90D
05622:  MOVFF  90E,03
05626:  MOVLB  9
05628:  MOVFF  90D,FE9
0562C:  MOVFF  90E,FEA
05630:  MOVF   FEF,F
05632:  BZ    5640
05634:  INCF   x0D,F
05636:  BTFSC  FD8.2
05638:  INCF   x0E,F
0563A:  MOVLB  0
0563C:  BRA    5622
0563E:  MOVLB  9
....................    return(sc - s); 
05640:  MOVF   x0B,W
05642:  SUBWF  x0D,W
05644:  MOVWF  00
05646:  MOVF   x0C,W
05648:  SUBWFB x0E,W
0564A:  MOVWF  03
0564C:  MOVFF  00,01
05650:  MOVWF  02
05652:  MOVLB  0
05654:  RETURN 0
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01098:  MOVFF  386,8FC
0109C:  MOVFF  385,8FB
010A0:  MOVFF  384,8FA
010A4:  MOVFF  383,8F9
010A8:  MOVLW  41
010AA:  MOVLB  9
010AC:  MOVWF  x00
010AE:  MOVLW  C6
010B0:  MOVLB  8
010B2:  MOVWF  xFF
010B4:  MOVLW  4E
010B6:  MOVWF  xFE
010B8:  MOVLW  6D
010BA:  MOVWF  xFD
010BC:  MOVLB  0
010BE:  BRA    0FF4
010C0:  MOVLW  39
010C2:  MOVLB  8
010C4:  ADDWF  00,W
010C6:  MOVLB  3
010C8:  MOVWF  x83
010CA:  MOVLW  30
010CC:  MOVLB  8
010CE:  ADDWFC 01,W
010D0:  MOVLB  3
010D2:  MOVWF  x84
010D4:  MOVLW  00
010D6:  MOVLB  8
010D8:  ADDWFC 02,W
010DA:  MOVLB  3
010DC:  MOVWF  x85
010DE:  MOVLW  00
010E0:  MOVLB  8
010E2:  ADDWFC 03,W
010E4:  MOVLB  3
010E6:  MOVWF  x86
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
010E8:  MOVFF  385,00
010EC:  MOVFF  386,01
010F0:  CLRF   02
010F2:  CLRF   03
010F4:  MOVFF  386,8FB
010F8:  MOVFF  385,8FA
010FC:  MOVFF  386,909
01100:  MOVFF  385,908
01104:  MOVLW  7F
01106:  MOVLB  9
01108:  MOVWF  x0B
0110A:  SETF   x0A
0110C:  MOVLB  0
0110E:  RCALL  1052
01110:  MOVFF  00,01
01114:  MOVFF  03,02
01118:  GOTO   1236 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
00FE0:  MOVFF  8FC,386
00FE4:  MOVFF  8FB,385
00FE8:  MOVFF  8FA,384
00FEC:  MOVFF  8F9,383
00FF0:  GOTO   1234 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
017BA:  MOVFF  9A2,9A3
....................     new.v[1]=v.v[0]; 
017BE:  MOVFF  9A1,9A4
....................  
....................     return(new.Val); 
017C2:  MOVLB  9
017C4:  MOVFF  9A3,01
017C8:  MOVFF  9A4,02
017CC:  MOVLB  0
017CE:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
026FA:  MOVFF  98D,98E
....................     new.v[1]=v.v[2]; 
026FE:  MOVFF  98C,98F
....................     new.v[2]=v.v[1]; 
02702:  MOVFF  98B,990
....................     new.v[3]=v.v[0]; 
02706:  MOVFF  98A,991
....................  
....................     return(new.Val); 
0270A:  MOVFF  98E,00
0270E:  MOVFF  98F,01
02712:  MOVFF  990,02
02716:  MOVFF  991,03
0271A:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
02464:  MOVLB  9
02466:  CLRF   x93
02468:  CLRF   x92
0246A:  CLRF   x91
0246C:  CLRF   x90
....................  
....................    i = count >> 1; 
0246E:  BCF    FD8.0
02470:  RRCF   x87,W
02472:  MOVWF  x89
02474:  RRCF   x86,W
02476:  MOVWF  x88
....................    val = (WORD *)buffer; 
02478:  MOVFF  985,98B
0247C:  MOVFF  984,98A
....................  
....................    while( i-- ) 
02480:  MOVFF  989,03
02484:  MOVF   x88,W
02486:  BTFSC  FD8.2
02488:  DECF   x89,F
0248A:  DECF   x88,F
0248C:  IORWF  03,W
0248E:  BZ    24BE
....................       sum.Val += *val++; 
02490:  MOVFF  98B,03
02494:  MOVFF  98A,00
02498:  MOVLW  02
0249A:  ADDWF  x8A,F
0249C:  BTFSC  FD8.0
0249E:  INCF   x8B,F
024A0:  MOVFF  00,FE9
024A4:  MOVFF  03,FEA
024A8:  MOVFF  FEC,03
024AC:  MOVF   FED,F
024AE:  MOVF   FEF,W
024B0:  ADDWF  x90,F
024B2:  MOVF   03,W
024B4:  ADDWFC x91,F
024B6:  MOVLW  00
024B8:  ADDWFC x92,F
024BA:  ADDWFC x93,F
024BC:  BRA    2480
....................  
....................    if ( count & 1 ) 
024BE:  MOVF   x86,W
024C0:  ANDLW  01
024C2:  MOVWF  00
024C4:  CLRF   03
024C6:  MOVF   00,W
024C8:  IORWF  03,W
024CA:  BZ    24E0
....................       sum.Val += *(BYTE *)val; 
024CC:  MOVFF  98A,FE9
024D0:  MOVFF  98B,FEA
024D4:  MOVF   FEF,W
024D6:  ADDWF  x90,F
024D8:  MOVLW  00
024DA:  ADDWFC x91,F
024DC:  ADDWFC x92,F
024DE:  ADDWFC x93,F
....................  
....................    tempSum.Val = sum.Val; 
024E0:  MOVFF  993,98F
024E4:  MOVFF  992,98E
024E8:  MOVFF  991,98D
024EC:  MOVFF  990,98C
....................    i = tempSum.words.MSB.Val; 
024F0:  MOVFF  98F,989
024F4:  MOVFF  98E,988
....................  
....................    while( i != 0u ) 
024F8:  MOVF   x88,F
024FA:  BNZ   2500
024FC:  MOVF   x89,F
024FE:  BZ    2546
....................    { 
....................       sum.words.MSB.Val = 0; 
02500:  CLRF   x93
02502:  CLRF   x92
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
02504:  CLRF   x97
02506:  CLRF   x96
02508:  MOVFF  991,995
0250C:  MOVFF  990,994
02510:  CLRF   02
02512:  CLRF   03
02514:  MOVF   x88,W
02516:  ADDWF  x90,W
02518:  MOVWF  x90
0251A:  MOVF   x89,W
0251C:  ADDWFC x91,W
0251E:  MOVWF  x91
02520:  MOVF   02,W
02522:  ADDWFC x96,W
02524:  MOVWF  x92
02526:  MOVF   03,W
02528:  ADDWFC x97,W
0252A:  MOVWF  x93
....................       tempSum.Val = sum.Val; 
0252C:  MOVFF  993,98F
02530:  MOVFF  992,98E
02534:  MOVFF  991,98D
02538:  MOVFF  990,98C
....................       i = tempSum.words.MSB.Val; 
0253C:  MOVFF  98F,989
02540:  MOVFF  98E,988
02544:  BRA    24F8
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
02546:  MOVFF  991,03
0254A:  COMF   03,F
0254C:  MOVF   x90,W
0254E:  XORLW  FF
02550:  MOVWF  01
02552:  MOVFF  03,02
02556:  MOVLB  0
02558:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
00AA0:  MOVLW  83
00AA2:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
00AA4:  MOVLW  34
00AA6:  MOVWF  FD7
00AA8:  MOVLW  8C
00AAA:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
00AAC:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
00AAE:  MOVLW  C0
00AB0:  IORWF  FF2,F
00AB2:  GOTO   1276 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
02AFC:  BCF    FF2.5
....................     ret=TickCount; 
02AFE:  MOVFF  389,949
02B02:  MOVFF  388,948
....................     enable_interrupts(INT_TIMER0); 
02B06:  BSF    FF2.5
....................     return ret; 
02B08:  MOVLB  9
02B0A:  MOVFF  948,01
02B0E:  MOVFF  949,02
02B12:  MOVLB  0
02B14:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00106:  MOVLB  3
00108:  INCF   x88,F
0010A:  BTFSC  FD8.2
0010C:  INCF   x89,F
....................  
....................         second_counter_intermediate++; 
0010E:  INCF   x8B,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00110:  MOVF   x8B,W
00112:  SUBLW  0B
00114:  BC    011A
....................             second_counter++; //increment this ever 1s 
00116:  INCF   x8A,F
....................             second_counter_intermediate=0; 
00118:  CLRF   x8B
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
0011A:  MOVLW  34
0011C:  MOVWF  FD7
0011E:  MOVLW  8C
00120:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
.................... /* 
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
.................... */  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
00122:  BCF    FF2.2
00124:  MOVLB  0
00126:  GOTO   0084
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
00AB6:  BCF    F94.3
00AB8:  BCF    F8B.3
....................    output_float(PIN_ENC_MAC_SO); 
00ABA:  BSF    F94.4
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
00ABC:  BCF    F94.1
00ABE:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
00AC0:  BCF    F94.0
00AC2:  BSF    F8B.0
00AC4:  GOTO   0DCE (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
00AC8:  MOVLB  9
00ACA:  CLRF   xAD
00ACC:  MOVF   xAD,W
00ACE:  SUBLW  07
00AD0:  BNC   0AFA
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
00AD2:  BCF    FD8.0
00AD4:  RLCF   xAC,F
00AD6:  BC    0ADC
00AD8:  BCF    F8B.5
00ADA:  BRA    0ADE
00ADC:  BSF    F8B.5
00ADE:  BCF    F94.5
....................       output_high(PIN_ENC_MAC_CLK); 
00AE0:  BCF    F94.3
00AE2:  BSF    F8B.3
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
00AE4:  BSF    F94.4
00AE6:  BTFSC  F82.4
00AE8:  BRA    0AEE
00AEA:  BCF    FD8.0
00AEC:  BRA    0AF0
00AEE:  BSF    FD8.0
00AF0:  RLCF   xAE,F
....................       output_low(PIN_ENC_MAC_CLK); 
00AF2:  BCF    F94.3
00AF4:  BCF    F8B.3
00AF6:  INCF   xAD,F
00AF8:  BRA    0ACC
....................    } 
....................    return(in); 
00AFA:  MOVFF  9AE,01
....................  #endif 
00AFE:  MOVLB  0
00B00:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
00DCC:  BRA    0AB6
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
00DCE:  MOVLW  1D
00DD0:  MOVLB  9
00DD2:  MOVWF  xA1
00DD4:  MOVLB  0
00DD6:  RCALL  0B02
00DD8:  MOVFF  01,8F6
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
00DDC:  MOVLB  8
00DDE:  BTFSS  xF6.3
00DE0:  BRA    0DE6
00DE2:  MOVLB  0
00DE4:  BRA    0DCE
00DE6:  MOVF   xF6,W
00DE8:  XORLW  FF
00DEA:  ANDLW  01
00DEC:  BTFSC  FD8.2
00DEE:  BRA    0DF4
00DF0:  MOVLB  0
00DF2:  BRA    0DCE
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
00DF4:  MOVLB  0
00DF6:  BRA    0B2C
....................     delay_ms(1); 
00DF8:  MOVLW  01
00DFA:  MOVLB  8
00DFC:  MOVWF  xFD
00DFE:  MOVLB  0
00E00:  CALL   05B4
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
00E04:  MOVLB  3
00E06:  CLRF   x87
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
00E08:  BSF    x90.0
....................    NextPacketLocation.Val = RXSTART; 
00E0A:  CLRF   x8D
00E0C:  CLRF   x8C
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
00E0E:  MOVLW  08
00E10:  MOVLB  9
00E12:  MOVWF  xA7
00E14:  CLRF   xA8
00E16:  MOVLB  0
00E18:  RCALL  0B40
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
00E1A:  MOVLW  09
00E1C:  MOVLB  9
00E1E:  MOVWF  xA7
00E20:  CLRF   xA8
00E22:  MOVLB  0
00E24:  RCALL  0B40
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
00E26:  MOVLW  0C
00E28:  MOVLB  9
00E2A:  MOVWF  xA7
00E2C:  MOVLW  F7
00E2E:  MOVWF  xA8
00E30:  MOVLB  0
00E32:  RCALL  0B40
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
00E34:  MOVLW  0D
00E36:  MOVLB  9
00E38:  MOVWF  xA7
00E3A:  MOVLW  1B
00E3C:  MOVWF  xA8
00E3E:  MOVLB  0
00E40:  RCALL  0B40
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
00E42:  MOVLW  0A
00E44:  MOVLB  9
00E46:  MOVWF  xA7
00E48:  MOVLW  F7
00E4A:  MOVWF  xA8
00E4C:  MOVLB  0
00E4E:  RCALL  0B40
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
00E50:  MOVLW  0B
00E52:  MOVLB  9
00E54:  MOVWF  xA7
00E56:  MOVLW  1B
00E58:  MOVWF  xA8
00E5A:  MOVLB  0
00E5C:  RCALL  0B40
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
00E5E:  MOVLW  04
00E60:  MOVLB  9
00E62:  MOVWF  xA7
00E64:  MOVLW  F8
00E66:  MOVWF  xA8
00E68:  MOVLB  0
00E6A:  RCALL  0B40
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
00E6C:  MOVLW  05
00E6E:  MOVLB  9
00E70:  MOVWF  xA7
00E72:  MOVLW  1B
00E74:  MOVWF  xA8
00E76:  MOVLB  0
00E78:  RCALL  0B40
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
00E7A:  MOVLW  02
00E7C:  MOVLB  9
00E7E:  MOVWF  xA5
00E80:  CLRF   xA4
00E82:  MOVLB  0
00E84:  RCALL  0B9A
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
00E86:  MOVLB  9
00E88:  CLRF   xA7
00E8A:  MOVLW  0D
00E8C:  MOVWF  xA8
00E8E:  MOVLB  0
00E90:  RCALL  0B40
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
00E92:  MOVLW  02
00E94:  MOVLB  9
00E96:  MOVWF  xA7
00E98:  MOVLW  32
00E9A:  MOVWF  xA8
00E9C:  MOVLB  0
00E9E:  RCALL  0B40
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
00EA0:  MOVLW  03
00EA2:  MOVLB  9
00EA4:  MOVWF  xA7
00EA6:  MOVLW  40
00EA8:  MOVWF  xA8
00EAA:  MOVLB  0
00EAC:  RCALL  0B40
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
00EAE:  MOVLW  09
00EB0:  MOVLB  9
00EB2:  MOVWF  xA7
00EB4:  MOVLW  3F
00EB6:  MOVWF  xA8
00EB8:  MOVLB  0
00EBA:  RCALL  0B40
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
00EBC:  MOVLW  06
00EBE:  MOVLB  9
00EC0:  MOVWF  xA7
00EC2:  MOVLW  12
00EC4:  MOVWF  xA8
00EC6:  MOVLB  0
00EC8:  RCALL  0B40
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
00ECA:  MOVLW  07
00ECC:  MOVLB  9
00ECE:  MOVWF  xA7
00ED0:  MOVLW  0C
00ED2:  MOVWF  xA8
00ED4:  MOVLB  0
00ED6:  RCALL  0B40
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
00ED8:  MOVLW  0A
00EDA:  MOVLB  9
00EDC:  MOVWF  xA7
00EDE:  MOVLW  EE
00EE0:  MOVWF  xA8
00EE2:  MOVLB  0
00EE4:  RCALL  0B40
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
00EE6:  MOVLW  0B
00EE8:  MOVLB  9
00EEA:  MOVWF  xA7
00EEC:  MOVLW  05
00EEE:  MOVWF  xA8
00EF0:  MOVLB  0
00EF2:  RCALL  0B40
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
00EF4:  MOVLW  03
00EF6:  MOVLB  9
00EF8:  MOVWF  xA5
00EFA:  MOVLW  04
00EFC:  MOVWF  xA4
00EFE:  MOVLB  0
00F00:  RCALL  0B9A
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
00F02:  MOVLW  04
00F04:  MOVLB  9
00F06:  MOVWF  xA7
00F08:  MOVFF  354,9A8
00F0C:  MOVLB  0
00F0E:  RCALL  0B40
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
00F10:  MOVLW  05
00F12:  MOVLB  9
00F14:  MOVWF  xA7
00F16:  MOVFF  355,9A8
00F1A:  MOVLB  0
00F1C:  RCALL  0B40
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
00F1E:  MOVLW  02
00F20:  MOVLB  9
00F22:  MOVWF  xA7
00F24:  MOVFF  356,9A8
00F28:  MOVLB  0
00F2A:  RCALL  0B40
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
00F2C:  MOVLW  03
00F2E:  MOVLB  9
00F30:  MOVWF  xA7
00F32:  MOVFF  357,9A8
00F36:  MOVLB  0
00F38:  RCALL  0B40
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
00F3A:  MOVLB  9
00F3C:  CLRF   xA7
00F3E:  MOVFF  358,9A8
00F42:  MOVLB  0
00F44:  RCALL  0B40
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
00F46:  MOVLW  01
00F48:  MOVLB  9
00F4A:  MOVWF  xA7
00F4C:  MOVFF  359,9A8
00F50:  MOVLB  0
00F52:  RCALL  0B40
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
00F54:  MOVLW  12
00F56:  MOVLB  9
00F58:  MOVWF  xA1
00F5A:  MOVLB  0
00F5C:  RCALL  0B02
00F5E:  MOVFF  01,391
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
00F62:  MOVLW  10
00F64:  MOVLB  8
00F66:  MOVWF  xFB
00F68:  MOVLW  01
00F6A:  MOVWF  xFD
00F6C:  CLRF   xFC
00F6E:  MOVLB  0
00F70:  RCALL  0BFE
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
00F72:  MOVLW  14
00F74:  MOVLB  8
00F76:  MOVWF  xFB
00F78:  MOVLW  04
00F7A:  MOVWF  xFD
00F7C:  MOVLW  72
00F7E:  MOVWF  xFC
00F80:  MOVLB  0
00F82:  RCALL  0BFE
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
00F84:  MOVLB  8
00F86:  CLRF   xF7
00F88:  MOVLB  0
00F8A:  BRA    0D2A
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
00F8C:  MOVLW  1F
00F8E:  MOVLB  9
00F90:  MOVWF  xA9
00F92:  MOVLW  04
00F94:  MOVWF  xAA
00F96:  MOVLB  0
00F98:  RCALL  0B7C
00F9A:  GOTO   1278 (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
06A76:  MOVLW  01
06A78:  MOVLB  8
06A7A:  MOVWF  xFB
06A7C:  MOVLB  0
06A7E:  CALL   0C8E
06A82:  MOVFF  01,8F6
06A86:  MOVLW  00
06A88:  MOVLB  8
06A8A:  BTFSC  01.2
06A8C:  MOVLW  01
06A8E:  MOVWF  01
06A90:  MOVLB  0
06A92:  GOTO   75BE (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
02C14:  MOVLW  1F
02C16:  MOVLB  9
02C18:  MOVWF  xA1
02C1A:  MOVLB  0
02C1C:  CALL   0B02
02C20:  MOVFF  01,983
02C24:  MOVLW  00
02C26:  MOVLB  9
02C28:  BTFSC  01.3
02C2A:  MOVLW  01
02C2C:  XORLW  00
02C2E:  BZ    2C34
02C30:  MOVLW  00
02C32:  BRA    2C36
02C34:  MOVLW  01
02C36:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
02C38:  MOVLB  0
02C3A:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
01AD2:  MOVLW  1F
01AD4:  MOVLB  9
01AD6:  MOVWF  xA1
01AD8:  MOVLB  0
01ADA:  CALL   0B02
01ADE:  MOVFF  01,983
01AE2:  MOVLW  00
01AE4:  MOVLB  9
01AE6:  BTFSC  01.3
01AE8:  MOVLW  01
01AEA:  XORLW  00
01AEC:  BNZ   1AF2
01AEE:  MOVLW  00
01AF0:  BRA    1AF4
01AF2:  MOVLW  FF
01AF4:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
01AF6:  MOVLB  0
01AF8:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
016E0:  MOVLB  3
016E2:  BTFSS  x90.0
016E4:  BRA    16E8
....................       return; 
016E6:  BRA    1752
....................    WasDiscarded = TRUE; 
016E8:  BSF    x90.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
016EA:  MOVLW  01
016EC:  SUBWF  x8C,W
016EE:  MOVLB  9
016F0:  MOVWF  x48
016F2:  MOVLW  00
016F4:  MOVLB  3
016F6:  SUBWFB x8D,W
016F8:  MOVLB  9
016FA:  MOVWF  x49
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
016FC:  MOVF   x49,W
016FE:  SUBLW  1A
01700:  BC    1714
01702:  XORLW  FF
01704:  BNZ   170C
01706:  MOVF   x48,W
01708:  SUBLW  F7
0170A:  BC    1714
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
0170C:  MOVLW  1B
0170E:  MOVWF  x49
01710:  MOVLW  F7
01712:  MOVWF  x48
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
01714:  MOVLW  1E
01716:  MOVWF  xA9
01718:  MOVLW  40
0171A:  MOVWF  xAA
0171C:  MOVLB  0
0171E:  CALL   0B7C
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
01722:  MOVLB  9
01724:  CLRF   xA5
01726:  MOVLW  0C
01728:  MOVWF  xA4
0172A:  MOVLB  0
0172C:  CALL   0B9A
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
01730:  MOVLW  0C
01732:  MOVLB  9
01734:  MOVWF  xA7
01736:  MOVFF  948,9A8
0173A:  MOVLB  0
0173C:  CALL   0B40
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
01740:  MOVLW  0D
01742:  MOVLB  9
01744:  MOVWF  xA7
01746:  MOVFF  949,9A8
0174A:  MOVLB  0
0174C:  CALL   0B40
01750:  MOVLB  3
01752:  MOVLB  0
01754:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
02C3C:  MOVLW  01
02C3E:  MOVLB  9
02C40:  MOVWF  xA5
02C42:  MOVLW  19
02C44:  MOVWF  xA4
02C46:  MOVLB  0
02C48:  CALL   0B9A
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
02C4C:  MOVLW  19
02C4E:  MOVLB  9
02C50:  MOVWF  xA1
02C52:  MOVLB  0
02C54:  CALL   0B02
02C58:  MOVFF  01,982
....................  
....................       BankSel(ERXWRPTL); 
02C5C:  MOVLB  9
02C5E:  CLRF   xA5
02C60:  MOVLW  0E
02C62:  MOVWF  xA4
02C64:  MOVLB  0
02C66:  CALL   0B9A
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
02C6A:  MOVLW  0E
02C6C:  MOVLB  9
02C6E:  MOVWF  xA1
02C70:  MOVLB  0
02C72:  CALL   0B02
02C76:  MOVFF  01,984
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
02C7A:  MOVLW  0F
02C7C:  MOVLB  9
02C7E:  MOVWF  xA1
02C80:  MOVLB  0
02C82:  CALL   0B02
02C86:  MOVFF  01,985
....................  
....................       BankSel(EPKTCNT); 
02C8A:  MOVLW  01
02C8C:  MOVLB  9
02C8E:  MOVWF  xA5
02C90:  MOVLW  19
02C92:  MOVWF  xA4
02C94:  MOVLB  0
02C96:  CALL   0B9A
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
02C9A:  MOVLW  19
02C9C:  MOVLB  9
02C9E:  MOVWF  xA1
02CA0:  MOVLB  0
02CA2:  CALL   0B02
02CA6:  MOVFF  01,986
02CAA:  MOVLB  9
02CAC:  MOVF   x82,W
02CAE:  SUBWF  01,W
02CB0:  BTFSC  FD8.2
02CB2:  BRA    2CB8
02CB4:  MOVLB  0
02CB6:  BRA    2C4C
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
02CB8:  CLRF   xA5
02CBA:  MOVLW  0C
02CBC:  MOVWF  xA4
02CBE:  MOVLB  0
02CC0:  CALL   0B9A
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
02CC4:  MOVLW  0C
02CC6:  MOVLB  9
02CC8:  MOVWF  xA1
02CCA:  MOVLB  0
02CCC:  CALL   0B02
02CD0:  MOVFF  01,982
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
02CD4:  MOVLW  0D
02CD6:  MOVLB  9
02CD8:  MOVWF  xA1
02CDA:  MOVLB  0
02CDC:  CALL   0B02
02CE0:  MOVFF  01,983
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
02CE4:  MOVLB  9
02CE6:  MOVF   x83,W
02CE8:  SUBWF  x85,W
02CEA:  BNC   2D18
02CEC:  BNZ   2CF4
02CEE:  MOVF   x84,W
02CF0:  SUBWF  x82,W
02CF2:  BC    2D18
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
02CF4:  MOVF   x82,W
02CF6:  SUBWF  x84,W
02CF8:  MOVWF  00
02CFA:  MOVF   x83,W
02CFC:  SUBWFB x85,W
02CFE:  MOVWF  03
02D00:  MOVF   00,W
02D02:  XORLW  FF
02D04:  ADDLW  F8
02D06:  MOVWF  00
02D08:  MOVLW  1B
02D0A:  SUBFWB 03,F
02D0C:  MOVFF  00,01
02D10:  MOVFF  03,02
02D14:  BRA    2D4E
....................    } 
02D16:  BRA    2D4E
....................    else if ( WritePT.Val == ReadPT.Val ) 
02D18:  MOVF   x82,W
02D1A:  SUBWF  x84,W
02D1C:  BNZ   2D30
02D1E:  MOVF   x83,W
02D20:  SUBWF  x85,W
02D22:  BNZ   2D30
....................    { 
....................       return RXSIZE - 1; 
02D24:  MOVLW  F7
02D26:  MOVWF  01
02D28:  MOVLW  1B
02D2A:  MOVWF  02
02D2C:  BRA    2D4E
....................    } 
02D2E:  BRA    2D4E
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
02D30:  MOVF   x84,W
02D32:  SUBWF  x82,W
02D34:  MOVWF  x86
02D36:  MOVF   x85,W
02D38:  SUBWFB x83,W
02D3A:  MOVWF  x87
02D3C:  MOVLW  01
02D3E:  SUBWF  x86,W
02D40:  MOVWF  00
02D42:  MOVLW  00
02D44:  SUBWFB x87,W
02D46:  MOVWF  03
02D48:  MOVFF  00,01
02D4C:  MOVWF  02
....................    } 
02D4E:  MOVLB  0
02D50:  GOTO   2FD2 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
017D0:  MOVLW  01
017D2:  MOVLB  9
017D4:  MOVWF  xA5
017D6:  MOVLW  19
017D8:  MOVWF  xA4
017DA:  MOVLB  0
017DC:  CALL   0B9A
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
017E0:  MOVLW  19
017E2:  MOVLB  9
017E4:  MOVWF  xA1
017E6:  MOVLB  0
017E8:  CALL   0B02
017EC:  MOVFF  01,914
017F0:  MOVLB  9
017F2:  MOVF   x14,F
017F4:  BNZ   17FC
....................       return FALSE; 
017F6:  MOVLW  00
017F8:  MOVWF  01
017FA:  BRA    1918
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
017FC:  MOVLB  3
017FE:  BTFSC  x90.0
01800:  BRA    1810
....................    { 
....................       MACDiscardRx(); 
01802:  MOVLB  0
01804:  RCALL  16E0
....................       return FALSE; 
01806:  MOVLW  00
01808:  MOVWF  01
0180A:  MOVLB  9
0180C:  BRA    1918
0180E:  MOVLB  3
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
01810:  MOVFF  38D,38F
01814:  MOVFF  38C,38E
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
01818:  MOVLB  9
0181A:  CLRF   xA5
0181C:  CLRF   xA4
0181E:  MOVLB  0
01820:  CALL   0B9A
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
01824:  MOVLB  9
01826:  CLRF   xA7
01828:  MOVFF  38C,9A8
0182C:  MOVLB  0
0182E:  CALL   0B40
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
01832:  MOVLW  01
01834:  MOVLB  9
01836:  MOVWF  xA7
01838:  MOVFF  38D,9A8
0183C:  MOVLB  0
0183E:  CALL   0B40
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
01842:  MOVLW  09
01844:  MOVLB  9
01846:  MOVWF  x15
01848:  CLRF   x14
0184A:  MOVWF  x91
0184C:  MOVFF  914,990
01850:  CLRF   x93
01852:  MOVLW  14
01854:  MOVWF  x92
01856:  MOVLB  0
01858:  RCALL  1756
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
0185A:  MOVFF  913,9A2
0185E:  MOVFF  912,9A1
01862:  RCALL  17BA
01864:  MOVFF  02,913
01868:  MOVFF  01,912
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
0186C:  MOVLB  9
0186E:  MOVF   x01,W
01870:  SUBLW  1A
01872:  BC    187E
01874:  XORLW  FF
01876:  BNZ   18A8
01878:  MOVF   x00,W
0187A:  SUBLW  F7
0187C:  BNC   18A8
0187E:  MOVLW  09
01880:  CLRF   x14
01882:  MOVFF  914,FE9
01886:  MOVWF  FEA
01888:  BTFSC  FEF.0
0188A:  BRA    18A8
0188C:  BTFSC  x05.7
0188E:  BRA    18A8
01890:  BTFSC  x04.4
01892:  BRA    18A8
01894:  MOVF   x03,W
01896:  SUBLW  04
01898:  BC    18A4
0189A:  XORLW  FF
0189C:  BNZ   18A8
0189E:  MOVF   x02,W
018A0:  SUBLW  EE
018A2:  BNC   18A8
018A4:  BTFSC  x04.7
018A6:  BRA    18AA
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
018A8:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
018AA:  MOVFF  901,38D
018AE:  MOVFF  900,38C
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
018B2:  MOVFF  8FD,03
018B6:  MOVFF  8FC,914
018BA:  MOVLB  9
018BC:  MOVFF  8FD,915
018C0:  MOVFF  8FD,FEA
018C4:  MOVFF  8FC,FE9
018C8:  MOVLW  09
018CA:  MOVWF  FE2
018CC:  MOVLW  0C
018CE:  MOVWF  FE1
018D0:  MOVLW  06
018D2:  MOVWF  01
018D4:  MOVFF  FE6,FEE
018D8:  DECFSZ 01,F
018DA:  BRA    18D4
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
018DC:  MOVFF  8FF,03
018E0:  MOVLB  8
018E2:  MOVFF  8FE,FE9
018E6:  MOVFF  03,FEA
018EA:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
018EC:  MOVLB  9
018EE:  MOVF   x13,W
018F0:  SUBLW  08
018F2:  BNZ   190E
018F4:  MOVF   x12,F
018F6:  BZ    18FE
018F8:  MOVF   x12,W
018FA:  SUBLW  06
018FC:  BNZ   190E
....................     { 
....................        *type = header.Type.v[0]; 
018FE:  MOVLB  8
01900:  MOVFF  8FE,FE9
01904:  MOVFF  8FF,FEA
01908:  MOVFF  912,FEF
0190C:  MOVLB  9
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
0190E:  MOVLB  3
01910:  BCF    x90.0
....................    return TRUE; 
01912:  MOVLW  01
01914:  MOVWF  01
01916:  MOVLB  9
01918:  MOVLB  0
0191A:  GOTO   44A6 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
01C00:  MOVLB  9
01C02:  CLRF   xA5
01C04:  MOVLW  02
01C06:  MOVWF  xA4
01C08:  MOVLB  0
01C0A:  CALL   0B9A
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
01C0E:  MOVLW  02
01C10:  MOVLB  9
01C12:  MOVWF  xA7
01C14:  MOVLW  F8
01C16:  MOVWF  xA8
01C18:  MOVLB  0
01C1A:  CALL   0B40
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
01C1E:  MOVLW  03
01C20:  MOVLB  9
01C22:  MOVWF  xA7
01C24:  MOVLW  1B
01C26:  MOVWF  xA8
01C28:  MOVLB  0
01C2A:  CALL   0B40
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
01C2E:  MOVLW  06
01C30:  MOVLB  9
01C32:  ADDWF  xA2,F
01C34:  MOVLW  1C
01C36:  ADDWFC xA3,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
01C38:  MOVLW  09
01C3A:  MOVWF  xA5
01C3C:  MOVLW  A2
01C3E:  MOVWF  xA4
01C40:  MOVWF  FE9
01C42:  MOVFF  9A5,FEA
01C46:  MOVFF  FEF,9A8
01C4A:  MOVLW  06
01C4C:  MOVWF  xA7
01C4E:  MOVLB  0
01C50:  CALL   0B40
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
01C54:  MOVLW  09
01C56:  MOVLB  9
01C58:  MOVWF  xA5
01C5A:  MOVLW  A2
01C5C:  MOVWF  xA4
01C5E:  MOVLW  01
01C60:  ADDWF  xA4,W
01C62:  MOVWF  FE9
01C64:  MOVLW  00
01C66:  ADDWFC xA5,W
01C68:  MOVWF  FEA
01C6A:  MOVFF  FEF,9A8
01C6E:  MOVLW  07
01C70:  MOVWF  xA7
01C72:  MOVLB  0
01C74:  CALL   0B40
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
01C78:  MOVLB  9
01C7A:  CLRF   xA5
01C7C:  MOVLB  0
01C7E:  RCALL  1B98
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
01C80:  MOVFF  9A0,9A7
01C84:  MOVFF  99F,9A6
01C88:  MOVLB  9
01C8A:  CLRF   xA9
01C8C:  MOVLW  06
01C8E:  MOVWF  xA8
01C90:  MOVLB  0
01C92:  RCALL  1BB6
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
01C94:  MOVLW  03
01C96:  MOVLB  9
01C98:  MOVWF  xA5
01C9A:  MOVLW  54
01C9C:  MOVWF  xA4
01C9E:  MOVFF  9A5,9A7
01CA2:  MOVWF  xA6
01CA4:  CLRF   xA9
01CA6:  MOVLW  06
01CA8:  MOVWF  xA8
01CAA:  MOVLB  0
01CAC:  RCALL  1BB6
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
01CAE:  MOVLW  08
01CB0:  MOVLB  9
01CB2:  MOVWF  xA5
01CB4:  MOVLB  0
01CB6:  RCALL  1B98
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
01CB8:  MOVLB  9
01CBA:  MOVF   xA1,F
01CBC:  BNZ   1CC2
01CBE:  MOVLW  00
01CC0:  BRA    1CC4
01CC2:  MOVLW  06
01CC4:  MOVWF  xA4
01CC6:  MOVWF  xA5
01CC8:  MOVLB  0
01CCA:  RCALL  1B98
01CCC:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
01CCE:  MOVLW  1C
01CD0:  MOVLB  9
01CD2:  MOVWF  xA1
01CD4:  MOVLB  0
01CD6:  CALL   0B02
01CDA:  MOVFF  01,98E
01CDE:  MOVLW  00
01CE0:  MOVLB  9
01CE2:  BTFSC  01.1
01CE4:  MOVLW  01
01CE6:  XORLW  00
01CE8:  BZ    1D0A
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
01CEA:  MOVLW  1F
01CEC:  MOVWF  xA9
01CEE:  MOVLW  80
01CF0:  MOVWF  xAA
01CF2:  MOVLB  0
01CF4:  CALL   0B7C
....................       BFCReg(ECON1, ECON1_TXRST); 
01CF8:  MOVLW  1F
01CFA:  MOVLB  9
01CFC:  MOVWF  xA6
01CFE:  MOVLW  80
01D00:  MOVWF  xA7
01D02:  MOVLB  0
01D04:  CALL   0B5E
01D08:  MOVLB  9
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01D0A:  MOVLW  1C
01D0C:  MOVWF  xA6
01D0E:  MOVLW  0A
01D10:  MOVWF  xA7
01D12:  MOVLB  0
01D14:  CALL   0B5E
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
01D18:  MOVLW  1F
01D1A:  MOVLB  9
01D1C:  MOVWF  xA9
01D1E:  MOVLW  08
01D20:  MOVWF  xAA
01D22:  MOVLB  0
01D24:  CALL   0B7C
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
01D28:  MOVLB  3
01D2A:  MOVF   x91,W
01D2C:  SUBLW  05
01D2E:  BTFSS  FD8.2
01D30:  BRA    1EFA
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01D32:  MOVLW  1C
01D34:  MOVLB  9
01D36:  MOVWF  xA1
01D38:  MOVLB  0
01D3A:  CALL   0B02
01D3E:  MOVFF  01,98E
01D42:  MOVLB  9
01D44:  MOVF   01,W
01D46:  ANDLW  0A
01D48:  BTFSS  FD8.2
01D4A:  BRA    1D50
01D4C:  MOVLB  3
01D4E:  BRA    1D32
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
01D50:  MOVLW  1C
01D52:  MOVWF  xA1
01D54:  MOVLB  0
01D56:  CALL   0B02
01D5A:  MOVFF  01,98E
01D5E:  MOVLW  00
01D60:  MOVLB  9
01D62:  BTFSC  01.1
01D64:  MOVLW  01
01D66:  XORLW  00
01D68:  BTFSC  FD8.2
01D6A:  BRA    1EF8
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
01D6C:  MOVLW  1F
01D6E:  MOVWF  xA6
01D70:  MOVLW  08
01D72:  MOVWF  xA7
01D74:  MOVLB  0
01D76:  CALL   0B5E
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
01D7A:  MOVLB  9
01D7C:  CLRF   xA5
01D7E:  CLRF   xA4
01D80:  MOVLB  0
01D82:  CALL   0B9A
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
01D86:  MOVLB  9
01D88:  CLRF   xA1
01D8A:  MOVLB  0
01D8C:  CALL   0B02
01D90:  MOVFF  01,982
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
01D94:  MOVLW  01
01D96:  MOVLB  9
01D98:  MOVWF  xA1
01D9A:  MOVLB  0
01D9C:  CALL   0B02
01DA0:  MOVFF  01,983
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
01DA4:  MOVLW  06
01DA6:  MOVLB  9
01DA8:  MOVWF  xA1
01DAA:  MOVLB  0
01DAC:  CALL   0B02
01DB0:  MOVFF  01,984
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
01DB4:  MOVLW  07
01DB6:  MOVLB  9
01DB8:  MOVWF  xA1
01DBA:  MOVLB  0
01DBC:  CALL   0B02
01DC0:  MOVFF  01,985
....................          TXEnd.Val++; 
01DC4:  MOVLB  9
01DC6:  INCF   x84,F
01DC8:  BTFSC  FD8.2
01DCA:  INCF   x85,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
01DCC:  CLRF   xA7
01DCE:  MOVFF  984,9A8
01DD2:  MOVLB  0
01DD4:  CALL   0B40
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
01DD8:  MOVLW  01
01DDA:  MOVLB  9
01DDC:  MOVWF  xA7
01DDE:  MOVFF  985,9A8
01DE2:  MOVLB  0
01DE4:  CALL   0B40
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01DE8:  MOVLW  09
01DEA:  MOVLB  9
01DEC:  MOVWF  x8F
01DEE:  MOVLW  86
01DF0:  MOVWF  x8E
01DF2:  MOVFF  98F,991
01DF6:  MOVWF  x90
01DF8:  CLRF   x93
01DFA:  MOVLW  07
01DFC:  MOVWF  x92
01DFE:  MOVLB  0
01E00:  RCALL  1756
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
01E02:  MOVLB  9
01E04:  CLRF   x8D
01E06:  MOVF   x8D,W
01E08:  SUBLW  0F
01E0A:  BNC   1EDA
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
01E0C:  MOVLW  1C
01E0E:  MOVWF  xA1
01E10:  MOVLB  0
01E12:  CALL   0B02
01E16:  MOVFF  01,98E
01E1A:  MOVLW  00
01E1C:  MOVLB  9
01E1E:  BTFSC  01.1
01E20:  MOVLW  01
01E22:  XORLW  00
01E24:  BZ    1ED0
01E26:  BTFSS  x89.5
01E28:  BRA    1ED0
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
01E2A:  MOVLW  1F
01E2C:  MOVWF  xA9
01E2E:  MOVLW  80
01E30:  MOVWF  xAA
01E32:  MOVLB  0
01E34:  CALL   0B7C
....................                BFCReg(ECON1, ECON1_TXRST); 
01E38:  MOVLW  1F
01E3A:  MOVLB  9
01E3C:  MOVWF  xA6
01E3E:  MOVLW  80
01E40:  MOVWF  xA7
01E42:  MOVLB  0
01E44:  CALL   0B5E
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
01E48:  MOVLW  1C
01E4A:  MOVLB  9
01E4C:  MOVWF  xA6
01E4E:  MOVLW  0A
01E50:  MOVWF  xA7
01E52:  MOVLB  0
01E54:  CALL   0B5E
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
01E58:  MOVLW  1F
01E5A:  MOVLB  9
01E5C:  MOVWF  xA9
01E5E:  MOVLW  08
01E60:  MOVWF  xAA
01E62:  MOVLB  0
01E64:  CALL   0B7C
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
01E68:  MOVLW  1C
01E6A:  MOVLB  9
01E6C:  MOVWF  xA1
01E6E:  MOVLB  0
01E70:  CALL   0B02
01E74:  MOVFF  01,98E
01E78:  MOVLB  9
01E7A:  MOVF   01,W
01E7C:  ANDLW  0A
01E7E:  BTFSS  FD8.2
01E80:  BRA    1E86
01E82:  MOVLB  0
01E84:  BRA    1E68
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
01E86:  MOVLW  1F
01E88:  MOVWF  xA6
01E8A:  MOVLW  08
01E8C:  MOVWF  xA7
01E8E:  MOVLB  0
01E90:  CALL   0B5E
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
01E94:  MOVLB  9
01E96:  CLRF   xA7
01E98:  MOVFF  984,9A8
01E9C:  MOVLB  0
01E9E:  CALL   0B40
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
01EA2:  MOVLW  01
01EA4:  MOVLB  9
01EA6:  MOVWF  xA7
01EA8:  MOVFF  985,9A8
01EAC:  MOVLB  0
01EAE:  CALL   0B40
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
01EB2:  MOVLW  09
01EB4:  MOVLB  9
01EB6:  MOVWF  x8F
01EB8:  MOVLW  86
01EBA:  MOVWF  x8E
01EBC:  MOVFF  98F,991
01EC0:  MOVWF  x90
01EC2:  CLRF   x93
01EC4:  MOVLW  07
01EC6:  MOVWF  x92
01EC8:  MOVLB  0
01ECA:  RCALL  1756
....................             } 
01ECC:  BRA    1ED4
01ECE:  MOVLB  9
....................             else 
....................             { 
....................                break; 
01ED0:  BRA    1EDA
01ED2:  MOVLB  0
....................             } 
01ED4:  MOVLB  9
01ED6:  INCF   x8D,F
01ED8:  BRA    1E06
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
01EDA:  CLRF   xA7
01EDC:  MOVFF  982,9A8
01EE0:  MOVLB  0
01EE2:  CALL   0B40
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
01EE6:  MOVLW  01
01EE8:  MOVLB  9
01EEA:  MOVWF  xA7
01EEC:  MOVFF  983,9A8
01EF0:  MOVLB  0
01EF2:  CALL   0B40
01EF6:  MOVLB  9
01EF8:  MOVLB  3
....................       } 
....................    } 
01EFA:  MOVLB  0
01EFC:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
0222E:  MOVLW  14
02230:  MOVLB  3
02232:  ADDWF  x8E,W
02234:  MOVLB  9
02236:  MOVWF  x31
02238:  MOVLW  00
0223A:  MOVLB  3
0223C:  ADDWFC x8F,W
0223E:  MOVLB  9
02240:  MOVWF  x32
02242:  MOVF   x2D,W
02244:  ADDWF  x31,W
02246:  MOVWF  x2F
02248:  MOVF   x2E,W
0224A:  ADDWFC x32,W
0224C:  MOVWF  x30
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
0224E:  MOVF   x30,W
02250:  SUBLW  1A
02252:  BC    2266
02254:  XORLW  FF
02256:  BNZ   225E
02258:  MOVF   x2F,W
0225A:  SUBLW  F7
0225C:  BC    2266
....................       ReadPT.Val -= RXSIZE; 
0225E:  MOVLW  F8
02260:  SUBWF  x2F,F
02262:  MOVLW  1B
02264:  SUBWFB x30,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
02266:  CLRF   xA5
02268:  CLRF   xA4
0226A:  MOVLB  0
0226C:  CALL   0B9A
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
02270:  MOVLB  9
02272:  CLRF   xA7
02274:  MOVFF  92F,9A8
02278:  MOVLB  0
0227A:  CALL   0B40
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
0227E:  MOVLW  01
02280:  MOVLB  9
02282:  MOVWF  xA7
02284:  MOVFF  930,9A8
02288:  MOVLB  0
0228A:  CALL   0B40
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
0228E:  MOVLW  02
02290:  MOVLB  9
02292:  MOVWF  xA7
02294:  MOVFF  92F,9A8
02298:  MOVLB  0
0229A:  CALL   0B40
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
0229E:  MOVLW  03
022A0:  MOVLB  9
022A2:  MOVWF  xA7
022A4:  MOVFF  930,9A8
022A8:  MOVLB  0
022AA:  CALL   0B40
022AE:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
01AFA:  MOVFF  99B,387
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
01AFE:  MOVLW  07
01B00:  MOVLB  9
01B02:  ADDWF  x9C,F
01B04:  MOVLW  1C
01B06:  ADDWFC x9D,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
01B08:  CLRF   xA5
01B0A:  MOVLW  02
01B0C:  MOVWF  xA4
01B0E:  MOVLB  0
01B10:  CALL   0B9A
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
01B14:  MOVLW  09
01B16:  MOVLB  9
01B18:  MOVWF  x9F
01B1A:  MOVLW  9C
01B1C:  MOVWF  x9E
01B1E:  MOVWF  FE9
01B20:  MOVFF  99F,FEA
01B24:  MOVFF  FEF,9A8
01B28:  CLRF   xA7
01B2A:  MOVLB  0
01B2C:  CALL   0B40
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
01B30:  MOVLW  09
01B32:  MOVLB  9
01B34:  MOVWF  x9F
01B36:  MOVLW  9C
01B38:  MOVWF  x9E
01B3A:  MOVLW  01
01B3C:  ADDWF  x9E,W
01B3E:  MOVWF  FE9
01B40:  MOVLW  00
01B42:  ADDWFC x9F,W
01B44:  MOVWF  FEA
01B46:  MOVFF  FEF,9A8
01B4A:  MOVLW  01
01B4C:  MOVWF  xA7
01B4E:  MOVLB  0
01B50:  CALL   0B40
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
01B54:  MOVLW  09
01B56:  MOVLB  9
01B58:  MOVWF  x9F
01B5A:  MOVLW  9C
01B5C:  MOVWF  x9E
01B5E:  MOVWF  FE9
01B60:  MOVFF  99F,FEA
01B64:  MOVFF  FEF,9A8
01B68:  MOVLW  02
01B6A:  MOVWF  xA7
01B6C:  MOVLB  0
01B6E:  CALL   0B40
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
01B72:  MOVLW  09
01B74:  MOVLB  9
01B76:  MOVWF  x9F
01B78:  MOVLW  9C
01B7A:  MOVWF  x9E
01B7C:  MOVLW  01
01B7E:  ADDWF  x9E,W
01B80:  MOVWF  FE9
01B82:  MOVLW  00
01B84:  ADDWFC x9F,W
01B86:  MOVWF  FEA
01B88:  MOVFF  FEF,9A8
01B8C:  MOVLW  03
01B8E:  MOVWF  xA7
01B90:  MOVLB  0
01B92:  CALL   0B40
01B96:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
02120:  MOVLW  14
02122:  MOVLB  3
02124:  ADDWF  x8E,W
02126:  MOVLB  9
02128:  MOVWF  x5D
0212A:  MOVLW  00
0212C:  MOVLB  3
0212E:  ADDWFC x8F,W
02130:  MOVLB  9
02132:  MOVWF  x5E
02134:  MOVF   x57,W
02136:  ADDWF  x5D,W
02138:  MOVWF  x5B
0213A:  MOVF   x58,W
0213C:  ADDWFC x5E,W
0213E:  MOVWF  x5C
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
02140:  MOVF   x5C,W
02142:  SUBLW  1A
02144:  BC    2158
02146:  XORLW  FF
02148:  BNZ   2150
0214A:  MOVF   x5B,W
0214C:  SUBLW  F7
0214E:  BC    2158
....................    { 
....................       temp.Val -= RXSIZE; 
02150:  MOVLW  F8
02152:  SUBWF  x5B,F
02154:  MOVLW  1B
02156:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
02158:  CLRF   xA5
0215A:  MOVLW  10
0215C:  MOVWF  xA4
0215E:  MOVLB  0
02160:  CALL   0B9A
....................    WriteReg(EDMASTL, temp.v[0]); 
02164:  MOVLW  10
02166:  MOVLB  9
02168:  MOVWF  xA7
0216A:  MOVFF  95B,9A8
0216E:  MOVLB  0
02170:  CALL   0B40
....................    WriteReg(EDMASTH, temp.v[1]); 
02174:  MOVLW  11
02176:  MOVLB  9
02178:  MOVWF  xA7
0217A:  MOVFF  95C,9A8
0217E:  MOVLB  0
02180:  CALL   0B40
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
02184:  MOVLW  01
02186:  MOVLB  9
02188:  SUBWF  x59,W
0218A:  MOVWF  00
0218C:  MOVLW  00
0218E:  SUBWFB x5A,W
02190:  MOVWF  03
02192:  MOVF   00,W
02194:  ADDWF  x5B,F
02196:  MOVF   03,W
02198:  ADDWFC x5C,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
0219A:  MOVF   x5C,W
0219C:  SUBLW  1A
0219E:  BC    21B2
021A0:  XORLW  FF
021A2:  BNZ   21AA
021A4:  MOVF   x5B,W
021A6:  SUBLW  F7
021A8:  BC    21B2
....................    { 
....................       temp.Val -= RXSIZE; 
021AA:  MOVLW  F8
021AC:  SUBWF  x5B,F
021AE:  MOVLW  1B
021B0:  SUBWFB x5C,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
021B2:  MOVLW  12
021B4:  MOVWF  xA7
021B6:  MOVFF  95B,9A8
021BA:  MOVLB  0
021BC:  CALL   0B40
....................    WriteReg(EDMANDH, temp.v[1]); 
021C0:  MOVLW  13
021C2:  MOVLB  9
021C4:  MOVWF  xA7
021C6:  MOVFF  95C,9A8
021CA:  MOVLB  0
021CC:  CALL   0B40
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
021D0:  MOVLW  1F
021D2:  MOVLB  9
021D4:  MOVWF  xA9
021D6:  MOVLW  30
021D8:  MOVWF  xAA
021DA:  MOVLB  0
021DC:  CALL   0B7C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
021E0:  MOVLW  1F
021E2:  MOVLB  9
021E4:  MOVWF  xA1
021E6:  MOVLB  0
021E8:  CALL   0B02
021EC:  MOVFF  01,95D
021F0:  MOVLW  00
021F2:  MOVLB  9
021F4:  BTFSC  01.5
021F6:  MOVLW  01
021F8:  XORLW  00
021FA:  BTFSC  FD8.2
021FC:  BRA    2202
021FE:  MOVLB  0
02200:  BRA    21E0
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02202:  MOVLW  16
02204:  MOVWF  xA1
02206:  MOVLB  0
02208:  CALL   0B02
0220C:  MOVFF  01,95C
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02210:  MOVLW  17
02212:  MOVLB  9
02214:  MOVWF  xA1
02216:  MOVLB  0
02218:  CALL   0B02
0221C:  MOVFF  01,95B
....................    return temp.Val; 
02220:  MOVLB  9
02222:  MOVFF  95B,01
02226:  MOVFF  95C,02
0222A:  MOVLB  0
0222C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
02D54:  MOVLW  06
02D56:  MOVLB  9
02D58:  ADDWF  x9B,W
02D5A:  MOVWF  xA1
02D5C:  MOVLW  1C
02D5E:  ADDWFC x9C,W
02D60:  MOVWF  xA2
02D62:  MOVLW  01
02D64:  ADDWF  xA1,W
02D66:  MOVWF  x9F
02D68:  MOVLW  00
02D6A:  ADDWFC xA2,W
02D6C:  MOVWF  xA0
.................... #endif 
....................    BankSel(EDMASTL); 
02D6E:  CLRF   xA5
02D70:  MOVLW  10
02D72:  MOVWF  xA4
02D74:  MOVLB  0
02D76:  CALL   0B9A
....................    WriteReg(EDMASTL, temp.v[0]); 
02D7A:  MOVLW  10
02D7C:  MOVLB  9
02D7E:  MOVWF  xA7
02D80:  MOVFF  99F,9A8
02D84:  MOVLB  0
02D86:  CALL   0B40
....................    WriteReg(EDMASTH, temp.v[1]); 
02D8A:  MOVLW  11
02D8C:  MOVLB  9
02D8E:  MOVWF  xA7
02D90:  MOVFF  9A0,9A8
02D94:  MOVLB  0
02D96:  CALL   0B40
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
02D9A:  MOVLW  01
02D9C:  MOVLB  9
02D9E:  SUBWF  x9D,W
02DA0:  MOVWF  00
02DA2:  MOVLW  00
02DA4:  SUBWFB x9E,W
02DA6:  MOVWF  03
02DA8:  MOVF   00,W
02DAA:  ADDWF  x9F,F
02DAC:  MOVF   03,W
02DAE:  ADDWFC xA0,F
....................    WriteReg(EDMANDL, temp.v[0]); 
02DB0:  MOVLW  12
02DB2:  MOVWF  xA7
02DB4:  MOVFF  99F,9A8
02DB8:  MOVLB  0
02DBA:  CALL   0B40
....................    WriteReg(EDMANDH, temp.v[1]); 
02DBE:  MOVLW  13
02DC0:  MOVLB  9
02DC2:  MOVWF  xA7
02DC4:  MOVFF  9A0,9A8
02DC8:  MOVLB  0
02DCA:  CALL   0B40
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02DCE:  MOVLW  1F
02DD0:  MOVLB  9
02DD2:  MOVWF  xA9
02DD4:  MOVLW  30
02DD6:  MOVWF  xAA
02DD8:  MOVLB  0
02DDA:  CALL   0B7C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02DDE:  MOVLW  1F
02DE0:  MOVLB  9
02DE2:  MOVWF  xA1
02DE4:  MOVLB  0
02DE6:  CALL   0B02
02DEA:  MOVFF  01,9A1
02DEE:  MOVLW  00
02DF0:  MOVLB  9
02DF2:  BTFSC  01.5
02DF4:  MOVLW  01
02DF6:  XORLW  00
02DF8:  BTFSC  FD8.2
02DFA:  BRA    2E00
02DFC:  MOVLB  0
02DFE:  BRA    2DDE
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
02E00:  MOVLW  16
02E02:  MOVWF  xA1
02E04:  MOVLB  0
02E06:  CALL   0B02
02E0A:  MOVFF  01,9A0
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
02E0E:  MOVLW  17
02E10:  MOVLB  9
02E12:  MOVWF  xA1
02E14:  MOVLB  0
02E16:  CALL   0B02
02E1A:  MOVFF  01,99F
....................    return temp.Val; 
02E1E:  MOVLB  9
02E20:  MOVFF  99F,01
02E24:  MOVFF  9A0,02
02E28:  MOVLB  0
02E2A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
02586:  MOVLB  9
02588:  MOVF   x82,F
0258A:  BNZ   259A
0258C:  MOVF   x83,F
0258E:  BNZ   259A
....................    { 
....................       return 0xFFFF; 
02590:  MOVLW  FF
02592:  MOVWF  01
02594:  MOVWF  02
02596:  BRA    26DA
....................    } 
02598:  BRA    25C8
....................    else if(len == 1u) 
0259A:  DECFSZ x82,W
0259C:  BRA    25C8
0259E:  MOVF   x83,F
025A0:  BNZ   25C8
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
025A2:  MOVLB  0
025A4:  RCALL  255A
025A6:  MOVLB  9
025A8:  CLRF   x87
025AA:  MOVFF  01,986
025AE:  MOVFF  01,03
025B2:  MOVLW  00
025B4:  CLRF   00
025B6:  DECF   00,F
025B8:  XORWF  00,F
025BA:  MOVLW  FF
025BC:  XORWF  03,F
025BE:  MOVFF  00,01
025C2:  MOVFF  03,02
025C6:  BRA    26DA
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
025C8:  CLRF   xA5
025CA:  CLRF   xA4
025CC:  MOVLB  0
025CE:  CALL   0B9A
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
025D2:  MOVLB  9
025D4:  CLRF   xA1
025D6:  MOVLB  0
025D8:  CALL   0B02
025DC:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
025E0:  MOVLW  01
025E2:  MOVLB  9
025E4:  MOVWF  xA1
025E6:  MOVLB  0
025E8:  CALL   0B02
025EC:  MOVFF  01,985
....................    WriteReg(EDMASTL, temp.v[0]); 
025F0:  MOVLW  10
025F2:  MOVLB  9
025F4:  MOVWF  xA7
025F6:  MOVFF  984,9A8
025FA:  MOVLB  0
025FC:  CALL   0B40
....................    WriteReg(EDMASTH, temp.v[1]); 
02600:  MOVLW  11
02602:  MOVLB  9
02604:  MOVWF  xA7
02606:  MOVFF  985,9A8
0260A:  MOVLB  0
0260C:  CALL   0B40
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
02610:  MOVLB  9
02612:  MOVF   x85,W
02614:  SUBLW  1B
02616:  BNC   264E
02618:  BNZ   2620
0261A:  MOVF   x84,W
0261C:  SUBLW  F7
0261E:  BNC   264E
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
02620:  MOVLW  01
02622:  SUBWF  x82,W
02624:  MOVWF  00
02626:  MOVLW  00
02628:  SUBWFB x83,W
0262A:  MOVWF  03
0262C:  MOVF   00,W
0262E:  ADDWF  x84,F
02630:  MOVF   03,W
02632:  ADDWFC x85,F
....................       if(temp.Val > RXSTOP) 
02634:  MOVF   x85,W
02636:  SUBLW  1A
02638:  BC    264C
0263A:  XORLW  FF
0263C:  BNZ   2644
0263E:  MOVF   x84,W
02640:  SUBLW  F7
02642:  BC    264C
....................       { 
....................          temp.Val -= RXSIZE; 
02644:  MOVLW  F8
02646:  SUBWF  x84,F
02648:  MOVLW  1B
0264A:  SUBWFB x85,F
....................       } 
....................    } 
0264C:  BRA    2662
....................    else 
....................    { 
....................       temp.Val += len-1; 
0264E:  MOVLW  01
02650:  SUBWF  x82,W
02652:  MOVWF  00
02654:  MOVLW  00
02656:  SUBWFB x83,W
02658:  MOVWF  03
0265A:  MOVF   00,W
0265C:  ADDWF  x84,F
0265E:  MOVF   03,W
02660:  ADDWFC x85,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
02662:  MOVLW  12
02664:  MOVWF  xA7
02666:  MOVFF  984,9A8
0266A:  MOVLB  0
0266C:  CALL   0B40
....................    WriteReg(EDMANDH, temp.v[1]); 
02670:  MOVLW  13
02672:  MOVLB  9
02674:  MOVWF  xA7
02676:  MOVFF  985,9A8
0267A:  MOVLB  0
0267C:  CALL   0B40
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
02680:  MOVLW  1F
02682:  MOVLB  9
02684:  MOVWF  xA9
02686:  MOVLW  30
02688:  MOVWF  xAA
0268A:  MOVLB  0
0268C:  CALL   0B7C
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
02690:  MOVLW  1F
02692:  MOVLB  9
02694:  MOVWF  xA1
02696:  MOVLB  0
02698:  CALL   0B02
0269C:  MOVFF  01,986
026A0:  MOVLW  00
026A2:  MOVLB  9
026A4:  BTFSC  01.5
026A6:  MOVLW  01
026A8:  XORLW  00
026AA:  BTFSC  FD8.2
026AC:  BRA    26B2
026AE:  MOVLB  0
026B0:  BRA    2690
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
026B2:  MOVLW  16
026B4:  MOVWF  xA1
026B6:  MOVLB  0
026B8:  CALL   0B02
026BC:  MOVFF  01,984
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
026C0:  MOVLW  17
026C2:  MOVLB  9
026C4:  MOVWF  xA1
026C6:  MOVLB  0
026C8:  CALL   0B02
026CC:  MOVFF  01,985
....................    return temp.Val; 
026D0:  MOVLB  9
026D2:  MOVFF  984,01
026D6:  MOVFF  985,02
026DA:  MOVLB  0
026DC:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
0255A:  BCF    F94.1
0255C:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
0255E:  MOVLW  3A
02560:  MOVLB  9
02562:  MOVWF  xAC
02564:  MOVLB  0
02566:  CALL   0AC8
....................    c=ENCSPIXfer(0); 
0256A:  MOVLB  9
0256C:  CLRF   xAC
0256E:  MOVLB  0
02570:  CALL   0AC8
02574:  MOVFF  01,986
....................    SPIUnselectEthernet(); 
02578:  BCF    F94.1
0257A:  BSF    F8B.1
....................    return(c); 
0257C:  MOVLB  9
0257E:  MOVFF  986,01
02582:  MOVLB  0
02584:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
01756:  MOVLB  9
01758:  CLRF   x95
0175A:  CLRF   x94
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
0175C:  BCF    F94.1
0175E:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
01760:  MOVLW  3A
01762:  MOVWF  xAC
01764:  MOVLB  0
01766:  CALL   0AC8
....................    while(i<len) 
0176A:  MOVLB  9
0176C:  MOVF   x95,W
0176E:  SUBWF  x93,W
01770:  BNC   17AA
01772:  BNZ   177A
01774:  MOVF   x92,W
01776:  SUBWF  x94,W
01778:  BC    17AA
....................    { 
....................       *val=ENCSPIXfer(0); 
0177A:  MOVFF  991,03
0177E:  MOVFF  990,996
01782:  MOVFF  991,997
01786:  CLRF   xAC
01788:  MOVLB  0
0178A:  CALL   0AC8
0178E:  MOVFF  997,FEA
01792:  MOVFF  996,FE9
01796:  MOVFF  01,FEF
....................       val++; 
0179A:  MOVLB  9
0179C:  INCF   x90,F
0179E:  BTFSC  FD8.2
017A0:  INCF   x91,F
....................       i++; 
017A2:  INCF   x94,F
017A4:  BTFSC  FD8.2
017A6:  INCF   x95,F
017A8:  BRA    176C
....................    } 
....................    SPIUnselectEthernet(); 
017AA:  BCF    F94.1
017AC:  BSF    F8B.1
....................  
....................    return(i); 
017AE:  MOVFF  994,01
017B2:  MOVFF  995,02
017B6:  MOVLB  0
017B8:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
01B98:  BCF    F94.1
01B9A:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01B9C:  MOVLW  7A
01B9E:  MOVLB  9
01BA0:  MOVWF  xAC
01BA2:  MOVLB  0
01BA4:  CALL   0AC8
....................    ENCSPIXfer(val); 
01BA8:  MOVFF  9A5,9AC
01BAC:  CALL   0AC8
....................    SPIUnselectEthernet(); 
01BB0:  BCF    F94.1
01BB2:  BSF    F8B.1
01BB4:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
01BB6:  BCF    F94.1
01BB8:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
01BBA:  MOVLW  7A
01BBC:  MOVLB  9
01BBE:  MOVWF  xAC
01BC0:  MOVLB  0
01BC2:  CALL   0AC8
....................    while(len--) 
01BC6:  MOVLB  9
01BC8:  MOVFF  9A9,03
01BCC:  MOVF   xA8,W
01BCE:  BTFSC  FD8.2
01BD0:  DECF   xA9,F
01BD2:  DECF   xA8,F
01BD4:  IORWF  03,W
01BD6:  BZ    1BF8
....................    { 
....................       ENCSPIXfer(*val); 
01BD8:  MOVFF  9A7,03
01BDC:  MOVFF  9A6,FE9
01BE0:  MOVFF  9A7,FEA
01BE4:  MOVFF  FEF,9AC
01BE8:  MOVLB  0
01BEA:  CALL   0AC8
....................       val++; 
01BEE:  MOVLB  9
01BF0:  INCF   xA6,F
01BF2:  BTFSC  FD8.2
01BF4:  INCF   xA7,F
01BF6:  BRA    1BC8
....................    } 
....................    SPIUnselectEthernet(); 
01BF8:  BCF    F94.1
01BFA:  BSF    F8B.1
01BFC:  MOVLB  0
01BFE:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B2C:  BCF    F94.1
00B2E:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
00B30:  MOVLB  9
00B32:  SETF   xAC
00B34:  MOVLB  0
00B36:  RCALL  0AC8
....................    SPIUnselectEthernet(); 
00B38:  BCF    F94.1
00B3A:  BSF    F8B.1
00B3C:  GOTO   0DF8 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
00B02:  BCF    F94.1
00B04:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
00B06:  MOVFF  9A1,9A3
00B0A:  MOVFF  9A1,9AC
00B0E:  MOVLB  0
00B10:  RCALL  0AC8
....................    c=ENCSPIXfer(0); 
00B12:  MOVLB  9
00B14:  CLRF   xAC
00B16:  MOVLB  0
00B18:  RCALL  0AC8
00B1A:  MOVFF  01,9A2
....................    SPIUnselectEthernet(); 
00B1E:  BCF    F94.1
00B20:  BSF    F8B.1
....................    return(c); 
00B22:  MOVLB  9
00B24:  MOVFF  9A2,01
00B28:  MOVLB  0
00B2A:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
00BCC:  BCF    F94.1
00BCE:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
00BD0:  MOVFF  8FE,900
00BD4:  MOVFF  8FE,9AC
00BD8:  MOVLB  0
00BDA:  RCALL  0AC8
....................    ENCSPIXfer(0); 
00BDC:  MOVLB  9
00BDE:  CLRF   xAC
00BE0:  MOVLB  0
00BE2:  RCALL  0AC8
....................    c=ENCSPIXfer(0); 
00BE4:  MOVLB  9
00BE6:  CLRF   xAC
00BE8:  MOVLB  0
00BEA:  RCALL  0AC8
00BEC:  MOVFF  01,8FF
....................  
....................    SPIUnselectEthernet(); 
00BF0:  BCF    F94.1
00BF2:  BSF    F8B.1
....................  
....................    return(c); 
00BF4:  MOVLB  8
00BF6:  MOVFF  8FF,01
00BFA:  MOVLB  0
00BFC:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
00C8E:  MOVLW  02
00C90:  MOVLB  9
00C92:  MOVWF  xA5
00C94:  MOVLW  14
00C96:  MOVWF  xA4
00C98:  MOVLB  0
00C9A:  RCALL  0B9A
....................    WriteReg(MIREGADR, Register); 
00C9C:  MOVLW  14
00C9E:  MOVLB  9
00CA0:  MOVWF  xA7
00CA2:  MOVFF  8FB,9A8
00CA6:  MOVLB  0
00CA8:  RCALL  0B40
....................    WriteReg(MICMD, MICMD_MIIRD); 
00CAA:  MOVLW  12
00CAC:  MOVLB  9
00CAE:  MOVWF  xA7
00CB0:  MOVLW  01
00CB2:  MOVWF  xA8
00CB4:  MOVLB  0
00CB6:  RCALL  0B40
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
00CB8:  MOVLW  03
00CBA:  MOVLB  9
00CBC:  MOVWF  xA5
00CBE:  MOVLW  0A
00CC0:  MOVWF  xA4
00CC2:  MOVLB  0
00CC4:  RCALL  0B9A
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00CC6:  MOVLW  0A
00CC8:  MOVLB  8
00CCA:  MOVWF  xFE
00CCC:  MOVLB  0
00CCE:  RCALL  0BCC
00CD0:  MOVFF  01,8FE
00CD4:  MOVLW  00
00CD6:  MOVLB  8
00CD8:  BTFSC  01.0
00CDA:  MOVLW  01
00CDC:  XORLW  00
00CDE:  BTFSC  FD8.2
00CE0:  BRA    0CE6
00CE2:  MOVLB  0
00CE4:  BRA    0CC6
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
00CE6:  MOVLW  02
00CE8:  MOVLB  9
00CEA:  MOVWF  xA5
00CEC:  MOVLW  14
00CEE:  MOVWF  xA4
00CF0:  MOVLB  0
00CF2:  RCALL  0B9A
....................    WriteReg(MICMD, 0x00); 
00CF4:  MOVLW  12
00CF6:  MOVLB  9
00CF8:  MOVWF  xA7
00CFA:  CLRF   xA8
00CFC:  MOVLB  0
00CFE:  RCALL  0B40
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
00D00:  MOVLW  18
00D02:  MOVLB  8
00D04:  MOVWF  xFE
00D06:  MOVLB  0
00D08:  RCALL  0BCC
00D0A:  MOVFF  01,8FC
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
00D0E:  MOVLW  19
00D10:  MOVLB  8
00D12:  MOVWF  xFE
00D14:  MOVLB  0
00D16:  RCALL  0BCC
00D18:  MOVFF  01,8FD
....................    return Result; 
00D1C:  MOVLB  8
00D1E:  MOVFF  8FC,01
00D22:  MOVFF  8FD,02
00D26:  MOVLB  0
00D28:  RETURN 0
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
00B40:  BCF    F94.1
00B42:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
00B44:  MOVLB  9
00B46:  MOVF   xA7,W
00B48:  IORLW  40
00B4A:  MOVWF  xA9
00B4C:  MOVWF  xAC
00B4E:  MOVLB  0
00B50:  RCALL  0AC8
....................    ENCSPIXfer(Data); 
00B52:  MOVFF  9A8,9AC
00B56:  RCALL  0AC8
....................    SPIUnselectEthernet(); 
00B58:  BCF    F94.1
00B5A:  BSF    F8B.1
00B5C:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00B5E:  BCF    F94.1
00B60:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
00B62:  MOVLB  9
00B64:  MOVF   xA6,W
00B66:  IORLW  A0
00B68:  MOVWF  xA8
00B6A:  MOVWF  xAC
00B6C:  MOVLB  0
00B6E:  RCALL  0AC8
....................    ENCSPIXfer(Data); 
00B70:  MOVFF  9A7,9AC
00B74:  RCALL  0AC8
....................    SPIUnselectEthernet(); 
00B76:  BCF    F94.1
00B78:  BSF    F8B.1
00B7A:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
00B7C:  BCF    F94.1
00B7E:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
00B80:  MOVLB  9
00B82:  MOVF   xA9,W
00B84:  IORLW  80
00B86:  MOVWF  xAB
00B88:  MOVWF  xAC
00B8A:  MOVLB  0
00B8C:  RCALL  0AC8
....................    ENCSPIXfer(Data); 
00B8E:  MOVFF  9AA,9AC
00B92:  RCALL  0AC8
....................    SPIUnselectEthernet(); 
00B94:  BCF    F94.1
00B96:  BSF    F8B.1
00B98:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
00BFE:  MOVLW  02
00C00:  MOVLB  9
00C02:  MOVWF  xA5
00C04:  MOVLW  14
00C06:  MOVWF  xA4
00C08:  MOVLB  0
00C0A:  RCALL  0B9A
....................    WriteReg(MIREGADR, Register); 
00C0C:  MOVLW  14
00C0E:  MOVLB  9
00C10:  MOVWF  xA7
00C12:  MOVFF  8FB,9A8
00C16:  MOVLB  0
00C18:  RCALL  0B40
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
00C1A:  MOVLW  08
00C1C:  MOVLB  8
00C1E:  MOVWF  xFF
00C20:  MOVLW  FC
00C22:  MOVWF  xFE
00C24:  MOVWF  FE9
00C26:  MOVFF  8FF,FEA
00C2A:  MOVFF  FEF,9A8
00C2E:  MOVLW  16
00C30:  MOVLB  9
00C32:  MOVWF  xA7
00C34:  MOVLB  0
00C36:  RCALL  0B40
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
00C38:  MOVLW  08
00C3A:  MOVLB  8
00C3C:  MOVWF  xFF
00C3E:  MOVLW  FC
00C40:  MOVWF  xFE
00C42:  MOVLW  01
00C44:  ADDWF  xFE,W
00C46:  MOVWF  FE9
00C48:  MOVLW  00
00C4A:  ADDWFC xFF,W
00C4C:  MOVWF  FEA
00C4E:  MOVFF  FEF,9A8
00C52:  MOVLW  17
00C54:  MOVLB  9
00C56:  MOVWF  xA7
00C58:  MOVLB  0
00C5A:  RCALL  0B40
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
00C5C:  MOVLW  03
00C5E:  MOVLB  9
00C60:  MOVWF  xA5
00C62:  MOVLW  0A
00C64:  MOVWF  xA4
00C66:  MOVLB  0
00C68:  RCALL  0B9A
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
00C6A:  MOVLW  0A
00C6C:  MOVLB  8
00C6E:  MOVWF  xFE
00C70:  MOVLB  0
00C72:  RCALL  0BCC
00C74:  MOVFF  01,8FE
00C78:  MOVLW  00
00C7A:  MOVLB  8
00C7C:  BTFSC  01.0
00C7E:  MOVLW  01
00C80:  XORLW  00
00C82:  BTFSC  FD8.2
00C84:  BRA    0C8A
00C86:  MOVLB  0
00C88:  BRA    0C6A
00C8A:  MOVLB  0
00C8C:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
00B9A:  MOVLW  1F
00B9C:  MOVLB  9
00B9E:  MOVWF  xA6
00BA0:  MOVLW  03
00BA2:  MOVWF  xA7
00BA4:  MOVLB  0
00BA6:  RCALL  0B5E
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
00BA8:  MOVLW  09
00BAA:  MOVLB  9
00BAC:  MOVWF  xA7
00BAE:  MOVLW  A4
00BB0:  MOVWF  xA6
00BB2:  MOVLW  01
00BB4:  ADDWF  xA6,W
00BB6:  MOVWF  FE9
00BB8:  MOVLW  00
00BBA:  ADDWFC xA7,W
00BBC:  MOVWF  FEA
00BBE:  MOVFF  FEF,9AA
00BC2:  MOVLW  1F
00BC4:  MOVWF  xA9
00BC6:  MOVLB  0
00BC8:  RCALL  0B7C
00BCA:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
00D2A:  MOVLW  1F
00D2C:  MOVLB  9
00D2E:  MOVWF  xA6
00D30:  MOVLW  0C
00D32:  MOVWF  xA7
00D34:  MOVLB  0
00D36:  RCALL  0B5E
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
00D38:  MOVLB  8
00D3A:  CLRF   xFB
00D3C:  MOVLB  0
00D3E:  RCALL  0C8E
00D40:  MOVFF  02,8FA
00D44:  MOVFF  01,8F9
....................    if(DuplexState == USE_PHY) 
00D48:  MOVLB  8
00D4A:  MOVF   xF7,W
00D4C:  SUBLW  02
00D4E:  BNZ   0D58
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
00D50:  CLRF   xF7
00D52:  BTFSC  xFA.0
00D54:  INCF   xF7,F
....................    } 
00D56:  BRA    0D6E
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
00D58:  BCF    xFA.0
00D5A:  BTFSC  xF7.0
00D5C:  BSF    xFA.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
00D5E:  CLRF   xFB
00D60:  MOVFF  8FA,8FD
00D64:  MOVFF  8F9,8FC
00D68:  MOVLB  0
00D6A:  RCALL  0BFE
00D6C:  MOVLB  8
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
00D6E:  MOVLW  02
00D70:  MOVLB  9
00D72:  MOVWF  xA5
00D74:  MOVWF  xA4
00D76:  MOVLB  0
00D78:  RCALL  0B9A
....................    Register = ReadMACReg(MACON3); 
00D7A:  MOVLW  02
00D7C:  MOVLB  8
00D7E:  MOVWF  xFE
00D80:  MOVLB  0
00D82:  RCALL  0BCC
00D84:  MOVFF  01,8F8
....................    Register.MACON3bits.FULDPX = DuplexState; 
00D88:  MOVLB  8
00D8A:  BCF    xF8.0
00D8C:  BTFSC  xF7.0
00D8E:  BSF    xF8.0
....................    WriteReg(MACON3, Register.Val); 
00D90:  MOVLW  02
00D92:  MOVLB  9
00D94:  MOVWF  xA7
00D96:  MOVFF  8F8,9A8
00D9A:  MOVLB  0
00D9C:  RCALL  0B40
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
00D9E:  MOVLB  8
00DA0:  MOVF   xF7,F
00DA2:  BZ    0DA8
00DA4:  MOVLW  15
00DA6:  BRA    0DAA
00DA8:  MOVLW  12
00DAA:  MOVWF  xFB
00DAC:  MOVLW  04
00DAE:  MOVLB  9
00DB0:  MOVWF  xA7
00DB2:  MOVFF  8FB,9A8
00DB6:  MOVLB  0
00DB8:  RCALL  0B40
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
00DBA:  MOVLW  1F
00DBC:  MOVLB  9
00DBE:  MOVWF  xA9
00DC0:  MOVLW  04
00DC2:  MOVWF  xAA
00DC4:  MOVLB  0
00DC6:  RCALL  0B7C
00DC8:  GOTO   0F8C (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
02378:  MOVLW  09
0237A:  MOVLB  9
0237C:  MOVWF  x1B
0237E:  MOVLW  06
02380:  MOVWF  x1A
02382:  MOVFF  91B,991
02386:  MOVWF  x90
02388:  CLRF   x93
0238A:  MOVLW  14
0238C:  MOVWF  x92
0238E:  MOVLB  0
02390:  CALL   1756
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
02394:  MOVLB  9
02396:  MOVF   x06,W
02398:  ANDLW  F0
0239A:  SUBLW  40
0239C:  BZ    23A4
....................     	return FALSE; 
0239E:  MOVLW  00
023A0:  MOVWF  01
023A2:  BRA    245E
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
023A4:  MOVF   x06,W
023A6:  ANDLW  0F
023A8:  MOVWF  00
023AA:  RLCF   00,W
023AC:  MOVLB  3
023AE:  MOVWF  x94
023B0:  RLCF   x94,F
023B2:  MOVLW  FC
023B4:  ANDWF  x94,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
023B6:  MOVLB  9
023B8:  CLRF   x58
023BA:  CLRF   x57
023BC:  CLRF   x5A
023BE:  MOVFF  394,959
023C2:  MOVLB  0
023C4:  RCALL  2120
023C6:  MOVFF  02,905
023CA:  MOVFF  01,904
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
023CE:  MOVLB  9
023D0:  CLRF   x2E
023D2:  MOVFF  394,92D
023D6:  MOVLB  0
023D8:  RCALL  222E
....................  
....................     if(CalcChecksum.Val) 
023DA:  MOVLB  9
023DC:  MOVF   x04,W
023DE:  IORWF  x05,W
023E0:  BZ    23E8
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
023E2:  MOVLW  00
023E4:  MOVWF  01
023E6:  BRA    245E
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
023E8:  MOVLW  09
023EA:  MOVWF  x9C
023EC:  MOVLW  06
023EE:  MOVWF  x9B
023F0:  MOVLB  0
023F2:  RCALL  22B0
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
023F4:  MOVLB  8
023F6:  MOVF   xFC,W
023F8:  IORWF  xFD,W
023FA:  BZ    2414
....................         localIP->Val    = header.DestAddress.Val; 
023FC:  MOVFF  8FC,FE9
02400:  MOVFF  8FD,FEA
02404:  MOVFF  916,FEF
02408:  MOVFF  917,FEC
0240C:  MOVFF  918,FEC
02410:  MOVFF  919,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
02414:  MOVLW  06
02416:  ADDWF  xFE,W
02418:  MOVWF  FE9
0241A:  MOVLW  00
0241C:  ADDWFC xFF,W
0241E:  MOVWF  FEA
02420:  MOVFF  912,FEF
02424:  MOVFF  913,FEC
02428:  MOVFF  914,FEC
0242C:  MOVFF  915,FEC
....................     *protocol           = header.Protocol; 
02430:  MOVLB  9
02432:  MOVFF  900,FE9
02436:  MOVFF  901,FEA
0243A:  MOVFF  90F,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
0243E:  MOVFF  902,FE9
02442:  MOVFF  903,FEA
02446:  MOVLB  3
02448:  MOVF   x94,W
0244A:  MOVLB  9
0244C:  SUBWF  x08,W
0244E:  MOVWF  00
02450:  MOVLW  00
02452:  SUBWFB x09,W
02454:  MOVFF  00,FEF
02458:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
0245A:  MOVLW  01
0245C:  MOVWF  01
0245E:  MOVLB  0
02460:  GOTO   4510 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
02E2C:  MOVLW  14
02E2E:  MOVLB  3
02E30:  MOVWF  x94
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
02E32:  MOVLW  45
02E34:  MOVLB  9
02E36:  MOVWF  x87
....................     header.TypeOfService    = IP_SERVICE; 
02E38:  CLRF   x88
....................     header.TotalLength      = sizeof(header) + len; 
02E3A:  MOVLW  14
02E3C:  ADDWF  x85,W
02E3E:  MOVWF  x89
02E40:  MOVLW  00
02E42:  ADDWFC x86,W
02E44:  MOVWF  x8A
....................     header.Identification   = ++_Identifier; 
02E46:  MOVLB  3
02E48:  INCF   x92,F
02E4A:  BTFSC  FD8.2
02E4C:  INCF   x93,F
02E4E:  MOVFF  393,98C
02E52:  MOVFF  392,98B
....................     header.FragmentInfo     = 0; 
02E56:  MOVLB  9
02E58:  CLRF   x8E
02E5A:  CLRF   x8D
....................     header.TimeToLive       = MY_IP_TTL; 
02E5C:  MOVLW  64
02E5E:  MOVWF  x8F
....................     header.Protocol         = protocol; 
02E60:  MOVFF  984,990
....................     header.HeaderChecksum   = 0; 
02E64:  CLRF   x92
02E66:  CLRF   x91
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
02E68:  MOVFF  353,996
02E6C:  MOVFF  352,995
02E70:  MOVFF  351,994
02E74:  MOVFF  350,993
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
02E78:  MOVLW  06
02E7A:  ADDWF  x82,W
02E7C:  MOVWF  FE9
02E7E:  MOVLW  00
02E80:  ADDWFC x83,W
02E82:  MOVWF  FEA
02E84:  MOVFF  FEF,997
02E88:  MOVFF  FEC,998
02E8C:  MOVFF  FEC,999
02E90:  MOVFF  FEC,99A
....................  
....................     SwapIPHeader(&header); 
02E94:  MOVLW  09
02E96:  MOVWF  x9C
02E98:  MOVLW  87
02E9A:  MOVWF  x9B
02E9C:  MOVLB  0
02E9E:  CALL   22B0
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
02EA2:  MOVLB  9
02EA4:  MOVFF  982,01
02EA8:  MOVFF  983,03
02EAC:  MOVFF  982,99B
02EB0:  MOVFF  983,99C
02EB4:  MOVLW  14
02EB6:  ADDWF  x85,W
02EB8:  MOVWF  x9D
02EBA:  MOVLW  00
02EBC:  ADDWFC x86,W
02EBE:  MOVWF  x9E
02EC0:  MOVFF  983,9A0
02EC4:  MOVFF  982,99F
02EC8:  CLRF   xA1
02ECA:  MOVWF  xA3
02ECC:  MOVFF  99D,9A2
02ED0:  MOVLB  0
02ED2:  CALL   1C00
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
02ED6:  MOVLW  09
02ED8:  MOVLB  9
02EDA:  MOVWF  x9C
02EDC:  MOVLW  87
02EDE:  MOVWF  x9B
02EE0:  MOVFF  99C,9A7
02EE4:  MOVWF  xA6
02EE6:  CLRF   xA9
02EE8:  MOVLW  14
02EEA:  MOVWF  xA8
02EEC:  MOVLB  0
02EEE:  CALL   1BB6
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
02EF2:  MOVLB  9
02EF4:  CLRF   x9C
02EF6:  CLRF   x9B
02EF8:  CLRF   x9E
02EFA:  MOVLW  14
02EFC:  MOVWF  x9D
02EFE:  MOVLB  0
02F00:  RCALL  2D54
02F02:  MOVFF  02,992
02F06:  MOVFF  01,991
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
02F0A:  MOVFF  387,99B
02F0E:  MOVLB  9
02F10:  CLRF   x9D
02F12:  MOVLW  0A
02F14:  MOVWF  x9C
02F16:  MOVLB  0
02F18:  CALL   1AFA
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
02F1C:  MOVLW  09
02F1E:  MOVLB  9
02F20:  MOVWF  x9C
02F22:  MOVLW  91
02F24:  MOVWF  x9B
02F26:  MOVFF  99C,9A7
02F2A:  MOVWF  xA6
02F2C:  CLRF   xA9
02F2E:  MOVLW  02
02F30:  MOVWF  xA8
02F32:  MOVLB  0
02F34:  CALL   1BB6
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
02F38:  MOVFF  387,99B
02F3C:  MOVLB  9
02F3E:  CLRF   x9D
02F40:  MOVLW  14
02F42:  MOVWF  x9C
02F44:  MOVLB  0
02F46:  CALL   1AFA
.................... #endif 
....................  
....................     return 0x0; 
02F4A:  MOVLW  00
02F4C:  MOVWF  01
02F4E:  MOVWF  02
02F50:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
026DE:  MOVLB  3
026E0:  MOVF   x94,W
026E2:  MOVLB  9
026E4:  ADDWF  x29,W
026E6:  MOVWF  x2B
026E8:  MOVLW  00
026EA:  ADDWFC x2A,W
026EC:  MOVWF  x2C
026EE:  MOVWF  x2E
026F0:  MOVFF  92B,92D
026F4:  MOVLB  0
026F6:  RCALL  222E
026F8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
022B0:  MOVLW  02
022B2:  MOVLB  9
022B4:  ADDWF  x9B,W
022B6:  MOVWF  01
022B8:  MOVLW  00
022BA:  ADDWFC x9C,W
022BC:  MOVWF  03
022BE:  MOVFF  01,99D
022C2:  MOVWF  x9E
022C4:  MOVLW  02
022C6:  ADDWF  x9B,W
022C8:  MOVWF  FE9
022CA:  MOVLW  00
022CC:  ADDWFC x9C,W
022CE:  MOVWF  FEA
022D0:  MOVFF  FEC,9A2
022D4:  MOVF   FED,F
022D6:  MOVFF  FEF,9A1
022DA:  MOVLB  0
022DC:  CALL   17BA
022E0:  MOVFF  99E,FEA
022E4:  MOVFF  99D,FE9
022E8:  MOVFF  02,FEC
022EC:  MOVF   FED,F
022EE:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
022F2:  MOVLW  04
022F4:  MOVLB  9
022F6:  ADDWF  x9B,W
022F8:  MOVWF  01
022FA:  MOVLW  00
022FC:  ADDWFC x9C,W
022FE:  MOVWF  03
02300:  MOVFF  01,99D
02304:  MOVWF  x9E
02306:  MOVLW  04
02308:  ADDWF  x9B,W
0230A:  MOVWF  FE9
0230C:  MOVLW  00
0230E:  ADDWFC x9C,W
02310:  MOVWF  FEA
02312:  MOVFF  FEC,9A2
02316:  MOVF   FED,F
02318:  MOVFF  FEF,9A1
0231C:  MOVLB  0
0231E:  CALL   17BA
02322:  MOVFF  99E,FEA
02326:  MOVFF  99D,FE9
0232A:  MOVFF  02,FEC
0232E:  MOVF   FED,F
02330:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
02334:  MOVLW  0A
02336:  MOVLB  9
02338:  ADDWF  x9B,W
0233A:  MOVWF  01
0233C:  MOVLW  00
0233E:  ADDWFC x9C,W
02340:  MOVWF  03
02342:  MOVFF  01,99D
02346:  MOVWF  x9E
02348:  MOVLW  0A
0234A:  ADDWF  x9B,W
0234C:  MOVWF  FE9
0234E:  MOVLW  00
02350:  ADDWFC x9C,W
02352:  MOVWF  FEA
02354:  MOVFF  FEC,9A2
02358:  MOVF   FED,F
0235A:  MOVFF  FEF,9A1
0235E:  MOVLB  0
02360:  CALL   17BA
02364:  MOVFF  99E,FEA
02368:  MOVFF  99D,FE9
0236C:  MOVFF  02,FEC
02370:  MOVF   FED,F
02372:  MOVFF  01,FEF
02376:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
0111C:  MOVLB  8
0111E:  CLRF   xF6
01120:  MOVF   xF6,W
01122:  SUBLW  22
01124:  BNC   1204
....................     { 
....................         ps = &TCB[s]; 
01126:  MOVLB  9
01128:  CLRF   x47
0112A:  MOVFF  8F6,946
0112E:  CLRF   x49
01130:  MOVLW  24
01132:  MOVWF  x48
01134:  MOVLB  0
01136:  RCALL  0FBE
01138:  MOVFF  02,03
0113C:  MOVF   01,W
0113E:  ADDLW  97
01140:  MOVWF  01
01142:  MOVLW  03
01144:  ADDWFC 03,F
01146:  MOVFF  01,8F7
0114A:  MOVLB  8
0114C:  MOVFF  03,8F8
....................  
....................         ps->smState             = TCP_CLOSED; 
01150:  MOVFF  8F7,FE9
01154:  MOVFF  8F8,FEA
01158:  MOVLW  0A
0115A:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
0115C:  MOVLW  23
0115E:  ADDWF  xF7,W
01160:  MOVWF  FE9
01162:  MOVLW  00
01164:  ADDWFC xF8,W
01166:  MOVWF  FEA
01168:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
0116A:  MOVLW  23
0116C:  ADDWF  xF7,W
0116E:  MOVWF  FE9
01170:  MOVLW  00
01172:  ADDWFC xF8,W
01174:  MOVWF  FEA
01176:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
01178:  MOVLW  23
0117A:  ADDWF  xF7,W
0117C:  MOVWF  FE9
0117E:  MOVLW  00
01180:  ADDWFC xF8,W
01182:  MOVWF  FEA
01184:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
01186:  MOVLW  23
01188:  ADDWF  xF7,W
0118A:  MOVWF  FE9
0118C:  MOVLW  00
0118E:  ADDWFC xF8,W
01190:  MOVWF  FEA
01192:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
01194:  MOVLW  23
01196:  ADDWF  xF7,W
01198:  MOVWF  FE9
0119A:  MOVLW  00
0119C:  ADDWFC xF8,W
0119E:  MOVWF  FEA
011A0:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
011A2:  MOVLW  0F
011A4:  ADDWF  xF7,W
011A6:  MOVWF  FE9
011A8:  MOVLW  00
011AA:  ADDWFC xF8,W
011AC:  MOVWF  FEA
011AE:  INCFSZ FEF,W
011B0:  BRA    11B4
011B2:  BRA    11DA
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
011B4:  MOVLW  0F
011B6:  ADDWF  xF7,W
011B8:  MOVWF  FE9
011BA:  MOVLW  00
011BC:  ADDWFC xF8,W
011BE:  MOVWF  FEA
011C0:  MOVFF  FEF,949
011C4:  MOVLB  0
011C6:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
011CA:  MOVLW  0F
011CC:  MOVLB  8
011CE:  ADDWF  xF7,W
011D0:  MOVWF  FE9
011D2:  MOVLW  00
011D4:  ADDWFC xF8,W
011D6:  MOVWF  FEA
011D8:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
011DA:  MOVLW  21
011DC:  ADDWF  xF7,W
011DE:  MOVWF  FE9
011E0:  MOVLW  00
011E2:  ADDWFC xF8,W
011E4:  MOVWF  FEA
011E6:  CLRF   FEC
011E8:  MOVF   FED,F
011EA:  MOVLW  24
011EC:  MOVWF  FEF
....................       ps->TxCount            = 0; 
011EE:  MOVLW  10
011F0:  ADDWF  xF7,W
011F2:  MOVWF  FE9
011F4:  MOVLW  00
011F6:  ADDWFC xF8,W
011F8:  MOVWF  FEA
011FA:  CLRF   FEC
011FC:  MOVF   FED,F
011FE:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
01200:  INCF   xF6,F
01202:  BRA    1120
....................     TCPInit_RandSeed+=get_timer0(); 
01204:  MOVF   FD6,W
01206:  ADDWF  x83,F
01208:  MOVF   FD7,W
0120A:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
0120C:  MOVF   FCE,W
0120E:  ADDWF  x83,F
01210:  MOVF   FCF,W
01212:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
01214:  MOVF   FCC,W
01216:  ADDWF  x83,F
01218:  MOVLW  00
0121A:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
0121C:  MOVF   FB2,W
0121E:  ADDWF  x83,F
01220:  MOVF   FB3,W
01222:  ADDWFC x84,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
01224:  CLRF   xFC
01226:  CLRF   xFB
01228:  MOVFF  884,8FA
0122C:  MOVFF  883,8F9
01230:  MOVLB  0
01232:  BRA    0FE0
....................     _NextPort=rand(); 
01234:  BRA    1098
01236:  MOVFF  02,396
0123A:  MOVFF  01,395
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
0123E:  MOVLW  04
01240:  MOVLB  3
01242:  ADDWF  x96,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
01244:  MOVF   x96,W
01246:  SUBLW  12
01248:  BC    125E
0124A:  XORLW  FF
0124C:  BNZ   1254
0124E:  MOVF   x95,W
01250:  SUBLW  87
01252:  BC    125E
01254:  MOVLW  88
01256:  SUBWF  x95,F
01258:  MOVLW  13
0125A:  SUBWFB x96,F
0125C:  BRA    1244
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
0125E:  MOVF   x96,W
01260:  SUBLW  03
01262:  BNC   1268
01264:  MOVLW  04
01266:  ADDWF  x96,F
01268:  MOVLB  0
0126A:  GOTO   127C (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
04710:  MOVLB  9
04712:  BCF    x00.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
04714:  MOVLB  8
04716:  CLRF   xFD
04718:  MOVF   xFD,W
0471A:  SUBLW  22
0471C:  BNC   4764
....................    { 
....................       ps = &TCB[s]; 
0471E:  MOVLB  9
04720:  CLRF   x47
04722:  MOVFF  8FD,946
04726:  CLRF   x49
04728:  MOVLW  24
0472A:  MOVWF  x48
0472C:  MOVLB  0
0472E:  CALL   0FBE
04732:  MOVFF  02,03
04736:  MOVF   01,W
04738:  ADDLW  97
0473A:  MOVWF  01
0473C:  MOVLW  03
0473E:  ADDWFC 03,F
04740:  MOVFF  01,8FE
04744:  MOVLB  8
04746:  MOVFF  03,8FF
....................       if(ps->smState == TCP_CLOSED) 
0474A:  MOVFF  8FE,FE9
0474E:  MOVFF  8FF,FEA
04752:  MOVF   FEF,W
04754:  SUBLW  0A
04756:  BNZ   4760
....................       { 
....................          lbFound = TRUE; 
04758:  MOVLB  9
0475A:  BSF    x00.0
....................          break; 
0475C:  MOVLB  8
0475E:  BRA    4764
....................       } 
04760:  INCF   xFD,F
04762:  BRA    4718
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
04764:  MOVLB  9
04766:  BTFSC  x00.0
04768:  BRA    4770
....................       return INVALID_SOCKET; 
0476A:  MOVLW  FE
0476C:  MOVWF  01
0476E:  BRA    4920
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
04770:  MOVLW  0B
04772:  MOVLB  8
04774:  ADDWF  xFE,W
04776:  MOVWF  FE9
04778:  MOVLW  00
0477A:  ADDWFC xFF,W
0477C:  MOVWF  FEA
0477E:  MOVLB  3
04780:  INCF   x95,F
04782:  BTFSC  FD8.2
04784:  INCF   x96,F
04786:  MOVFF  396,FEC
0478A:  MOVF   FED,F
0478C:  MOVFF  395,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
04790:  MOVF   x96,W
04792:  SUBLW  12
04794:  BC    47A6
04796:  XORLW  FF
04798:  BNZ   47A0
0479A:  MOVF   x95,W
0479C:  SUBLW  87
0479E:  BC    47A6
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
047A0:  MOVLW  03
047A2:  MOVWF  x96
047A4:  SETF   x95
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
047A6:  MOVLW  23
047A8:  MOVLB  8
047AA:  ADDWF  xFE,W
047AC:  MOVWF  FE9
047AE:  MOVLW  00
047B0:  ADDWFC xFF,W
047B2:  MOVWF  FEA
047B4:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
047B6:  MOVLW  0D
047B8:  ADDWF  xFE,W
047BA:  MOVWF  FE9
047BC:  MOVLW  00
047BE:  ADDWFC xFF,W
047C0:  MOVWF  FEA
047C2:  MOVFF  8FC,FEC
047C6:  MOVF   FED,F
047C8:  MOVFF  8FB,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
047CC:  MOVLW  16
047CE:  ADDWF  xFE,W
047D0:  MOVWF  FE9
047D2:  MOVLW  00
047D4:  ADDWFC xFF,W
047D6:  MOVWF  FEA
047D8:  MOVLW  01
047DA:  ADDWF  FEE,F
047DC:  MOVLW  00
047DE:  ADDWFC FEE,F
047E0:  ADDWFC FEE,F
047E2:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
047E4:  MOVLW  1A
047E6:  ADDWF  xFE,W
047E8:  MOVWF  FE9
047EA:  MOVLW  00
047EC:  ADDWFC xFF,W
047EE:  MOVWF  FEA
047F0:  MOVF   FEE,F
047F2:  MOVF   FEE,F
047F4:  CLRF   FEC
047F6:  MOVF   FED,F
047F8:  CLRF   FEF
047FA:  MOVF   FED,F
047FC:  CLRF   FEF
047FE:  MOVF   FED,F
04800:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
04802:  MOVLW  01
04804:  ADDWF  xFE,W
04806:  MOVWF  01
04808:  MOVLW  00
0480A:  ADDWFC xFF,W
0480C:  MOVWF  03
0480E:  MOVFF  01,901
04812:  MOVLB  9
04814:  MOVWF  x02
04816:  MOVWF  FEA
04818:  MOVFF  01,FE9
0481C:  MOVFF  8FA,FE2
04820:  MOVFF  8F9,FE1
04824:  MOVLW  0A
04826:  MOVWF  01
04828:  MOVFF  FE6,FEE
0482C:  DECFSZ 01,F
0482E:  BRA    4828
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
04830:  MOVLW  01
04832:  MOVLB  8
04834:  ADDWF  xFE,W
04836:  MOVWF  01
04838:  MOVLW  00
0483A:  ADDWFC xFF,W
0483C:  MOVWF  03
0483E:  MOVFF  01,901
04842:  MOVLB  9
04844:  MOVWF  x02
04846:  MOVLW  0B
04848:  MOVLB  8
0484A:  ADDWF  xFE,W
0484C:  MOVWF  FE9
0484E:  MOVLW  00
04850:  ADDWFC xFF,W
04852:  MOVWF  FEA
04854:  MOVFF  FEC,94D
04858:  MOVF   FED,F
0485A:  MOVFF  FEF,94C
0485E:  MOVLW  0D
04860:  ADDWF  xFE,W
04862:  MOVWF  FE9
04864:  MOVLW  00
04866:  ADDWFC xFF,W
04868:  MOVWF  FEA
0486A:  MOVFF  FEC,94F
0486E:  MOVF   FED,F
04870:  MOVFF  FEF,94E
04874:  MOVLW  16
04876:  ADDWF  xFE,W
04878:  MOVWF  FE9
0487A:  MOVLW  00
0487C:  ADDWFC xFF,W
0487E:  MOVWF  FEA
04880:  MOVFF  FEF,950
04884:  MOVFF  FEC,951
04888:  MOVFF  FEC,952
0488C:  MOVFF  FEC,953
04890:  MOVLW  1A
04892:  ADDWF  xFE,W
04894:  MOVWF  FE9
04896:  MOVLW  00
04898:  ADDWFC xFF,W
0489A:  MOVWF  FEA
0489C:  MOVFF  FEF,954
048A0:  MOVFF  FEC,955
048A4:  MOVFF  FEC,956
048A8:  MOVFF  FEC,957
048AC:  MOVFF  03,94B
048B0:  MOVFF  01,94A
048B4:  MOVLW  02
048B6:  MOVLB  9
048B8:  MOVWF  x58
048BA:  SETF   x59
048BC:  CLRF   x5B
048BE:  CLRF   x5A
048C0:  MOVLB  0
048C2:  CALL   2F52
....................  
....................    ps->smState = TCP_SYN_SENT; 
048C6:  MOVLB  8
048C8:  MOVFF  8FE,FE9
048CC:  MOVFF  8FF,FEA
048D0:  MOVLW  01
048D2:  MOVWF  FEF
....................    ps->SND_SEQ++; 
048D4:  MOVLW  16
048D6:  ADDWF  xFE,W
048D8:  MOVWF  FE9
048DA:  MOVLW  00
048DC:  ADDWFC xFF,W
048DE:  MOVWF  FEA
048E0:  MOVLW  01
048E2:  ADDWF  FEE,F
048E4:  MOVLW  00
048E6:  ADDWFC FEE,F
048E8:  ADDWFC FEE,F
048EA:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
048EC:  MOVLW  1F
048EE:  ADDWF  xFE,W
048F0:  MOVWF  01
048F2:  MOVLW  00
048F4:  ADDWFC xFF,W
048F6:  MOVWF  03
048F8:  MOVFF  01,901
048FC:  MOVLB  9
048FE:  MOVWF  x02
04900:  MOVLB  0
04902:  CALL   2AFC
04906:  MOVFF  902,FEA
0490A:  MOVFF  901,FE9
0490E:  MOVFF  02,FEC
04912:  MOVF   FED,F
04914:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
04918:  MOVLB  8
0491A:  MOVFF  8FD,01
0491E:  MOVLB  9
04920:  MOVLB  0
04922:  GOTO   53FA (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
04926:  MOVLB  9
04928:  CLRF   x47
0492A:  MOVFF  8F9,946
0492E:  CLRF   x49
04930:  MOVLW  24
04932:  MOVWF  x48
04934:  MOVLB  0
04936:  CALL   0FBE
0493A:  MOVFF  02,8FB
0493E:  MOVFF  01,8FA
04942:  MOVLW  97
04944:  MOVLB  8
04946:  ADDWF  01,W
04948:  MOVWF  FE9
0494A:  MOVLW  03
0494C:  ADDWFC 02,W
0494E:  MOVWF  FEA
04950:  MOVF   FEF,W
04952:  SUBLW  03
04954:  BZ    495A
04956:  MOVLW  00
04958:  BRA    495C
0495A:  MOVLW  01
0495C:  MOVWF  01
0495E:  MOVLB  0
04960:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
05080:  MOVLB  9
05082:  CLRF   x47
05084:  MOVFF  8FB,946
05088:  CLRF   x49
0508A:  MOVLW  24
0508C:  MOVWF  x48
0508E:  MOVLB  0
05090:  CALL   0FBE
05094:  MOVFF  02,03
05098:  MOVF   01,W
0509A:  ADDLW  97
0509C:  MOVWF  01
0509E:  MOVLW  03
050A0:  ADDWFC 03,F
050A2:  MOVFF  01,8FC
050A6:  MOVLB  8
050A8:  MOVFF  03,8FD
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
050AC:  MOVFF  8FC,FE9
050B0:  MOVFF  8FD,FEA
050B4:  MOVF   FEF,W
050B6:  SUBLW  03
050B8:  BZ    50DA
050BA:  MOVFF  8FC,FE9
050BE:  MOVFF  8FD,FEA
050C2:  MOVF   FEF,W
050C4:  SUBLW  02
050C6:  BZ    50DA
....................    { 
....................       CloseSocket(ps); 
050C8:  MOVFF  8FD,947
050CC:  MOVFF  8FC,946
050D0:  MOVLB  0
050D2:  CALL   2B16
....................       return; 
050D6:  BRA    51A0
050D8:  MOVLB  8
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
050DA:  MOVFF  8FB,903
050DE:  MOVLB  0
050E0:  BRA    501E
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
050E2:  MOVLW  01
050E4:  MOVLB  8
050E6:  ADDWF  xFC,W
050E8:  MOVWF  01
050EA:  MOVLW  00
050EC:  ADDWFC xFD,W
050EE:  MOVWF  03
050F0:  MOVFF  01,900
050F4:  MOVLB  9
050F6:  MOVWF  x01
050F8:  MOVLW  0B
050FA:  MOVLB  8
050FC:  ADDWF  xFC,W
050FE:  MOVWF  FE9
05100:  MOVLW  00
05102:  ADDWFC xFD,W
05104:  MOVWF  FEA
05106:  MOVFF  FEC,94D
0510A:  MOVF   FED,F
0510C:  MOVFF  FEF,94C
05110:  MOVLW  0D
05112:  ADDWF  xFC,W
05114:  MOVWF  FE9
05116:  MOVLW  00
05118:  ADDWFC xFD,W
0511A:  MOVWF  FEA
0511C:  MOVFF  FEC,94F
05120:  MOVF   FED,F
05122:  MOVFF  FEF,94E
05126:  MOVLW  16
05128:  ADDWF  xFC,W
0512A:  MOVWF  FE9
0512C:  MOVLW  00
0512E:  ADDWFC xFD,W
05130:  MOVWF  FEA
05132:  MOVFF  FEF,950
05136:  MOVFF  FEC,951
0513A:  MOVFF  FEC,952
0513E:  MOVFF  FEC,953
05142:  MOVLW  1A
05144:  ADDWF  xFC,W
05146:  MOVWF  FE9
05148:  MOVLW  00
0514A:  ADDWFC xFD,W
0514C:  MOVWF  FEA
0514E:  MOVFF  FEF,954
05152:  MOVFF  FEC,955
05156:  MOVFF  FEC,956
0515A:  MOVFF  FEC,957
0515E:  MOVFF  03,94B
05162:  MOVFF  01,94A
05166:  MOVLW  11
05168:  MOVLB  9
0516A:  MOVWF  x58
0516C:  SETF   x59
0516E:  CLRF   x5B
05170:  CLRF   x5A
05172:  MOVLB  0
05174:  CALL   2F52
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
05178:  MOVLW  16
0517A:  MOVLB  8
0517C:  ADDWF  xFC,W
0517E:  MOVWF  FE9
05180:  MOVLW  00
05182:  ADDWFC xFD,W
05184:  MOVWF  FEA
05186:  MOVLW  01
05188:  ADDWF  FEE,F
0518A:  MOVLW  00
0518C:  ADDWFC FEE,F
0518E:  ADDWFC FEE,F
05190:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
05192:  MOVFF  8FC,FE9
05196:  MOVFF  8FD,FEA
0519A:  MOVLW  04
0519C:  MOVWF  FEF
0519E:  MOVLB  0
....................  
....................    return; 
051A0:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
04C9A:  MOVLB  9
04C9C:  CLRF   x47
04C9E:  MOVFF  904,946
04CA2:  CLRF   x49
04CA4:  MOVLW  24
04CA6:  MOVWF  x48
04CA8:  MOVLB  0
04CAA:  CALL   0FBE
04CAE:  MOVFF  02,03
04CB2:  MOVF   01,W
04CB4:  ADDLW  97
04CB6:  MOVWF  01
04CB8:  MOVLW  03
04CBA:  ADDWFC 03,F
04CBC:  MOVFF  01,905
04CC0:  MOVLB  9
04CC2:  MOVFF  03,906
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
04CC6:  MOVLW  0F
04CC8:  ADDWF  x05,W
04CCA:  MOVWF  FE9
04CCC:  MOVLW  00
04CCE:  ADDWFC x06,W
04CD0:  MOVWF  FEA
04CD2:  INCFSZ FEF,W
04CD4:  BRA    4CDC
....................       return FALSE; 
04CD6:  MOVLW  00
04CD8:  MOVWF  01
04CDA:  BRA    4E36
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
04CDC:  MOVLW  23
04CDE:  ADDWF  x05,W
04CE0:  MOVWF  FE9
04CE2:  MOVLW  00
04CE4:  ADDWFC x06,W
04CE6:  MOVWF  FEA
04CE8:  MOVFF  FEF,00
04CEC:  RRCF   00,W
04CEE:  ANDLW  01
04CF0:  BNZ   4CF8
....................       return FALSE; 
04CF2:  MOVLW  00
04CF4:  MOVWF  01
04CF6:  BRA    4E36
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
04CF8:  MOVLW  01
04CFA:  ADDWF  x05,W
04CFC:  MOVWF  01
04CFE:  MOVLW  00
04D00:  ADDWFC x06,W
04D02:  MOVWF  03
04D04:  MOVFF  01,907
04D08:  MOVWF  x08
04D0A:  MOVLW  0B
04D0C:  ADDWF  x05,W
04D0E:  MOVWF  FE9
04D10:  MOVLW  00
04D12:  ADDWFC x06,W
04D14:  MOVWF  FEA
04D16:  MOVFF  FEC,94D
04D1A:  MOVF   FED,F
04D1C:  MOVFF  FEF,94C
04D20:  MOVLW  0D
04D22:  ADDWF  x05,W
04D24:  MOVWF  FE9
04D26:  MOVLW  00
04D28:  ADDWFC x06,W
04D2A:  MOVWF  FEA
04D2C:  MOVFF  FEC,94F
04D30:  MOVF   FED,F
04D32:  MOVFF  FEF,94E
04D36:  MOVLW  16
04D38:  ADDWF  x05,W
04D3A:  MOVWF  FE9
04D3C:  MOVLW  00
04D3E:  ADDWFC x06,W
04D40:  MOVWF  FEA
04D42:  MOVFF  FEF,950
04D46:  MOVFF  FEC,951
04D4A:  MOVFF  FEC,952
04D4E:  MOVFF  FEC,953
04D52:  MOVLW  1A
04D54:  ADDWF  x05,W
04D56:  MOVWF  FE9
04D58:  MOVLW  00
04D5A:  ADDWFC x06,W
04D5C:  MOVWF  FEA
04D5E:  MOVFF  FEF,954
04D62:  MOVFF  FEC,955
04D66:  MOVFF  FEC,956
04D6A:  MOVFF  FEC,957
04D6E:  MOVLW  0F
04D70:  ADDWF  x05,W
04D72:  MOVWF  FE9
04D74:  MOVLW  00
04D76:  ADDWFC x06,W
04D78:  MOVWF  FEA
04D7A:  MOVFF  FEF,959
04D7E:  MOVLW  10
04D80:  ADDWF  x05,W
04D82:  MOVWF  FE9
04D84:  MOVLW  00
04D86:  ADDWFC x06,W
04D88:  MOVWF  FEA
04D8A:  MOVFF  FEC,95B
04D8E:  MOVF   FED,F
04D90:  MOVFF  FEF,95A
04D94:  MOVFF  03,94B
04D98:  MOVFF  01,94A
04D9C:  MOVLW  18
04D9E:  MOVWF  x58
04DA0:  MOVLB  0
04DA2:  CALL   2F52
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
04DA6:  MOVLW  16
04DA8:  MOVLB  9
04DAA:  ADDWF  x05,W
04DAC:  MOVWF  01
04DAE:  MOVLW  00
04DB0:  ADDWFC x06,W
04DB2:  MOVWF  03
04DB4:  MOVFF  01,907
04DB8:  MOVWF  x08
04DBA:  MOVWF  FEA
04DBC:  MOVFF  01,FE9
04DC0:  MOVFF  FEF,909
04DC4:  MOVFF  FEC,90A
04DC8:  MOVFF  FEC,90B
04DCC:  MOVFF  FEC,90C
04DD0:  MOVLW  10
04DD2:  ADDWF  x05,W
04DD4:  MOVWF  FE9
04DD6:  MOVLW  00
04DD8:  ADDWFC x06,W
04DDA:  MOVWF  FEA
04DDC:  MOVFF  FEC,03
04DE0:  MOVF   FED,F
04DE2:  MOVFF  FEF,00
04DE6:  MOVFF  03,01
04DEA:  CLRF   02
04DEC:  CLRF   03
04DEE:  MOVF   x09,W
04DF0:  ADDWF  00,F
04DF2:  MOVF   x0A,W
04DF4:  ADDWFC 01,F
04DF6:  MOVF   x0B,W
04DF8:  ADDWFC 02,F
04DFA:  MOVF   x0C,W
04DFC:  ADDWFC 03,F
04DFE:  MOVFF  908,FEA
04E02:  MOVFF  907,FE9
04E06:  MOVFF  00,FEF
04E0A:  MOVFF  01,FEC
04E0E:  MOVFF  02,FEC
04E12:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
04E16:  MOVLW  23
04E18:  ADDWF  x05,W
04E1A:  MOVWF  FE9
04E1C:  MOVLW  00
04E1E:  ADDWFC x06,W
04E20:  MOVWF  FEA
04E22:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
04E24:  MOVLW  23
04E26:  ADDWF  x05,W
04E28:  MOVWF  FE9
04E2A:  MOVLW  00
04E2C:  ADDWFC x06,W
04E2E:  MOVWF  FEA
04E30:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
04E32:  MOVLW  01
04E34:  MOVWF  01
04E36:  MOVLB  0
04E38:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
04A8E:  MOVLB  9
04A90:  CLRF   x47
04A92:  MOVFF  909,946
04A96:  CLRF   x49
04A98:  MOVLW  24
04A9A:  MOVWF  x48
04A9C:  MOVLB  0
04A9E:  CALL   0FBE
04AA2:  MOVFF  01,90A
04AA6:  MOVLW  14
04AA8:  MOVLB  9
04AAA:  ADDWF  01,W
04AAC:  MOVWF  01
04AAE:  MOVLW  00
04AB0:  ADDWFC 02,W
04AB2:  MOVWF  03
04AB4:  MOVF   01,W
04AB6:  ADDLW  97
04AB8:  MOVWF  FE9
04ABA:  MOVLW  03
04ABC:  ADDWFC 03,W
04ABE:  MOVWF  FEA
04AC0:  MOVFF  FEC,90B
04AC4:  MOVF   FED,F
04AC6:  MOVFF  FEF,90A
04ACA:  MOVF   x0A,F
04ACC:  BNZ   4AD8
04ACE:  MOVF   x0B,F
04AD0:  BNZ   4AD8
....................       return FALSE; 
04AD2:  MOVLW  00
04AD4:  MOVWF  01
04AD6:  BRA    4B58
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04AD8:  CLRF   x47
04ADA:  MOVFF  909,946
04ADE:  CLRF   x49
04AE0:  MOVLW  24
04AE2:  MOVWF  x48
04AE4:  MOVLB  0
04AE6:  CALL   0FBE
04AEA:  MOVFF  02,90B
04AEE:  MOVFF  01,90A
04AF2:  MOVLW  0F
04AF4:  MOVLB  9
04AF6:  ADDWF  01,W
04AF8:  MOVWF  01
04AFA:  MOVLW  00
04AFC:  ADDWFC 02,W
04AFE:  MOVWF  03
04B00:  MOVF   01,W
04B02:  ADDLW  97
04B04:  MOVWF  FE9
04B06:  MOVLW  03
04B08:  ADDWFC 03,W
04B0A:  MOVWF  FEA
04B0C:  INCFSZ FEF,W
04B0E:  BRA    4B20
....................       return IPIsTxReady(FALSE); 
04B10:  CLRF   x82
04B12:  MOVLB  0
04B14:  CALL   2C14
04B18:  MOVF   01,W
04B1A:  MOVLB  9
04B1C:  BRA    4B58
04B1E:  BRA    4B58
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
04B20:  CLRF   x47
04B22:  MOVFF  909,946
04B26:  CLRF   x49
04B28:  MOVLW  24
04B2A:  MOVWF  x48
04B2C:  MOVLB  0
04B2E:  CALL   0FBE
04B32:  MOVFF  02,90B
04B36:  MOVFF  01,90A
04B3A:  MOVLW  23
04B3C:  MOVLB  9
04B3E:  ADDWF  x0A,F
04B40:  MOVLW  00
04B42:  ADDWFC x0B,F
04B44:  MOVLW  97
04B46:  ADDWF  x0A,W
04B48:  MOVWF  FE9
04B4A:  MOVLW  03
04B4C:  ADDWFC x0B,W
04B4E:  MOVWF  FEA
04B50:  MOVLW  00
04B52:  BTFSC  FEF.1
04B54:  MOVLW  01
04B56:  MOVWF  01
04B58:  MOVLB  0
04B5A:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
04B5C:  MOVFF  904,909
04B60:  RCALL  4A8E
04B62:  MOVF   01,F
04B64:  BNZ   4B6E
....................       return(0); 
04B66:  MOVLW  00
04B68:  MOVWF  01
04B6A:  MOVWF  02
04B6C:  BRA    4C94
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
04B6E:  MOVLB  9
04B70:  CLRF   x47
04B72:  MOVFF  904,946
04B76:  CLRF   x49
04B78:  MOVLW  24
04B7A:  MOVWF  x48
04B7C:  MOVLB  0
04B7E:  CALL   0FBE
04B82:  MOVFF  02,90A
04B86:  MOVFF  01,909
04B8A:  MOVLW  0F
04B8C:  MOVLB  9
04B8E:  ADDWF  01,W
04B90:  MOVWF  01
04B92:  MOVLW  00
04B94:  ADDWFC 02,W
04B96:  MOVWF  03
04B98:  MOVF   01,W
04B9A:  ADDLW  97
04B9C:  MOVWF  FE9
04B9E:  MOVLW  03
04BA0:  ADDWFC 03,W
04BA2:  MOVWF  FEA
04BA4:  INCFSZ FEF,W
04BA6:  BRA    4BAE
....................       txCount = 0; 
04BA8:  CLRF   x06
04BAA:  CLRF   x05
04BAC:  BRA    4BE8
....................    else 
....................       txCount = TCB[s].TxCount; 
04BAE:  CLRF   x47
04BB0:  MOVFF  904,946
04BB4:  CLRF   x49
04BB6:  MOVLW  24
04BB8:  MOVWF  x48
04BBA:  MOVLB  0
04BBC:  CALL   0FBE
04BC0:  MOVFF  01,909
04BC4:  MOVLW  10
04BC6:  MOVLB  9
04BC8:  ADDWF  01,W
04BCA:  MOVWF  01
04BCC:  MOVLW  00
04BCE:  ADDWFC 02,W
04BD0:  MOVWF  03
04BD2:  MOVF   01,W
04BD4:  ADDLW  97
04BD6:  MOVWF  FE9
04BD8:  MOVLW  03
04BDA:  ADDWFC 03,W
04BDC:  MOVWF  FEA
04BDE:  MOVFF  FEC,906
04BE2:  MOVF   FED,F
04BE4:  MOVFF  FEF,905
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
04BE8:  MOVLW  CA
04BEA:  BSF    FD8.0
04BEC:  SUBFWB x05,W
04BEE:  MOVWF  x07
04BF0:  MOVLW  03
04BF2:  SUBFWB x06,W
04BF4:  MOVWF  x08
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
04BF6:  CLRF   x47
04BF8:  MOVFF  904,946
04BFC:  CLRF   x49
04BFE:  MOVLW  24
04C00:  MOVWF  x48
04C02:  MOVLB  0
04C04:  CALL   0FBE
04C08:  MOVFF  02,90A
04C0C:  MOVFF  01,909
04C10:  MOVLW  14
04C12:  MOVLB  9
04C14:  ADDWF  01,W
04C16:  MOVWF  01
04C18:  MOVLW  00
04C1A:  ADDWFC 02,W
04C1C:  MOVWF  03
04C1E:  MOVF   01,W
04C20:  ADDLW  97
04C22:  MOVWF  FE9
04C24:  MOVLW  03
04C26:  ADDWFC 03,W
04C28:  MOVWF  FEA
04C2A:  MOVFF  FEC,03
04C2E:  MOVF   FED,F
04C30:  MOVFF  FEF,01
04C34:  MOVF   03,W
04C36:  SUBWF  x08,W
04C38:  BNC   4C80
04C3A:  BNZ   4C42
04C3C:  MOVF   x07,W
04C3E:  SUBWF  01,W
04C40:  BC    4C80
04C42:  CLRF   x47
04C44:  MOVFF  904,946
04C48:  CLRF   x49
04C4A:  MOVLW  24
04C4C:  MOVWF  x48
04C4E:  MOVLB  0
04C50:  CALL   0FBE
04C54:  MOVFF  02,90A
04C58:  MOVFF  01,909
04C5C:  MOVLW  14
04C5E:  MOVLB  9
04C60:  ADDWF  01,W
04C62:  MOVWF  01
04C64:  MOVLW  00
04C66:  ADDWFC 02,W
04C68:  MOVWF  03
04C6A:  MOVF   01,W
04C6C:  ADDLW  97
04C6E:  MOVWF  FE9
04C70:  MOVLW  03
04C72:  ADDWFC 03,W
04C74:  MOVWF  FEA
04C76:  MOVFF  FEC,03
04C7A:  MOVF   FED,F
04C7C:  MOVF   FEF,W
04C7E:  BRA    4C86
04C80:  MOVFF  908,03
04C84:  MOVF   x07,W
04C86:  MOVWF  x07
04C88:  MOVFF  03,908
....................  
....................    return(txAvail); 
04C8C:  MOVFF  907,01
04C90:  MOVFF  908,02
04C94:  MOVLB  0
04C96:  GOTO   4F14 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
04E3A:  MOVLB  9
04E3C:  CLRF   x47
04E3E:  MOVFF  8FB,946
04E42:  CLRF   x49
04E44:  MOVLW  24
04E46:  MOVWF  x48
04E48:  MOVLB  0
04E4A:  CALL   0FBE
04E4E:  MOVFF  02,03
04E52:  MOVF   01,W
04E54:  ADDLW  97
04E56:  MOVWF  01
04E58:  MOVLW  03
04E5A:  ADDWFC 03,F
04E5C:  MOVFF  01,900
04E60:  MOVLB  9
04E62:  MOVFF  03,901
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
04E66:  MOVLW  14
04E68:  ADDWF  x00,W
04E6A:  MOVWF  FE9
04E6C:  MOVLW  00
04E6E:  ADDWFC x01,W
04E70:  MOVWF  FEA
04E72:  MOVFF  FEC,905
04E76:  MOVF   FED,F
04E78:  MOVFF  FEF,904
04E7C:  MOVF   x04,F
04E7E:  BNZ   4E8C
04E80:  MOVF   x05,F
04E82:  BNZ   4E8C
....................       return 0; 
04E84:  MOVLW  00
04E86:  MOVWF  01
04E88:  MOVWF  02
04E8A:  BRA    5018
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
04E8C:  MOVLW  0F
04E8E:  ADDWF  x00,W
04E90:  MOVWF  FE9
04E92:  MOVLW  00
04E94:  ADDWFC x01,W
04E96:  MOVWF  FEA
04E98:  INCFSZ FEF,W
04E9A:  BRA    4F0C
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
04E9C:  MOVLW  0F
04E9E:  ADDWF  x00,W
04EA0:  MOVWF  01
04EA2:  MOVLW  00
04EA4:  ADDWFC x01,W
04EA6:  MOVWF  03
04EA8:  MOVFF  01,904
04EAC:  MOVWF  x05
04EAE:  CLRF   x82
04EB0:  MOVLB  0
04EB2:  CALL   1AD2
04EB6:  MOVFF  905,FEA
04EBA:  MOVFF  904,FE9
04EBE:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
04EC2:  MOVLW  0F
04EC4:  MOVLB  9
04EC6:  ADDWF  x00,W
04EC8:  MOVWF  FE9
04ECA:  MOVLW  00
04ECC:  ADDWFC x01,W
04ECE:  MOVWF  FEA
04ED0:  INCFSZ FEF,W
04ED2:  BRA    4EDC
....................          return 0; 
04ED4:  MOVLW  00
04ED6:  MOVWF  01
04ED8:  MOVWF  02
04EDA:  BRA    5018
....................  
....................       ps->TxCount = 0; 
04EDC:  MOVLW  10
04EDE:  ADDWF  x00,W
04EE0:  MOVWF  FE9
04EE2:  MOVLW  00
04EE4:  ADDWFC x01,W
04EE6:  MOVWF  FEA
04EE8:  CLRF   FEC
04EEA:  MOVF   FED,F
04EEC:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
04EEE:  MOVLW  0F
04EF0:  ADDWF  x00,W
04EF2:  MOVWF  FE9
04EF4:  MOVLW  00
04EF6:  ADDWFC x01,W
04EF8:  MOVWF  FEA
04EFA:  MOVFF  FEF,99B
04EFE:  CLRF   x9D
04F00:  MOVLW  28
04F02:  MOVWF  x9C
04F04:  MOVLB  0
04F06:  CALL   1AFA
04F0A:  MOVLB  9
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
04F0C:  MOVFF  8FB,904
04F10:  MOVLB  0
04F12:  BRA    4B5C
04F14:  MOVFF  02,903
04F18:  MOVFF  01,902
....................     
....................    len = n < len ? n : len; 
04F1C:  MOVLB  9
04F1E:  MOVF   x03,W
04F20:  MOVLB  8
04F22:  SUBWF  xFF,W
04F24:  BNC   4F42
04F26:  BNZ   4F36
04F28:  MOVF   xFE,W
04F2A:  MOVLB  9
04F2C:  SUBWF  x02,W
04F2E:  BTFSS  FD8.0
04F30:  BRA    4F36
04F32:  MOVLB  8
04F34:  BRA    4F42
04F36:  MOVFF  903,03
04F3A:  MOVLB  9
04F3C:  MOVF   x02,W
04F3E:  BRA    4F48
04F40:  MOVLB  8
04F42:  MOVFF  8FF,03
04F46:  MOVF   xFE,W
04F48:  MOVLB  8
04F4A:  MOVWF  xFE
04F4C:  MOVFF  03,8FF
....................    n = len; 
04F50:  MOVFF  8FF,903
04F54:  MOVFF  8FE,902
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
04F58:  MOVLW  23
04F5A:  MOVLB  9
04F5C:  ADDWF  x00,W
04F5E:  MOVWF  FE9
04F60:  MOVLW  00
04F62:  ADDWFC x01,W
04F64:  MOVWF  FEA
04F66:  BSF    FEF.4
....................  
....................    while (n--) 
04F68:  MOVFF  903,03
04F6C:  MOVF   x02,W
04F6E:  BTFSC  FD8.2
04F70:  DECF   x03,F
04F72:  DECF   x02,F
04F74:  IORWF  03,W
04F76:  BZ    4FDC
....................    { 
....................       MACPut(*ptr++); 
04F78:  MOVLB  8
04F7A:  MOVFF  8FD,03
04F7E:  MOVF   xFC,W
04F80:  INCF   xFC,F
04F82:  BTFSC  FD8.2
04F84:  INCF   xFD,F
04F86:  MOVWF  FE9
04F88:  MOVFF  03,FEA
04F8C:  MOVFF  FEF,9A5
04F90:  MOVLB  0
04F92:  CALL   1B98
....................       ps->RemoteWindow -= 1; 
04F96:  MOVLW  14
04F98:  MOVLB  9
04F9A:  ADDWF  x00,W
04F9C:  MOVWF  FE9
04F9E:  MOVLW  00
04FA0:  ADDWFC x01,W
04FA2:  MOVWF  FEA
04FA4:  MOVLW  01
04FA6:  SUBWF  FEF,W
04FA8:  MOVWF  00
04FAA:  MOVLW  00
04FAC:  SUBWFB FEC,W
04FAE:  MOVWF  03
04FB0:  MOVF   00,W
04FB2:  MOVF   FED,F
04FB4:  MOVWF  FEF
04FB6:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
04FBA:  MOVLW  10
04FBC:  ADDWF  x00,W
04FBE:  MOVWF  FE9
04FC0:  MOVLW  00
04FC2:  ADDWFC x01,W
04FC4:  MOVWF  FEA
04FC6:  MOVLW  01
04FC8:  ADDWF  FEF,W
04FCA:  MOVWF  01
04FCC:  MOVLW  00
04FCE:  ADDWFC FEC,W
04FD0:  MOVWF  03
04FD2:  MOVF   FED,F
04FD4:  MOVFF  01,FEF
04FD8:  MOVWF  FEC
04FDA:  BRA    4F68
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
04FDC:  MOVLW  10
04FDE:  ADDWF  x00,W
04FE0:  MOVWF  FE9
04FE2:  MOVLW  00
04FE4:  ADDWFC x01,W
04FE6:  MOVWF  FEA
04FE8:  MOVFF  FEC,905
04FEC:  MOVF   FED,F
04FEE:  MOVFF  FEF,904
04FF2:  MOVF   x05,W
04FF4:  SUBLW  02
04FF6:  BC    500C
04FF8:  XORLW  FF
04FFA:  BNZ   5002
04FFC:  MOVF   x04,W
04FFE:  SUBLW  C9
05000:  BC    500C
....................       TCPFlush(s); 
05002:  MOVFF  8FB,904
05006:  MOVLB  0
05008:  RCALL  4C9A
0500A:  MOVLB  9
....................  
....................    return(len); 
0500C:  MOVLB  8
0500E:  MOVFF  8FE,01
05012:  MOVFF  8FF,02
05016:  MOVLB  9
05018:  MOVLB  0
0501A:  GOTO   5266 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
0501E:  MOVLB  9
05020:  CLRF   x47
05022:  MOVFF  903,946
05026:  CLRF   x49
05028:  MOVLW  24
0502A:  MOVWF  x48
0502C:  MOVLB  0
0502E:  CALL   0FBE
05032:  MOVFF  02,03
05036:  MOVF   01,W
05038:  ADDLW  97
0503A:  MOVWF  01
0503C:  MOVLW  03
0503E:  ADDWFC 03,F
05040:  MOVFF  01,904
05044:  MOVLB  9
05046:  MOVFF  03,905
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
0504A:  MOVLW  23
0504C:  ADDWF  x04,W
0504E:  MOVWF  FE9
05050:  MOVLW  00
05052:  ADDWFC x05,W
05054:  MOVWF  FEA
05056:  BTFSC  FEF.3
05058:  BRA    5060
....................         return FALSE; 
0505A:  MOVLW  00
0505C:  MOVWF  01
0505E:  BRA    507A
....................  
....................     MACDiscardRx(); 
05060:  MOVLB  0
05062:  CALL   16E0
....................     ps->Flags.bIsGetReady = FALSE; 
05066:  MOVLW  23
05068:  MOVLB  9
0506A:  ADDWF  x04,W
0506C:  MOVWF  FE9
0506E:  MOVLW  00
05070:  ADDWFC x05,W
05072:  MOVWF  FEA
05074:  BCF    FEF.3
....................  
....................     return TRUE; 
05076:  MOVLW  01
05078:  MOVWF  01
0507A:  MOVLB  0
0507C:  GOTO   50E2 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
049A2:  MOVLB  9
049A4:  CLRF   x47
049A6:  MOVFF  8FB,946
049AA:  CLRF   x49
049AC:  MOVLW  24
049AE:  MOVWF  x48
049B0:  MOVLB  0
049B2:  CALL   0FBE
049B6:  MOVFF  02,03
049BA:  MOVF   01,W
049BC:  ADDLW  97
049BE:  MOVWF  01
049C0:  MOVLW  03
049C2:  ADDWFC 03,F
049C4:  MOVFF  01,8FE
049C8:  MOVLB  8
049CA:  MOVFF  03,8FF
....................  
....................     if ( ps->Flags.bIsGetReady ) 
049CE:  MOVLW  23
049D0:  ADDWF  xFE,W
049D2:  MOVWF  FE9
049D4:  MOVLW  00
049D6:  ADDWFC xFF,W
049D8:  MOVWF  FEA
049DA:  BTFSS  FEF.3
049DC:  BRA    4A84
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
049DE:  MOVLW  23
049E0:  ADDWF  xFE,W
049E2:  MOVWF  FE9
049E4:  MOVLW  00
049E6:  ADDWFC xFF,W
049E8:  MOVWF  FEA
049EA:  BTFSS  FEF.2
049EC:  BRA    4A0C
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
049EE:  MOVLB  9
049F0:  CLRF   x2A
049F2:  MOVLW  14
049F4:  MOVWF  x29
049F6:  MOVLB  0
049F8:  CALL   26DE
....................  
....................             ps->Flags.bFirstRead = FALSE; 
049FC:  MOVLW  23
049FE:  MOVLB  8
04A00:  ADDWF  xFE,W
04A02:  MOVWF  FE9
04A04:  MOVLW  00
04A06:  ADDWFC xFF,W
04A08:  MOVWF  FEA
04A0A:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
04A0C:  MOVLW  12
04A0E:  ADDWF  xFE,W
04A10:  MOVWF  FE9
04A12:  MOVLW  00
04A14:  ADDWFC xFF,W
04A16:  MOVWF  FEA
04A18:  MOVFF  FEC,901
04A1C:  MOVF   FED,F
04A1E:  MOVFF  FEF,900
04A22:  MOVLB  9
04A24:  MOVF   x00,F
04A26:  BNZ   4A4A
04A28:  MOVF   x01,F
04A2A:  BNZ   4A4A
....................         { 
....................             MACDiscardRx(); 
04A2C:  MOVLB  0
04A2E:  CALL   16E0
....................             ps->Flags.bIsGetReady = FALSE; 
04A32:  MOVLW  23
04A34:  MOVLB  8
04A36:  ADDWF  xFE,W
04A38:  MOVWF  FE9
04A3A:  MOVLW  00
04A3C:  ADDWFC xFF,W
04A3E:  MOVWF  FEA
04A40:  BCF    FEF.3
....................             return FALSE; 
04A42:  MOVLW  00
04A44:  MOVWF  01
04A46:  BRA    4A88
04A48:  MOVLB  9
....................         } 
....................  
....................          ps->RxCount--; 
04A4A:  MOVLW  12
04A4C:  MOVLB  8
04A4E:  ADDWF  xFE,W
04A50:  MOVWF  FE9
04A52:  MOVLW  00
04A54:  ADDWFC xFF,W
04A56:  MOVWF  FEA
04A58:  MOVLW  FF
04A5A:  ADDWF  FEF,F
04A5C:  BC    4A62
04A5E:  MOVF   FEE,F
04A60:  DECF   FED,F
....................          *data = MACGet(); 
04A62:  MOVFF  8FD,901
04A66:  MOVFF  8FC,900
04A6A:  MOVLB  0
04A6C:  CALL   255A
04A70:  MOVFF  901,FEA
04A74:  MOVFF  900,FE9
04A78:  MOVFF  01,FEF
....................         return TRUE; 
04A7C:  MOVLW  01
04A7E:  MOVWF  01
04A80:  MOVLB  8
04A82:  BRA    4A88
....................     } 
....................     return FALSE; 
04A84:  MOVLW  00
04A86:  MOVWF  01
04A88:  MOVLB  0
04A8A:  GOTO   51CA (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
04962:  MOVLB  9
04964:  CLRF   x47
04966:  MOVFF  8FB,946
0496A:  CLRF   x49
0496C:  MOVLW  24
0496E:  MOVWF  x48
04970:  MOVLB  0
04972:  CALL   0FBE
04976:  MOVFF  02,8FD
0497A:  MOVFF  01,8FC
0497E:  MOVLW  23
04980:  MOVLB  8
04982:  ADDWF  xFC,F
04984:  MOVLW  00
04986:  ADDWFC xFD,F
04988:  MOVLW  97
0498A:  ADDWF  xFC,W
0498C:  MOVWF  FE9
0498E:  MOVLW  03
04990:  ADDWFC xFD,W
04992:  MOVWF  FEA
04994:  MOVLW  00
04996:  BTFSC  FEF.3
04998:  MOVLW  01
0499A:  MOVWF  01
0499C:  MOVLB  0
0499E:  GOTO   51AA (RETURN)
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
03FCC:  MOVLB  9
03FCE:  CLRF   x07
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
03FD0:  MOVLB  8
03FD2:  CLRF   xFC
03FD4:  MOVF   xFC,W
03FD6:  SUBLW  22
03FD8:  BTFSS  FD8.0
03FDA:  BRA    4446
....................    { 
....................       ps = &TCB[s]; 
03FDC:  MOVLB  9
03FDE:  CLRF   x47
03FE0:  MOVFF  8FC,946
03FE4:  CLRF   x49
03FE6:  MOVLW  24
03FE8:  MOVWF  x48
03FEA:  MOVLB  0
03FEC:  CALL   0FBE
03FF0:  MOVFF  02,03
03FF4:  MOVF   01,W
03FF6:  ADDLW  97
03FF8:  MOVWF  01
03FFA:  MOVLW  03
03FFC:  ADDWFC 03,F
03FFE:  MOVFF  01,901
04002:  MOVLB  9
04004:  MOVFF  03,902
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
04008:  MOVLW  23
0400A:  ADDWF  x01,W
0400C:  MOVWF  FE9
0400E:  MOVLW  00
04010:  ADDWFC x02,W
04012:  MOVWF  FEA
04014:  BTFSC  FEF.3
04016:  BRA    4028
04018:  MOVLW  23
0401A:  ADDWF  x01,W
0401C:  MOVWF  FE9
0401E:  MOVLW  00
04020:  ADDWFC x02,W
04022:  MOVWF  FEA
04024:  BTFSS  FEF.4
04026:  BRA    402A
....................          continue; 
04028:  BRA    4440
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
0402A:  MOVFF  901,FE9
0402E:  MOVFF  902,FEA
04032:  MOVF   FEF,W
04034:  SUBLW  0A
04036:  BZ    4058
04038:  MOVFF  901,FE9
0403C:  MOVFF  902,FEA
04040:  MOVF   FEF,F
04042:  BNZ   405A
04044:  MOVLW  23
04046:  ADDWF  x01,W
04048:  MOVWF  FE9
0404A:  MOVLW  00
0404C:  ADDWFC x02,W
0404E:  MOVWF  FEA
04050:  MOVF   FEF,W
04052:  ANDLW  01
04054:  SUBLW  01
04056:  BNZ   405A
....................          continue; 
04058:  BRA    4440
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
0405A:  MOVFF  901,FE9
0405E:  MOVFF  902,FEA
04062:  MOVF   FEF,W
04064:  SUBLW  03
04066:  BNZ   407E
04068:  MOVLW  23
0406A:  ADDWF  x01,W
0406C:  MOVWF  FE9
0406E:  MOVLW  00
04070:  ADDWFC x02,W
04072:  MOVWF  FEA
04074:  MOVF   FEF,W
04076:  ANDLW  01
04078:  SUBLW  01
0407A:  BNZ   407E
....................          continue; 
0407C:  BRA    4440
....................  
....................  
....................       tick = TickGet(); 
0407E:  MOVLB  0
04080:  CALL   2AFC
04084:  MOVFF  02,900
04088:  MOVFF  01,8FF
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
0408C:  MOVLW  1F
0408E:  MOVLB  9
04090:  ADDWF  x01,W
04092:  MOVWF  FE9
04094:  MOVLW  00
04096:  ADDWFC x02,W
04098:  MOVWF  FEA
0409A:  MOVFF  FEC,03
0409E:  MOVF   FED,F
040A0:  MOVFF  FEF,01
040A4:  MOVF   x00,W
040A6:  SUBWF  03,W
040A8:  BNC   40BC
040AA:  BNZ   40C0
040AC:  MOVF   01,W
040AE:  MOVLB  8
040B0:  SUBWF  xFF,W
040B2:  BTFSC  FD8.0
040B4:  BRA    40BA
040B6:  MOVLB  9
040B8:  BRA    40C0
040BA:  MOVLB  9
040BC:  MOVLW  00
040BE:  BRA    40C2
040C0:  MOVLW  01
040C2:  CLRF   03
040C4:  IORWF  03,W
040C6:  BZ    4102
040C8:  MOVLW  1F
040CA:  ADDWF  x01,W
040CC:  MOVWF  FE9
040CE:  MOVLW  00
040D0:  ADDWFC x02,W
040D2:  MOVWF  FEA
040D4:  MOVFF  FEC,03
040D8:  MOVF   FED,F
040DA:  MOVF   FEF,W
040DC:  SUBLW  FF
040DE:  MOVWF  x08
040E0:  MOVLW  FF
040E2:  SUBFWB 03,W
040E4:  MOVWF  x09
040E6:  MOVLB  8
040E8:  MOVF   xFF,W
040EA:  MOVLB  9
040EC:  ADDWF  x08,F
040EE:  MOVF   x00,W
040F0:  ADDWFC x09,F
040F2:  MOVLW  01
040F4:  ADDWF  x08,W
040F6:  MOVWF  01
040F8:  MOVLW  00
040FA:  ADDWFC x09,W
040FC:  MOVWF  03
040FE:  MOVF   01,W
04100:  BRA    4126
04102:  MOVLW  1F
04104:  ADDWF  x01,W
04106:  MOVWF  FE9
04108:  MOVLW  00
0410A:  ADDWFC x02,W
0410C:  MOVWF  FEA
0410E:  MOVFF  FEC,03
04112:  MOVF   FED,F
04114:  MOVF   FEF,W
04116:  MOVLB  8
04118:  SUBWF  xFF,W
0411A:  MOVWF  00
0411C:  MOVF   03,W
0411E:  MOVLB  9
04120:  SUBWFB x00,W
04122:  MOVWF  03
04124:  MOVF   00,W
04126:  MOVLB  8
04128:  MOVWF  xFD
0412A:  MOVFF  03,8FE
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
0412E:  MOVLW  21
04130:  MOVLB  9
04132:  ADDWF  x01,W
04134:  MOVWF  FE9
04136:  MOVLW  00
04138:  ADDWFC x02,W
0413A:  MOVWF  FEA
0413C:  MOVFF  FEC,03
04140:  MOVF   FED,F
04142:  MOVFF  FEF,01
04146:  MOVLB  8
04148:  MOVF   xFE,W
0414A:  SUBWF  03,W
0414C:  BNC   415C
0414E:  BNZ   4156
04150:  MOVF   xFD,W
04152:  SUBWF  01,W
04154:  BNC   415C
....................          continue; 
04156:  MOVLB  9
04158:  BRA    4440
0415A:  MOVLB  8
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
0415C:  MOVLW  01
0415E:  MOVLB  9
04160:  MOVWF  x82
04162:  MOVLB  0
04164:  CALL   2C14
04168:  MOVF   01,F
0416A:  BNZ   416E
....................          return; 
0416C:  BRA    4446
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
0416E:  MOVLW  1F
04170:  MOVLB  9
04172:  ADDWF  x01,W
04174:  MOVWF  01
04176:  MOVLW  00
04178:  ADDWFC x02,W
0417A:  MOVWF  03
0417C:  MOVFF  01,908
04180:  MOVWF  x09
04182:  MOVLB  0
04184:  CALL   2AFC
04188:  MOVFF  909,FEA
0418C:  MOVFF  908,FE9
04190:  MOVFF  02,FEC
04194:  MOVF   FED,F
04196:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
0419A:  MOVLW  21
0419C:  MOVLB  9
0419E:  ADDWF  x01,W
041A0:  MOVWF  FE9
041A2:  MOVLW  00
041A4:  ADDWFC x02,W
041A6:  MOVWF  FEA
041A8:  BCF    FD8.0
041AA:  RLCF   FEF,W
041AC:  MOVWF  02
041AE:  RLCF   FEC,W
041B0:  MOVWF  03
041B2:  MOVF   02,W
041B4:  MOVF   FED,F
041B6:  MOVWF  FEF
041B8:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
041BC:  MOVLW  1E
041BE:  ADDWF  x01,W
041C0:  MOVWF  FE9
041C2:  MOVLW  00
041C4:  ADDWFC x02,W
041C6:  MOVWF  FEA
041C8:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
041CA:  MOVFF  901,FE9
041CE:  MOVFF  902,FEA
041D2:  MOVLW  01
041D4:  SUBWF  FEF,W
041D6:  ADDLW  F7
041D8:  BTFSC  FD8.0
041DA:  BRA    4362
041DC:  ADDLW  09
041DE:  MOVLB  0
041E0:  GOTO   444C
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
041E4:  MOVLW  02
041E6:  MOVLB  9
041E8:  MOVWF  x07
....................          break; 
041EA:  BRA    4362
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
041EC:  MOVLW  1E
041EE:  MOVLB  9
041F0:  ADDWF  x01,W
041F2:  MOVWF  FE9
041F4:  MOVLW  00
041F6:  ADDWFC x02,W
041F8:  MOVWF  FEA
041FA:  MOVF   FEF,W
041FC:  SUBLW  03
041FE:  BNC   4206
....................          { 
....................             flags = SYN | ACK; 
04200:  MOVLW  12
04202:  MOVWF  x07
....................          } 
04204:  BRA    4232
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
04206:  MOVLW  23
04208:  ADDWF  x01,W
0420A:  MOVWF  FE9
0420C:  MOVLW  00
0420E:  ADDWFC x02,W
04210:  MOVWF  FEA
04212:  BTFSS  FEF.0
04214:  BRA    4222
....................             { 
....................                ps->smState = TCP_LISTEN; 
04216:  MOVFF  901,FE9
0421A:  MOVFF  902,FEA
0421E:  CLRF   FEF
....................             } 
04220:  BRA    4232
....................             else 
....................             { 
....................                flags = SYN; 
04222:  MOVLW  02
04224:  MOVWF  x07
....................                ps->smState = TCP_SYN_SENT; 
04226:  MOVFF  901,FE9
0422A:  MOVFF  902,FEA
0422E:  MOVLW  01
04230:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
04232:  BRA    4362
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04234:  MOVLW  1E
04236:  MOVLB  9
04238:  ADDWF  x01,W
0423A:  MOVWF  FE9
0423C:  MOVLW  00
0423E:  ADDWFC x02,W
04240:  MOVWF  FEA
04242:  MOVF   FEF,W
04244:  SUBLW  03
04246:  BNC   4286
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04248:  MOVLW  0F
0424A:  ADDWF  x01,W
0424C:  MOVWF  FE9
0424E:  MOVLW  00
04250:  ADDWFC x02,W
04252:  MOVWF  FEA
04254:  INCFSZ FEF,W
04256:  BRA    425A
04258:  BRA    427C
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
0425A:  MOVLW  0F
0425C:  ADDWF  x01,W
0425E:  MOVWF  FE9
04260:  MOVLW  00
04262:  ADDWFC x02,W
04264:  MOVWF  FEA
04266:  MOVFF  FEF,99B
0426A:  CLRF   x9D
0426C:  CLRF   x9C
0426E:  MOVLB  0
04270:  CALL   1AFA
....................                MACFlush(); 
04274:  CALL   1CCE
....................             } 
04278:  BRA    4282
0427A:  MOVLB  9
....................             else 
....................                flags = ACK; 
0427C:  MOVLW  10
0427E:  MOVWF  x07
04280:  MOVLB  0
....................          } 
04282:  BRA    42D0
04284:  MOVLB  9
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
04286:  MOVLW  0F
04288:  ADDWF  x01,W
0428A:  MOVWF  FE9
0428C:  MOVLW  00
0428E:  ADDWFC x02,W
04290:  MOVWF  FEA
04292:  INCFSZ FEF,W
04294:  BRA    4298
04296:  BRA    42BE
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
04298:  MOVLW  0F
0429A:  ADDWF  x01,W
0429C:  MOVWF  FE9
0429E:  MOVLW  00
042A0:  ADDWFC x02,W
042A2:  MOVWF  FEA
042A4:  MOVFF  FEF,949
042A8:  MOVLB  0
042AA:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
042AE:  MOVLW  0F
042B0:  MOVLB  9
042B2:  ADDWF  x01,W
042B4:  MOVWF  FE9
042B6:  MOVLW  00
042B8:  ADDWFC x02,W
042BA:  MOVWF  FEA
042BC:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
042BE:  MOVLW  11
042C0:  MOVWF  x07
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
042C2:  MOVFF  901,FE9
042C6:  MOVFF  902,FEA
042CA:  MOVLW  04
042CC:  MOVWF  FEF
042CE:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
042D0:  MOVLB  9
042D2:  BRA    4362
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
042D4:  MOVLW  1E
042D6:  MOVLB  9
042D8:  ADDWF  x01,W
042DA:  MOVWF  FE9
042DC:  MOVLW  00
042DE:  ADDWFC x02,W
042E0:  MOVWF  FEA
042E2:  MOVF   FEF,W
042E4:  SUBLW  03
042E6:  BNC   42EE
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
042E8:  MOVLW  01
042EA:  MOVWF  x07
....................          } 
042EC:  BRA    42FE
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
042EE:  MOVFF  902,947
042F2:  MOVFF  901,946
042F6:  MOVLB  0
042F8:  CALL   2B16
042FC:  MOVLB  9
....................          } 
....................          break; 
042FE:  BRA    4362
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
04300:  MOVFF  902,947
04304:  MOVFF  901,946
04308:  CALL   2B16
....................          break; 
0430C:  MOVLB  9
0430E:  BRA    4362
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
04310:  MOVFF  902,947
04314:  MOVFF  901,946
04318:  CALL   2B16
....................          break; 
0431C:  MOVLB  9
0431E:  BRA    4362
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
04320:  MOVLW  01
04322:  MOVLB  9
04324:  MOVWF  x07
....................          ps->smState = TCP_LAST_ACK; 
04326:  MOVFF  901,FE9
0432A:  MOVFF  902,FEA
0432E:  MOVLW  09
04330:  MOVWF  FEF
....................          break; 
04332:  BRA    4362
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
04334:  MOVLW  1E
04336:  MOVLB  9
04338:  ADDWF  x01,W
0433A:  MOVWF  FE9
0433C:  MOVLW  00
0433E:  ADDWFC x02,W
04340:  MOVWF  FEA
04342:  MOVF   FEF,W
04344:  SUBLW  03
04346:  BNC   434E
....................             flags = FIN; 
04348:  MOVLW  01
0434A:  MOVWF  x07
0434C:  BRA    435E
....................          else 
....................             CloseSocket(ps); 
0434E:  MOVFF  902,947
04352:  MOVFF  901,946
04356:  MOVLB  0
04358:  CALL   2B16
0435C:  MOVLB  9
....................          break; 
0435E:  BRA    4362
04360:  MOVLB  9
....................       } 
....................  
....................  
....................       if(flags) 
04362:  MOVF   x07,F
04364:  BZ    4440
....................       { 
....................          if(flags & ACK) 
04366:  BTFSS  x07.4
04368:  BRA    4388
....................             seq = ps->SND_SEQ; 
0436A:  MOVLW  16
0436C:  ADDWF  x01,W
0436E:  MOVWF  FE9
04370:  MOVLW  00
04372:  ADDWFC x02,W
04374:  MOVWF  FEA
04376:  MOVFF  FEF,903
0437A:  MOVFF  FEC,904
0437E:  MOVFF  FEC,905
04382:  MOVFF  FEC,906
04386:  BRA    43BC
....................          else 
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
04388:  MOVLW  16
0438A:  ADDWF  x01,W
0438C:  MOVWF  FE9
0438E:  MOVLW  00
04390:  ADDWFC x02,W
04392:  MOVWF  FEA
04394:  MOVFF  FEF,903
04398:  MOVFF  FEC,904
0439C:  MOVFF  FEC,905
043A0:  MOVFF  FEC,906
....................             ps->SND_SEQ++; 
043A4:  MOVLW  16
043A6:  ADDWF  x01,W
043A8:  MOVWF  FE9
043AA:  MOVLW  00
043AC:  ADDWFC x02,W
043AE:  MOVWF  FEA
043B0:  MOVLW  01
043B2:  ADDWF  FEE,F
043B4:  MOVLW  00
043B6:  ADDWFC FEE,F
043B8:  ADDWFC FEE,F
043BA:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
043BC:  MOVLW  01
043BE:  ADDWF  x01,W
043C0:  MOVWF  01
043C2:  MOVLW  00
043C4:  ADDWFC x02,W
043C6:  MOVWF  03
043C8:  MOVFF  01,908
043CC:  MOVWF  x09
043CE:  MOVLW  0B
043D0:  ADDWF  x01,W
043D2:  MOVWF  FE9
043D4:  MOVLW  00
043D6:  ADDWFC x02,W
043D8:  MOVWF  FEA
043DA:  MOVFF  FEC,94D
043DE:  MOVF   FED,F
043E0:  MOVFF  FEF,94C
043E4:  MOVLW  0D
043E6:  ADDWF  x01,W
043E8:  MOVWF  FE9
043EA:  MOVLW  00
043EC:  ADDWFC x02,W
043EE:  MOVWF  FEA
043F0:  MOVFF  FEC,94F
043F4:  MOVF   FED,F
043F6:  MOVFF  FEF,94E
043FA:  MOVLW  1A
043FC:  ADDWF  x01,W
043FE:  MOVWF  FE9
04400:  MOVLW  00
04402:  ADDWFC x02,W
04404:  MOVWF  FEA
04406:  MOVFF  FEF,954
0440A:  MOVFF  FEC,955
0440E:  MOVFF  FEC,956
04412:  MOVFF  FEC,957
04416:  MOVFF  03,94B
0441A:  MOVFF  01,94A
0441E:  MOVFF  906,953
04422:  MOVFF  905,952
04426:  MOVFF  904,951
0442A:  MOVFF  903,950
0442E:  MOVFF  907,958
04432:  SETF   x59
04434:  CLRF   x5B
04436:  CLRF   x5A
04438:  MOVLB  0
0443A:  CALL   2F52
0443E:  MOVLB  9
....................       } 
04440:  MOVLB  8
04442:  INCF   xFC,F
04444:  BRA    3FD4
04446:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
04448:  GOTO   462A (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
03B8C:  MOVLW  06
03B8E:  MOVLB  8
03B90:  ADDWF  xFC,W
03B92:  MOVWF  FE9
03B94:  MOVLW  00
03B96:  ADDWFC xFD,W
03B98:  MOVWF  FEA
03B9A:  MOVFF  FEF,916
03B9E:  MOVFF  FEC,917
03BA2:  MOVFF  FEC,918
03BA6:  MOVFF  FEC,919
....................    pseudoHeader.DestAddress        = *localIP; 
03BAA:  MOVFF  8FE,FE9
03BAE:  MOVFF  8FF,FEA
03BB2:  MOVFF  FEF,91A
03BB6:  MOVFF  FEC,91B
03BBA:  MOVFF  FEC,91C
03BBE:  MOVFF  FEC,91D
....................    pseudoHeader.Zero               = 0x0; 
03BC2:  MOVLB  9
03BC4:  CLRF   x1E
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
03BC6:  MOVLW  06
03BC8:  MOVWF  x1F
....................    pseudoHeader.TCPLength          = len; 
03BCA:  MOVFF  901,921
03BCE:  MOVFF  900,920
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03BD2:  MOVFF  921,9A2
03BD6:  MOVFF  920,9A1
03BDA:  MOVLB  0
03BDC:  CALL   17BA
03BE0:  MOVFF  02,921
03BE4:  MOVFF  01,920
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
03BE8:  MOVLW  09
03BEA:  MOVLB  9
03BEC:  MOVWF  x29
03BEE:  MOVLW  16
03BF0:  MOVWF  x28
03BF2:  MOVFF  929,985
03BF6:  MOVWF  x84
03BF8:  CLRF   x87
03BFA:  MOVLW  0C
03BFC:  MOVWF  x86
03BFE:  MOVLB  0
03C00:  CALL   2464
03C04:  MOVFF  01,923
03C08:  MOVLB  9
03C0A:  COMF   x23,F
03C0C:  MOVFF  02,924
03C10:  COMF   x24,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
03C12:  MOVFF  901,983
03C16:  MOVFF  900,982
03C1A:  MOVLB  0
03C1C:  CALL   2586
03C20:  MOVFF  02,926
03C24:  MOVFF  01,925
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
03C28:  MOVLB  9
03C2A:  MOVF   x26,W
03C2C:  SUBWF  x23,W
03C2E:  BNZ   3C36
03C30:  MOVF   x25,W
03C32:  SUBWF  x24,W
03C34:  BZ    3C44
....................    { 
....................       MACDiscardRx(); 
03C36:  MOVLB  0
03C38:  CALL   16E0
....................       return TRUE; 
03C3C:  MOVLW  01
03C3E:  MOVWF  01
03C40:  BRA    3D18
03C42:  MOVLB  9
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
03C44:  CLRF   x2A
03C46:  CLRF   x29
03C48:  MOVLB  0
03C4A:  CALL   26DE
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
03C4E:  MOVLW  09
03C50:  MOVLB  9
03C52:  MOVWF  x29
03C54:  MOVLW  02
03C56:  MOVWF  x28
03C58:  MOVFF  929,991
03C5C:  MOVWF  x90
03C5E:  CLRF   x93
03C60:  MOVLW  14
03C62:  MOVWF  x92
03C64:  MOVLB  0
03C66:  CALL   1756
....................    SwapTCPHeader(&TCPHeader); 
03C6A:  MOVLW  09
03C6C:  MOVLB  9
03C6E:  MOVWF  x83
03C70:  MOVLW  02
03C72:  MOVWF  x82
03C74:  MOVLB  0
03C76:  CALL   271C
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
03C7A:  MOVLB  9
03C7C:  SWAPF  x0E,W
03C7E:  ANDLW  0F
03C80:  MOVWF  00
03C82:  RLCF   00,F
03C84:  RLCF   00,F
03C86:  MOVLW  FC
03C88:  ANDWF  00,F
03C8A:  MOVF   00,W
03C8C:  ADDLW  EC
03C8E:  MOVWF  x27
....................    len = len - optionsSize - sizeof(TCPHeader); 
03C90:  MOVF   x27,W
03C92:  SUBWF  x00,W
03C94:  MOVWF  x28
03C96:  MOVLW  00
03C98:  SUBWFB x01,W
03C9A:  MOVWF  x29
03C9C:  MOVLW  14
03C9E:  SUBWF  x28,W
03CA0:  MOVWF  x00
03CA2:  MOVLW  00
03CA4:  SUBWFB x29,W
03CA6:  MOVWF  x01
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
03CA8:  SWAPF  x0E,W
03CAA:  ANDLW  0F
03CAC:  MOVWF  00
03CAE:  RLCF   00,W
03CB0:  MOVWF  x28
03CB2:  RLCF   x28,F
03CB4:  MOVLW  FC
03CB6:  ANDWF  x28,F
03CB8:  CLRF   x2A
03CBA:  MOVFF  928,929
03CBE:  MOVLB  0
03CC0:  CALL   26DE
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
03CC4:  MOVLW  09
03CC6:  MOVLB  9
03CC8:  MOVWF  x29
03CCA:  MOVLW  02
03CCC:  MOVWF  x28
03CCE:  MOVFF  8FD,92B
03CD2:  MOVFF  8FC,92A
03CD6:  MOVLB  0
03CD8:  GOTO   28FA
03CDC:  MOVFF  01,922
....................    if(socket != INVALID_SOCKET) 
03CE0:  MOVLB  9
03CE2:  MOVF   x22,W
03CE4:  SUBLW  FE
03CE6:  BZ    3D0E
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
03CE8:  MOVFF  922,928
03CEC:  MOVFF  8FD,92A
03CF0:  MOVFF  8FC,929
03CF4:  MOVLW  09
03CF6:  MOVWF  x2C
03CF8:  MOVLW  02
03CFA:  MOVWF  x2B
03CFC:  MOVFF  901,92E
03D00:  MOVFF  900,92D
03D04:  MOVLB  0
03D06:  GOTO   3176
....................    } 
03D0A:  BRA    3D14
03D0C:  MOVLB  9
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
03D0E:  MOVLB  0
03D10:  CALL   16E0
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
03D14:  MOVLW  01
03D16:  MOVWF  01
03D18:  GOTO   4568 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
02F52:  MOVLW  01
02F54:  MOVLB  9
02F56:  MOVWF  x82
02F58:  MOVLB  0
02F5A:  RCALL  2C14
02F5C:  MOVF   01,F
02F5E:  BZ    2F52
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
02F60:  MOVLB  9
02F62:  INCFSZ x59,W
02F64:  BRA    2F76
....................       buff = MACGetTxBuffer(TRUE); 
02F66:  MOVLW  01
02F68:  MOVWF  x82
02F6A:  MOVLB  0
02F6C:  CALL   1AD2
02F70:  MOVFF  01,959
02F74:  MOVLB  9
....................  
....................    if(buff == INVALID_BUFFER) 
02F76:  INCFSZ x59,W
02F78:  BRA    2F7C
....................       return; 
02F7A:  BRA    3172
....................  
....................    IPSetTxBuffer(buff, 0); 
02F7C:  MOVFF  959,99B
02F80:  CLRF   x9D
02F82:  MOVLW  14
02F84:  MOVWF  x9C
02F86:  MOVLB  0
02F88:  CALL   1AFA
....................  
....................    header.SourcePort           = localPort; 
02F8C:  MOVFF  94D,95F
02F90:  MOVFF  94C,95E
....................    header.DestPort             = remotePort; 
02F94:  MOVFF  94F,961
02F98:  MOVFF  94E,960
....................    header.SeqNumber            = tseq; 
02F9C:  MOVFF  953,965
02FA0:  MOVFF  952,964
02FA4:  MOVFF  951,963
02FA8:  MOVFF  950,962
....................    header.AckNumber            = tack; 
02FAC:  MOVFF  957,969
02FB0:  MOVFF  956,968
02FB4:  MOVFF  955,967
02FB8:  MOVFF  954,966
....................    header.Flags.bits.Reserved2 = 0; 
02FBC:  MOVLW  3F
02FBE:  MOVLB  9
02FC0:  ANDWF  x6B,W
02FC2:  MOVWF  x6B
....................    header.DataOffset.Reserved3 = 0; 
02FC4:  MOVLW  F0
02FC6:  ANDWF  x6A,W
02FC8:  MOVWF  x6A
....................    header.Flags.b              = flags; 
02FCA:  MOVFF  958,96B
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
02FCE:  MOVLB  0
02FD0:  BRA    2C3C
02FD2:  MOVFF  02,96D
02FD6:  MOVFF  01,96C
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
02FDA:  MOVLB  9
02FDC:  MOVF   x6D,F
02FDE:  BNZ   2FE6
02FE0:  MOVF   x6C,W
02FE2:  SUBLW  28
02FE4:  BC    2FF0
....................    { 
....................       header.Window -= 40; 
02FE6:  MOVLW  28
02FE8:  SUBWF  x6C,F
02FEA:  MOVLW  00
02FEC:  SUBWFB x6D,F
....................    } 
02FEE:  BRA    2FF4
....................    else 
....................       header.Window = 0; 
02FF0:  CLRF   x6D
02FF2:  CLRF   x6C
.................... #endif 
....................  
....................    header.Checksum             = 0; 
02FF4:  CLRF   x6F
02FF6:  CLRF   x6E
....................    header.UrgentPointer        = 0; 
02FF8:  CLRF   x71
02FFA:  CLRF   x70
....................  
....................    SwapTCPHeader(&header); 
02FFC:  MOVLW  09
02FFE:  MOVWF  x83
03000:  MOVLW  5E
03002:  MOVWF  x82
03004:  MOVLB  0
03006:  CALL   271C
....................  
....................    len += sizeof(header); 
0300A:  MOVLW  14
0300C:  MOVLB  9
0300E:  ADDWF  x5A,F
03010:  MOVLW  00
03012:  ADDWFC x5B,F
....................  
....................    if ( flags & SYN ) 
03014:  BTFSS  x58.1
03016:  BRA    3036
....................    { 
....................       len += sizeof(options); 
03018:  MOVLW  04
0301A:  ADDWF  x5A,F
0301C:  MOVLW  00
0301E:  ADDWFC x5B,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
03020:  MOVLW  02
03022:  MOVWF  x72
....................       options.Length = 0x04; 
03024:  MOVLW  04
03026:  MOVWF  x73
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
03028:  MOVWF  x74
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
0302A:  CLRF   x75
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
0302C:  MOVLW  0F
0302E:  ANDWF  x6A,W
03030:  IORLW  60
03032:  MOVWF  x6A
....................    } 
03034:  BRA    303E
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
03036:  MOVLW  0F
03038:  ANDWF  x6A,W
0303A:  IORLW  50
0303C:  MOVWF  x6A
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
0303E:  MOVFF  353,979
03042:  MOVFF  352,978
03046:  MOVFF  351,977
0304A:  MOVFF  350,976
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
0304E:  MOVLW  06
03050:  ADDWF  x4A,W
03052:  MOVWF  FE9
03054:  MOVLW  00
03056:  ADDWFC x4B,W
03058:  MOVWF  FEA
0305A:  MOVFF  FEF,97A
0305E:  MOVFF  FEC,97B
03062:  MOVFF  FEC,97C
03066:  MOVFF  FEC,97D
....................    pseudoHeader.Zero           = 0x0; 
0306A:  CLRF   x7E
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
0306C:  MOVLW  06
0306E:  MOVWF  x7F
....................    pseudoHeader.TCPLength      = len; 
03070:  MOVFF  95B,981
03074:  MOVFF  95A,980
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
03078:  MOVFF  981,9A2
0307C:  MOVFF  980,9A1
03080:  MOVLB  0
03082:  CALL   17BA
03086:  MOVFF  02,981
0308A:  MOVFF  01,980
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
0308E:  MOVLW  09
03090:  MOVLB  9
03092:  MOVWF  x83
03094:  MOVLW  76
03096:  MOVWF  x82
03098:  MOVFF  983,985
0309C:  MOVWF  x84
0309E:  CLRF   x87
030A0:  MOVLW  0C
030A2:  MOVWF  x86
030A4:  MOVLB  0
030A6:  CALL   2464
030AA:  MOVFF  01,96E
030AE:  MOVLB  9
030B0:  COMF   x6E,F
030B2:  MOVFF  02,96F
030B6:  COMF   x6F,F
....................    checkSum.Val = header.Checksum; 
030B8:  MOVFF  96F,95D
030BC:  MOVFF  96E,95C
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
030C0:  MOVFF  94B,983
030C4:  MOVFF  94A,982
030C8:  MOVLW  06
030CA:  MOVWF  x84
030CC:  MOVFF  95B,986
030D0:  MOVFF  95A,985
030D4:  MOVLB  0
030D6:  RCALL  2E2C
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
030D8:  MOVLW  09
030DA:  MOVLB  9
030DC:  MOVWF  x83
030DE:  MOVLW  5E
030E0:  MOVWF  x82
030E2:  MOVFF  983,9A7
030E6:  MOVWF  xA6
030E8:  CLRF   xA9
030EA:  MOVLW  14
030EC:  MOVWF  xA8
030EE:  MOVLB  0
030F0:  CALL   1BB6
....................  
....................    if ( flags & SYN ) 
030F4:  MOVLB  9
030F6:  BTFSS  x58.1
030F8:  BRA    3116
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
030FA:  MOVLW  09
030FC:  MOVWF  x83
030FE:  MOVLW  72
03100:  MOVWF  x82
03102:  MOVFF  983,9A7
03106:  MOVWF  xA6
03108:  CLRF   xA9
0310A:  MOVLW  04
0310C:  MOVWF  xA8
0310E:  MOVLB  0
03110:  CALL   1BB6
03114:  MOVLB  9
....................  
....................    IPSetTxBuffer(buff, 0); 
03116:  MOVFF  959,99B
0311A:  CLRF   x9D
0311C:  MOVLW  14
0311E:  MOVWF  x9C
03120:  MOVLB  0
03122:  CALL   1AFA
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
03126:  MOVFF  95B,983
0312A:  MOVFF  95A,982
0312E:  CALL   2586
03132:  MOVFF  02,95D
03136:  MOVFF  01,95C
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
0313A:  MOVFF  959,99B
0313E:  MOVLB  9
03140:  CLRF   x9D
03142:  MOVLW  24
03144:  MOVWF  x9C
03146:  MOVLB  0
03148:  CALL   1AFA
....................    MACPut(checkSum.v[1]); 
0314C:  MOVFF  95D,9A5
03150:  CALL   1B98
....................    MACPut(checkSum.v[0]); 
03154:  MOVFF  95C,9A5
03158:  CALL   1B98
....................    MACSetTxBuffer(buff, 0); 
0315C:  MOVFF  959,99B
03160:  MOVLB  9
03162:  CLRF   x9D
03164:  CLRF   x9C
03166:  MOVLB  0
03168:  CALL   1AFA
....................  
....................    MACFlush(); 
0316C:  CALL   1CCE
03170:  MOVLB  9
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
03172:  MOVLB  0
03174:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
028FA:  MOVLW  FE
028FC:  MOVLB  9
028FE:  MOVWF  x2F
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
02900:  CLRF   x2E
02902:  MOVF   x2E,W
02904:  SUBLW  22
02906:  BTFSS  FD8.0
02908:  BRA    2A10
....................    { 
....................       ps = &TCB[s]; 
0290A:  CLRF   x47
0290C:  MOVFF  92E,946
02910:  CLRF   x49
02912:  MOVLW  24
02914:  MOVWF  x48
02916:  MOVLB  0
02918:  CALL   0FBE
0291C:  MOVFF  02,03
02920:  MOVF   01,W
02922:  ADDLW  97
02924:  MOVWF  01
02926:  MOVLW  03
02928:  ADDWFC 03,F
0292A:  MOVFF  01,92C
0292E:  MOVLB  9
02930:  MOVFF  03,92D
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
02934:  MOVFF  92C,FE9
02938:  MOVFF  92D,FEA
0293C:  MOVF   FEF,W
0293E:  SUBLW  0A
02940:  BZ    2A0C
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
02942:  MOVLW  0B
02944:  ADDWF  x2C,W
02946:  MOVWF  FE9
02948:  MOVLW  00
0294A:  ADDWFC x2D,W
0294C:  MOVWF  FEA
0294E:  MOVFF  FEC,931
02952:  MOVF   FED,F
02954:  MOVFF  FEF,930
02958:  MOVLW  02
0295A:  ADDWF  x28,W
0295C:  MOVWF  FE9
0295E:  MOVLW  00
02960:  ADDWFC x29,W
02962:  MOVWF  FEA
02964:  MOVFF  FEC,03
02968:  MOVF   FED,F
0296A:  MOVF   FEF,W
0296C:  SUBWF  x30,W
0296E:  BNZ   2A0C
02970:  MOVF   03,W
02972:  SUBWF  x31,W
02974:  BNZ   2A0C
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
02976:  MOVFF  92C,FE9
0297A:  MOVFF  92D,FEA
0297E:  MOVF   FEF,F
02980:  BNZ   2986
....................                partialMatch = s; 
02982:  MOVFF  92E,92F
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
02986:  MOVLW  0D
02988:  ADDWF  x2C,W
0298A:  MOVWF  FE9
0298C:  MOVLW  00
0298E:  ADDWFC x2D,W
02990:  MOVWF  FEA
02992:  MOVFF  FEC,931
02996:  MOVF   FED,F
02998:  MOVFF  FEF,930
0299C:  MOVFF  928,FE9
029A0:  MOVFF  929,FEA
029A4:  MOVFF  FEC,03
029A8:  MOVF   FED,F
029AA:  MOVF   FEF,W
029AC:  SUBWF  x30,W
029AE:  BNZ   2A0C
029B0:  MOVF   03,W
029B2:  SUBWF  x31,W
029B4:  BNZ   2A0C
029B6:  MOVLW  07
029B8:  ADDWF  x2C,W
029BA:  MOVWF  FE9
029BC:  MOVLW  00
029BE:  ADDWFC x2D,W
029C0:  MOVWF  FEA
029C2:  MOVFF  FEF,930
029C6:  MOVFF  FEC,931
029CA:  MOVFF  FEC,932
029CE:  MOVFF  FEC,933
029D2:  MOVLW  06
029D4:  ADDWF  x2A,W
029D6:  MOVWF  FE9
029D8:  MOVLW  00
029DA:  ADDWFC x2B,W
029DC:  MOVWF  FEA
029DE:  MOVFF  FEF,00
029E2:  MOVFF  FEC,01
029E6:  MOVFF  FEC,02
029EA:  MOVFF  FEC,03
029EE:  MOVF   00,W
029F0:  SUBWF  x30,W
029F2:  BNZ   2A0C
029F4:  MOVF   01,W
029F6:  SUBWF  x31,W
029F8:  BNZ   2A0C
029FA:  MOVF   02,W
029FC:  SUBWF  x32,W
029FE:  BNZ   2A0C
02A00:  MOVF   03,W
02A02:  SUBWF  x33,W
02A04:  BNZ   2A0C
....................             { 
....................                return s; 
02A06:  MOVFF  92E,01
02A0A:  BRA    2AF6
....................             } 
....................          } 
....................       } 
02A0C:  INCF   x2E,F
02A0E:  BRA    2902
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
02A10:  MOVF   x2F,W
02A12:  SUBLW  FE
02A14:  BNZ   2A1C
....................       return INVALID_SOCKET; 
02A16:  MOVLW  FE
02A18:  MOVWF  01
02A1A:  BRA    2AF6
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
02A1C:  CLRF   x47
02A1E:  MOVFF  92F,946
02A22:  CLRF   x49
02A24:  MOVLW  24
02A26:  MOVWF  x48
02A28:  MOVLB  0
02A2A:  CALL   0FBE
02A2E:  MOVFF  02,03
02A32:  MOVF   01,W
02A34:  ADDLW  97
02A36:  MOVWF  01
02A38:  MOVLW  03
02A3A:  ADDWFC 03,F
02A3C:  MOVFF  01,92C
02A40:  MOVLB  9
02A42:  MOVFF  03,92D
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
02A46:  MOVLW  01
02A48:  ADDWF  x2C,W
02A4A:  MOVWF  01
02A4C:  MOVLW  00
02A4E:  ADDWFC x2D,W
02A50:  MOVWF  03
02A52:  MOVFF  01,930
02A56:  MOVWF  x31
02A58:  MOVWF  FEA
02A5A:  MOVFF  01,FE9
02A5E:  MOVFF  92B,FE2
02A62:  MOVFF  92A,FE1
02A66:  MOVLW  0A
02A68:  MOVWF  01
02A6A:  MOVFF  FE6,FEE
02A6E:  DECFSZ 01,F
02A70:  BRA    2A6A
....................    ps->remotePort          = h->SourcePort; 
02A72:  MOVLW  0D
02A74:  ADDWF  x2C,W
02A76:  MOVWF  01
02A78:  MOVLW  00
02A7A:  ADDWFC x2D,W
02A7C:  MOVFF  928,FE9
02A80:  MOVFF  929,FEA
02A84:  MOVFF  FEC,03
02A88:  MOVF   FED,F
02A8A:  MOVFF  FEF,932
02A8E:  MOVWF  FEA
02A90:  MOVFF  01,FE9
02A94:  MOVFF  03,FEC
02A98:  MOVF   FED,F
02A9A:  MOVFF  932,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
02A9E:  MOVLW  23
02AA0:  ADDWF  x2C,W
02AA2:  MOVWF  FE9
02AA4:  MOVLW  00
02AA6:  ADDWFC x2D,W
02AA8:  MOVWF  FEA
02AAA:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
02AAC:  MOVLW  0F
02AAE:  ADDWF  x2C,W
02AB0:  MOVWF  FE9
02AB2:  MOVLW  00
02AB4:  ADDWFC x2D,W
02AB6:  MOVWF  FEA
02AB8:  INCFSZ FEF,W
02ABA:  BRA    2ABE
02ABC:  BRA    2AE4
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
02ABE:  MOVLW  0F
02AC0:  ADDWF  x2C,W
02AC2:  MOVWF  FE9
02AC4:  MOVLW  00
02AC6:  ADDWFC x2D,W
02AC8:  MOVWF  FEA
02ACA:  MOVFF  FEF,949
02ACE:  MOVLB  0
02AD0:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
02AD4:  MOVLW  0F
02AD6:  MOVLB  9
02AD8:  ADDWF  x2C,W
02ADA:  MOVWF  FE9
02ADC:  MOVLW  00
02ADE:  ADDWFC x2D,W
02AE0:  MOVWF  FEA
02AE2:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
02AE4:  MOVLW  23
02AE6:  ADDWF  x2C,W
02AE8:  MOVWF  FE9
02AEA:  MOVLW  00
02AEC:  ADDWFC x2D,W
02AEE:  MOVWF  FEA
02AF0:  BSF    FEF.1
....................  
....................    return partialMatch; 
02AF2:  MOVFF  92F,01
02AF6:  MOVLB  0
02AF8:  GOTO   3CDC (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
0271C:  MOVLB  9
0271E:  MOVFF  982,01
02722:  MOVFF  983,03
02726:  MOVFF  982,984
0272A:  MOVFF  983,985
0272E:  MOVFF  982,FE9
02732:  MOVFF  983,FEA
02736:  MOVFF  FEC,9A2
0273A:  MOVF   FED,F
0273C:  MOVFF  FEF,9A1
02740:  MOVLB  0
02742:  CALL   17BA
02746:  MOVFF  985,FEA
0274A:  MOVFF  984,FE9
0274E:  MOVFF  02,FEC
02752:  MOVF   FED,F
02754:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
02758:  MOVLW  02
0275A:  MOVLB  9
0275C:  ADDWF  x82,W
0275E:  MOVWF  01
02760:  MOVLW  00
02762:  ADDWFC x83,W
02764:  MOVWF  03
02766:  MOVFF  01,984
0276A:  MOVWF  x85
0276C:  MOVLW  02
0276E:  ADDWF  x82,W
02770:  MOVWF  FE9
02772:  MOVLW  00
02774:  ADDWFC x83,W
02776:  MOVWF  FEA
02778:  MOVFF  FEC,9A2
0277C:  MOVF   FED,F
0277E:  MOVFF  FEF,9A1
02782:  MOVLB  0
02784:  CALL   17BA
02788:  MOVFF  985,FEA
0278C:  MOVFF  984,FE9
02790:  MOVFF  02,FEC
02794:  MOVF   FED,F
02796:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
0279A:  MOVLW  04
0279C:  MOVLB  9
0279E:  ADDWF  x82,W
027A0:  MOVWF  01
027A2:  MOVLW  00
027A4:  ADDWFC x83,W
027A6:  MOVWF  03
027A8:  MOVFF  01,984
027AC:  MOVWF  x85
027AE:  MOVLW  04
027B0:  ADDWF  x82,W
027B2:  MOVWF  FE9
027B4:  MOVLW  00
027B6:  ADDWFC x83,W
027B8:  MOVWF  FEA
027BA:  MOVFF  FEF,98A
027BE:  MOVFF  FEC,98B
027C2:  MOVFF  FEC,98C
027C6:  MOVFF  FEC,98D
027CA:  MOVLB  0
027CC:  RCALL  26FA
027CE:  MOVFF  985,FEA
027D2:  MOVFF  984,FE9
027D6:  MOVFF  00,FEF
027DA:  MOVFF  01,FEC
027DE:  MOVFF  02,FEC
027E2:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
027E6:  MOVLW  08
027E8:  MOVLB  9
027EA:  ADDWF  x82,W
027EC:  MOVWF  01
027EE:  MOVLW  00
027F0:  ADDWFC x83,W
027F2:  MOVWF  03
027F4:  MOVFF  01,984
027F8:  MOVWF  x85
027FA:  MOVLW  08
027FC:  ADDWF  x82,W
027FE:  MOVWF  FE9
02800:  MOVLW  00
02802:  ADDWFC x83,W
02804:  MOVWF  FEA
02806:  MOVFF  FEF,98A
0280A:  MOVFF  FEC,98B
0280E:  MOVFF  FEC,98C
02812:  MOVFF  FEC,98D
02816:  MOVLB  0
02818:  RCALL  26FA
0281A:  MOVFF  985,FEA
0281E:  MOVFF  984,FE9
02822:  MOVFF  00,FEF
02826:  MOVFF  01,FEC
0282A:  MOVFF  02,FEC
0282E:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
02832:  MOVLW  0E
02834:  MOVLB  9
02836:  ADDWF  x82,W
02838:  MOVWF  01
0283A:  MOVLW  00
0283C:  ADDWFC x83,W
0283E:  MOVWF  03
02840:  MOVFF  01,984
02844:  MOVWF  x85
02846:  MOVLW  0E
02848:  ADDWF  x82,W
0284A:  MOVWF  FE9
0284C:  MOVLW  00
0284E:  ADDWFC x83,W
02850:  MOVWF  FEA
02852:  MOVFF  FEC,9A2
02856:  MOVF   FED,F
02858:  MOVFF  FEF,9A1
0285C:  MOVLB  0
0285E:  CALL   17BA
02862:  MOVFF  985,FEA
02866:  MOVFF  984,FE9
0286A:  MOVFF  02,FEC
0286E:  MOVF   FED,F
02870:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
02874:  MOVLW  10
02876:  MOVLB  9
02878:  ADDWF  x82,W
0287A:  MOVWF  01
0287C:  MOVLW  00
0287E:  ADDWFC x83,W
02880:  MOVWF  03
02882:  MOVFF  01,984
02886:  MOVWF  x85
02888:  MOVLW  10
0288A:  ADDWF  x82,W
0288C:  MOVWF  FE9
0288E:  MOVLW  00
02890:  ADDWFC x83,W
02892:  MOVWF  FEA
02894:  MOVFF  FEC,9A2
02898:  MOVF   FED,F
0289A:  MOVFF  FEF,9A1
0289E:  MOVLB  0
028A0:  CALL   17BA
028A4:  MOVFF  985,FEA
028A8:  MOVFF  984,FE9
028AC:  MOVFF  02,FEC
028B0:  MOVF   FED,F
028B2:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
028B6:  MOVLW  12
028B8:  MOVLB  9
028BA:  ADDWF  x82,W
028BC:  MOVWF  01
028BE:  MOVLW  00
028C0:  ADDWFC x83,W
028C2:  MOVWF  03
028C4:  MOVFF  01,984
028C8:  MOVWF  x85
028CA:  MOVLW  12
028CC:  ADDWF  x82,W
028CE:  MOVWF  FE9
028D0:  MOVLW  00
028D2:  ADDWFC x83,W
028D4:  MOVWF  FEA
028D6:  MOVFF  FEC,9A2
028DA:  MOVF   FED,F
028DC:  MOVFF  FEF,9A1
028E0:  MOVLB  0
028E2:  CALL   17BA
028E6:  MOVFF  985,FEA
028EA:  MOVFF  984,FE9
028EE:  MOVFF  02,FEC
028F2:  MOVF   FED,F
028F4:  MOVFF  01,FEF
028F8:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
02B16:  MOVLW  0F
02B18:  MOVLB  9
02B1A:  ADDWF  x46,W
02B1C:  MOVWF  FE9
02B1E:  MOVLW  00
02B20:  ADDWFC x47,W
02B22:  MOVWF  FEA
02B24:  INCFSZ FEF,W
02B26:  BRA    2B2A
02B28:  BRA    2B5E
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
02B2A:  MOVLW  0F
02B2C:  ADDWF  x46,W
02B2E:  MOVWF  FE9
02B30:  MOVLW  00
02B32:  ADDWFC x47,W
02B34:  MOVWF  FEA
02B36:  MOVFF  FEF,949
02B3A:  MOVLB  0
02B3C:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
02B40:  MOVLW  0F
02B42:  MOVLB  9
02B44:  ADDWF  x46,W
02B46:  MOVWF  FE9
02B48:  MOVLW  00
02B4A:  ADDWFC x47,W
02B4C:  MOVWF  FEA
02B4E:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
02B50:  MOVLW  23
02B52:  ADDWF  x46,W
02B54:  MOVWF  FE9
02B56:  MOVLW  00
02B58:  ADDWFC x47,W
02B5A:  MOVWF  FEA
02B5C:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
02B5E:  MOVLW  07
02B60:  ADDWF  x46,W
02B62:  MOVWF  FE9
02B64:  MOVLW  00
02B66:  ADDWFC x47,W
02B68:  MOVWF  FEA
02B6A:  MOVF   FEE,F
02B6C:  MOVF   FEE,F
02B6E:  CLRF   FEC
02B70:  MOVF   FED,F
02B72:  CLRF   FEF
02B74:  MOVF   FED,F
02B76:  CLRF   FEF
02B78:  MOVF   FED,F
02B7A:  CLRF   FEF
....................     ps->remotePort = 0x00; 
02B7C:  MOVLW  0D
02B7E:  ADDWF  x46,W
02B80:  MOVWF  FE9
02B82:  MOVLW  00
02B84:  ADDWFC x47,W
02B86:  MOVWF  FEA
02B88:  CLRF   FEC
02B8A:  MOVF   FED,F
02B8C:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
02B8E:  MOVLW  23
02B90:  ADDWF  x46,W
02B92:  MOVWF  FE9
02B94:  MOVLW  00
02B96:  ADDWFC x47,W
02B98:  MOVWF  FEA
02B9A:  BTFSS  FEF.3
02B9C:  BRA    2BA6
....................     { 
....................         MACDiscardRx(); 
02B9E:  MOVLB  0
02BA0:  CALL   16E0
02BA4:  MOVLB  9
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
02BA6:  MOVLW  23
02BA8:  ADDWF  x46,W
02BAA:  MOVWF  FE9
02BAC:  MOVLW  00
02BAE:  ADDWFC x47,W
02BB0:  MOVWF  FEA
02BB2:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
02BB4:  MOVLW  21
02BB6:  ADDWF  x46,W
02BB8:  MOVWF  FE9
02BBA:  MOVLW  00
02BBC:  ADDWFC x47,W
02BBE:  MOVWF  FEA
02BC0:  CLRF   FEC
02BC2:  MOVF   FED,F
02BC4:  MOVLW  24
02BC6:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
02BC8:  MOVLW  23
02BCA:  ADDWF  x46,W
02BCC:  MOVWF  FE9
02BCE:  MOVLW  00
02BD0:  ADDWFC x47,W
02BD2:  MOVWF  FEA
02BD4:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
02BD6:  MOVLW  23
02BD8:  ADDWF  x46,W
02BDA:  MOVWF  FE9
02BDC:  MOVLW  00
02BDE:  ADDWFC x47,W
02BE0:  MOVWF  FEA
02BE2:  BTFSS  FEF.0
02BE4:  BRA    2BF2
....................     { 
....................         ps->smState = TCP_LISTEN; 
02BE6:  MOVFF  946,FE9
02BEA:  MOVFF  947,FEA
02BEE:  CLRF   FEF
....................     } 
02BF0:  BRA    2BFE
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
02BF2:  MOVFF  946,FE9
02BF6:  MOVFF  947,FEA
02BFA:  MOVLW  0A
02BFC:  MOVWF  FEF
....................     } 
....................     //ps->smState = TCP_CLOSED; 
....................  
....................    ps->TxCount = 0; 
02BFE:  MOVLW  10
02C00:  ADDWF  x46,W
02C02:  MOVWF  FE9
02C04:  MOVLW  00
02C06:  ADDWFC x47,W
02C08:  MOVWF  FEA
02C0A:  CLRF   FEC
02C0C:  MOVF   FED,F
02C0E:  CLRF   FEF
....................  
....................     return; 
02C10:  MOVLB  0
02C12:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
03176:  MOVLB  9
03178:  CLRF   x47
0317A:  MOVFF  928,946
0317E:  CLRF   x49
03180:  MOVLW  24
03182:  MOVWF  x48
03184:  MOVLB  0
03186:  CALL   0FBE
0318A:  MOVFF  02,03
0318E:  MOVF   01,W
03190:  ADDLW  97
03192:  MOVWF  01
03194:  MOVLW  03
03196:  ADDWFC 03,F
03198:  MOVFF  01,93F
0319C:  MOVLB  9
0319E:  MOVFF  03,940
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
031A2:  CLRF   x41
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
031A4:  MOVLW  1E
031A6:  ADDWF  x3F,W
031A8:  MOVWF  FE9
031AA:  MOVLW  00
031AC:  ADDWFC x40,W
031AE:  MOVWF  FEA
031B0:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
031B2:  MOVLW  1F
031B4:  ADDWF  x3F,W
031B6:  MOVWF  01
031B8:  MOVLW  00
031BA:  ADDWFC x40,W
031BC:  MOVWF  03
031BE:  MOVFF  01,946
031C2:  MOVWF  x47
031C4:  MOVLB  0
031C6:  RCALL  2AFC
031C8:  MOVFF  947,FEA
031CC:  MOVFF  946,FE9
031D0:  MOVFF  02,FEC
031D4:  MOVF   FED,F
031D6:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
031DA:  MOVLW  21
031DC:  MOVLB  9
031DE:  ADDWF  x3F,W
031E0:  MOVWF  FE9
031E2:  MOVLW  00
031E4:  ADDWFC x40,W
031E6:  MOVWF  FEA
031E8:  CLRF   FEC
031EA:  MOVF   FED,F
031EC:  MOVLW  24
031EE:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
031F0:  MOVLW  0D
031F2:  ADDWF  x2B,W
031F4:  MOVWF  FE9
031F6:  MOVLW  00
031F8:  ADDWFC x2C,W
031FA:  MOVWF  FEA
031FC:  BTFSS  FEF.2
031FE:  BRA    323C
....................    { 
....................       MACDiscardRx(); 
03200:  MOVLB  0
03202:  CALL   16E0
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
03206:  MOVLB  9
03208:  MOVFF  93F,01
0320C:  MOVFF  940,03
03210:  MOVFF  93F,946
03214:  MOVFF  940,947
03218:  MOVLW  23
0321A:  ADDWF  x3F,W
0321C:  MOVWF  FE9
0321E:  MOVLW  00
03220:  ADDWFC x40,W
03222:  MOVWF  FEA
03224:  BTFSS  FEF.0
03226:  BRA    322C
03228:  MOVLW  00
0322A:  BRA    322E
0322C:  MOVLW  01
0322E:  MOVFF  947,FEA
03232:  MOVFF  946,FE9
03236:  MOVWF  FEF
....................       return; 
03238:  GOTO   3B86
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
0323C:  MOVLW  16
0323E:  ADDWF  x3F,W
03240:  MOVWF  FE9
03242:  MOVLW  00
03244:  ADDWFC x40,W
03246:  MOVWF  FEA
03248:  MOVFF  FEF,933
0324C:  MOVFF  FEC,934
03250:  MOVFF  FEC,935
03254:  MOVFF  FEC,936
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
03258:  MOVLW  0E
0325A:  ADDWF  x2B,W
0325C:  MOVWF  FE9
0325E:  MOVLW  00
03260:  ADDWFC x2C,W
03262:  MOVWF  FEA
03264:  MOVFF  FEC,947
03268:  MOVF   FED,F
0326A:  MOVFF  FEF,946
0326E:  CLRF   x48
03270:  CLRF   x49
03272:  MOVLW  08
03274:  ADDWF  x2B,W
03276:  MOVWF  FE9
03278:  MOVLW  00
0327A:  ADDWFC x2C,W
0327C:  MOVWF  FEA
0327E:  MOVFF  FEF,00
03282:  MOVFF  FEC,01
03286:  MOVFF  FEC,02
0328A:  MOVFF  FEC,03
0328E:  MOVF   00,W
03290:  SUBWF  x33,W
03292:  MOVWF  00
03294:  MOVF   01,W
03296:  SUBWFB x34,W
03298:  MOVWF  01
0329A:  MOVF   02,W
0329C:  SUBWFB x35,W
0329E:  MOVWF  02
032A0:  MOVF   03,W
032A2:  SUBWFB x36,W
032A4:  MOVWF  03
032A6:  MOVF   00,W
032A8:  SUBWF  x46,F
032AA:  MOVF   01,W
032AC:  SUBWFB x47,F
032AE:  MOVF   02,W
032B0:  SUBWFB x48,F
032B2:  MOVF   03,W
032B4:  SUBWFB x49,F
032B6:  MOVLW  10
032B8:  ADDWF  x3F,W
032BA:  MOVWF  FE9
032BC:  MOVLW  00
032BE:  ADDWFC x40,W
032C0:  MOVWF  FEA
032C2:  MOVFF  FEC,03
032C6:  MOVF   FED,F
032C8:  MOVFF  FEF,00
032CC:  MOVFF  03,01
032D0:  CLRF   02
032D2:  CLRF   03
032D4:  MOVF   00,W
032D6:  SUBWF  x46,W
032D8:  MOVWF  x42
032DA:  MOVF   01,W
032DC:  SUBWFB x47,W
032DE:  MOVWF  x43
032E0:  MOVF   02,W
032E2:  SUBWFB x48,W
032E4:  MOVWF  x44
032E6:  MOVF   03,W
032E8:  SUBWFB x49,W
032EA:  MOVWF  x45
....................    if(temp < 0) 
032EC:  BTFSS  x45.7
032EE:  BRA    3304
....................    { 
....................       ps->RemoteWindow = 0; 
032F0:  MOVLW  14
032F2:  ADDWF  x3F,W
032F4:  MOVWF  FE9
032F6:  MOVLW  00
032F8:  ADDWFC x40,W
032FA:  MOVWF  FEA
032FC:  CLRF   FEC
032FE:  MOVF   FED,F
03300:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
03302:  BRA    3318
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
03304:  MOVLW  14
03306:  ADDWF  x3F,W
03308:  MOVWF  FE9
0330A:  MOVLW  00
0330C:  ADDWFC x40,W
0330E:  MOVWF  FEA
03310:  MOVFF  92F,FEF
03314:  MOVFF  930,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
03318:  MOVFF  93F,FE9
0331C:  MOVFF  940,FEA
03320:  DECFSZ FEF,W
03322:  BRA    348E
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
03324:  MOVLW  0D
03326:  ADDWF  x2B,W
03328:  MOVWF  FE9
0332A:  MOVLW  00
0332C:  ADDWFC x2C,W
0332E:  MOVWF  FEA
03330:  BTFSC  FEF.1
03332:  BRA    3358
....................       { 
....................          MACDiscardRx(); 
03334:  MOVLB  0
03336:  CALL   16E0
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
0333A:  MOVLW  0D
0333C:  MOVLB  9
0333E:  ADDWF  x2B,W
03340:  MOVWF  FE9
03342:  MOVLW  00
03344:  ADDWFC x2C,W
03346:  MOVWF  FEA
03348:  BTFSS  FEF.4
0334A:  BRA    3354
....................           { 
....................             flags = RST; 
0334C:  MOVLW  04
0334E:  MOVWF  x41
....................             goto SendTCPControlPacket; 
03350:  GOTO   3B20
....................            } 
....................  
....................          return; 
03354:  GOTO   3B86
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
03358:  MOVLW  1A
0335A:  ADDWF  x3F,W
0335C:  MOVWF  01
0335E:  MOVLW  00
03360:  ADDWFC x40,W
03362:  MOVFF  01,946
03366:  MOVWF  x47
03368:  MOVLW  04
0336A:  ADDWF  x2B,W
0336C:  MOVWF  FE9
0336E:  MOVLW  00
03370:  ADDWFC x2C,W
03372:  MOVWF  FEA
03374:  MOVFF  FEF,948
03378:  MOVFF  FEC,949
0337C:  MOVFF  FEC,94A
03380:  MOVFF  FEC,94B
03384:  MOVF   x2D,W
03386:  ADDWF  x48,F
03388:  MOVF   x2E,W
0338A:  ADDWFC x49,F
0338C:  MOVLW  00
0338E:  ADDWFC x4A,F
03390:  ADDWFC x4B,F
03392:  MOVLW  01
03394:  ADDWF  x48,W
03396:  MOVWF  00
03398:  MOVLW  00
0339A:  ADDWFC x49,W
0339C:  MOVWF  01
0339E:  MOVLW  00
033A0:  ADDWFC x4A,W
033A2:  MOVWF  02
033A4:  MOVLW  00
033A6:  ADDWFC x4B,W
033A8:  MOVFF  947,FEA
033AC:  MOVFF  946,FE9
033B0:  MOVFF  00,FEF
033B4:  MOVFF  01,FEC
033B8:  MOVFF  02,FEC
033BC:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
033BE:  MOVLW  1A
033C0:  ADDWF  x3F,W
033C2:  MOVWF  FE9
033C4:  MOVLW  00
033C6:  ADDWFC x40,W
033C8:  MOVWF  FEA
033CA:  MOVFF  FEF,92F
033CE:  MOVFF  FEC,930
033D2:  MOVFF  FEC,931
033D6:  MOVFF  FEC,932
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
033DA:  MOVLW  0D
033DC:  ADDWF  x2B,W
033DE:  MOVWF  FE9
033E0:  MOVLW  00
033E2:  ADDWFC x2C,W
033E4:  MOVWF  FEA
033E6:  BTFSC  FEF.4
033E8:  BRA    3404
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
033EA:  MOVFF  93F,FE9
033EE:  MOVFF  940,FEA
033F2:  MOVLW  02
033F4:  MOVWF  FEF
....................          MACDiscardRx(); 
033F6:  MOVLB  0
033F8:  CALL   16E0
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
033FC:  MOVLW  12
033FE:  MOVLB  9
03400:  MOVWF  x41
....................          goto SendTCPControlPacket; 
03402:  BRA    3B20
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
03404:  MOVFF  93F,FE9
03408:  MOVFF  940,FEA
0340C:  MOVLW  03
0340E:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
03410:  MOVLW  10
03412:  MOVWF  x41
....................  
....................       ps->RemoteWindow = h->Window; 
03414:  MOVLW  14
03416:  ADDWF  x3F,W
03418:  MOVWF  01
0341A:  MOVLW  00
0341C:  ADDWFC x40,W
0341E:  MOVWF  03
03420:  MOVWF  x47
03422:  MOVLW  0E
03424:  ADDWF  x2B,W
03426:  MOVWF  FE9
03428:  MOVLW  00
0342A:  ADDWFC x2C,W
0342C:  MOVWF  FEA
0342E:  MOVFF  FEC,03
03432:  MOVF   FED,F
03434:  MOVFF  FEF,948
03438:  MOVFF  947,FEA
0343C:  MOVFF  01,FE9
03440:  MOVFF  03,FEC
03444:  MOVF   FED,F
03446:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
0344A:  MOVF   x2D,W
0344C:  IORWF  x2E,W
0344E:  BZ    3484
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
03450:  MOVLW  23
03452:  ADDWF  x3F,W
03454:  MOVWF  FE9
03456:  MOVLW  00
03458:  ADDWFC x40,W
0345A:  MOVWF  FEA
0345C:  BSF    FEF.3
....................          ps->RxCount             = len; 
0345E:  MOVLW  12
03460:  ADDWF  x3F,W
03462:  MOVWF  FE9
03464:  MOVLW  00
03466:  ADDWFC x40,W
03468:  MOVWF  FEA
0346A:  MOVFF  92E,FEC
0346E:  MOVF   FED,F
03470:  MOVFF  92D,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
03474:  MOVLW  23
03476:  ADDWF  x3F,W
03478:  MOVWF  FE9
0347A:  MOVLW  00
0347C:  ADDWFC x40,W
0347E:  MOVWF  FEA
03480:  BSF    FEF.2
....................       } 
03482:  BRA    348C
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
03484:  MOVLB  0
03486:  CALL   16E0
0348A:  MOVLB  9
....................       } 
....................       goto SendTCPControlPacket; 
0348C:  BRA    3B20
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
0348E:  MOVFF  93F,FE9
03492:  MOVFF  940,FEA
03496:  MOVF   FEF,F
03498:  BTFSS  FD8.2
0349A:  BRA    3610
....................    { 
....................       MACDiscardRx(); 
0349C:  MOVLB  0
0349E:  CALL   16E0
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
034A2:  MOVLW  0D
034A4:  MOVLB  9
034A6:  ADDWF  x2B,W
034A8:  MOVWF  FE9
034AA:  MOVLW  00
034AC:  ADDWFC x2C,W
034AE:  MOVWF  FEA
034B0:  BTFSC  FEF.1
034B2:  BRA    34BA
....................       { 
....................          flags = RST; 
034B4:  MOVLW  04
034B6:  MOVWF  x41
....................          goto SendTCPControlPacket; 
034B8:  BRA    3B20
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
034BA:  MOVLW  1A
034BC:  ADDWF  x3F,W
034BE:  MOVWF  01
034C0:  MOVLW  00
034C2:  ADDWFC x40,W
034C4:  MOVFF  01,946
034C8:  MOVWF  x47
034CA:  MOVLW  04
034CC:  ADDWF  x2B,W
034CE:  MOVWF  FE9
034D0:  MOVLW  00
034D2:  ADDWFC x2C,W
034D4:  MOVWF  FEA
034D6:  MOVFF  FEF,948
034DA:  MOVFF  FEC,949
034DE:  MOVFF  FEC,94A
034E2:  MOVFF  FEC,94B
034E6:  MOVF   x2D,W
034E8:  ADDWF  x48,F
034EA:  MOVF   x2E,W
034EC:  ADDWFC x49,F
034EE:  MOVLW  00
034F0:  ADDWFC x4A,F
034F2:  ADDWFC x4B,F
034F4:  MOVLW  01
034F6:  ADDWF  x48,W
034F8:  MOVWF  00
034FA:  MOVLW  00
034FC:  ADDWFC x49,W
034FE:  MOVWF  01
03500:  MOVLW  00
03502:  ADDWFC x4A,W
03504:  MOVWF  02
03506:  MOVLW  00
03508:  ADDWFC x4B,W
0350A:  MOVFF  947,FEA
0350E:  MOVFF  946,FE9
03512:  MOVFF  00,FEF
03516:  MOVFF  01,FEC
0351A:  MOVFF  02,FEC
0351E:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
03520:  MOVLW  14
03522:  ADDWF  x3F,W
03524:  MOVWF  01
03526:  MOVLW  00
03528:  ADDWFC x40,W
0352A:  MOVWF  03
0352C:  MOVWF  x47
0352E:  MOVLW  0E
03530:  ADDWF  x2B,W
03532:  MOVWF  FE9
03534:  MOVLW  00
03536:  ADDWFC x2C,W
03538:  MOVWF  FEA
0353A:  MOVFF  FEC,03
0353E:  MOVF   FED,F
03540:  MOVFF  FEF,948
03544:  MOVFF  947,FEA
03548:  MOVFF  01,FE9
0354C:  MOVFF  03,FEC
03550:  MOVF   FED,F
03552:  MOVFF  948,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
03556:  MOVLW  01
03558:  ADDWF  x3F,W
0355A:  MOVWF  01
0355C:  MOVLW  00
0355E:  ADDWFC x40,W
03560:  MOVWF  03
03562:  MOVFF  01,946
03566:  MOVWF  x47
03568:  MOVWF  FEA
0356A:  MOVFF  01,FE9
0356E:  MOVFF  92A,FE2
03572:  MOVFF  929,FE1
03576:  MOVLW  0A
03578:  MOVWF  01
0357A:  MOVFF  FE6,FEE
0357E:  DECFSZ 01,F
03580:  BRA    357A
....................       ps->remotePort = h->SourcePort; 
03582:  MOVLW  0D
03584:  ADDWF  x3F,W
03586:  MOVWF  01
03588:  MOVLW  00
0358A:  ADDWFC x40,W
0358C:  MOVFF  92B,FE9
03590:  MOVFF  92C,FEA
03594:  MOVFF  FEC,03
03598:  MOVF   FED,F
0359A:  MOVFF  FEF,948
0359E:  MOVWF  FEA
035A0:  MOVFF  01,FE9
035A4:  MOVFF  03,FEC
035A8:  MOVF   FED,F
035AA:  MOVFF  948,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
035AE:  MOVFF  93F,FE9
035B2:  MOVFF  940,FEA
035B6:  MOVLW  02
035B8:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
035BA:  MOVLW  16
035BC:  ADDWF  x3F,W
035BE:  MOVWF  FE9
035C0:  MOVLW  00
035C2:  ADDWFC x40,W
035C4:  MOVWF  FEA
035C6:  MOVFF  FEF,933
035CA:  MOVFF  FEC,934
035CE:  MOVFF  FEC,935
035D2:  MOVFF  FEC,936
....................       ps->SND_SEQ++; 
035D6:  MOVLW  16
035D8:  ADDWF  x3F,W
035DA:  MOVWF  FE9
035DC:  MOVLW  00
035DE:  ADDWFC x40,W
035E0:  MOVWF  FEA
035E2:  MOVLW  01
035E4:  ADDWF  FEE,F
035E6:  MOVLW  00
035E8:  ADDWFC FEE,F
035EA:  ADDWFC FEE,F
035EC:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
035EE:  MOVLW  1A
035F0:  ADDWF  x3F,W
035F2:  MOVWF  FE9
035F4:  MOVLW  00
035F6:  ADDWFC x40,W
035F8:  MOVWF  FEA
035FA:  MOVFF  FEF,92F
035FE:  MOVFF  FEC,930
03602:  MOVFF  FEC,931
03606:  MOVFF  FEC,932
....................       flags = SYN | ACK; 
0360A:  MOVLW  12
0360C:  MOVWF  x41
....................       goto SendTCPControlPacket; 
0360E:  BRA    3B20
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
03610:  MOVLW  1A
03612:  ADDWF  x3F,W
03614:  MOVWF  FE9
03616:  MOVLW  00
03618:  ADDWFC x40,W
0361A:  MOVWF  FEA
0361C:  MOVFF  FEF,937
03620:  MOVFF  FEC,938
03624:  MOVFF  FEC,939
03628:  MOVFF  FEC,93A
....................    prevSeq = ps->SND_SEQ; 
0362C:  MOVLW  16
0362E:  ADDWF  x3F,W
03630:  MOVWF  FE9
03632:  MOVLW  00
03634:  ADDWFC x40,W
03636:  MOVWF  FEA
03638:  MOVFF  FEF,93B
0363C:  MOVFF  FEC,93C
03640:  MOVFF  FEC,93D
03644:  MOVFF  FEC,93E
....................  
....................    ack = h->SeqNumber; 
03648:  MOVLW  04
0364A:  ADDWF  x2B,W
0364C:  MOVWF  FE9
0364E:  MOVLW  00
03650:  ADDWFC x2C,W
03652:  MOVWF  FEA
03654:  MOVFF  FEF,92F
03658:  MOVFF  FEC,930
0365C:  MOVFF  FEC,931
03660:  MOVFF  FEC,932
....................    ack += (DWORD)len; 
03664:  CLRF   02
03666:  CLRF   03
03668:  MOVF   x2D,W
0366A:  ADDWF  x2F,F
0366C:  MOVF   x2E,W
0366E:  ADDWFC x30,F
03670:  MOVF   02,W
03672:  ADDWFC x31,F
03674:  MOVF   03,W
03676:  ADDWFC x32,F
....................    seq = ps->SND_SEQ; 
03678:  MOVLW  16
0367A:  ADDWF  x3F,W
0367C:  MOVWF  FE9
0367E:  MOVLW  00
03680:  ADDWFC x40,W
03682:  MOVWF  FEA
03684:  MOVFF  FEF,933
03688:  MOVFF  FEC,934
0368C:  MOVFF  FEC,935
03690:  MOVFF  FEC,936
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
03694:  MOVLW  04
03696:  ADDWF  x2B,W
03698:  MOVWF  FE9
0369A:  MOVLW  00
0369C:  ADDWFC x2C,W
0369E:  MOVWF  FEA
036A0:  MOVFF  FEF,946
036A4:  MOVFF  FEC,947
036A8:  MOVFF  FEC,948
036AC:  MOVFF  FEC,949
036B0:  MOVF   x37,W
036B2:  SUBWF  x46,W
036B4:  BTFSS  FD8.2
036B6:  BRA    3B04
036B8:  MOVF   x38,W
036BA:  SUBWF  x47,W
036BC:  BTFSS  FD8.2
036BE:  BRA    3B04
036C0:  MOVF   x39,W
036C2:  SUBWF  x48,W
036C4:  BTFSS  FD8.2
036C6:  BRA    3B04
036C8:  MOVF   x3A,W
036CA:  SUBWF  x49,W
036CC:  BTFSS  FD8.2
036CE:  BRA    3B04
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
036D0:  MOVFF  93F,FE9
036D4:  MOVFF  940,FEA
036D8:  MOVF   FEF,W
036DA:  SUBLW  02
036DC:  BNZ   3764
....................          { 
....................             if(h->Flags.bits.flagACK) 
036DE:  MOVLW  0D
036E0:  ADDWF  x2B,W
036E2:  MOVWF  FE9
036E4:  MOVLW  00
036E6:  ADDWFC x2C,W
036E8:  MOVWF  FEA
036EA:  BTFSS  FEF.4
036EC:  BRA    375A
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
036EE:  MOVLW  1A
036F0:  ADDWF  x3F,W
036F2:  MOVWF  FE9
036F4:  MOVLW  00
036F6:  ADDWFC x40,W
036F8:  MOVWF  FEA
036FA:  MOVFF  92F,FEF
036FE:  MOVFF  930,FEC
03702:  MOVFF  931,FEC
03706:  MOVFF  932,FEC
....................                ps->smState = TCP_ESTABLISHED; 
0370A:  MOVFF  93F,FE9
0370E:  MOVFF  940,FEA
03712:  MOVLW  03
03714:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
03716:  MOVF   x2D,W
03718:  IORWF  x2E,W
0371A:  BZ    3750
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
0371C:  MOVLW  23
0371E:  ADDWF  x3F,W
03720:  MOVWF  FE9
03722:  MOVLW  00
03724:  ADDWFC x40,W
03726:  MOVWF  FEA
03728:  BSF    FEF.3
....................                   ps->RxCount             = len; 
0372A:  MOVLW  12
0372C:  ADDWF  x3F,W
0372E:  MOVWF  FE9
03730:  MOVLW  00
03732:  ADDWFC x40,W
03734:  MOVWF  FEA
03736:  MOVFF  92E,FEC
0373A:  MOVF   FED,F
0373C:  MOVFF  92D,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
03740:  MOVLW  23
03742:  ADDWF  x3F,W
03744:  MOVWF  FE9
03746:  MOVLW  00
03748:  ADDWFC x40,W
0374A:  MOVWF  FEA
0374C:  BSF    FEF.2
....................                } 
0374E:  BRA    3758
....................                else 
....................                   MACDiscardRx(); 
03750:  MOVLB  0
03752:  CALL   16E0
03756:  MOVLB  9
....................             } 
03758:  BRA    3762
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
0375A:  MOVLB  0
0375C:  CALL   16E0
03760:  MOVLB  9
....................             } 
....................          } 
03762:  BRA    3B02
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
03764:  MOVLW  1A
03766:  ADDWF  x3F,W
03768:  MOVWF  FE9
0376A:  MOVLW  00
0376C:  ADDWFC x40,W
0376E:  MOVWF  FEA
03770:  MOVFF  92F,FEF
03774:  MOVFF  930,FEC
03778:  MOVFF  931,FEC
0377C:  MOVFF  932,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
03780:  MOVFF  93F,FE9
03784:  MOVFF  940,FEA
03788:  MOVF   FEF,W
0378A:  SUBLW  03
0378C:  BTFSS  FD8.2
0378E:  BRA    3934
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
03790:  MOVLW  0D
03792:  ADDWF  x2B,W
03794:  MOVWF  FE9
03796:  MOVLW  00
03798:  ADDWFC x2C,W
0379A:  MOVWF  FEA
0379C:  BTFSS  FEF.4
0379E:  BRA    37F6
037A0:  MOVLW  23
037A2:  ADDWF  x3F,W
037A4:  MOVWF  FE9
037A6:  MOVLW  00
037A8:  ADDWFC x40,W
037AA:  MOVWF  FEA
037AC:  BTFSC  FEF.1
037AE:  BRA    37F6
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
037B0:  MOVLW  0F
037B2:  ADDWF  x3F,W
037B4:  MOVWF  FE9
037B6:  MOVLW  00
037B8:  ADDWFC x40,W
037BA:  MOVWF  FEA
037BC:  INCFSZ FEF,W
037BE:  BRA    37C2
037C0:  BRA    37F6
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
037C2:  MOVLW  0F
037C4:  ADDWF  x3F,W
037C6:  MOVWF  FE9
037C8:  MOVLW  00
037CA:  ADDWFC x40,W
037CC:  MOVWF  FEA
037CE:  MOVFF  FEF,949
037D2:  MOVLB  0
037D4:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
037D8:  MOVLW  0F
037DA:  MOVLB  9
037DC:  ADDWF  x3F,W
037DE:  MOVWF  FE9
037E0:  MOVLW  00
037E2:  ADDWFC x40,W
037E4:  MOVWF  FEA
037E6:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
037E8:  MOVLW  23
037EA:  ADDWF  x3F,W
037EC:  MOVWF  FE9
037EE:  MOVLW  00
037F0:  ADDWFC x40,W
037F2:  MOVWF  FEA
037F4:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
037F6:  MOVLW  0D
037F8:  ADDWF  x2B,W
037FA:  MOVWF  FE9
037FC:  MOVLW  00
037FE:  ADDWFC x2C,W
03800:  MOVWF  FEA
03802:  BTFSS  FEF.0
03804:  BRA    389C
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
03806:  MOVLW  11
03808:  MOVWF  x41
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
0380A:  MOVLW  16
0380C:  ADDWF  x3F,W
0380E:  MOVWF  FE9
03810:  MOVLW  00
03812:  ADDWFC x40,W
03814:  MOVWF  FEA
03816:  MOVFF  FEF,933
0381A:  MOVFF  FEC,934
0381E:  MOVFF  FEC,935
03822:  MOVFF  FEC,936
....................                   ps->SND_SEQ++; 
03826:  MOVLW  16
03828:  ADDWF  x3F,W
0382A:  MOVWF  FE9
0382C:  MOVLW  00
0382E:  ADDWFC x40,W
03830:  MOVWF  FEA
03832:  MOVLW  01
03834:  ADDWF  FEE,F
03836:  MOVLW  00
03838:  ADDWFC FEE,F
0383A:  ADDWFC FEE,F
0383C:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
0383E:  MOVLW  1A
03840:  ADDWF  x3F,W
03842:  MOVWF  FE9
03844:  MOVLW  00
03846:  ADDWFC x40,W
03848:  MOVWF  FEA
0384A:  MOVLW  01
0384C:  ADDWF  FEF,W
0384E:  MOVWF  00
03850:  MOVLW  00
03852:  ADDWFC FEC,W
03854:  MOVWF  01
03856:  MOVLW  00
03858:  ADDWFC FEC,W
0385A:  MOVWF  02
0385C:  MOVLW  00
0385E:  ADDWFC FEC,W
03860:  MOVF   FED,F
03862:  MOVF   FED,F
03864:  MOVF   FED,F
03866:  MOVFF  00,FEF
0386A:  MOVFF  01,FEC
0386E:  MOVFF  02,FEC
03872:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03874:  MOVLW  1A
03876:  ADDWF  x3F,W
03878:  MOVWF  FE9
0387A:  MOVLW  00
0387C:  ADDWFC x40,W
0387E:  MOVWF  FEA
03880:  MOVFF  FEF,92F
03884:  MOVFF  FEC,930
03888:  MOVFF  FEC,931
0388C:  MOVFF  FEC,932
....................                   ps->smState = TCP_LAST_ACK; 
03890:  MOVFF  93F,FE9
03894:  MOVFF  940,FEA
03898:  MOVLW  09
0389A:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
0389C:  MOVF   x2D,W
0389E:  IORWF  x2E,W
038A0:  BZ    392A
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
038A2:  MOVLW  23
038A4:  ADDWF  x3F,W
038A6:  MOVWF  FE9
038A8:  MOVLW  00
038AA:  ADDWFC x40,W
038AC:  MOVWF  FEA
038AE:  BTFSC  FEF.3
038B0:  BRA    38E8
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
038B2:  MOVLW  23
038B4:  ADDWF  x3F,W
038B6:  MOVWF  FE9
038B8:  MOVLW  00
038BA:  ADDWFC x40,W
038BC:  MOVWF  FEA
038BE:  BSF    FEF.3
....................                      ps->RxCount             = len; 
038C0:  MOVLW  12
038C2:  ADDWF  x3F,W
038C4:  MOVWF  FE9
038C6:  MOVLW  00
038C8:  ADDWFC x40,W
038CA:  MOVWF  FEA
038CC:  MOVFF  92E,FEC
038D0:  MOVF   FED,F
038D2:  MOVFF  92D,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
038D6:  MOVLW  23
038D8:  ADDWF  x3F,W
038DA:  MOVWF  FE9
038DC:  MOVLW  00
038DE:  ADDWFC x40,W
038E0:  MOVWF  FEA
038E2:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
038E4:  BSF    x41.4
....................                   } 
038E6:  BRA    3928
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
038E8:  MOVLW  16
038EA:  ADDWF  x3F,W
038EC:  MOVWF  FE9
038EE:  MOVLW  00
038F0:  ADDWFC x40,W
038F2:  MOVWF  FEA
038F4:  MOVFF  93B,FEF
038F8:  MOVFF  93C,FEC
038FC:  MOVFF  93D,FEC
03900:  MOVFF  93E,FEC
....................                      ps->SND_ACK = prevAck; 
03904:  MOVLW  1A
03906:  ADDWF  x3F,W
03908:  MOVWF  FE9
0390A:  MOVLW  00
0390C:  ADDWFC x40,W
0390E:  MOVWF  FEA
03910:  MOVFF  937,FEF
03914:  MOVFF  938,FEC
03918:  MOVFF  939,FEC
0391C:  MOVFF  93A,FEC
....................  
....................                      MACDiscardRx(); 
03920:  MOVLB  0
03922:  CALL   16E0
03926:  MOVLB  9
....................                   } 
....................                } 
03928:  BRA    3932
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
0392A:  MOVLB  0
0392C:  CALL   16E0
03930:  MOVLB  9
....................                } 
....................             } 
03932:  BRA    3B02
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
03934:  MOVFF  93F,FE9
03938:  MOVFF  940,FEA
0393C:  MOVF   FEF,W
0393E:  SUBLW  09
03940:  BNZ   396C
....................             { 
....................                MACDiscardRx(); 
03942:  MOVLB  0
03944:  CALL   16E0
....................  
....................                if(h->Flags.bits.flagACK) 
03948:  MOVLW  0D
0394A:  MOVLB  9
0394C:  ADDWF  x2B,W
0394E:  MOVWF  FE9
03950:  MOVLW  00
03952:  ADDWFC x2C,W
03954:  MOVWF  FEA
03956:  BTFSS  FEF.4
03958:  BRA    396A
....................                { 
....................                   CloseSocket(ps); 
0395A:  MOVFF  940,947
0395E:  MOVFF  93F,946
03962:  MOVLB  0
03964:  CALL   2B16
03968:  MOVLB  9
....................                } 
....................             } 
0396A:  BRA    3B02
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
0396C:  MOVFF  93F,FE9
03970:  MOVFF  940,FEA
03974:  MOVF   FEF,W
03976:  SUBLW  04
03978:  BNZ   3A3E
....................             { 
....................                MACDiscardRx(); 
0397A:  MOVLB  0
0397C:  CALL   16E0
....................  
....................                if(h->Flags.bits.flagFIN) 
03980:  MOVLW  0D
03982:  MOVLB  9
03984:  ADDWF  x2B,W
03986:  MOVWF  FE9
03988:  MOVLW  00
0398A:  ADDWFC x2C,W
0398C:  MOVWF  FEA
0398E:  BTFSS  FEF.0
03990:  BRA    3A1C
....................                { 
....................                   flags = ACK; 
03992:  MOVLW  10
03994:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03996:  MOVLW  1A
03998:  ADDWF  x3F,W
0399A:  MOVWF  FE9
0399C:  MOVLW  00
0399E:  ADDWFC x40,W
039A0:  MOVWF  FEA
039A2:  MOVLW  01
039A4:  ADDWF  FEF,W
039A6:  MOVWF  00
039A8:  MOVLW  00
039AA:  ADDWFC FEC,W
039AC:  MOVWF  01
039AE:  MOVLW  00
039B0:  ADDWFC FEC,W
039B2:  MOVWF  02
039B4:  MOVLW  00
039B6:  ADDWFC FEC,W
039B8:  MOVF   FED,F
039BA:  MOVF   FED,F
039BC:  MOVF   FED,F
039BE:  MOVFF  00,FEF
039C2:  MOVFF  01,FEC
039C6:  MOVFF  02,FEC
039CA:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
039CC:  MOVLW  1A
039CE:  ADDWF  x3F,W
039D0:  MOVWF  FE9
039D2:  MOVLW  00
039D4:  ADDWFC x40,W
039D6:  MOVWF  FEA
039D8:  MOVFF  FEF,92F
039DC:  MOVFF  FEC,930
039E0:  MOVFF  FEC,931
039E4:  MOVFF  FEC,932
....................                   if(h->Flags.bits.flagACK) 
039E8:  MOVLW  0D
039EA:  ADDWF  x2B,W
039EC:  MOVWF  FE9
039EE:  MOVLW  00
039F0:  ADDWFC x2C,W
039F2:  MOVWF  FEA
039F4:  BTFSS  FEF.4
039F6:  BRA    3A0A
....................                   { 
....................                      CloseSocket(ps); 
039F8:  MOVFF  940,947
039FC:  MOVFF  93F,946
03A00:  MOVLB  0
03A02:  CALL   2B16
....................                   } 
03A06:  BRA    3A18
03A08:  MOVLB  9
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
03A0A:  MOVFF  93F,FE9
03A0E:  MOVFF  940,FEA
03A12:  MOVLW  06
03A14:  MOVWF  FEF
03A16:  MOVLB  0
....................                   } 
....................                } 
03A18:  BRA    3A3A
03A1A:  MOVLB  9
....................                else if(h->Flags.bits.flagACK) 
03A1C:  MOVLW  0D
03A1E:  ADDWF  x2B,W
03A20:  MOVWF  FE9
03A22:  MOVLW  00
03A24:  ADDWFC x2C,W
03A26:  MOVWF  FEA
03A28:  BTFSS  FEF.4
03A2A:  BRA    3A38
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
03A2C:  MOVFF  93F,FE9
03A30:  MOVFF  940,FEA
03A34:  MOVLW  05
03A36:  MOVWF  FEF
03A38:  MOVLB  0
....................                } 
....................             } 
03A3A:  BRA    3B00
03A3C:  MOVLB  9
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
03A3E:  MOVFF  93F,FE9
03A42:  MOVFF  940,FEA
03A46:  MOVF   FEF,W
03A48:  SUBLW  05
03A4A:  BNZ   3ACC
....................             { 
....................                MACDiscardRx(); 
03A4C:  MOVLB  0
03A4E:  CALL   16E0
....................  
....................                if(h->Flags.bits.flagFIN) 
03A52:  MOVLW  0D
03A54:  MOVLB  9
03A56:  ADDWF  x2B,W
03A58:  MOVWF  FE9
03A5A:  MOVLW  00
03A5C:  ADDWFC x2C,W
03A5E:  MOVWF  FEA
03A60:  BTFSS  FEF.0
03A62:  BRA    3ACA
....................                { 
....................                   flags = ACK; 
03A64:  MOVLW  10
03A66:  MOVWF  x41
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
03A68:  MOVLW  1A
03A6A:  ADDWF  x3F,W
03A6C:  MOVWF  FE9
03A6E:  MOVLW  00
03A70:  ADDWFC x40,W
03A72:  MOVWF  FEA
03A74:  MOVLW  01
03A76:  ADDWF  FEF,W
03A78:  MOVWF  00
03A7A:  MOVLW  00
03A7C:  ADDWFC FEC,W
03A7E:  MOVWF  01
03A80:  MOVLW  00
03A82:  ADDWFC FEC,W
03A84:  MOVWF  02
03A86:  MOVLW  00
03A88:  ADDWFC FEC,W
03A8A:  MOVF   FED,F
03A8C:  MOVF   FED,F
03A8E:  MOVF   FED,F
03A90:  MOVFF  00,FEF
03A94:  MOVFF  01,FEC
03A98:  MOVFF  02,FEC
03A9C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
03A9E:  MOVLW  1A
03AA0:  ADDWF  x3F,W
03AA2:  MOVWF  FE9
03AA4:  MOVLW  00
03AA6:  ADDWFC x40,W
03AA8:  MOVWF  FEA
03AAA:  MOVFF  FEF,92F
03AAE:  MOVFF  FEC,930
03AB2:  MOVFF  FEC,931
03AB6:  MOVFF  FEC,932
....................                   CloseSocket(ps); 
03ABA:  MOVFF  940,947
03ABE:  MOVFF  93F,946
03AC2:  MOVLB  0
03AC4:  CALL   2B16
03AC8:  MOVLB  9
....................                } 
....................             } 
03ACA:  BRA    3B02
....................             else if ( ps->smState == TCP_CLOSING ) 
03ACC:  MOVFF  93F,FE9
03AD0:  MOVFF  940,FEA
03AD4:  MOVF   FEF,W
03AD6:  SUBLW  06
03AD8:  BNZ   3B02
....................             { 
....................                MACDiscardRx(); 
03ADA:  MOVLB  0
03ADC:  CALL   16E0
....................  
....................                if ( h->Flags.bits.flagACK ) 
03AE0:  MOVLW  0D
03AE2:  MOVLB  9
03AE4:  ADDWF  x2B,W
03AE6:  MOVWF  FE9
03AE8:  MOVLW  00
03AEA:  ADDWFC x2C,W
03AEC:  MOVWF  FEA
03AEE:  BTFSS  FEF.4
03AF0:  BRA    3B02
....................                { 
....................                   CloseSocket(ps); 
03AF2:  MOVFF  940,947
03AF6:  MOVFF  93F,946
03AFA:  MOVLB  0
03AFC:  CALL   2B16
03B00:  MOVLB  9
....................                } 
....................             } 
....................          } 
....................       } 
03B02:  BRA    3B20
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
03B04:  MOVLB  0
03B06:  CALL   16E0
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
03B0A:  MOVLW  10
03B0C:  MOVLB  9
03B0E:  MOVWF  x41
....................          ack = prevAck; 
03B10:  MOVFF  93A,932
03B14:  MOVFF  939,931
03B18:  MOVFF  938,930
03B1C:  MOVFF  937,92F
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
03B20:  MOVF   x41,F
03B22:  BZ    3B86
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
03B24:  MOVLW  02
03B26:  ADDWF  x2B,W
03B28:  MOVWF  FE9
03B2A:  MOVLW  00
03B2C:  ADDWFC x2C,W
03B2E:  MOVWF  FEA
03B30:  MOVFF  FEC,94D
03B34:  MOVF   FED,F
03B36:  MOVFF  FEF,94C
03B3A:  MOVFF  92B,FE9
03B3E:  MOVFF  92C,FEA
03B42:  MOVFF  FEC,94F
03B46:  MOVF   FED,F
03B48:  MOVFF  FEF,94E
03B4C:  MOVFF  92A,94B
03B50:  MOVFF  929,94A
03B54:  MOVFF  936,953
03B58:  MOVFF  935,952
03B5C:  MOVFF  934,951
03B60:  MOVFF  933,950
03B64:  MOVFF  932,957
03B68:  MOVFF  931,956
03B6C:  MOVFF  930,955
03B70:  MOVFF  92F,954
03B74:  MOVFF  941,958
03B78:  SETF   x59
03B7A:  CLRF   x5B
03B7C:  CLRF   x5A
03B7E:  MOVLB  0
03B80:  CALL   2F52
03B84:  MOVLB  9
....................    } 
03B86:  MOVLB  0
03B88:  GOTO   3D0A (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
03DE4:  MOVLW  09
03DE6:  MOVLB  9
03DE8:  MOVWF  x55
03DEA:  MOVLW  08
03DEC:  MOVWF  x54
03DEE:  MOVFF  955,991
03DF2:  MOVWF  x90
03DF4:  CLRF   x93
03DF6:  MOVWF  x92
03DF8:  MOVLB  0
03DFA:  CALL   1756
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
03DFE:  MOVLB  9
03E00:  CLRF   x53
03E02:  CLRF   x52
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
03E04:  MOVFF  903,03
03E08:  MOVFF  902,FE9
03E0C:  MOVFF  903,FEA
03E10:  MOVFF  FEF,959
03E14:  CLRF   x58
03E16:  MOVLW  14
03E18:  MOVWF  x57
03E1A:  CLRF   x5A
03E1C:  MOVLB  0
03E1E:  CALL   2120
03E22:  MOVFF  02,951
03E26:  MOVFF  01,950
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
03E2A:  MOVLB  9
03E2C:  MOVFF  902,FE9
03E30:  MOVFF  903,FEA
03E34:  MOVLW  08
03E36:  SUBWF  FEF,W
03E38:  MOVWF  FEF
....................     MACGetArray(data, *len); 
03E3A:  MOVFF  903,03
03E3E:  MOVFF  902,FE9
03E42:  MOVFF  903,FEA
03E46:  MOVFF  FEF,992
03E4A:  MOVFF  901,991
03E4E:  MOVFF  900,990
03E52:  CLRF   x93
03E54:  MOVLB  0
03E56:  CALL   1756
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
03E5A:  MOVLW  09
03E5C:  MOVLB  9
03E5E:  MOVWF  x57
03E60:  MOVLW  08
03E62:  MOVWF  x56
03E64:  MOVLB  0
03E66:  RCALL  3D1C
....................  
....................     *code = packet.Type; 
03E68:  MOVLB  8
03E6A:  MOVFF  8FE,FE9
03E6E:  MOVFF  8FF,FEA
03E72:  MOVFF  908,FEF
....................     *id = packet.Identifier; 
03E76:  MOVLB  9
03E78:  MOVFF  904,FE9
03E7C:  MOVFF  905,FEA
03E80:  MOVFF  90D,FEC
03E84:  MOVF   FED,F
03E86:  MOVFF  90C,FEF
....................     *seq = packet.SequenceNumber; 
03E8A:  MOVFF  906,FE9
03E8E:  MOVFF  907,FEA
03E92:  MOVFF  90F,FEC
03E96:  MOVF   FED,F
03E98:  MOVFF  90E,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
03E9C:  MOVF   x52,W
03E9E:  SUBWF  x50,W
03EA0:  BNZ   3EA8
03EA2:  MOVF   x53,W
03EA4:  SUBWF  x51,W
03EA6:  BZ    3EAC
03EA8:  MOVLW  00
03EAA:  BRA    3EAE
03EAC:  MOVLW  01
03EAE:  MOVWF  01
03EB0:  MOVLB  0
03EB2:  GOTO   45BA (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
03EB6:  MOVLW  01
03EB8:  MOVLB  9
03EBA:  MOVWF  x82
03EBC:  MOVLB  0
03EBE:  CALL   1AD2
03EC2:  MOVFF  01,950
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
03EC6:  MOVLB  9
03EC8:  INCFSZ x50,W
03ECA:  BRA    3ECE
....................       return; 
03ECC:  BRA    3FC6
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
03ECE:  MOVFF  950,99B
03ED2:  CLRF   x9D
03ED4:  MOVLW  14
03ED6:  MOVWF  x9C
03ED8:  MOVLB  0
03EDA:  CALL   1AFA
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
03EDE:  CLRF   03
03EE0:  MOVLB  9
03EE2:  MOVF   x01,W
03EE4:  ADDLW  08
03EE6:  MOVWF  x4E
03EE8:  MOVLW  00
03EEA:  ADDWFC 03,W
03EEC:  MOVWF  x4F
....................  
....................     packet.Code             = 0; 
03EEE:  CLRF   x07
....................     packet.Type             = code; 
03EF0:  MOVFF  8FE,906
....................     packet.Checksum         = 0; 
03EF4:  CLRF   x09
03EF6:  CLRF   x08
....................     packet.Identifier       = id; 
03EF8:  MOVFF  903,90B
03EFC:  MOVFF  902,90A
....................     packet.SequenceNumber   = seq; 
03F00:  MOVFF  905,90D
03F04:  MOVFF  904,90C
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
03F08:  MOVLW  09
03F0A:  MOVWF  FEA
03F0C:  MOVLW  0E
03F0E:  MOVWF  FE9
03F10:  MOVFF  900,FE2
03F14:  MOVFF  8FF,FE1
03F18:  MOVF   x01,W
03F1A:  MOVWF  01
03F1C:  BZ    3F26
03F1E:  MOVFF  FE6,FEE
03F22:  DECFSZ 01,F
03F24:  BRA    3F1E
....................  
....................     SwapICMPPacket(&packet); 
03F26:  MOVLW  09
03F28:  MOVWF  x57
03F2A:  MOVLW  06
03F2C:  MOVWF  x56
03F2E:  MOVLB  0
03F30:  RCALL  3D1C
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
03F32:  MOVLW  08
03F34:  MOVLB  9
03F36:  ADDWF  x01,W
03F38:  CLRF   x52
03F3A:  MOVWF  x51
03F3C:  MOVFF  8FD,983
03F40:  MOVFF  8FC,982
03F44:  MOVLW  01
03F46:  MOVWF  x84
03F48:  MOVFF  952,986
03F4C:  MOVFF  951,985
03F50:  MOVLB  0
03F52:  CALL   2E2C
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
03F56:  MOVLW  09
03F58:  MOVLB  9
03F5A:  MOVWF  x52
03F5C:  MOVLW  06
03F5E:  MOVWF  x51
03F60:  MOVFF  952,9A7
03F64:  MOVWF  xA6
03F66:  MOVFF  94F,9A9
03F6A:  MOVFF  94E,9A8
03F6E:  MOVLB  0
03F70:  CALL   1BB6
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
03F74:  MOVLB  9
03F76:  CLRF   x9C
03F78:  MOVLW  14
03F7A:  MOVWF  x9B
03F7C:  MOVFF  94F,99E
03F80:  MOVFF  94E,99D
03F84:  MOVLB  0
03F86:  CALL   2D54
03F8A:  MOVFF  02,909
03F8E:  MOVFF  01,908
....................    IPSetTxBuffer(MyTxBuffer, 2); 
03F92:  MOVFF  950,99B
03F96:  MOVLB  9
03F98:  CLRF   x9D
03F9A:  MOVLW  16
03F9C:  MOVWF  x9C
03F9E:  MOVLB  0
03FA0:  CALL   1AFA
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
03FA4:  MOVLW  09
03FA6:  MOVLB  9
03FA8:  MOVWF  x52
03FAA:  MOVLW  08
03FAC:  MOVWF  x51
03FAE:  MOVFF  952,9A7
03FB2:  MOVWF  xA6
03FB4:  CLRF   xA9
03FB6:  MOVLW  02
03FB8:  MOVWF  xA8
03FBA:  MOVLB  0
03FBC:  CALL   1BB6
.................... #endif 
....................  
....................  
....................     MACFlush(); 
03FC0:  CALL   1CCE
03FC4:  MOVLB  9
03FC6:  MOVLB  0
03FC8:  GOTO   4616 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
03D1C:  MOVLW  04
03D1E:  MOVLB  9
03D20:  ADDWF  x56,W
03D22:  MOVWF  01
03D24:  MOVLW  00
03D26:  ADDWFC x57,W
03D28:  MOVWF  03
03D2A:  MOVFF  01,958
03D2E:  MOVWF  x59
03D30:  MOVLW  04
03D32:  ADDWF  x56,W
03D34:  MOVWF  FE9
03D36:  MOVLW  00
03D38:  ADDWFC x57,W
03D3A:  MOVWF  FEA
03D3C:  MOVFF  FEC,9A2
03D40:  MOVF   FED,F
03D42:  MOVFF  FEF,9A1
03D46:  MOVLB  0
03D48:  CALL   17BA
03D4C:  MOVFF  959,FEA
03D50:  MOVFF  958,FE9
03D54:  MOVFF  02,FEC
03D58:  MOVF   FED,F
03D5A:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
03D5E:  MOVLW  06
03D60:  MOVLB  9
03D62:  ADDWF  x56,W
03D64:  MOVWF  01
03D66:  MOVLW  00
03D68:  ADDWFC x57,W
03D6A:  MOVWF  03
03D6C:  MOVFF  01,958
03D70:  MOVWF  x59
03D72:  MOVLW  06
03D74:  ADDWF  x56,W
03D76:  MOVWF  FE9
03D78:  MOVLW  00
03D7A:  ADDWFC x57,W
03D7C:  MOVWF  FEA
03D7E:  MOVFF  FEC,9A2
03D82:  MOVF   FED,F
03D84:  MOVFF  FEF,9A1
03D88:  MOVLB  0
03D8A:  CALL   17BA
03D8E:  MOVFF  959,FEA
03D92:  MOVFF  958,FE9
03D96:  MOVFF  02,FEC
03D9A:  MOVF   FED,F
03D9C:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
03DA0:  MOVLW  02
03DA2:  MOVLB  9
03DA4:  ADDWF  x56,W
03DA6:  MOVWF  01
03DA8:  MOVLW  00
03DAA:  ADDWFC x57,W
03DAC:  MOVWF  03
03DAE:  MOVFF  01,958
03DB2:  MOVWF  x59
03DB4:  MOVLW  02
03DB6:  ADDWF  x56,W
03DB8:  MOVWF  FE9
03DBA:  MOVLW  00
03DBC:  ADDWFC x57,W
03DBE:  MOVWF  FEA
03DC0:  MOVFF  FEC,9A2
03DC4:  MOVF   FED,F
03DC6:  MOVFF  FEF,9A1
03DCA:  MOVLB  0
03DCC:  CALL   17BA
03DD0:  MOVFF  959,FEA
03DD4:  MOVFF  958,FE9
03DD8:  MOVFF  02,FEC
03DDC:  MOVF   FED,F
03DDE:  MOVFF  01,FEF
03DE2:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
00F9E:  MOVLB  3
00FA0:  BCF    x90.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
00FA2:  MOVLB  8
00FA4:  SETF   x85
....................     Cache.MACAddr.v[1] = 0xff; 
00FA6:  SETF   x86
....................     Cache.MACAddr.v[2] = 0xff; 
00FA8:  SETF   x87
....................     Cache.MACAddr.v[3] = 0xff; 
00FAA:  SETF   x88
....................     Cache.MACAddr.v[4] = 0xff; 
00FAC:  SETF   x89
....................     Cache.MACAddr.v[5] = 0xff; 
00FAE:  SETF   x8A
....................  
....................     Cache.IPAddr.Val = 0x0; 
00FB0:  CLRF   x8E
00FB2:  CLRF   x8D
00FB4:  CLRF   x8C
00FB6:  CLRF   x8B
00FB8:  MOVLB  0
00FBA:  GOTO   127A (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
02082:  MOVLW  00
02084:  MOVLB  3
02086:  BTFSC  x90.1
02088:  MOVLW  01
0208A:  XORLW  00
0208C:  MOVLB  0
0208E:  BZ    2092
02090:  BRA    20F2
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
02092:  MOVLW  08
02094:  MOVLB  9
02096:  MOVWF  x08
02098:  MOVLW  FC
0209A:  MOVWF  x07
0209C:  MOVLW  09
0209E:  MOVWF  x0A
020A0:  MOVLW  06
020A2:  MOVWF  x09
020A4:  MOVLB  0
020A6:  BRA    19DA
020A8:  MOVF   01,F
020AA:  BNZ   20AE
....................             break; 
020AC:  BRA    2118
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
020AE:  CALL   16E0
....................  
....................         if ( opCode == ARP_REPLY ) 
020B2:  MOVLB  9
020B4:  MOVF   x06,F
020B6:  BNZ   20EC
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
020B8:  MOVLW  08
020BA:  MOVWF  FEA
020BC:  MOVLW  85
020BE:  MOVWF  FE9
020C0:  MOVLW  08
020C2:  MOVWF  FE2
020C4:  MOVLW  FC
020C6:  MOVWF  FE1
020C8:  MOVLW  06
020CA:  MOVWF  01
020CC:  MOVFF  FE6,FEE
020D0:  DECFSZ 01,F
020D2:  BRA    20CC
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
020D4:  MOVFF  905,88E
020D8:  MOVFF  904,88D
020DC:  MOVFF  903,88C
020E0:  MOVFF  902,88B
....................             break; 
020E4:  MOVLB  0
020E6:  BRA    2118
....................         } 
020E8:  BRA    20F2
020EA:  MOVLB  9
....................         else 
....................             smARP = SM_ARP_REPLY; 
020EC:  MOVLB  3
020EE:  BSF    x90.1
020F0:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
020F2:  MOVLW  08
020F4:  MOVLB  9
020F6:  MOVWF  x08
020F8:  MOVLW  FC
020FA:  MOVWF  x07
020FC:  CLRF   x09
020FE:  MOVLB  0
02100:  RCALL  1EFE
02102:  MOVF   01,F
02104:  BZ    210E
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
02106:  MOVLB  3
02108:  BCF    x90.1
.................... 		} 
0210A:  BRA    2116
0210C:  MOVLB  0
....................         else 
....................             return FALSE; 
0210E:  MOVLW  00
02110:  MOVWF  01
02112:  BRA    211C
02114:  MOVLB  3
....................         break; 
02116:  MOVLB  0
....................  
....................     } 
....................     return TRUE; 
02118:  MOVLW  01
0211A:  MOVWF  01
0211C:  GOTO   44D8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
04654:  MOVLB  8
04656:  MOVFF  8F9,FE9
0465A:  MOVFF  8FA,FEA
0465E:  MOVFF  FEF,901
04662:  MOVFF  FEC,902
04666:  MOVFF  FEC,903
0466A:  MOVFF  FEC,904
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
0466E:  MOVLW  08
04670:  MOVLB  9
04672:  MOVWF  x08
04674:  MOVLW  FB
04676:  MOVWF  x07
04678:  MOVLW  01
0467A:  MOVWF  x09
0467C:  MOVLB  0
0467E:  CALL   1EFE
04682:  GOTO   5328 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
04686:  MOVLB  8
04688:  MOVFF  8F9,FE9
0468C:  MOVFF  8FA,FEA
04690:  MOVFF  FEF,00
04694:  MOVFF  FEC,01
04698:  MOVFF  FEC,02
0469C:  MOVFF  FEC,03
046A0:  MOVF   00,W
046A2:  SUBWF  x8B,W
046A4:  BNZ   46B8
046A6:  MOVF   01,W
046A8:  SUBWF  x8C,W
046AA:  BNZ   46B8
046AC:  MOVF   02,W
046AE:  SUBWF  x8D,W
046B0:  BNZ   46B8
046B2:  MOVF   03,W
046B4:  SUBWF  x8E,W
046B6:  BZ    46E0
046B8:  MOVLB  3
046BA:  MOVF   x5E,W
046BC:  MOVLB  8
046BE:  SUBWF  x8B,W
046C0:  BNZ   4706
046C2:  MOVLB  3
046C4:  MOVF   x5F,W
046C6:  MOVLB  8
046C8:  SUBWF  x8C,W
046CA:  BNZ   4706
046CC:  MOVLB  3
046CE:  MOVF   x60,W
046D0:  MOVLB  8
046D2:  SUBWF  x8D,W
046D4:  BNZ   4706
046D6:  MOVLB  3
046D8:  MOVF   x61,W
046DA:  MOVLB  8
046DC:  SUBWF  x8E,W
046DE:  BNZ   4706
....................     { 
....................         *MACAddr = Cache.MACAddr; 
046E0:  MOVFF  8FC,03
046E4:  MOVFF  8FB,FE9
046E8:  MOVFF  8FC,FEA
046EC:  MOVLW  08
046EE:  MOVWF  FE2
046F0:  MOVLW  85
046F2:  MOVWF  FE1
046F4:  MOVLW  06
046F6:  MOVWF  01
046F8:  MOVFF  FE6,FEE
046FC:  DECFSZ 01,F
046FE:  BRA    46F8
....................         return TRUE; 
04700:  MOVLW  01
04702:  MOVWF  01
04704:  BRA    470A
....................     } 
....................     return FALSE; 
04706:  MOVLW  00
04708:  MOVWF  01
0470A:  MOVLB  0
0470C:  GOTO   5354 (RETURN)
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
019DA:  MOVLW  09
019DC:  MOVLB  9
019DE:  MOVWF  x91
019E0:  MOVLW  0B
019E2:  MOVWF  x90
019E4:  CLRF   x93
019E6:  MOVLW  1C
019E8:  MOVWF  x92
019EA:  MOVLB  0
019EC:  RCALL  1756
....................  
....................     MACDiscardRx(); 
019EE:  RCALL  16E0
....................  
....................     SwapARPPacket(&packet); 
019F0:  MOVLW  09
019F2:  MOVLB  9
019F4:  MOVWF  x28
019F6:  MOVLW  0B
019F8:  MOVWF  x27
019FA:  MOVLB  0
019FC:  RCALL  191E
....................  
....................    debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
019FE:  MOVLB  9
01A00:  DECFSZ x0B,W
01A02:  BRA    1A14
01A04:  MOVF   x0C,F
01A06:  BNZ   1A14
01A08:  MOVF   x0F,W
01A0A:  SUBLW  06
01A0C:  BNZ   1A14
01A0E:  MOVF   x10,W
01A10:  SUBLW  04
01A12:  BZ    1A1A
....................          return FALSE; 
01A14:  MOVLW  00
01A16:  MOVWF  01
01A18:  BRA    1ACC
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
01A1A:  MOVF   x11,W
01A1C:  SUBLW  02
01A1E:  BNZ   1A34
01A20:  MOVF   x12,F
01A22:  BNZ   1A34
....................         *opCode = ARP_REPLY; 
01A24:  MOVFF  90A,03
01A28:  MOVFF  909,FE9
01A2C:  MOVFF  90A,FEA
01A30:  CLRF   FEF
01A32:  BRA    1A60
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
01A34:  DECFSZ x11,W
01A36:  BRA    1A4E
01A38:  MOVF   x12,F
01A3A:  BNZ   1A4E
....................         *opCode = ARP_REQUEST; 
01A3C:  MOVFF  90A,03
01A40:  MOVFF  909,FE9
01A44:  MOVFF  90A,FEA
01A48:  MOVLW  01
01A4A:  MOVWF  FEF
01A4C:  BRA    1A60
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
01A4E:  MOVFF  909,FE9
01A52:  MOVFF  90A,FEA
01A56:  MOVLW  02
01A58:  MOVWF  FEF
....................         return FALSE; 
01A5A:  MOVLW  00
01A5C:  MOVWF  01
01A5E:  BRA    1ACC
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
01A60:  MOVLB  3
01A62:  MOVF   x50,W
01A64:  MOVLB  9
01A66:  SUBWF  x23,W
01A68:  BNZ   1AC8
01A6A:  MOVLB  3
01A6C:  MOVF   x51,W
01A6E:  MOVLB  9
01A70:  SUBWF  x24,W
01A72:  BNZ   1AC8
01A74:  MOVLB  3
01A76:  MOVF   x52,W
01A78:  MOVLB  9
01A7A:  SUBWF  x25,W
01A7C:  BNZ   1AC8
01A7E:  MOVLB  3
01A80:  MOVF   x53,W
01A82:  MOVLB  9
01A84:  SUBWF  x26,W
01A86:  BNZ   1AC8
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
01A88:  MOVFF  907,FE9
01A8C:  MOVFF  908,FEA
01A90:  MOVLW  09
01A92:  MOVWF  FE2
01A94:  MOVLW  13
01A96:  MOVWF  FE1
01A98:  MOVLW  06
01A9A:  MOVWF  01
01A9C:  MOVFF  FE6,FEE
01AA0:  DECFSZ 01,F
01AA2:  BRA    1A9C
....................         remote->IPAddr      = packet.SenderIPAddr; 
01AA4:  MOVLW  06
01AA6:  ADDWF  x07,W
01AA8:  MOVWF  FE9
01AAA:  MOVLW  00
01AAC:  ADDWFC x08,W
01AAE:  MOVWF  FEA
01AB0:  MOVFF  919,FEF
01AB4:  MOVFF  91A,FEC
01AB8:  MOVFF  91B,FEC
01ABC:  MOVFF  91C,FEC
....................         return TRUE; 
01AC0:  MOVLW  01
01AC2:  MOVWF  01
01AC4:  BRA    1ACC
....................     } 
01AC6:  BRA    1ACC
....................     else 
....................         return FALSE; 
01AC8:  MOVLW  00
01ACA:  MOVWF  01
01ACC:  MOVLB  0
01ACE:  GOTO   20A8 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
01EFE:  MOVLW  01
01F00:  MOVLB  9
01F02:  MOVWF  x82
01F04:  MOVLB  0
01F06:  RCALL  1AD2
01F08:  MOVFF  01,926
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
01F0C:  MOVLB  9
01F0E:  INCFSZ x26,W
01F10:  BRA    1F18
....................       return FALSE; 
01F12:  MOVLW  00
01F14:  MOVWF  01
01F16:  BRA    207E
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
01F18:  MOVFF  926,99B
01F1C:  CLRF   x9D
01F1E:  CLRF   x9C
01F20:  MOVLB  0
01F22:  RCALL  1AFA
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
01F24:  MOVLB  9
01F26:  CLRF   x0B
01F28:  MOVLW  01
01F2A:  MOVWF  x0A
....................     packet.Protocol                 = ARP_IP; 
01F2C:  MOVLW  08
01F2E:  MOVWF  x0D
01F30:  CLRF   x0C
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
01F32:  MOVLW  06
01F34:  MOVWF  x0E
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
01F36:  MOVLW  04
01F38:  MOVWF  x0F
....................  
....................     if ( opCode == ARP_REQUEST ) 
01F3A:  DECFSZ x09,W
01F3C:  BRA    1F52
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
01F3E:  CLRF   x11
01F40:  MOVLW  01
01F42:  MOVWF  x10
....................         packet.TargetMACAddr.v[0]   = 0xff; 
01F44:  SETF   x1C
....................         packet.TargetMACAddr.v[1]   = 0xff; 
01F46:  SETF   x1D
....................         packet.TargetMACAddr.v[2]   = 0xff; 
01F48:  SETF   x1E
....................         packet.TargetMACAddr.v[3]   = 0xff; 
01F4A:  SETF   x1F
....................         packet.TargetMACAddr.v[4]   = 0xff; 
01F4C:  SETF   x20
....................         packet.TargetMACAddr.v[5]   = 0xff; 
01F4E:  SETF   x21
....................     } 
01F50:  BRA    1F74
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
01F52:  CLRF   x11
01F54:  MOVLW  02
01F56:  MOVWF  x10
....................         packet.TargetMACAddr        = remote->MACAddr; 
01F58:  MOVFF  907,FE1
01F5C:  MOVFF  908,FE2
01F60:  MOVLW  09
01F62:  MOVWF  FEA
01F64:  MOVLW  1C
01F66:  MOVWF  FE9
01F68:  MOVLW  06
01F6A:  MOVWF  01
01F6C:  MOVFF  FE6,FEE
01F70:  DECFSZ 01,F
01F72:  BRA    1F6C
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
01F74:  MOVLW  09
01F76:  MOVWF  FEA
01F78:  MOVLW  12
01F7A:  MOVWF  FE9
01F7C:  MOVLW  03
01F7E:  MOVWF  FE2
01F80:  MOVLW  54
01F82:  MOVWF  FE1
01F84:  MOVLW  06
01F86:  MOVWF  01
01F88:  MOVFF  FE6,FEE
01F8C:  DECFSZ 01,F
01F8E:  BRA    1F88
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
01F90:  MOVFF  353,91B
01F94:  MOVFF  352,91A
01F98:  MOVFF  351,919
01F9C:  MOVFF  350,918
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
01FA0:  MOVLW  06
01FA2:  ADDWF  x07,W
01FA4:  MOVWF  FE9
01FA6:  MOVLW  00
01FA8:  ADDWFC x08,W
01FAA:  MOVWF  FEA
01FAC:  MOVFF  FEF,00
01FB0:  MOVFF  FEC,01
01FB4:  MOVFF  FEC,02
01FB8:  MOVFF  FEC,03
01FBC:  MOVF   00,W
01FBE:  XORWF  x18,W
01FC0:  MOVWF  x27
01FC2:  MOVF   01,W
01FC4:  XORWF  x19,W
01FC6:  MOVWF  x28
01FC8:  MOVF   02,W
01FCA:  XORWF  x1A,W
01FCC:  MOVWF  x29
01FCE:  MOVF   03,W
01FD0:  XORWF  x1B,W
01FD2:  MOVWF  x2A
01FD4:  MOVF   x27,W
01FD6:  MOVLB  3
01FD8:  ANDWF  x5A,W
01FDA:  MOVWF  00
01FDC:  MOVLB  9
01FDE:  MOVF   x28,W
01FE0:  MOVLB  3
01FE2:  ANDWF  x5B,W
01FE4:  MOVWF  01
01FE6:  MOVLB  9
01FE8:  MOVF   x29,W
01FEA:  MOVLB  3
01FEC:  ANDWF  x5C,W
01FEE:  MOVWF  02
01FF0:  MOVLB  9
01FF2:  MOVF   x2A,W
01FF4:  MOVLB  3
01FF6:  ANDWF  x5D,W
01FF8:  MOVWF  03
01FFA:  MOVF   00,F
01FFC:  BNZ   200A
01FFE:  MOVF   01,F
02000:  BNZ   200A
02002:  MOVF   02,F
02004:  BNZ   200A
02006:  MOVF   03,F
02008:  BZ    201C
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
0200A:  MOVFF  361,925
0200E:  MOVFF  360,924
02012:  MOVFF  35F,923
02016:  MOVFF  35E,922
....................     } 
0201A:  BRA    203C
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
0201C:  MOVLW  06
0201E:  MOVLB  9
02020:  ADDWF  x07,W
02022:  MOVWF  FE9
02024:  MOVLW  00
02026:  ADDWFC x08,W
02028:  MOVWF  FEA
0202A:  MOVFF  FEF,922
0202E:  MOVFF  FEC,923
02032:  MOVFF  FEC,924
02036:  MOVFF  FEC,925
0203A:  MOVLB  3
....................  
....................     SwapARPPacket(&packet); 
0203C:  MOVLW  09
0203E:  MOVLB  9
02040:  MOVWF  x28
02042:  MOVLW  0A
02044:  MOVWF  x27
02046:  MOVLB  0
02048:  RCALL  191E
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
0204A:  MOVLW  09
0204C:  MOVLB  9
0204E:  MOVWF  xA0
02050:  MOVLW  1C
02052:  MOVWF  x9F
02054:  MOVLW  06
02056:  MOVWF  xA1
02058:  CLRF   xA3
0205A:  MOVLW  1C
0205C:  MOVWF  xA2
0205E:  MOVLB  0
02060:  RCALL  1C00
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
02062:  MOVLW  09
02064:  MOVLB  9
02066:  MOVWF  xA7
02068:  MOVLW  0A
0206A:  MOVWF  xA6
0206C:  CLRF   xA9
0206E:  MOVLW  1C
02070:  MOVWF  xA8
02072:  MOVLB  0
02074:  RCALL  1BB6
....................  
....................     MACFlush(); 
02076:  RCALL  1CCE
....................     
....................    return TRUE; 
02078:  MOVLW  01
0207A:  MOVWF  01
0207C:  MOVLB  9
0207E:  MOVLB  0
02080:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
0191E:  MOVLB  9
01920:  MOVFF  927,01
01924:  MOVFF  928,03
01928:  MOVFF  927,929
0192C:  MOVFF  928,92A
01930:  MOVFF  927,FE9
01934:  MOVFF  928,FEA
01938:  MOVFF  FEC,9A2
0193C:  MOVF   FED,F
0193E:  MOVFF  FEF,9A1
01942:  MOVLB  0
01944:  RCALL  17BA
01946:  MOVFF  92A,FEA
0194A:  MOVFF  929,FE9
0194E:  MOVFF  02,FEC
01952:  MOVF   FED,F
01954:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
01958:  MOVLW  02
0195A:  MOVLB  9
0195C:  ADDWF  x27,W
0195E:  MOVWF  01
01960:  MOVLW  00
01962:  ADDWFC x28,W
01964:  MOVWF  03
01966:  MOVFF  01,929
0196A:  MOVWF  x2A
0196C:  MOVLW  02
0196E:  ADDWF  x27,W
01970:  MOVWF  FE9
01972:  MOVLW  00
01974:  ADDWFC x28,W
01976:  MOVWF  FEA
01978:  MOVFF  FEC,9A2
0197C:  MOVF   FED,F
0197E:  MOVFF  FEF,9A1
01982:  MOVLB  0
01984:  RCALL  17BA
01986:  MOVFF  92A,FEA
0198A:  MOVFF  929,FE9
0198E:  MOVFF  02,FEC
01992:  MOVF   FED,F
01994:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
01998:  MOVLW  06
0199A:  MOVLB  9
0199C:  ADDWF  x27,W
0199E:  MOVWF  01
019A0:  MOVLW  00
019A2:  ADDWFC x28,W
019A4:  MOVWF  03
019A6:  MOVFF  01,929
019AA:  MOVWF  x2A
019AC:  MOVLW  06
019AE:  ADDWF  x27,W
019B0:  MOVWF  FE9
019B2:  MOVLW  00
019B4:  ADDWFC x28,W
019B6:  MOVWF  FEA
019B8:  MOVFF  FEC,9A2
019BC:  MOVF   FED,F
019BE:  MOVFF  FEF,9A1
019C2:  MOVLB  0
019C4:  RCALL  17BA
019C6:  MOVFF  92A,FEA
019CA:  MOVFF  929,FE9
019CE:  MOVFF  02,FEC
019D2:  MOVF   FED,F
019D4:  MOVFF  01,FEF
019D8:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
0126E:  MOVLB  8
01270:  CLRF   x8F
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
01272:  MOVLB  0
01274:  BRA    0AA0
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
01276:  BRA    0DCC
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
01278:  BRA    0F9E
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
0127A:  BRA    111C
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
0127C:  GOTO   6C4C (RETURN)
....................    TFTPInit(); 
.................... #endif 
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
04478:  MOVLB  8
0447A:  BCF    xFB.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
0447C:  BCF    xFB.0
....................         switch(smStack) 
0447E:  MOVF   x8F,W
04480:  ADDLW  F9
04482:  BTFSC  FD8.0
04484:  BRA    4622
04486:  ADDLW  07
04488:  MOVLB  0
0448A:  GOTO   462C
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
0448E:  MOVLW  08
04490:  MOVLB  8
04492:  MOVWF  xFD
04494:  MOVLW  90
04496:  MOVWF  xFC
04498:  MOVLW  08
0449A:  MOVWF  xFF
0449C:  MOVLW  FA
0449E:  MOVWF  xFE
044A0:  MOVLB  0
044A2:  GOTO   17D0
044A6:  MOVF   01,F
044A8:  BNZ   44B0
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
044AA:  MOVLB  8
044AC:  BRA    4622
044AE:  MOVLB  0
....................             } 
....................  
....................             debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
044B0:  MOVLB  8
044B2:  BSF    xFB.0
....................             if ( type.MACFrameType == MAC_IP ) { 
044B4:  MOVF   xFA,F
044B6:  BNZ   44BE
....................                 smStack = SM_STACK_IP; 
044B8:  MOVLW  02
044BA:  MOVWF  x8F
....................                 debug_stack(debug_putc, "IP "); 
....................             } 
044BC:  BRA    44D2
....................             else if ( type.MACFrameType == MAC_ARP ) { 
044BE:  MOVF   xFA,W
044C0:  SUBLW  06
044C2:  BNZ   44CA
....................                 smStack = SM_STACK_ARP; 
044C4:  MOVLW  05
044C6:  MOVWF  x8F
....................                 debug_stack(debug_putc, "ARP "); 
....................             } 
044C8:  BRA    44D2
....................             else { 
....................                 MACDiscardRx(); 
044CA:  MOVLB  0
044CC:  CALL   16E0
044D0:  MOVLB  8
....................                 debug_stack(debug_putc, "DISCARD"); 
....................             } 
....................             break; 
044D2:  BRA    4622
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
044D4:  GOTO   2082
044D8:  MOVF   01,F
044DA:  BZ    44E2
....................                 smStack = SM_STACK_IDLE; 
044DC:  MOVLB  8
044DE:  CLRF   x8F
044E0:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
044E2:  MOVLB  8
044E4:  BRA    4622
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
044E6:  MOVLW  08
044E8:  MOVLB  8
044EA:  MOVWF  xFD
044EC:  MOVLW  F6
044EE:  MOVWF  xFC
044F0:  MOVLW  08
044F2:  MOVWF  xFF
044F4:  MOVLW  90
044F6:  MOVWF  xFE
044F8:  MOVLW  08
044FA:  MOVLB  9
044FC:  MOVWF  x01
044FE:  MOVLW  FA
04500:  MOVWF  x00
04502:  MOVLW  08
04504:  MOVWF  x03
04506:  MOVLW  9A
04508:  MOVWF  x02
0450A:  MOVLB  0
0450C:  GOTO   2378
04510:  MOVF   01,F
04512:  BZ    453E
....................             { 
....................                 lbContinue = TRUE; 
04514:  MOVLB  8
04516:  BSF    xFB.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
04518:  DECFSZ xFA,W
0451A:  BRA    4522
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
0451C:  MOVLW  03
0451E:  MOVWF  x8F
....................                     debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
04520:  BRA    453A
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
04522:  MOVF   xFA,W
04524:  SUBLW  06
04526:  BNZ   452E
....................                     smStack = SM_STACK_TCP; 
04528:  MOVLW  06
0452A:  MOVWF  x8F
....................                     debug_stack(debug_putc, "TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
0452C:  BRA    453A
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack(debug_putc, "UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
0452E:  BCF    xFB.0
....................                     MACDiscardRx(); 
04530:  MOVLB  0
04532:  CALL   16E0
....................  
....................                     smStack = SM_STACK_IDLE; 
04536:  MOVLB  8
04538:  CLRF   x8F
....................                     debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................                 } 
....................             } 
0453A:  BRA    4546
0453C:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
0453E:  CALL   16E0
....................                 smStack = SM_STACK_IDLE; 
04542:  MOVLB  8
04544:  CLRF   x8F
....................                 debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................             } 
....................             break; 
04546:  BRA    4622
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
04548:  MOVLW  08
0454A:  MOVLB  8
0454C:  MOVWF  xFD
0454E:  MOVLW  90
04550:  MOVWF  xFC
04552:  MOVLW  08
04554:  MOVWF  xFF
04556:  MOVLW  F6
04558:  MOVWF  xFE
0455A:  MOVFF  89B,901
0455E:  MOVFF  89A,900
04562:  MOVLB  0
04564:  GOTO   3B8C
04568:  MOVF   01,F
0456A:  BZ    4572
....................             { 
....................                 debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
0456C:  MOVLB  8
0456E:  CLRF   x8F
04570:  MOVLB  0
....................             } 
....................             break; 
04572:  MOVLB  8
04574:  BRA    4622
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
04576:  MOVLB  8
04578:  CLRF   x8F
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
0457A:  MOVF   x9B,F
0457C:  BNZ   45CC
0457E:  MOVF   x9A,W
04580:  SUBLW  48
04582:  BNC   45CC
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
04584:  MOVLW  08
04586:  MOVWF  xFD
04588:  MOVLW  9A
0458A:  MOVWF  xFC
0458C:  MOVLW  08
0458E:  MOVWF  xFF
04590:  MOVLW  FA
04592:  MOVWF  xFE
04594:  MOVLW  08
04596:  MOVLB  9
04598:  MOVWF  x01
0459A:  MOVLW  9C
0459C:  MOVWF  x00
0459E:  MOVFF  8FD,903
045A2:  MOVFF  8FC,902
045A6:  MOVLW  08
045A8:  MOVWF  x05
045AA:  MOVLW  DC
045AC:  MOVWF  x04
045AE:  MOVLW  08
045B0:  MOVWF  x07
045B2:  MOVLW  DE
045B4:  MOVWF  x06
045B6:  MOVLB  0
045B8:  BRA    3DE4
045BA:  MOVF   01,F
045BC:  BZ    45CE
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
045BE:  MOVLB  8
045C0:  MOVF   xFA,W
045C2:  SUBLW  08
045C4:  BNZ   45CC
....................                     { 
....................                         debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
045C6:  BSF    xFB.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
045C8:  MOVLW  04
045CA:  MOVWF  x8F
045CC:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
045CE:  CALL   16E0
....................             break; 
045D2:  MOVLB  8
045D4:  BRA    4622
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
045D6:  MOVLW  01
045D8:  MOVLB  9
045DA:  MOVWF  x82
045DC:  MOVLB  0
045DE:  CALL   2C14
045E2:  MOVF   01,F
045E4:  BZ    461C
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
045E6:  MOVLW  08
045E8:  MOVLB  8
045EA:  MOVWF  xFD
045EC:  MOVLW  90
045EE:  MOVWF  xFC
045F0:  CLRF   xFE
045F2:  MOVLW  08
045F4:  MOVLB  9
045F6:  MOVWF  x00
045F8:  MOVLW  9C
045FA:  MOVLB  8
045FC:  MOVWF  xFF
045FE:  MOVFF  89A,901
04602:  MOVFF  8DD,903
04606:  MOVFF  8DC,902
0460A:  MOVFF  8DF,905
0460E:  MOVFF  8DE,904
04612:  MOVLB  0
04614:  BRA    3EB6
....................  
....................                 debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
04616:  MOVLB  8
04618:  CLRF   x8F
0461A:  MOVLB  0
....................             } 
....................             break; 
0461C:  MOVLB  8
0461E:  BRA    4622
04620:  MOVLB  8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
04622:  BTFSC  xFB.0
04624:  BRA    447C
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
04626:  MOVLB  0
04628:  BRA    3FCC
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
0462A:  RETURN 0
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
....................  
....................  
.................... // Dirección IP de la PC (destino). 
.................... IP_ADDR server; 
.................... // Puerto TCP. 
.................... #define EXAMPLE_TCP_PORT   (int16)7654 
.................... //int reintento_envio; 
.................... // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX. 
....................  
.................... void MACAddrInit(void) 
.................... { 
....................    MY_MAC_BYTE1=0x00; 
*
00A3E:  MOVLB  3
00A40:  CLRF   x54
....................    MY_MAC_BYTE2=0x04; 
00A42:  MOVLW  04
00A44:  MOVWF  x55
....................    MY_MAC_BYTE3=0xA3; 
00A46:  MOVLW  A3
00A48:  MOVWF  x56
....................    MY_MAC_BYTE4=0x00; 
00A4A:  CLRF   x57
....................    MY_MAC_BYTE5=0x00; 
00A4C:  CLRF   x58
....................    MY_MAC_BYTE6=0x11; 
00A4E:  MOVLW  11
00A50:  MOVWF  x59
00A52:  MOVLB  0
00A54:  GOTO   6C40 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    // IP del dispositivo. 
....................    MY_IP_BYTE1=192; 
00A58:  MOVLW  C0
00A5A:  MOVLB  3
00A5C:  MOVWF  x50
....................    MY_IP_BYTE2=168; 
00A5E:  MOVLW  A8
00A60:  MOVWF  x51
....................    MY_IP_BYTE3=1; 
00A62:  MOVLW  01
00A64:  MOVWF  x52
....................    MY_IP_BYTE4=151; 
00A66:  MOVLW  97
00A68:  MOVWF  x53
....................  
....................    // Puerta de enlace. 
....................    MY_GATE_BYTE1=192; 
00A6A:  MOVLW  C0
00A6C:  MOVWF  x5E
....................    MY_GATE_BYTE2=168; 
00A6E:  MOVLW  A8
00A70:  MOVWF  x5F
....................    MY_GATE_BYTE3=1; 
00A72:  MOVLW  01
00A74:  MOVWF  x60
....................    MY_GATE_BYTE4=254; 
00A76:  MOVLW  FE
00A78:  MOVWF  x61
....................  
....................    // Máscara de Subred. 
....................    MY_MASK_BYTE1=255; 
00A7A:  SETF   x5A
....................    MY_MASK_BYTE2=255; 
00A7C:  SETF   x5B
....................    MY_MASK_BYTE3=255; 
00A7E:  SETF   x5C
....................    MY_MASK_BYTE4=0; 
00A80:  CLRF   x5D
00A82:  MOVLB  0
00A84:  GOTO   6C44 (RETURN)
.................... } 
....................  
.................... void ServerAddrInit(void) { 
....................    // IP del servidor.. 
....................    server.v[0]=192; 
00A88:  MOVLW  C0
00A8A:  MOVLB  8
00A8C:  MOVWF  xE0
....................    server.v[1]=168; 
00A8E:  MOVLW  A8
00A90:  MOVWF  xE1
....................    server.v[2]=1; 
00A92:  MOVLW  01
00A94:  MOVWF  xE2
....................    server.v[3]=150; 
00A96:  MOVLW  96
00A98:  MOVWF  xE3
00A9A:  MOVLB  0
00A9C:  GOTO   6C48 (RETURN)
.................... } 
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
....................  
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    //static int8 counter; 
....................    //char str[20]; 
....................    static int8 button1_held; 
....................     
....................    if (TCPIsGetReady(socket)) {//ESCUCHA PUERTO TCP 
*
051A2:  MOVFF  8F9,8FB
051A6:  GOTO   4962
051AA:  MOVF   01,F
051AC:  BZ    5230
....................       //fprintf(DEBUG,"\r\nLEE SOCKET"); 
.................... //   if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      lcd_putc("LEE SOCKET          ");         } 
....................       edo_str=1;//bandera de dato recibido en socket actual 
051AE:  MOVLW  01
051B0:  MOVWF  4E
....................       i=0; 
051B2:  CLRF   41
051B4:  CLRF   40
....................       while ( TCPGet(socket, &c) ) { 
051B6:  MOVFF  8F9,8FB
051BA:  MOVLW  08
051BC:  MOVLB  8
051BE:  MOVWF  xFD
051C0:  MOVLW  FA
051C2:  MOVWF  xFC
051C4:  MOVLB  0
051C6:  GOTO   49A2
051CA:  MOVF   01,F
051CC:  BZ    5230
....................          rxtcp[i++]=c; 
051CE:  MOVFF  41,03
051D2:  MOVF   40,W
051D4:  INCF   40,F
051D6:  BTFSC  FD8.2
051D8:  INCF   41,F
051DA:  MOVLB  8
051DC:  MOVWF  xFB
051DE:  MOVLW  60
051E0:  ADDWF  xFB,W
051E2:  MOVWF  FE9
051E4:  MOVLW  01
051E6:  ADDWFC 03,W
051E8:  MOVWF  FEA
051EA:  MOVFF  8FA,FEF
....................          if (c=='@') { 
051EE:  MOVF   xFA,W
051F0:  SUBLW  40
051F2:  BNZ   520E
....................             edo_str=0; 
051F4:  CLRF   4E
....................             lcd_gotoxy(20,4); 
051F6:  MOVLW  14
051F8:  MOVWF  xFD
051FA:  MOVLW  04
051FC:  MOVWF  xFE
051FE:  MOVLB  0
05200:  CALL   05DE
....................             printf(lcd_putc,"%c",c); 
05204:  MOVFF  8FA,8FC
05208:  CALL   0632
0520C:  MOVLB  8
....................          } 
....................          if (i>port_size) {i=port_size;} 
0520E:  MOVF   41,F
05210:  BNZ   5218
05212:  MOVF   40,W
05214:  SUBLW  5A
05216:  BC    521E
05218:  CLRF   41
0521A:  MOVLW  5A
0521C:  MOVWF  40
....................          rxtcp[i]=0; 
0521E:  MOVLW  60
05220:  ADDWF  40,W
05222:  MOVWF  FE9
05224:  MOVLW  01
05226:  ADDWFC 41,W
05228:  MOVWF  FEA
0522A:  CLRF   FEF
0522C:  MOVLB  0
0522E:  BRA    51B6
....................       } 
....................    } 
....................  
.................... //send message over TCP 
....................    //if(envia_pc) fprintf(DEBUG,"envia_pc:%u !button1_held:%u TCPIsPutReady(socket):%u\r\n",envia_pc,button1_held, TCPIsPutReady(socket) ); 
....................    if (envia_pc && !button1_held && TCPIsPutReady(socket)) {//ENVIA MENSAJE POR TCP 
05230:  MOVF   1A,F
05232:  BZ    5272
05234:  MOVLB  8
05236:  MOVF   xE4,F
05238:  BTFSC  FD8.2
0523A:  BRA    5240
0523C:  MOVLB  0
0523E:  BRA    5272
05240:  MOVFF  8F9,909
05244:  MOVLB  0
05246:  RCALL  4A8E
05248:  MOVF   01,F
0524A:  BZ    5272
....................       button1_held=TRUE; 
0524C:  MOVLW  01
0524E:  MOVLB  8
05250:  MOVWF  xE4
....................       TCPPutArray(socket,txtcp,size_tx_tcp);//SOCKET,DATO,NO.BYTES 
05252:  MOVFF  8F9,8FB
05256:  MOVWF  xFD
05258:  MOVLW  06
0525A:  MOVWF  xFC
0525C:  CLRF   xFF
0525E:  MOVFF  48,8FE
05262:  MOVLB  0
05264:  BRA    4E3A
....................       TCPFlush(socket); 
05266:  MOVFF  8F9,904
0526A:  RCALL  4C9A
....................       reintento_envio=0; 
0526C:  CLRF   4F
....................       envia_pc=0; 
0526E:  CLRF   1A
....................       //fprintf(DEBUG,"Envio:%s\r\n",txtcp); 
.................... //      if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      printf(lcd_putc,"Envio:%s       ",txtcp);} 
....................    }////////////////// 
05270:  BRA    529C
....................    else if (envia_pc && !button1_held && !TCPIsPutReady(socket)) {//SI NO PUEDE VACIAR DATOS ROMPE CONEXION 
05272:  MOVF   1A,F
05274:  BZ    529C
05276:  MOVLB  8
05278:  MOVF   xE4,F
0527A:  BTFSC  FD8.2
0527C:  BRA    5282
0527E:  MOVLB  0
05280:  BRA    529C
05282:  MOVFF  8F9,909
05286:  MOVLB  0
05288:  RCALL  4A8E
0528A:  MOVF   01,F
0528C:  BNZ   529C
....................       reintento_envio++; 
0528E:  INCF   4F,F
....................       if(reintento_envio>=10) TCPDisconnect(socket); 
05290:  MOVF   4F,W
05292:  SUBLW  09
05294:  BC    529C
05296:  MOVFF  8F9,8FB
0529A:  RCALL  5080
....................    }/////////////////// 
....................     
....................    if (!envia_pc) { 
0529C:  MOVF   1A,F
0529E:  BNZ   52A6
....................       button1_held=FALSE; 
052A0:  MOVLB  8
052A2:  CLRF   xE4
052A4:  MOVLB  0
....................    } 
....................     
....................    //#if defined(ESTADO_entrada04)//CIERRA LAS CONEXIONES 
....................    //if (ESTADO_entrada04) { 
....................      // return(TRUE); 
....................    //} 
....................   //#endif 
....................  
....................    return(TRUE); 
052A6:  MOVLW  01
052A8:  MOVWF  01
052AA:  GOTO   54F8 (RETURN)
.................... } 
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_ARP_REQ=1, MYTCP_STATE_ARP_WAIT=2, 
....................       MYTCP_STATE_CONNECT=3, MYTCP_STATE_CONNECT_WAIT=4, 
....................       MYTCP_STATE_CONNECTED=5, MYTCP_STATE_DISCONNECT=6, 
....................       MYTCP_STATE_FORCE_DISCONNECT=7 
....................    } state=0; 
....................    static NODE_INFO remote; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................  
....................    currTick=TickGet(); 
052AE:  CALL   2AFC
052B2:  MOVFF  02,8F7
052B6:  MOVFF  01,8F6
....................  
....................    switch (state) { 
052BA:  MOVLB  8
052BC:  MOVF   xE8,W
052BE:  ADDLW  F8
052C0:  BTFSC  FD8.0
052C2:  BRA    55EC
052C4:  ADDLW  08
052C6:  MOVLB  0
052C8:  GOTO   55F0
....................       case MYTCP_STATE_NEW: 
....................          memcpy(&remote.IPAddr, &server, sizeof(IP_ADDR)); 
052CC:  MOVFF  8E0,8EF
052D0:  MOVFF  8E1,8F0
052D4:  MOVFF  8E2,8F1
052D8:  MOVFF  8E3,8F2
....................          //fprintf(DEBUG,"\n Solicitud ARP."); 
....................          if(!espera)   { 
052DC:  MOVLB  2
052DE:  MOVF   x7D,F
052E0:  BNZ   5300
....................          lcd_gotoxy(1,4); 
052E2:  MOVLW  01
052E4:  MOVLB  8
052E6:  MOVWF  xFD
052E8:  MOVLW  04
052EA:  MOVWF  xFE
052EC:  MOVLB  0
052EE:  CALL   05DE
....................          lcd_putc("Solicitud ARP.      ");} 
052F2:  MOVLW  2A
052F4:  MOVWF  FF6
052F6:  MOVLW  01
052F8:  MOVWF  FF7
052FA:  CALL   0696
052FE:  MOVLB  2
....................          state=MYTCP_STATE_ARP_REQ; 
05300:  MOVLW  01
05302:  MOVLB  8
05304:  MOVWF  xE8
05306:  MOVLB  0
....................  
....................       case MYTCP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
05308:  MOVLW  01
0530A:  MOVLB  9
0530C:  MOVWF  x82
0530E:  MOVLB  0
05310:  CALL   2C14
05314:  MOVF   01,F
05316:  BZ    5338
....................             ARPResolve(&remote.IPAddr); 
05318:  MOVLW  08
0531A:  MOVLB  8
0531C:  MOVWF  xFA
0531E:  MOVLW  EF
05320:  MOVWF  xF9
05322:  MOVLB  0
05324:  GOTO   4654
....................             lastTick=currTick; 
05328:  MOVFF  8F7,8E6
0532C:  MOVFF  8F6,8E5
....................             state=MYTCP_STATE_ARP_WAIT; 
05330:  MOVLW  02
05332:  MOVLB  8
05334:  MOVWF  xE8
05336:  MOVLB  0
....................          } 
....................          break; 
05338:  MOVLB  8
0533A:  BRA    55EC
....................  
....................       case MYTCP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) { 
0533C:  MOVLW  08
0533E:  MOVLB  8
05340:  MOVWF  xFA
05342:  MOVLW  EF
05344:  MOVWF  xF9
05346:  MOVLW  08
05348:  MOVWF  xFC
0534A:  MOVLW  E9
0534C:  MOVWF  xFB
0534E:  MOVLB  0
05350:  GOTO   4686
05354:  MOVF   01,F
05356:  BZ    5384
....................             state=MYTCP_STATE_CONNECT; 
05358:  MOVLW  03
0535A:  MOVLB  8
0535C:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTANDO...      "); 
....................             if(!espera)   { 
0535E:  MOVLB  2
05360:  MOVF   x7D,F
05362:  BNZ   5382
....................             lcd_gotoxy(1,4); 
05364:  MOVLW  01
05366:  MOVLB  8
05368:  MOVWF  xFD
0536A:  MOVLW  04
0536C:  MOVWF  xFE
0536E:  MOVLB  0
05370:  CALL   05DE
....................             lcd_putc("CONECTANDO...       ");} 
05374:  MOVLW  40
05376:  MOVWF  FF6
05378:  MOVLW  01
0537A:  MOVWF  FF7
0537C:  CALL   0696
05380:  MOVLB  2
....................          } 
05382:  BRA    53DE
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) { 
05384:  MOVLB  8
05386:  MOVF   xF7,W
05388:  SUBWF  xE6,W
0538A:  BNC   5394
0538C:  BNZ   5398
0538E:  MOVF   xE5,W
05390:  SUBWF  xF6,W
05392:  BNC   5398
05394:  MOVLW  00
05396:  BRA    539A
05398:  MOVLW  01
0539A:  CLRF   03
0539C:  IORWF  03,W
0539E:  BZ    53C6
053A0:  MOVLW  FF
053A2:  BSF    FD8.0
053A4:  SUBFWB xE5,W
053A6:  MOVWF  xF9
053A8:  MOVLW  FF
053AA:  SUBFWB xE6,W
053AC:  MOVWF  xFA
053AE:  MOVF   xF6,W
053B0:  ADDWF  xF9,F
053B2:  MOVF   xF7,W
053B4:  ADDWFC xFA,F
053B6:  MOVLW  01
053B8:  ADDWF  xF9,W
053BA:  MOVWF  01
053BC:  MOVLW  00
053BE:  ADDWFC xFA,W
053C0:  MOVWF  03
053C2:  MOVF   01,W
053C4:  BRA    53D4
053C6:  MOVF   xE5,W
053C8:  SUBWF  xF6,W
053CA:  MOVWF  00
053CC:  MOVF   xE6,W
053CE:  SUBWFB xF7,W
053D0:  MOVWF  03
053D2:  MOVF   00,W
053D4:  SUBLW  18
053D6:  BC    53DC
....................             state=MYTCP_STATE_ARP_REQ; 
053D8:  MOVLW  01
053DA:  MOVWF  xE8
053DC:  MOVLB  2
....................          } 
....................          break; 
053DE:  MOVLB  8
053E0:  BRA    55EC
....................  
....................       case MYTCP_STATE_CONNECT: 
....................          socket2=socket=TCPConnect(&remote, EXAMPLE_TCP_PORT); 
053E2:  MOVLW  08
053E4:  MOVLB  8
053E6:  MOVWF  xFA
053E8:  MOVLW  E9
053EA:  MOVWF  xF9
053EC:  MOVLW  1D
053EE:  MOVWF  xFC
053F0:  MOVLW  E6
053F2:  MOVWF  xFB
053F4:  MOVLB  0
053F6:  GOTO   4710
053FA:  MOVFF  01,8E7
053FE:  MOVFF  8E7,51
....................          if (socket!=INVALID_SOCKET) { 
05402:  MOVLB  8
05404:  MOVF   xE7,W
05406:  SUBLW  FE
05408:  BZ    5420
....................             lastTick=TickGet(); 
0540A:  MOVLB  0
0540C:  CALL   2AFC
05410:  MOVFF  02,8E6
05414:  MOVFF  01,8E5
....................             state=MYTCP_STATE_CONNECT_WAIT; 
05418:  MOVLW  04
0541A:  MOVLB  8
0541C:  MOVWF  xE8
....................          } 
0541E:  BRA    5446
....................          else { 
....................             //fprintf(DEBUG,"\nError en el socket."); 
....................             if(!espera)   { 
05420:  MOVLB  2
05422:  MOVF   x7D,F
05424:  BNZ   5444
....................                lcd_gotoxy(1,4);  
05426:  MOVLW  01
05428:  MOVLB  8
0542A:  MOVWF  xFD
0542C:  MOVLW  04
0542E:  MOVWF  xFE
05430:  MOVLB  0
05432:  CALL   05DE
....................                lcd_putc("Error en el socket. ");} 
05436:  MOVLW  56
05438:  MOVWF  FF6
0543A:  MOVLW  01
0543C:  MOVWF  FF7
0543E:  CALL   0696
05442:  MOVLB  2
05444:  MOVLB  8
....................          } 
....................          break; 
05446:  BRA    55EC
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(socket)) { 
05448:  MOVFF  8E7,8F9
0544C:  CALL   4926
05450:  MOVF   01,F
05452:  BZ    5488
....................             state=MYTCP_STATE_CONNECTED; 
05454:  MOVLW  05
05456:  MOVLB  8
05458:  MOVWF  xE8
....................             //fprintf(DEBUG,"\nCONECTADO! "); 
....................             if(!espera)   { 
0545A:  MOVLB  2
0545C:  MOVF   x7D,F
0545E:  BNZ   547E
....................                lcd_gotoxy(1,4); 
05460:  MOVLW  01
05462:  MOVLB  8
05464:  MOVWF  xFD
05466:  MOVLW  04
05468:  MOVWF  xFE
0546A:  MOVLB  0
0546C:  CALL   05DE
....................                lcd_putc("CONECTADO           ");} 
05470:  MOVLW  6C
05472:  MOVWF  FF6
05474:  MOVLW  01
05476:  MOVWF  FF7
05478:  CALL   0696
0547C:  MOVLB  2
....................             output_high(salida06); 
0547E:  BCF    F94.2
05480:  BSF    F8B.2
....................             inicializado=1; 
05482:  MOVLW  01
05484:  MOVWF  50
....................          } 
05486:  BRA    54E2
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
05488:  MOVLB  8
0548A:  MOVF   xF7,W
0548C:  SUBWF  xE6,W
0548E:  BNC   5498
05490:  BNZ   549C
05492:  MOVF   xE5,W
05494:  SUBWF  xF6,W
05496:  BNC   549C
05498:  MOVLW  00
0549A:  BRA    549E
0549C:  MOVLW  01
0549E:  CLRF   03
054A0:  IORWF  03,W
054A2:  BZ    54CA
054A4:  MOVLW  FF
054A6:  BSF    FD8.0
054A8:  SUBFWB xE5,W
054AA:  MOVWF  xF9
054AC:  MOVLW  FF
054AE:  SUBFWB xE6,W
054B0:  MOVWF  xFA
054B2:  MOVF   xF6,W
054B4:  ADDWF  xF9,F
054B6:  MOVF   xF7,W
054B8:  ADDWFC xFA,F
054BA:  MOVLW  01
054BC:  ADDWF  xF9,W
054BE:  MOVWF  01
054C0:  MOVLW  00
054C2:  ADDWFC xFA,W
054C4:  MOVWF  03
054C6:  MOVF   01,W
054C8:  BRA    54D8
054CA:  MOVF   xE5,W
054CC:  SUBWF  xF6,W
054CE:  MOVWF  00
054D0:  MOVF   xE6,W
054D2:  SUBWFB xF7,W
054D4:  MOVWF  03
054D6:  MOVF   00,W
054D8:  SUBLW  78
054DA:  BC    54E0
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
054DC:  MOVLW  07
054DE:  MOVWF  xE8
054E0:  MOVLB  2
....................          } 
....................          break; 
054E2:  MOVLB  8
054E4:  BRA    55EC
....................  
....................       case MYTCP_STATE_CONNECTED: 
....................          if (TCPIsConnected(socket)) { 
054E6:  MOVFF  8E7,8F9
054EA:  CALL   4926
054EE:  MOVF   01,F
054F0:  BZ    550E
....................             dis=TCPConnectedTask(socket); 
054F2:  MOVFF  8E7,8F9
054F6:  BRA    51A2
054F8:  MOVFF  01,8F8
....................             //fprintf(DEBUG,"\ndis:%u ",dis); 
....................             if (dis) { 
054FC:  MOVLB  8
054FE:  MOVF   xF8,F
05500:  BZ    550A
....................                //state=MYTCP_STATE_DISCONNECT; 
....................                lastTick=currTick; 
05502:  MOVFF  8F7,8E6
05506:  MOVFF  8F6,8E5
....................             } 
....................          } 
0550A:  BRA    5514
0550C:  MOVLB  0
....................          else { 
....................             //fprintf(DEBUG,"\nDESCONECTADO.   "); 
....................             //state=MYTCP_STATE_CONNECT; 
....................             state=MYTCP_STATE_DISCONNECT; 
0550E:  MOVLW  06
05510:  MOVLB  8
05512:  MOVWF  xE8
....................             //output_low(salida06); 
....................          } 
....................          break; 
05514:  BRA    55EC
....................  
....................       case MYTCP_STATE_DISCONNECT: 
....................          //fprintf(DEBUG,"\nDESCONECTANDO.   "); 
....................          if(!espera)   { 
05516:  MOVLB  2
05518:  MOVF   x7D,F
0551A:  BNZ   553A
....................             lcd_gotoxy(1,4); 
0551C:  MOVLW  01
0551E:  MOVLB  8
05520:  MOVWF  xFD
05522:  MOVLW  04
05524:  MOVWF  xFE
05526:  MOVLB  0
05528:  CALL   05DE
....................             lcd_putc("DESCONECTADO       ");} 
0552C:  MOVLW  82
0552E:  MOVWF  FF6
05530:  MOVLW  01
05532:  MOVWF  FF7
05534:  CALL   0696
05538:  MOVLB  2
....................          output_low(salida06); 
0553A:  BCF    F94.2
0553C:  BCF    F8B.2
....................          inicializado=0; 
0553E:  CLRF   50
....................          if (TCPIsPutReady(socket)) { 
05540:  MOVFF  8E7,909
05544:  MOVLB  0
05546:  CALL   4A8E
0554A:  MOVF   01,F
0554C:  BZ    5556
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
0554E:  MOVLW  07
05550:  MOVLB  8
05552:  MOVWF  xE8
....................          } 
05554:  BRA    55AE
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
05556:  MOVLB  8
05558:  MOVF   xF7,W
0555A:  SUBWF  xE6,W
0555C:  BNC   5566
0555E:  BNZ   556A
05560:  MOVF   xE5,W
05562:  SUBWF  xF6,W
05564:  BNC   556A
05566:  MOVLW  00
05568:  BRA    556C
0556A:  MOVLW  01
0556C:  CLRF   03
0556E:  IORWF  03,W
05570:  BZ    5598
05572:  MOVLW  FF
05574:  BSF    FD8.0
05576:  SUBFWB xE5,W
05578:  MOVWF  xF9
0557A:  MOVLW  FF
0557C:  SUBFWB xE6,W
0557E:  MOVWF  xFA
05580:  MOVF   xF6,W
05582:  ADDWF  xF9,F
05584:  MOVF   xF7,W
05586:  ADDWFC xFA,F
05588:  MOVLW  01
0558A:  ADDWF  xF9,W
0558C:  MOVWF  01
0558E:  MOVLW  00
05590:  ADDWFC xFA,W
05592:  MOVWF  03
05594:  MOVF   01,W
05596:  BRA    55A6
05598:  MOVF   xE5,W
0559A:  SUBWF  xF6,W
0559C:  MOVWF  00
0559E:  MOVF   xE6,W
055A0:  SUBWFB xF7,W
055A2:  MOVWF  03
055A4:  MOVF   00,W
055A6:  SUBLW  78
055A8:  BC    55AE
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
055AA:  MOVLW  07
055AC:  MOVWF  xE8
....................          } 
....................          break; 
055AE:  BRA    55EC
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
....................          TCPDisconnect(socket); 
055B0:  MOVFF  8E7,8FB
055B4:  RCALL  5080
....................          state=MYTCP_STATE_CONNECT; 
055B6:  MOVLW  03
055B8:  MOVLB  8
055BA:  MOVWF  xE8
....................          if(!espera)   { 
055BC:  MOVLB  2
055BE:  MOVF   x7D,F
055C0:  BNZ   55E0
....................             lcd_gotoxy(1,4); 
055C2:  MOVLW  01
055C4:  MOVLB  8
055C6:  MOVWF  xFD
055C8:  MOVLW  04
055CA:  MOVWF  xFE
055CC:  MOVLB  0
055CE:  CALL   05DE
....................             lcd_putc("DESCONECTADO       ");} 
055D2:  MOVLW  96
055D4:  MOVWF  FF6
055D6:  MOVLW  01
055D8:  MOVWF  FF7
055DA:  CALL   0696
055DE:  MOVLB  2
....................          output_low(salida06); 
055E0:  BCF    F94.2
055E2:  BCF    F8B.2
....................          inicializado=0; 
055E4:  CLRF   50
....................          break; 
055E6:  MOVLB  8
055E8:  BRA    55EC
055EA:  MOVLB  8
....................    } 
055EC:  MOVLB  0
055EE:  RETURN 0
.................... } 
....................  
.................... ////wiegand/// 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... wiegand_cuenta++; 
*
001AA:  MOVLB  2
001AC:  INCF   x11,F
.................... time_relay1++; 
001AE:  INCF   1F,F
.................... time_boleto++; 
001B0:  INCF   x89,F
.................... cuenta++; 
001B2:  INCF   x7C,F
.................... cta_lcd++; 
001B4:  INCF   x8B,F
.................... set_timer1(3036); //50 ms 
001B6:  MOVLW  0B
001B8:  MOVWF  FCF
001BA:  MOVLW  DC
001BC:  MOVWF  FCE
.................... } 
....................  
001BE:  BCF    F9E.0
001C0:  MOVLB  0
001C2:  GOTO   0084
.................... #int_ext 
.................... void EXT_isr(void){//data1 
....................    while (!input(PIN_B0) ) {} 
001C6:  BSF    F93.0
001C8:  BTFSS  F81.0
001CA:  BRA    01C6
....................    wiegand_cuenta=0; 
001CC:  MOVLB  2
001CE:  CLRF   x11
....................    wieg=1; 
001D0:  MOVLW  01
001D2:  MOVWF  x0C
....................    data[sub_indice]=1; 
001D4:  CLRF   03
001D6:  MOVF   x0F,W
001D8:  ADDLW  16
001DA:  MOVWF  FE9
001DC:  MOVLW  02
001DE:  ADDWFC 03,W
001E0:  MOVWF  FEA
001E2:  MOVLW  01
001E4:  MOVWF  FEF
....................    sub_indice++; 
001E6:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
001E8:  MOVF   x0F,W
001EA:  SUBLW  1A
001EC:  BNZ   01F2
....................       wieg_full=1; 
001EE:  MOVLW  01
001F0:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
.................... } 
....................  
001F2:  BCF    FF2.1
001F4:  MOVLB  0
001F6:  GOTO   0084
.................... #int_ext1 
.................... void EXT1_isr(void){//data0 
....................    while (!input(PIN_B1) ) {} 
001FA:  BSF    F93.1
001FC:  BTFSS  F81.1
001FE:  BRA    01FA
....................    wiegand_cuenta=0; 
00200:  MOVLB  2
00202:  CLRF   x11
....................    wieg=1; 
00204:  MOVLW  01
00206:  MOVWF  x0C
....................    data[sub_indice]=0; 
00208:  CLRF   03
0020A:  MOVF   x0F,W
0020C:  ADDLW  16
0020E:  MOVWF  FE9
00210:  MOVLW  02
00212:  ADDWFC 03,W
00214:  MOVWF  FEA
00216:  CLRF   FEF
....................    sub_indice++; 
00218:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
0021A:  MOVF   x0F,W
0021C:  SUBLW  1A
0021E:  BNZ   0224
....................       wieg_full=1; 
00220:  MOVLW  01
00222:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
00224:  BCF    FF0.0
00226:  MOVLB  0
00228:  GOTO   0084
.................... } 
.................... /////////////////////// 
.................... //funciones extra 
.................... void wiegand_read_card(); 
.................... void enviar_tcp(); 
.................... /////////boleto//////////////////// 
.................... void reset(); 
.................... void encri(); 
.................... void barra1(); 
.................... void barra2(); 
.................... void CR(); 
.................... void LF(); 
.................... void ticket(); 
.................... void sensores(); 
.................... void llaves(); 
.................... void rd_eeprom(); 
.................... void zeller(); 
.................... void horario(); 
.................... void fecha(); 
....................  
.................... void main(void) { 
*
06A96:  CLRF   FF8
06A98:  BCF    FD0.7
06A9A:  BSF    07.7
06A9C:  CLRF   19
06A9E:  BCF    FB8.3
06AA0:  MOVLW  40
06AA2:  MOVWF  FAF
06AA4:  MOVLW  A6
06AA6:  MOVWF  FAC
06AA8:  MOVLW  90
06AAA:  MOVWF  FAB
06AAC:  MOVLB  2
06AAE:  CLRF   x0F
06AB0:  CLRF   x10
06AB2:  MOVLB  3
06AB4:  CLRF   x89
06AB6:  CLRF   x88
06AB8:  CLRF   x8A
06ABA:  CLRF   x8B
06ABC:  CLRF   x93
06ABE:  CLRF   x92
06AC0:  MOVLW  04
06AC2:  MOVWF  x96
06AC4:  CLRF   x95
06AC6:  MOVLW  FE
06AC8:  MOVLB  8
06ACA:  MOVWF  xE7
06ACC:  CLRF   xE8
06ACE:  CLRF   xF4
06AD0:  CLRF   xF3
06AD2:  MOVF   FC1,W
06AD4:  ANDLW  C0
06AD6:  IORLW  0F
06AD8:  MOVWF  FC1
06ADA:  MOVLW  07
06ADC:  MOVWF  FB4
06ADE:  MOVLB  3
06AE0:  BCF    x90.1
06AE2:  BRA    6BDA
06AE4:  DATA 0B,02
06AE6:  DATA 8D,42
06AE8:  DATA 4F,4C
06AEA:  DATA 45,54
06AEC:  DATA 4F,5F
06AEE:  DATA 46,4F
06AF0:  DATA 4C,00
06AF2:  DATA 0B,02
06AF4:  DATA 99,42
06AF6:  DATA 4F,52
06AF8:  DATA 52,41
06AFA:  DATA 52,54
06AFC:  DATA 4F,44
06AFE:  DATA 4F,00
06B00:  DATA 0B,02
06B02:  DATA A5,42
06B04:  DATA 4F,52
06B06:  DATA 52,41
06B08:  DATA 52,5F
06B0A:  DATA 54,41
06B0C:  DATA 47,00
06B0E:  DATA 0B,02
06B10:  DATA B1,41
06B12:  DATA 42,52
06B14:  DATA 49,52
06B16:  DATA 5F,45
06B18:  DATA 4E,54
06B1A:  DATA 52,00
06B1C:  DATA 0B,02
06B1E:  DATA BD,43
06B20:  DATA 55,50
06B22:  DATA 4F,5F
06B24:  DATA 4C,4C
06B26:  DATA 45,4E
06B28:  DATA 4F,00
06B2A:  DATA 0B,02
06B2C:  DATA C9,43
06B2E:  DATA 55,50
06B30:  DATA 4F,5F
06B32:  DATA 44,49
06B34:  DATA 53,50
06B36:  DATA 4F,00
06B38:  DATA 0B,02
06B3A:  DATA D5,4D
06B3C:  DATA 45,4E
06B3E:  DATA 53,41
06B40:  DATA 4A,45
06B42:  DATA 45,4E
06B44:  DATA 31,00
06B46:  DATA 0A,42
06B48:  DATA E1,20
06B4A:  DATA 01,80
06B4C:  DATA 00,0B
06B4E:  DATA 02,ED
06B50:  DATA 43,4F
06B52:  DATA 4E,53
06B54:  DATA 55,4C
06B56:  DATA 54,41
06B58:  DATA 30,31
06B5A:  DATA 00,0B
06B5C:  DATA 02,F9
06B5E:  DATA 43,4F
06B60:  DATA 4E,46
06B62:  DATA 49,47
06B64:  DATA 44,41
06B66:  DATA 54,45
06B68:  DATA 00,0B
06B6A:  DATA 03,05
06B6C:  DATA 43,4F
06B6E:  DATA 4E,46
06B70:  DATA 49,47
06B72:  DATA 55,52
06B74:  DATA 41,42
06B76:  DATA 00,0B
06B78:  DATA 03,11
06B7A:  DATA 42,4F
06B7C:  DATA 52,52
06B7E:  DATA 41,5F
06B80:  DATA 43,4F
06B82:  DATA 4E,31
06B84:  DATA 00,0B
06B86:  DATA 03,1D
06B88:  DATA 46,4F
06B8A:  DATA 4C,49
06B8C:  DATA 4F,52
06B8E:  DATA 45,53
06B90:  DATA 45,54
06B92:  DATA 00,06
06B94:  DATA 03,29
06B96:  DATA 50,41
06B98:  DATA 47,41
06B9A:  DATA 44,4F
06B9C:  DATA 04,C0
06B9E:  DATA 30,01
06BA0:  DATA 80,00
06BA2:  DATA 18,03
06BA4:  DATA 35,42
06BA6:  DATA 4F,4C
06BA8:  DATA 45,54
06BAA:  DATA 4F,00
06BAC:  DATA 42,41
06BAE:  DATA 52,52
06BB0:  DATA 45,52
06BB2:  DATA 41,41
06BB4:  DATA 42,49
06BB6:  DATA 45,52
06BB8:  DATA 54,41
06BBA:  DATA 45,31
06BBC:  DATA 00,02
06BBE:  DATA 03,81
06BC0:  DATA 00,00
06BC2:  DATA 01,03
06BC4:  DATA 94,00
06BC6:  DATA 0A,48
06BC8:  DATA 85,00
06BCA:  DATA 46,48
06BCC:  DATA 9A,00
06BCE:  DATA 03,08
06BD0:  DATA E4,00
06BD2:  DATA 00,00
06BD4:  DATA 0A,48
06BD6:  DATA E9,00
06BD8:  DATA 00,00
06BDA:  MOVLW  00
06BDC:  MOVWF  FF8
06BDE:  MOVLW  6A
06BE0:  MOVWF  FF7
06BE2:  MOVLW  E4
06BE4:  MOVWF  FF6
06BE6:  TBLRD*+
06BE8:  MOVF   FF5,W
06BEA:  MOVWF  00
06BEC:  XORLW  00
06BEE:  BZ    6C16
06BF0:  TBLRD*+
06BF2:  MOVF   FF5,W
06BF4:  MOVWF  01
06BF6:  BTFSC  FE8.7
06BF8:  BRA    6C04
06BFA:  ANDLW  0F
06BFC:  MOVWF  FEA
06BFE:  TBLRD*+
06C00:  MOVFF  FF5,FE9
06C04:  BTFSC  01.6
06C06:  TBLRD*+
06C08:  BTFSS  01.6
06C0A:  TBLRD*+
06C0C:  MOVFF  FF5,FEE
06C10:  DCFSNZ 00,F
06C12:  BRA    6BE6
06C14:  BRA    6C08
06C16:  CLRF   FF8
....................    //fprintf(DEBUG,"\r\n\nCLIENTE TCP/IP\r\n"); 
....................    lcd_putc("\fINICIANDO"); 
06C18:  MOVLW  2C
06C1A:  MOVWF  FF6
06C1C:  MOVLW  02
06C1E:  MOVWF  FF7
06C20:  MOVLB  0
06C22:  CALL   0696
....................    setup_adc_ports(NO_ANALOGS); 
06C26:  MOVF   FC1,W
06C28:  ANDLW  C0
06C2A:  IORLW  0F
06C2C:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
06C2E:  BCF    FC2.0
....................     
....................    init_ext_eeprom();//iniciar memoria 
06C30:  GOTO   06B6
....................    lcd_init();//iniciar LCD 
06C34:  GOTO   06BE
....................    llaves(); 
06C38:  GOTO   073A
....................     
....................    MACAddrInit(); 
06C3C:  GOTO   0A3E
....................    IPAddrInit(); 
06C40:  GOTO   0A58
....................    ServerAddrInit(); 
06C44:  GOTO   0A88
....................    StackInit(); 
06C48:  GOTO   126E
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
06C4C:  MOVLW  B5
06C4E:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);//Habilito interrupción particular del TIMER1 
06C50:  BSF    F9D.0
....................    set_timer1(3036);//Carga del TMR1 
06C52:  MOVLW  0B
06C54:  MOVWF  FCF
06C56:  MOVLW  DC
06C58:  MOVWF  FCE
....................    ext_int_edge(0,L_TO_H);       //Asigno flancos de subida 
06C5A:  BSF    FF1.6
....................    ext_int_edge(1,L_TO_H);       //Asigno flancos de subida 
06C5C:  BSF    FF1.5
....................    enable_interrupts(INT_EXT1); 
06C5E:  BSF    FF0.3
....................    enable_interrupts(INT_EXT); 
06C60:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);//Habilito interrupciones globales 
06C62:  MOVLW  C0
06C64:  IORWF  FF2,F
....................  
....................    envia_pc=0; 
06C66:  CLRF   1A
....................    //int linked_out=0; 
....................    edo_str=envia_pc=0; 
06C68:  CLRF   1A
06C6A:  MOVFF  1A,4E
....................    re_bol=0; 
06C6E:  MOVLB  2
06C70:  CLRF   x8A
....................    //leyendo validacion de pago 
....................    int vigencia; 
....................    vigencia=read_ext_eeprom(10); 
06C72:  MOVLB  9
06C74:  CLRF   x07
06C76:  MOVLW  0A
06C78:  MOVWF  x06
06C7A:  MOVLB  0
06C7C:  CALL   1362
06C80:  MOVFF  01,8F5
....................    if(vigencia!=1) { 
06C84:  MOVLB  8
06C86:  DECFSZ xF5,W
06C88:  BRA    6C8C
06C8A:  BRA    6CD0
....................       write_ext_eeprom(10,1); 
06C8C:  MOVLB  9
06C8E:  CLRF   x07
06C90:  MOVLW  0A
06C92:  MOVWF  x06
06C94:  MOVLW  01
06C96:  MOVWF  x08
06C98:  MOVLB  0
06C9A:  CALL   140A
....................       write_ext_eeprom(11,0); 
06C9E:  MOVLB  9
06CA0:  CLRF   x07
06CA2:  MOVLW  0B
06CA4:  MOVWF  x06
06CA6:  CLRF   x08
06CA8:  MOVLB  0
06CAA:  CALL   140A
....................       write_ext_eeprom(12,0); 
06CAE:  MOVLB  9
06CB0:  CLRF   x07
06CB2:  MOVLW  0C
06CB4:  MOVWF  x06
06CB6:  CLRF   x08
06CB8:  MOVLB  0
06CBA:  CALL   140A
....................       write_ext_eeprom(13,0); 
06CBE:  MOVLB  9
06CC0:  CLRF   x07
06CC2:  MOVLW  0D
06CC4:  MOVWF  x06
06CC6:  CLRF   x08
06CC8:  MOVLB  0
06CCA:  CALL   140A
06CCE:  MOVLB  8
....................    } 
....................    pago=read_ext_eeprom(11);// 
06CD0:  MOVLB  9
06CD2:  CLRF   x07
06CD4:  MOVLW  0B
06CD6:  MOVWF  x06
06CD8:  MOVLB  0
06CDA:  CALL   1362
06CDE:  MOVFF  01,27B
....................    dias_prueba=read_ext_eeprom(12);//dias de prueba 
06CE2:  MOVLB  9
06CE4:  CLRF   x07
06CE6:  MOVLW  0C
06CE8:  MOVWF  x06
06CEA:  MOVLB  0
06CEC:  CALL   1362
06CF0:  MOVFF  01,279
....................    dia_temp=read_ext_eeprom(13);// 
06CF4:  MOVLB  9
06CF6:  CLRF   x07
06CF8:  MOVLW  0D
06CFA:  MOVWF  x06
06CFC:  MOVLB  0
06CFE:  CALL   1362
06D02:  MOVFF  01,27A
....................    lcd_gotoxy(1,1); 
06D06:  MOVLW  01
06D08:  MOVLB  8
06D0A:  MOVWF  xFD
06D0C:  MOVWF  xFE
06D0E:  MOVLB  0
06D10:  CALL   05DE
....................    printf(lcd_putc,"Dias:%u PAGO:%d",dias_prueba,pago); 
06D14:  MOVLW  38
06D16:  MOVWF  FF6
06D18:  MOVLW  02
06D1A:  MOVWF  FF7
06D1C:  MOVLW  05
06D1E:  MOVLB  8
06D20:  MOVWF  xF7
06D22:  MOVLB  0
06D24:  CALL   1510
06D28:  MOVFF  279,8F7
06D2C:  MOVLW  1B
06D2E:  MOVLB  8
06D30:  MOVWF  xF8
06D32:  MOVLB  0
06D34:  CALL   1566
06D38:  MOVLW  3F
06D3A:  MOVWF  FF6
06D3C:  MOVLW  02
06D3E:  MOVWF  FF7
06D40:  MOVLW  06
06D42:  MOVLB  8
06D44:  MOVWF  xF7
06D46:  MOVLB  0
06D48:  CALL   1510
06D4C:  MOVFF  27B,8F6
06D50:  MOVLW  18
06D52:  MOVLB  8
06D54:  MOVWF  xF7
06D56:  MOVLB  0
06D58:  GOTO   15E8
....................    lcd_gotoxy(1,2); 
06D5C:  MOVLW  01
06D5E:  MOVLB  8
06D60:  MOVWF  xFD
06D62:  MOVLW  02
06D64:  MOVWF  xFE
06D66:  MOVLB  0
06D68:  CALL   05DE
....................    printf(lcd_putc,"Restan:%u ",(dia_limite-dias_prueba) ); 
06D6C:  MOVLW  5A
06D6E:  BSF    FD8.0
06D70:  MOVLB  2
06D72:  SUBFWB x79,W
06D74:  MOVLB  8
06D76:  MOVWF  xF6
06D78:  MOVLW  48
06D7A:  MOVWF  FF6
06D7C:  MOVLW  02
06D7E:  MOVWF  FF7
06D80:  MOVLW  07
06D82:  MOVWF  xF7
06D84:  MOVLB  0
06D86:  CALL   1510
06D8A:  MOVFF  8F6,8F7
06D8E:  MOVLW  1B
06D90:  MOVLB  8
06D92:  MOVWF  xF8
06D94:  MOVLB  0
06D96:  CALL   1566
06D9A:  MOVLW  20
06D9C:  MOVLB  8
06D9E:  MOVWF  xFC
06DA0:  MOVLB  0
06DA2:  CALL   0632
....................    delay_ms(1000); 
06DA6:  MOVLW  04
06DA8:  MOVLB  8
06DAA:  MOVWF  xF6
06DAC:  MOVLW  FA
06DAE:  MOVWF  xFD
06DB0:  MOVLB  0
06DB2:  CALL   05B4
06DB6:  MOVLB  8
06DB8:  DECFSZ xF6,F
06DBA:  BRA    6DAC
....................    setup_wdt(WDT_ON); 
06DBC:  BSF    FD1.0
....................    ////////////////// 
....................    hrs2=espera=fmensaje=0; 
06DBE:  MOVLB  3
06DC0:  CLRF   x4D
06DC2:  MOVFF  34D,27D
06DC6:  MOVFF  27D,27E
....................    reset(); 
06DCA:  MOVLB  0
06DCC:  GOTO   16B2
....................    while(TRUE) { 
....................       restart_wdt(); 
06DD0:  CLRWDT
....................       StackTask(); 
06DD2:  CALL   4478
....................       MyTCPTask(); 
06DD6:  CALL   52AE
....................       if( (dias_prueba>dia_limite)&&(pago!=1) ){//pruebas 
06DDA:  MOVLB  2
06DDC:  MOVF   x79,W
06DDE:  SUBLW  5A
06DE0:  BC    6EAE
06DE2:  DECFSZ x7B,W
06DE4:  BRA    6DE8
06DE6:  BRA    6EAE
....................          lcd_gotoxy(1,1); 
06DE8:  MOVLW  01
06DEA:  MOVLB  8
06DEC:  MOVWF  xFD
06DEE:  MOVWF  xFE
06DF0:  MOVLB  0
06DF2:  CALL   05DE
....................          lcd_putc("TIEMPO DE PRUEBA"); 
06DF6:  MOVLW  54
06DF8:  MOVWF  FF6
06DFA:  MOVLW  02
06DFC:  MOVWF  FF7
06DFE:  CALL   0696
....................          lcd_gotoxy(1,2); 
06E02:  MOVLW  01
06E04:  MOVLB  8
06E06:  MOVWF  xFD
06E08:  MOVLW  02
06E0A:  MOVWF  xFE
06E0C:  MOVLB  0
06E0E:  CALL   05DE
....................          lcd_putc("  HA EXPIRADO   "); 
06E12:  MOVLW  66
06E14:  MOVWF  FF6
06E16:  MOVLW  02
06E18:  MOVWF  FF7
06E1A:  CALL   0696
....................          if(edo_str){ 
06E1E:  MOVF   4E,F
06E20:  BZ    6EA8
....................             edo_str=0; 
06E22:  CLRF   4E
....................             strcpy(XX,rxtcp); 
06E24:  CLRF   FEA
06E26:  MOVLW  52
06E28:  MOVWF  FE9
06E2A:  MOVLW  01
06E2C:  MOVWF  FE2
06E2E:  MOVLW  60
06E30:  MOVWF  FE1
06E32:  MOVF   FE7,F
06E34:  MOVFF  FE6,FEE
06E38:  BNZ   6E32
....................             if( (XX[0]=='P')&&(XX[1]=='A')&&(XX[2]=='G')&&(XX[3]=='A')&&(XX[4]=='D')&&(XX[5]=='O') ){ 
06E3A:  MOVF   52,W
06E3C:  SUBLW  50
06E3E:  BNZ   6EA8
06E40:  MOVF   53,W
06E42:  SUBLW  41
06E44:  BNZ   6EA8
06E46:  MOVF   54,W
06E48:  SUBLW  47
06E4A:  BNZ   6EA8
06E4C:  MOVF   55,W
06E4E:  SUBLW  41
06E50:  BNZ   6EA8
06E52:  MOVF   56,W
06E54:  SUBLW  44
06E56:  BNZ   6EA8
06E58:  MOVF   57,W
06E5A:  SUBLW  4F
06E5C:  BNZ   6EA8
....................                pago=1; 
06E5E:  MOVLW  01
06E60:  MOVLB  2
06E62:  MOVWF  x7B
....................                write_ext_eeprom(11,pago);// 
06E64:  MOVLB  9
06E66:  CLRF   x07
06E68:  MOVLW  0B
06E6A:  MOVWF  x06
06E6C:  MOVFF  27B,908
06E70:  MOVLB  0
06E72:  CALL   140A
....................                strcpy (txtcp, "BOLETERA_PAGADO"); 
06E76:  MOVLW  01
06E78:  MOVWF  FEA
06E7A:  MOVLW  06
06E7C:  MOVWF  FE9
06E7E:  MOVLW  00
06E80:  CALL   00E6
06E84:  TBLRD*-
06E86:  TBLRD*+
06E88:  MOVF   FF5,W
06E8A:  MOVWF  FEE
06E8C:  IORLW  00
06E8E:  BNZ   6E86
....................                size_tx_tcp=strlen(txtcp); 
06E90:  MOVLW  01
06E92:  MOVLB  9
06E94:  MOVWF  x0C
06E96:  MOVLW  06
06E98:  MOVWF  x0B
06E9A:  MOVLB  0
06E9C:  CALL   561A
06EA0:  MOVFF  01,48
....................                enviar_tcp(); 
06EA4:  CALL   5656
....................             } 
....................          } 
....................       } 
06EA8:  GOTO   75BA
06EAC:  MOVLB  2
....................       else{ 
....................          wiegand_read_card(); 
06EAE:  MOVLB  0
06EB0:  GOTO   570C
....................          sensores(); 
06EB4:  GOTO   58B2
....................          if(edo_str){//bandera de dato recibido en socket actual 
06EB8:  MOVF   4E,F
06EBA:  BTFSC  FD8.2
06EBC:  BRA    7156
....................             edo_str=0; 
06EBE:  CLRF   4E
....................             //fprintf(DEBUG,"\r\nrxtcp:%s",rxtcp); 
....................             //printf(lcd_putc,"\frxtcp:%s",rxtcp); 
....................             strcpy(XX,rxtcp); 
06EC0:  CLRF   FEA
06EC2:  MOVLW  52
06EC4:  MOVWF  FE9
06EC6:  MOVLW  01
06EC8:  MOVWF  FE2
06ECA:  MOVLW  60
06ECC:  MOVWF  FE1
06ECE:  MOVF   FE7,F
06ED0:  MOVFF  FE6,FEE
06ED4:  BNZ   6ECE
....................             //fprintf(U1PRINTER,"\frxtcp:%s",XX); 
....................             rd_eeprom(); 
06ED6:  GOTO   5960
....................             //lcd_gotoxy(1,3); 
....................             //printf(lcd_putc,"rxtcp:%s",rxtcp); 
....................             //lcd_gotoxy(1,4); 
....................             //printf(lcd_putc,"b:%Ld                ",b); 
....................             switch (b) { 
06EDA:  MOVFF  44,00
06EDE:  MOVF   45,W
06EE0:  MOVWF  03
06EE2:  BNZ   6EEA
06EE4:  MOVLW  01
06EE6:  SUBWF  00,W
06EE8:  BZ    6F72
06EEA:  MOVF   03,W
06EEC:  BNZ   6EF6
06EEE:  MOVLW  02
06EF0:  SUBWF  00,W
06EF2:  BTFSC  FD8.2
06EF4:  BRA    6FA4
06EF6:  MOVF   03,W
06EF8:  BNZ   6F00
06EFA:  MOVLW  03
06EFC:  SUBWF  00,W
06EFE:  BZ    6FA6
06F00:  MOVF   03,W
06F02:  BNZ   6F0A
06F04:  MOVLW  04
06F06:  SUBWF  00,W
06F08:  BZ    6FA8
06F0A:  MOVF   03,W
06F0C:  BNZ   6F14
06F0E:  MOVLW  05
06F10:  SUBWF  00,W
06F12:  BZ    6FC2
06F14:  MOVF   03,W
06F16:  BNZ   6F1E
06F18:  MOVLW  06
06F1A:  SUBWF  00,W
06F1C:  BZ    6FC4
06F1E:  MOVF   03,W
06F20:  BNZ   6F28
06F22:  MOVLW  07
06F24:  SUBWF  00,W
06F26:  BZ    6FC6
06F28:  MOVF   03,W
06F2A:  BNZ   6F34
06F2C:  MOVLW  08
06F2E:  SUBWF  00,W
06F30:  BTFSC  FD8.2
06F32:  BRA    70FE
06F34:  MOVF   03,W
06F36:  BNZ   6F40
06F38:  MOVLW  09
06F3A:  SUBWF  00,W
06F3C:  BTFSC  FD8.2
06F3E:  BRA    7100
06F40:  MOVF   03,W
06F42:  BNZ   6F4C
06F44:  MOVLW  0A
06F46:  SUBWF  00,W
06F48:  BTFSC  FD8.2
06F4A:  BRA    7102
06F4C:  MOVF   03,W
06F4E:  BNZ   6F58
06F50:  MOVLW  0B
06F52:  SUBWF  00,W
06F54:  BTFSC  FD8.2
06F56:  BRA    7108
06F58:  MOVF   03,W
06F5A:  BNZ   6F64
06F5C:  MOVLW  0D
06F5E:  SUBWF  00,W
06F60:  BTFSC  FD8.2
06F62:  BRA    710A
06F64:  MOVF   03,W
06F66:  BNZ   6F70
06F68:  MOVLW  0E
06F6A:  SUBWF  00,W
06F6C:  BTFSC  FD8.2
06F6E:  BRA    710C
06F70:  BRA    7156
....................               case 1: {//IMPRIMIR BOLETO 
....................                   espera=1; 
06F72:  MOVLW  01
06F74:  MOVLB  2
06F76:  MOVWF  x7D
....................                   printf(lcd_putc,"\f\n   TOME SU BOLETO\n Y AVANCE POR FAVOR"); 
06F78:  MOVLW  78
06F7A:  MOVWF  FF6
06F7C:  MOVLW  02
06F7E:  MOVWF  FF7
06F80:  MOVLB  0
06F82:  CALL   0696
....................                   ticket(); 
06F86:  GOTO   5DB4
....................                   output_high(salida01);//abre entrada 
06F8A:  BCF    F92.5
06F8C:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
06F8E:  BCF    F96.0
06F90:  BSF    F8D.0
....................                   relay1=1; 
06F92:  MOVLW  01
06F94:  MOVWF  1D
....................                   time_relay1=0; 
06F96:  CLRF   1F
....................                   flag_pluma=1; 
06F98:  MOVLB  2
06F9A:  MOVWF  x88
....................                   //sprintf(txtcp,barra_codi);//CONFIRMACION DE BOLETO IMPRESO 
....................                   //size_tx_tcp=strlen(txtcp); 
....................                   //enviar_tcp(); 
....................                   cta_lcd=0; 
06F9C:  CLRF   x8B
....................                   re_bol=1; 
06F9E:  MOVWF  x8A
....................                   break;} 
06FA0:  MOVLB  0
06FA2:  BRA    7156
....................               case 2: {//VIGENCIA POR VENCER O VENCIDA 
....................                   break;} 
06FA4:  BRA    7156
....................               case 3: {//no activa en entrada 
....................                   break;} 
06FA6:  BRA    7156
....................               case 4: {//ABRIR ENTRADA 
....................                   //lcd_putc("\f\n     BIENVENIDO"); 
....................                   output_high(salida01);//abre entrada 
06FA8:  BCF    F92.5
06FAA:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
06FAC:  BCF    F96.0
06FAE:  BSF    F8D.0
....................                   flag_pluma=1; 
06FB0:  MOVLW  01
06FB2:  MOVLB  2
06FB4:  MOVWF  x88
....................                   relay1=1; 
06FB6:  MOVWF  1D
....................                   time_relay1=0; 
06FB8:  CLRF   1F
....................                   b=0; 
06FBA:  CLRF   45
06FBC:  CLRF   44
....................                   break;} 
06FBE:  MOVLB  0
06FC0:  BRA    7156
....................               case 5: {//CUPO LLENO 
....................                   break;} 
06FC2:  BRA    7156
....................               case 6: {//ACTIVA BOLETOS 
....................                   break;} 
06FC4:  BRA    7156
....................               case 7: {//MENSAJES DE LCD 
....................                      memset(lcd_men, 0, sizeof(lcd_men) ); 
06FC6:  MOVLW  01
06FC8:  MOVWF  FEA
06FCA:  MOVLW  BA
06FCC:  MOVWF  FE9
06FCE:  CLRF   00
06FD0:  CLRF   02
06FD2:  MOVLW  50
06FD4:  MOVWF  01
06FD6:  CALL   56F2
....................                      for(i=0;i<strlen(XX);i++) lcd_men[i]=XX[instruccion_size+i]; 
06FDA:  CLRF   41
06FDC:  CLRF   40
06FDE:  MOVLB  9
06FE0:  CLRF   x0C
06FE2:  MOVLW  52
06FE4:  MOVWF  x0B
06FE6:  MOVLB  0
06FE8:  CALL   561A
06FEC:  MOVFF  02,03
06FF0:  MOVF   41,W
06FF2:  SUBWF  02,W
06FF4:  BNC   7038
06FF6:  BNZ   6FFE
06FF8:  MOVF   01,W
06FFA:  SUBWF  40,W
06FFC:  BC    7038
06FFE:  MOVLW  BA
07000:  ADDWF  40,W
07002:  MOVWF  01
07004:  MOVLW  01
07006:  ADDWFC 41,W
07008:  MOVWF  03
0700A:  MOVFF  01,8F6
0700E:  MOVLB  8
07010:  MOVWF  xF7
07012:  MOVLW  5C
07014:  ADDWF  40,W
07016:  MOVWF  FE9
07018:  MOVLW  00
0701A:  ADDWFC 41,W
0701C:  MOVWF  FEA
0701E:  MOVFF  FEF,8FA
07022:  MOVFF  03,FEA
07026:  MOVFF  01,FE9
0702A:  MOVFF  8FA,FEF
0702E:  INCF   40,F
07030:  BTFSC  FD8.2
07032:  INCF   41,F
07034:  MOVLB  0
07036:  BRA    6FDE
....................                      lcd_putc("\f"); 
07038:  MOVLW  A0
0703A:  MOVWF  FF6
0703C:  MOVLW  02
0703E:  MOVWF  FF7
07040:  CALL   0696
....................                      for(i=0;i<strlen(lcd_men);i++){ 
07044:  CLRF   41
07046:  CLRF   40
07048:  MOVLW  01
0704A:  MOVLB  9
0704C:  MOVWF  x0C
0704E:  MOVLW  BA
07050:  MOVWF  x0B
07052:  MOVLB  0
07054:  CALL   561A
07058:  MOVFF  02,03
0705C:  MOVF   41,W
0705E:  SUBWF  02,W
07060:  BNC   70F2
07062:  BNZ   706A
07064:  MOVF   01,W
07066:  SUBWF  40,W
07068:  BC    70F2
....................                         if(i==0)lcd_gotoxy(1,1); 
0706A:  MOVF   40,F
0706C:  BTFSS  FD8.2
0706E:  BRA    7084
07070:  MOVF   41,F
07072:  BNZ   7084
07074:  MOVLW  01
07076:  MOVLB  8
07078:  MOVWF  xFD
0707A:  MOVWF  xFE
0707C:  MOVLB  0
0707E:  CALL   05DE
07082:  BRA    70D6
....................                         else if(i==20) lcd_gotoxy(1,2); 
07084:  MOVF   40,W
07086:  SUBLW  14
07088:  BNZ   70A0
0708A:  MOVF   41,F
0708C:  BNZ   70A0
0708E:  MOVLW  01
07090:  MOVLB  8
07092:  MOVWF  xFD
07094:  MOVLW  02
07096:  MOVWF  xFE
07098:  MOVLB  0
0709A:  CALL   05DE
0709E:  BRA    70D6
....................                         else if(i==40) lcd_gotoxy(1,3); 
070A0:  MOVF   40,W
070A2:  SUBLW  28
070A4:  BNZ   70BC
070A6:  MOVF   41,F
070A8:  BNZ   70BC
070AA:  MOVLW  01
070AC:  MOVLB  8
070AE:  MOVWF  xFD
070B0:  MOVLW  03
070B2:  MOVWF  xFE
070B4:  MOVLB  0
070B6:  CALL   05DE
070BA:  BRA    70D6
....................                         else if(i==60) lcd_gotoxy(1,4); 
070BC:  MOVF   40,W
070BE:  SUBLW  3C
070C0:  BNZ   70D6
070C2:  MOVF   41,F
070C4:  BNZ   70D6
070C6:  MOVLW  01
070C8:  MOVLB  8
070CA:  MOVWF  xFD
070CC:  MOVLW  04
070CE:  MOVWF  xFE
070D0:  MOVLB  0
070D2:  CALL   05DE
....................                         printf(lcd_putc,"%c",lcd_men[i]); 
070D6:  MOVLW  BA
070D8:  ADDWF  40,W
070DA:  MOVWF  FE9
070DC:  MOVLW  01
070DE:  ADDWFC 41,W
070E0:  MOVWF  FEA
070E2:  MOVFF  FEF,8FC
070E6:  CALL   0632
070EA:  INCF   40,F
070EC:  BTFSC  FD8.2
070EE:  INCF   41,F
070F0:  BRA    7048
....................                      } 
....................                      espera=1; 
070F2:  MOVLW  01
070F4:  MOVLB  2
070F6:  MOVWF  x7D
....................                      cta_lcd=0; 
070F8:  CLRF   x8B
....................                      break;}// 
070FA:  MOVLB  0
070FC:  BRA    7156
....................               case 8: {//MOITOREO DESACTIVADO 
....................                      break;}// 
070FE:  BRA    7156
....................               case 9: {//CONSULTA ENTRADAS SIN CONEXION 
....................                   break;} 
07100:  BRA    7156
....................               case 10:{//CONFIGURA FECHA Y HORA 
....................                   fecha(); 
07102:  GOTO   646C
....................                   break;} 
07106:  BRA    7156
....................               case 11:{//ultima conexion 
....................                   break;} 
07108:  BRA    7156
....................               case 13:{//RESET DE FOLIOS 
....................                   break;} 
0710A:  BRA    7156
....................               case 14:{//PAGO EFECTUADO 
....................                   pago=1; 
0710C:  MOVLW  01
0710E:  MOVLB  2
07110:  MOVWF  x7B
....................                   write_ext_eeprom(11,pago);// 
07112:  MOVLB  9
07114:  CLRF   x07
07116:  MOVLW  0B
07118:  MOVWF  x06
0711A:  MOVFF  27B,908
0711E:  MOVLB  0
07120:  CALL   140A
....................                   strcpy (txtcp, "BOLETERA_PAGADO"); 
07124:  MOVLW  01
07126:  MOVWF  FEA
07128:  MOVLW  06
0712A:  MOVWF  FE9
0712C:  MOVLW  00
0712E:  CALL   00E6
07132:  TBLRD*-
07134:  TBLRD*+
07136:  MOVF   FF5,W
07138:  MOVWF  FEE
0713A:  IORLW  00
0713C:  BNZ   7134
....................                   size_tx_tcp=strlen(txtcp); 
0713E:  MOVLW  01
07140:  MOVLB  9
07142:  MOVWF  x0C
07144:  MOVLW  06
07146:  MOVWF  x0B
07148:  MOVLB  0
0714A:  CALL   561A
0714E:  MOVFF  01,48
....................                   enviar_tcp(); 
07152:  CALL   5656
....................                   break;} 
....................             }//end switch 
....................          }//end dato recibido tcp 
....................          ////////////////////////////////////// 
....................          if( (relay1)&&(time_relay1>=21) ){ 
07156:  MOVF   1D,F
07158:  BZ    716A
0715A:  MOVF   1F,W
0715C:  SUBLW  14
0715E:  BC    716A
....................             relay1=0; 
07160:  CLRF   1D
....................             output_low(salida01); 
07162:  BCF    F92.5
07164:  BCF    F89.5
....................             output_low(salida02); 
07166:  BCF    F96.0
07168:  BCF    F8D.0
....................          } 
....................          //if( (time_boleto>60)&&(re_bol) )  re_bol=0; 
....................           
....................          if( (espera)&&(cta_lcd>=100) ) espera=0; 
0716A:  MOVLB  2
0716C:  MOVF   x7D,F
0716E:  BZ    7178
07170:  MOVF   x8B,W
07172:  SUBLW  63
07174:  BC    7178
07176:  CLRF   x7D
....................           
....................          if( (cuenta>=20)&&(espera==0) ){//CADA 2 SEGUNDOS VERIFICA FECHA Y HORA 
07178:  MOVF   x7C,W
0717A:  SUBLW  13
0717C:  BTFSC  FD8.0
0717E:  BRA    75B8
07180:  MOVF   x7D,F
07182:  BTFSS  FD8.2
07184:  BRA    75B8
....................              ds1307_get_time(hrs,min,sec); 
....................              ds1307_get_date(day,month,yr,dow); 
....................              if(hrs2!=hrs){ 
*
07360:  MOVLB  2
07362:  MOVF   x73,W
07364:  SUBWF  x7E,W
07366:  BZ    73B8
....................                dia=31;//ultimo dia del mes 
07368:  CLRF   x82
0736A:  MOVLW  1F
0736C:  MOVWF  x81
....................                mes2=10;//octubre, mes en el que cambia horario invierno 
0736E:  CLRF   x80
07370:  MOVLW  0A
07372:  MOVWF  x7F
....................                zeller(); 
07374:  MOVLB  0
07376:  GOTO   65D8
....................                hrs2=hrs; 
0737A:  MOVFF  273,27E
....................                if( (dia_temp!=day)&&(pago!=1) ){ 
0737E:  MOVLB  2
07380:  MOVF   x70,W
07382:  SUBWF  x7A,W
07384:  BZ    73B8
07386:  DECFSZ x7B,W
07388:  BRA    738C
0738A:  BRA    73B8
....................                   dia_temp=day; 
0738C:  MOVFF  270,27A
....................                   dias_prueba++; 
07390:  INCF   x79,F
....................                   write_ext_eeprom(12,dias_prueba);//dias de prueba 
07392:  MOVLB  9
07394:  CLRF   x07
07396:  MOVLW  0C
07398:  MOVWF  x06
0739A:  MOVFF  279,908
0739E:  MOVLB  0
073A0:  CALL   140A
....................                   write_ext_eeprom(13,dia_temp);// 
073A4:  MOVLB  9
073A6:  CLRF   x07
073A8:  MOVLW  0D
073AA:  MOVWF  x06
073AC:  MOVFF  27A,908
073B0:  MOVLB  0
073B2:  CALL   140A
073B6:  MOVLB  2
....................                } 
....................              }//FIN CONFIGURA AUTMATICO FECHA Y HORA 
....................              //cuenta_lcd=0; 
....................              puntos=!puntos; 
073B8:  MOVF   x77,F
073BA:  BZ    73C0
073BC:  MOVLW  00
073BE:  BRA    73C2
073C0:  MOVLW  01
073C2:  MOVWF  x77
....................              if( (!espera)&&(!en1) ){ 
073C4:  MOVF   x7D,F
073C6:  BTFSS  FD8.2
073C8:  BRA    75B6
073CA:  MOVF   x83,F
073CC:  BTFSS  FD8.2
073CE:  BRA    75B6
....................                lcd_gotoxy(1,1); 
073D0:  MOVLW  01
073D2:  MOVLB  8
073D4:  MOVWF  xFD
073D6:  MOVWF  xFE
073D8:  MOVLB  0
073DA:  CALL   05DE
....................                lcd_putc("                    "); 
073DE:  MOVLW  A2
073E0:  MOVWF  FF6
073E2:  MOVLW  02
073E4:  MOVWF  FF7
073E6:  CALL   0696
....................                lcd_gotoxy(1,2);//printf(lcd_putc,"  %02d %02d %02d %02d/%02d/%02d   ",hrs_e,min_e,sec_e,day_e,month,yr); 
073EA:  MOVLW  01
073EC:  MOVLB  8
073EE:  MOVWF  xFD
073F0:  MOVLW  02
073F2:  MOVWF  xFE
073F4:  MOVLB  0
073F6:  CALL   05DE
....................                if(puntos==0)   printf(lcd_putc,"   %02d %02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
073FA:  MOVLB  2
073FC:  MOVF   x77,F
073FE:  BNZ   74AC
07400:  MOVLW  B8
07402:  MOVWF  FF6
07404:  MOVLW  02
07406:  MOVWF  FF7
07408:  MOVLW  03
0740A:  MOVLB  8
0740C:  MOVWF  xF7
0740E:  MOVLB  0
07410:  CALL   1510
07414:  MOVFF  273,8F6
07418:  MOVLW  01
0741A:  MOVLB  8
0741C:  MOVWF  xF7
0741E:  MOVLB  0
07420:  CALL   69AA
07424:  MOVLW  20
07426:  MOVLB  8
07428:  MOVWF  xFC
0742A:  MOVLB  0
0742C:  CALL   0632
07430:  MOVFF  274,8F6
07434:  MOVLW  01
07436:  MOVLB  8
07438:  MOVWF  xF7
0743A:  MOVLB  0
0743C:  CALL   69AA
07440:  MOVLW  20
07442:  MOVLB  8
07444:  MOVWF  xFC
07446:  MOVLB  0
07448:  CALL   0632
0744C:  MOVFF  270,8F6
07450:  MOVLW  01
07452:  MOVLB  8
07454:  MOVWF  xF7
07456:  MOVLB  0
07458:  CALL   69AA
0745C:  MOVLW  2F
0745E:  MOVLB  8
07460:  MOVWF  xFC
07462:  MOVLB  0
07464:  CALL   0632
07468:  MOVFF  271,8F6
0746C:  MOVLW  01
0746E:  MOVLB  8
07470:  MOVWF  xF7
07472:  MOVLB  0
07474:  CALL   69AA
07478:  MOVLW  2F
0747A:  MOVLB  8
0747C:  MOVWF  xFC
0747E:  MOVLB  0
07480:  CALL   0632
07484:  MOVFF  272,8F6
07488:  MOVLW  01
0748A:  MOVLB  8
0748C:  MOVWF  xF7
0748E:  MOVLB  0
07490:  CALL   69AA
07494:  MOVLW  D3
07496:  MOVWF  FF6
07498:  MOVLW  02
0749A:  MOVWF  FF7
0749C:  MOVLW  04
0749E:  MOVLB  8
074A0:  MOVWF  xF7
074A2:  MOVLB  0
074A4:  CALL   1510
074A8:  BRA    7554
074AA:  MOVLB  2
....................                else   printf(lcd_putc,"   %02d:%02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
074AC:  MOVLW  D8
074AE:  MOVWF  FF6
074B0:  MOVLW  02
074B2:  MOVWF  FF7
074B4:  MOVLW  03
074B6:  MOVLB  8
074B8:  MOVWF  xF7
074BA:  MOVLB  0
074BC:  CALL   1510
074C0:  MOVFF  273,8F6
074C4:  MOVLW  01
074C6:  MOVLB  8
074C8:  MOVWF  xF7
074CA:  MOVLB  0
074CC:  CALL   69AA
074D0:  MOVLW  3A
074D2:  MOVLB  8
074D4:  MOVWF  xFC
074D6:  MOVLB  0
074D8:  CALL   0632
074DC:  MOVFF  274,8F6
074E0:  MOVLW  01
074E2:  MOVLB  8
074E4:  MOVWF  xF7
074E6:  MOVLB  0
074E8:  CALL   69AA
074EC:  MOVLW  20
074EE:  MOVLB  8
074F0:  MOVWF  xFC
074F2:  MOVLB  0
074F4:  CALL   0632
074F8:  MOVFF  270,8F6
074FC:  MOVLW  01
074FE:  MOVLB  8
07500:  MOVWF  xF7
07502:  MOVLB  0
07504:  CALL   69AA
07508:  MOVLW  2F
0750A:  MOVLB  8
0750C:  MOVWF  xFC
0750E:  MOVLB  0
07510:  CALL   0632
07514:  MOVFF  271,8F6
07518:  MOVLW  01
0751A:  MOVLB  8
0751C:  MOVWF  xF7
0751E:  MOVLB  0
07520:  CALL   69AA
07524:  MOVLW  2F
07526:  MOVLB  8
07528:  MOVWF  xFC
0752A:  MOVLB  0
0752C:  CALL   0632
07530:  MOVFF  272,8F6
07534:  MOVLW  01
07536:  MOVLB  8
07538:  MOVWF  xF7
0753A:  MOVLB  0
0753C:  CALL   69AA
07540:  MOVLW  F3
07542:  MOVWF  FF6
07544:  MOVLW  02
07546:  MOVWF  FF7
07548:  MOVLW  04
0754A:  MOVLB  8
0754C:  MOVWF  xF7
0754E:  MOVLB  0
07550:  CALL   1510
....................                cambio_msj++; 
07554:  MOVLB  2
07556:  INCF   x78,F
....................                lcd_gotoxy(1,3); 
07558:  MOVLW  01
0755A:  MOVLB  8
0755C:  MOVWF  xFD
0755E:  MOVLW  03
07560:  MOVWF  xFE
07562:  MOVLB  0
07564:  CALL   05DE
....................                if(cambio_msj>=10) lcd_putc("   WWW.ACCESA.ME    ");//COMPLEJO CITY ANGELÓPOLIS   
07568:  MOVLB  2
0756A:  MOVF   x78,W
0756C:  SUBLW  09
0756E:  BC    7582
07570:  MOVLW  F8
07572:  MOVWF  FF6
07574:  MOVLW  02
07576:  MOVWF  FF7
07578:  MOVLB  0
0757A:  CALL   0696
0757E:  BRA    7590
07580:  MOVLB  2
....................                else lcd_putc("       ACCESA       "); 
07582:  MOVLW  0E
07584:  MOVWF  FF6
07586:  MOVLW  03
07588:  MOVWF  FF7
0758A:  MOVLB  0
0758C:  CALL   0696
....................                lcd_gotoxy(1,4); 
07590:  MOVLW  01
07592:  MOVLB  8
07594:  MOVWF  xFD
07596:  MOVLW  04
07598:  MOVWF  xFE
0759A:  MOVLB  0
0759C:  CALL   05DE
....................                lcd_putc("                    "); 
075A0:  MOVLW  24
075A2:  MOVWF  FF6
075A4:  MOVLW  03
075A6:  MOVWF  FF7
075A8:  CALL   0696
....................                if(cambio_msj>=20) cambio_msj=0; 
075AC:  MOVLB  2
075AE:  MOVF   x78,W
075B0:  SUBLW  13
075B2:  BC    75B6
075B4:  CLRF   x78
....................              } 
....................              cuenta=0; 
075B6:  CLRF   x7C
075B8:  MOVLB  0
....................          }//END SEGUNDO 
....................       } 
....................       //if( (MACIsLinked()==0)&&(inicializado)&&(linked_out==0) ){//cable off 
....................       if( (MACIsLinked()==0)&&(inicializado) ){//cable off 
075BA:  GOTO   6A76
075BE:  MOVF   01,F
075C0:  BNZ   75CE
075C2:  MOVF   50,F
075C4:  BZ    75CE
....................          //linked_out=1; 
....................          TCPDisconnect(socket2); 
075C6:  MOVFF  51,8FB
075CA:  CALL   5080
....................       } 
075CE:  GOTO   6DD0
....................       ////////////////////////////////////// 
....................    }//end true 
.................... }//end main 
....................  
075D2:  SLEEP 
.................... int convertir_to_entero(char *cadena){ 
*
062B0:  MOVLB  8
062B2:  CLRF   xF9
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
062B4:  MOVF   xF7,W
062B6:  SUBLW  30
062B8:  BNZ   62C2
062BA:  MOVF   xF8,F
062BC:  BNZ   62C2
062BE:  CLRF   xF9
062C0:  BRA    6350
....................    else if(cadena=='1') valor=1; 
062C2:  MOVF   xF7,W
062C4:  SUBLW  31
062C6:  BNZ   62D2
062C8:  MOVF   xF8,F
062CA:  BNZ   62D2
062CC:  MOVLW  01
062CE:  MOVWF  xF9
062D0:  BRA    6350
....................    else if(cadena=='2') valor=2; 
062D2:  MOVF   xF7,W
062D4:  SUBLW  32
062D6:  BNZ   62E2
062D8:  MOVF   xF8,F
062DA:  BNZ   62E2
062DC:  MOVLW  02
062DE:  MOVWF  xF9
062E0:  BRA    6350
....................    else if(cadena=='3') valor=3; 
062E2:  MOVF   xF7,W
062E4:  SUBLW  33
062E6:  BNZ   62F2
062E8:  MOVF   xF8,F
062EA:  BNZ   62F2
062EC:  MOVLW  03
062EE:  MOVWF  xF9
062F0:  BRA    6350
....................    else if(cadena=='4') valor=4; 
062F2:  MOVF   xF7,W
062F4:  SUBLW  34
062F6:  BNZ   6302
062F8:  MOVF   xF8,F
062FA:  BNZ   6302
062FC:  MOVLW  04
062FE:  MOVWF  xF9
06300:  BRA    6350
....................    else if(cadena=='5') valor=5; 
06302:  MOVF   xF7,W
06304:  SUBLW  35
06306:  BNZ   6312
06308:  MOVF   xF8,F
0630A:  BNZ   6312
0630C:  MOVLW  05
0630E:  MOVWF  xF9
06310:  BRA    6350
....................    else if(cadena=='6') valor=6; 
06312:  MOVF   xF7,W
06314:  SUBLW  36
06316:  BNZ   6322
06318:  MOVF   xF8,F
0631A:  BNZ   6322
0631C:  MOVLW  06
0631E:  MOVWF  xF9
06320:  BRA    6350
....................    else if(cadena=='7') valor=7; 
06322:  MOVF   xF7,W
06324:  SUBLW  37
06326:  BNZ   6332
06328:  MOVF   xF8,F
0632A:  BNZ   6332
0632C:  MOVLW  07
0632E:  MOVWF  xF9
06330:  BRA    6350
....................    else if(cadena=='8') valor=8; 
06332:  MOVF   xF7,W
06334:  SUBLW  38
06336:  BNZ   6342
06338:  MOVF   xF8,F
0633A:  BNZ   6342
0633C:  MOVLW  08
0633E:  MOVWF  xF9
06340:  BRA    6350
....................    else if(cadena=='9') valor=9; 
06342:  MOVF   xF7,W
06344:  SUBLW  39
06346:  BNZ   6350
06348:  MOVF   xF8,F
0634A:  BNZ   6350
0634C:  MOVLW  09
0634E:  MOVWF  xF9
....................    return valor; 
06350:  MOVFF  8F9,01
06354:  MOVLB  0
06356:  RETURN 0
.................... } 
....................  
.................... void fecha(){//falta revisar si se deshabilitan las int globales 
....................    disable_interrupts(INT_RDA); 
*
0646C:  BCF    F9D.5
....................    //delay_ms(1000); 
.................... //   lcd_gotoxy(1,2); 
.................... //   lcd_putc("\f     CONFIGURA      ");// 
.................... //   lcd_gotoxy(1,3); 
.................... //   lcd_putc("     FECHA/HORA     "); 
....................     
....................    setup_wdt(WDT_ON); 
0646E:  BSF    FD1.0
....................    restart_wdt(); 
06470:  CLRWDT
....................     
....................    day=(convertir_to_entero(XX[instruccion_size])*10)+convertir_to_entero(XX[instruccion_size+1]); 
06472:  MOVLB  8
06474:  CLRF   xF8
06476:  MOVFF  5C,8F7
0647A:  MOVLB  0
0647C:  RCALL  62B0
0647E:  MOVF   01,W
06480:  MULLW  0A
06482:  MOVFF  FF3,8F6
06486:  MOVLB  8
06488:  CLRF   xF8
0648A:  MOVFF  5D,8F7
0648E:  MOVLB  0
06490:  RCALL  62B0
06492:  MOVF   01,W
06494:  MOVLB  8
06496:  ADDWF  xF6,W
06498:  MOVLB  2
0649A:  MOVWF  x70
....................    hrs=(convertir_to_entero(XX[instruccion_size+7])*10)+convertir_to_entero(XX[instruccion_size+8]); 
0649C:  MOVLB  8
0649E:  CLRF   xF8
064A0:  MOVFF  63,8F7
064A4:  MOVLB  0
064A6:  RCALL  62B0
064A8:  MOVF   01,W
064AA:  MULLW  0A
064AC:  MOVFF  FF3,8F6
064B0:  MOVLB  8
064B2:  CLRF   xF8
064B4:  MOVFF  64,8F7
064B8:  MOVLB  0
064BA:  RCALL  62B0
064BC:  MOVF   01,W
064BE:  MOVLB  8
064C0:  ADDWF  xF6,W
064C2:  MOVLB  2
064C4:  MOVWF  x73
....................    min=(convertir_to_entero(XX[instruccion_size+9])*10)+convertir_to_entero(XX[instruccion_size+10]); 
064C6:  MOVLB  8
064C8:  CLRF   xF8
064CA:  MOVFF  65,8F7
064CE:  MOVLB  0
064D0:  RCALL  62B0
064D2:  MOVF   01,W
064D4:  MULLW  0A
064D6:  MOVFF  FF3,8F6
064DA:  MOVLB  8
064DC:  CLRF   xF8
064DE:  MOVFF  66,8F7
064E2:  MOVLB  0
064E4:  RCALL  62B0
064E6:  MOVF   01,W
064E8:  MOVLB  8
064EA:  ADDWF  xF6,W
064EC:  MOVLB  2
064EE:  MOVWF  x74
....................    sec=(convertir_to_entero(XX[instruccion_size+11])*10)+convertir_to_entero(XX[instruccion_size+12]); 
064F0:  MOVLB  8
064F2:  CLRF   xF8
064F4:  MOVFF  67,8F7
064F8:  MOVLB  0
064FA:  RCALL  62B0
064FC:  MOVF   01,W
064FE:  MULLW  0A
06500:  MOVFF  FF3,8F6
06504:  MOVLB  8
06506:  CLRF   xF8
06508:  MOVFF  68,8F7
0650C:  MOVLB  0
0650E:  RCALL  62B0
06510:  MOVF   01,W
06512:  MOVLB  8
06514:  ADDWF  xF6,W
06516:  MOVLB  2
06518:  MOVWF  x75
....................     
....................    month=(convertir_to_entero(XX[instruccion_size+2])*10)+convertir_to_entero(XX[instruccion_size+3]); 
0651A:  MOVLB  8
0651C:  CLRF   xF8
0651E:  MOVFF  5E,8F7
06522:  MOVLB  0
06524:  RCALL  62B0
06526:  MOVF   01,W
06528:  MULLW  0A
0652A:  MOVFF  FF3,8F6
0652E:  MOVLB  8
06530:  CLRF   xF8
06532:  MOVFF  5F,8F7
06536:  MOVLB  0
06538:  RCALL  62B0
0653A:  MOVF   01,W
0653C:  MOVLB  8
0653E:  ADDWF  xF6,W
06540:  MOVLB  2
06542:  MOVWF  x71
....................    yr= (convertir_to_entero(XX[instruccion_size+4])*10)+convertir_to_entero(XX[instruccion_size+5]); 
06544:  MOVLB  8
06546:  CLRF   xF8
06548:  MOVFF  60,8F7
0654C:  MOVLB  0
0654E:  RCALL  62B0
06550:  MOVF   01,W
06552:  MULLW  0A
06554:  MOVFF  FF3,8F6
06558:  MOVLB  8
0655A:  CLRF   xF8
0655C:  MOVFF  61,8F7
06560:  MOVLB  0
06562:  RCALL  62B0
06564:  MOVF   01,W
06566:  MOVLB  8
06568:  ADDWF  xF6,W
0656A:  MOVLB  2
0656C:  MOVWF  x72
....................    dow= convertir_to_entero(XX[instruccion_size+6]); 
0656E:  MOVLB  8
06570:  CLRF   xF8
06572:  MOVFF  62,8F7
06576:  MOVLB  0
06578:  RCALL  62B0
0657A:  MOVFF  01,276
....................    ///////////////////// 
....................    ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos), ,hora,min,seg 
0657E:  MOVFF  270,906
06582:  MOVFF  271,907
06586:  MOVFF  272,908
0658A:  MOVFF  276,909
0658E:  MOVFF  273,90A
06592:  MOVFF  274,90B
06596:  MOVFF  275,90C
0659A:  RCALL  6380
....................    //lcd_gotoxy(1,1); 
....................    //printf(lcd_putc,"      %02d:%02d:%02d      ",hrs,min,sec); 
....................    //lcd_gotoxy(1,2); 
....................    //printf (lcd_putc,"     %02d/%02d/2%03d     ",day,month,yr); 
....................    //lcd_gotoxy(1,3); 
....................    //lcd_putc("  DATOS GUARDADOS   "); 
....................    lcd_gotoxy(1,4); 
0659C:  MOVLW  01
0659E:  MOVLB  8
065A0:  MOVWF  xFD
065A2:  MOVLW  04
065A4:  MOVWF  xFE
065A6:  MOVLB  0
065A8:  CALL   05DE
....................    lcd_putc("  Hora Actualizada  "); 
065AC:  MOVLW  3A
065AE:  MOVWF  FF6
065B0:  MOVLW  03
065B2:  MOVWF  FF7
065B4:  CALL   0696
....................    delay_ms(2500); 
065B8:  MOVLW  0A
065BA:  MOVLB  8
065BC:  MOVWF  xF6
065BE:  MOVLW  FA
065C0:  MOVWF  xFD
065C2:  MOVLB  0
065C4:  CALL   05B4
065C8:  MOVLB  8
065CA:  DECFSZ xF6,F
065CC:  BRA    65BE
....................    restart_wdt(); 
065CE:  CLRWDT
....................    //if(demo==1) printf("\r\nXX:%s",XX); 
....................    enable_interrupts(INT_RDA); 
065D0:  BSF    F9D.5
065D2:  MOVLB  0
065D4:  GOTO   7156 (RETURN)
.................... } 
....................  
.................... void wiegand_read_card(){ 
....................  if(wieg_full){ 
*
0570C:  MOVLB  2
0570E:  MOVF   x10,F
05710:  BTFSC  FD8.2
05712:  BRA    583E
....................    //disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
....................    deci=0; 
05714:  CLRF   x15
05716:  CLRF   x14
05718:  CLRF   x13
0571A:  CLRF   x12
....................    for(i=1;i<sub_indice-1;i++) deci = (deci<<1)|data[i]; 
0571C:  CLRF   41
0571E:  MOVLW  01
05720:  MOVWF  40
05722:  MOVLW  01
05724:  SUBWF  x0F,W
05726:  MOVF   41,F
05728:  BNZ   5778
0572A:  SUBWF  40,W
0572C:  BC    5778
0572E:  BCF    FD8.0
05730:  RLCF   x12,W
05732:  MOVLB  8
05734:  MOVWF  xF7
05736:  MOVLB  2
05738:  RLCF   x13,W
0573A:  MOVLB  8
0573C:  MOVWF  xF8
0573E:  MOVLB  2
05740:  RLCF   x14,W
05742:  MOVLB  8
05744:  MOVWF  xF9
05746:  MOVLB  2
05748:  RLCF   x15,W
0574A:  MOVLB  8
0574C:  MOVWF  xFA
0574E:  MOVLW  16
05750:  ADDWF  40,W
05752:  MOVWF  FE9
05754:  MOVLW  02
05756:  ADDWFC 41,W
05758:  MOVWF  FEA
0575A:  MOVF   FEF,W
0575C:  IORWF  xF7,W
0575E:  MOVLB  2
05760:  MOVWF  x12
05762:  MOVFF  8F8,213
05766:  MOVFF  8F9,214
0576A:  MOVFF  8FA,215
0576E:  MOVLB  2
05770:  INCF   40,F
05772:  BTFSC  FD8.2
05774:  INCF   41,F
05776:  BRA    5722
....................    sprintf(YY,"%08LX",deci);// imprime en un arreglo (printf en ram) 
05778:  MOVLB  8
0577A:  CLRF   xF4
0577C:  MOVLW  AC
0577E:  MOVWF  xF3
05780:  MOVFF  215,8F6
05784:  MOVLW  37
05786:  MOVWF  xF7
05788:  MOVLB  0
0578A:  RCALL  5682
0578C:  MOVFF  214,8F6
05790:  MOVLW  37
05792:  MOVLB  8
05794:  MOVWF  xF7
05796:  MOVLB  0
05798:  RCALL  5682
0579A:  MOVFF  213,8F6
0579E:  MOVLW  37
057A0:  MOVLB  8
057A2:  MOVWF  xF7
057A4:  MOVLB  0
057A6:  RCALL  5682
057A8:  MOVFF  212,8F6
057AC:  MOVLW  37
057AE:  MOVLB  8
057B0:  MOVWF  xF7
057B2:  MOVLB  0
057B4:  RCALL  5682
....................    sprintf(txtcp,"EN1-%08LX",deci);// imprime en un arreglo (printf en ram) 
057B6:  MOVLW  01
057B8:  MOVLB  8
057BA:  MOVWF  xF4
057BC:  MOVLW  06
057BE:  MOVWF  xF3
057C0:  MOVLW  50
057C2:  MOVWF  FF6
057C4:  MOVLW  03
057C6:  MOVWF  FF7
057C8:  MOVLW  04
057CA:  MOVWF  xF6
057CC:  MOVLB  0
057CE:  BRA    56C8
057D0:  MOVFF  215,8F6
057D4:  MOVLW  37
057D6:  MOVLB  8
057D8:  MOVWF  xF7
057DA:  MOVLB  0
057DC:  RCALL  5682
057DE:  MOVFF  214,8F6
057E2:  MOVLW  37
057E4:  MOVLB  8
057E6:  MOVWF  xF7
057E8:  MOVLB  0
057EA:  RCALL  5682
057EC:  MOVFF  213,8F6
057F0:  MOVLW  37
057F2:  MOVLB  8
057F4:  MOVWF  xF7
057F6:  MOVLB  0
057F8:  RCALL  5682
057FA:  MOVFF  212,8F6
057FE:  MOVLW  37
05800:  MOVLB  8
05802:  MOVWF  xF7
05804:  MOVLB  0
05806:  RCALL  5682
....................    //fprintf(DEBUG,"TA:%s\r\n",txtcp); 
....................    //lcd_gotoxy(1,3); 
....................    //printf(lcd_putc,"TA:%s",txtcp); 
....................    size_tx_tcp=strlen(txtcp); 
05808:  MOVLW  01
0580A:  MOVLB  9
0580C:  MOVWF  x0C
0580E:  MOVLW  06
05810:  MOVWF  x0B
05812:  MOVLB  0
05814:  RCALL  561A
05816:  MOVFF  01,48
....................    enviar_tcp(); 
0581A:  RCALL  5656
....................    //validar_tag_salida();//FUNCION PARA ABRIR AUTOMATICAMENTE Y GUARDAR ESTADO DE ANTIPASS 
....................    wieg_full=0; 
0581C:  MOVLB  2
0581E:  CLRF   x10
....................    wieg=sub_indice=0; 
05820:  CLRF   x0F
05822:  MOVFF  20F,20C
....................    wiegand_cuenta=0; 
05826:  CLRF   x11
....................    memset(data, 0, sizeof(data) ); 
05828:  MOVLW  02
0582A:  MOVWF  FEA
0582C:  MOVLW  16
0582E:  MOVWF  FE9
05830:  CLRF   00
05832:  CLRF   02
05834:  MOVLW  1A
05836:  MOVWF  01
05838:  MOVLB  0
0583A:  RCALL  56F2
0583C:  MOVLB  2
....................  }//END TARJETA LEIDA 
....................  if( (wieg==1)&&(wiegand_cuenta>=3) ) { 
0583E:  DECFSZ x0C,W
05840:  BRA    588A
05842:  MOVF   x11,W
05844:  SUBLW  02
05846:  BC    588A
....................       wigmal++; 
05848:  INCF   x0D,F
....................       //fprintf(DEBUG,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_gotoxy(1,4); 
....................       //printf(lcd_putc,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_putc("CAPTURA INCOMPLETA  "); 
....................       wieg_full=0; 
0584A:  CLRF   x10
....................       deci=0; 
0584C:  CLRF   x15
0584E:  CLRF   x14
05850:  CLRF   x13
05852:  CLRF   x12
....................       ///////////UNIFICANDO EL TAMAÑO DEL DATO LEIDO///////////////// 
....................       deteccion_nulo=0; 
05854:  CLRF   x0A
....................       pre_cuenta=0; 
05856:  CLRF   x0B
....................       ////////////////////// 
....................       wieg=sub_indice=i=0; 
05858:  CLRF   41
0585A:  CLRF   40
0585C:  MOVFF  40,20F
05860:  MOVFF  20F,20C
....................       wiegand_cuenta=0; 
05864:  CLRF   x11
....................       for(i=0;i<wieg_size;i++) data[i]=0; 
05866:  CLRF   41
05868:  CLRF   40
0586A:  MOVF   41,F
0586C:  BNZ   588A
0586E:  MOVF   40,W
05870:  SUBLW  19
05872:  BNC   588A
05874:  MOVLW  16
05876:  ADDWF  40,W
05878:  MOVWF  FE9
0587A:  MOVLW  02
0587C:  ADDWFC 41,W
0587E:  MOVWF  FEA
05880:  CLRF   FEF
05882:  INCF   40,F
05884:  BTFSC  FD8.2
05886:  INCF   41,F
05888:  BRA    586A
....................  } 
0588A:  MOVLB  0
0588C:  GOTO   6EB4 (RETURN)
.................... } 
....................  
.................... void enviar_tcp(){ 
....................    envia_pc=1; 
*
05656:  MOVLW  01
05658:  MOVWF  1A
....................    StackTask(); 
0565A:  CALL   4478
....................    MyTCPTask(); 
0565E:  RCALL  52AE
05660:  RETURN 0
.................... } 
.................... //////////////////// 
.................... void zeller(){ 
.................... int16 dia_s1,dia_s2,dia_s3,diac,mesc,dia_fecha;//(day,month,yr,dow,hrs,min,sec 
....................    int siglo,asiglo,resultado,di2; 
....................    diac=31; 
*
065D8:  MOVLB  8
065DA:  CLRF   xFD
065DC:  MOVLW  1F
065DE:  MOVWF  xFC
....................    mesc=10; 
065E0:  CLRF   xFF
065E2:  MOVLW  0A
065E4:  MOVWF  xFE
....................    siglo=20; 
065E6:  MOVLW  14
065E8:  MOVLB  9
065EA:  MOVWF  x02
....................    asiglo=yr; 
065EC:  MOVFF  272,903
....................    //fprintf(U1PRINTER,"Dia:%Ld mes:%Ld año:%d siglo:%d asiglo:%d\r\n",diac,mesc,asiglo,siglo,asiglo); 
....................    if(mesc<3){ 
065F0:  MOVLB  8
065F2:  MOVF   xFF,F
065F4:  BNZ   660A
065F6:  MOVF   xFE,W
065F8:  SUBLW  02
065FA:  BNC   660A
....................       mesc+=12; 
065FC:  MOVLW  0C
065FE:  ADDWF  xFE,F
06600:  MOVLW  00
06602:  ADDWFC xFF,F
....................       asiglo--; 
06604:  MOVLB  9
06606:  DECF   x03,F
06608:  MOVLB  8
....................    } 
....................    dia_s1=(siglo/4)+5*siglo; 
0660A:  MOVLB  9
0660C:  RRCF   x02,W
0660E:  MOVWF  x06
06610:  RRCF   x06,F
06612:  MOVLW  3F
06614:  ANDWF  x06,F
06616:  MOVF   x02,W
06618:  MULLW  05
0661A:  MOVF   FF3,W
0661C:  ADDWF  x06,W
0661E:  MOVLB  8
06620:  MOVWF  xF6
06622:  CLRF   xF7
....................    dia_s2=dia_s1+asiglo+(asiglo/4); 
06624:  MOVLB  9
06626:  MOVF   x03,W
06628:  MOVLB  8
0662A:  ADDWF  xF6,W
0662C:  MOVLB  9
0662E:  MOVWF  x06
06630:  MOVLW  00
06632:  MOVLB  8
06634:  ADDWFC xF7,W
06636:  MOVLB  9
06638:  MOVWF  x07
0663A:  RRCF   x03,W
0663C:  MOVWF  00
0663E:  RRCF   00,F
06640:  MOVLW  3F
06642:  ANDWF  00,F
06644:  MOVF   00,W
06646:  ADDWF  x06,W
06648:  MOVLB  8
0664A:  MOVWF  xF8
0664C:  MOVLW  00
0664E:  MOVLB  9
06650:  ADDWFC x07,W
06652:  MOVLB  8
06654:  MOVWF  xF9
....................    dia_s3=dia_s2+((mesc+1)*26)/10; 
06656:  MOVLW  01
06658:  ADDWF  xFE,W
0665A:  MOVLB  9
0665C:  MOVWF  x06
0665E:  MOVLW  00
06660:  MOVLB  8
06662:  ADDWFC xFF,W
06664:  MOVLB  9
06666:  MOVWF  x07
06668:  MOVWF  x47
0666A:  MOVFF  906,946
0666E:  CLRF   x49
06670:  MOVLW  1A
06672:  MOVWF  x48
06674:  MOVLB  0
06676:  CALL   0FBE
0667A:  MOVFF  02,907
0667E:  MOVFF  01,906
06682:  MOVFF  02,909
06686:  MOVFF  01,908
0668A:  MOVLB  9
0668C:  CLRF   x0B
0668E:  MOVLW  0A
06690:  MOVWF  x0A
06692:  MOVLB  0
06694:  CALL   1052
06698:  MOVF   01,W
0669A:  MOVLB  8
0669C:  ADDWF  xF8,W
0669E:  MOVWF  xFA
066A0:  MOVF   02,W
066A2:  ADDWFC xF9,W
066A4:  MOVWF  xFB
....................    dia_fecha=(dia_s3+diac)%7;//dia de fin de mes 
066A6:  MOVF   xFC,W
066A8:  ADDWF  xFA,W
066AA:  MOVLB  9
066AC:  MOVWF  x06
066AE:  MOVLB  8
066B0:  MOVF   xFD,W
066B2:  ADDWFC xFB,W
066B4:  MOVLB  9
066B6:  MOVWF  x07
066B8:  MOVWF  x09
066BA:  MOVFF  906,908
066BE:  CLRF   x0B
066C0:  MOVLW  07
066C2:  MOVWF  x0A
066C4:  MOVLB  0
066C6:  CALL   1052
066CA:  MOVFF  00,900
066CE:  MOVLB  9
066D0:  MOVFF  03,901
....................    if(dia_fecha==0) dia_fecha=7; 
066D4:  MOVF   x00,F
066D6:  BNZ   66E2
066D8:  MOVF   x01,F
066DA:  BNZ   66E2
066DC:  CLRF   x01
066DE:  MOVLW  07
066E0:  MOVWF  x00
....................    //fprintf(U1PRINTER,"Dia:%Ld ",dia_fecha); 
....................    resultado=31-(dia_fecha-1); 
066E2:  MOVLW  01
066E4:  SUBWF  x00,W
066E6:  MOVWF  00
066E8:  MOVLW  00
066EA:  SUBWFB x01,W
066EC:  MOVF   00,W
066EE:  XORLW  FF
066F0:  ADDLW  20
066F2:  MOVWF  x04
....................    //fprintf(U1PRINTER,"Dia:%d ",resultado); 
.................... ///////////revisar cambio de horario//////////// 
.................... ds1307_get_date(day,month,yr,dow); 
.................... ds1307_get_time(hrs,min,sec); 
.................... di2=read_ext_eeprom(14); 
*
068CC:  MOVLB  9
068CE:  CLRF   x07
068D0:  MOVLW  0E
068D2:  MOVWF  x06
068D4:  MOVLB  0
068D6:  CALL   1362
068DA:  MOVFF  01,905
.................... if((month==4)&&(dow==1)&&(hrs>=2)&&(di2!=1)){//cambia a horario de verano 
068DE:  MOVLB  2
068E0:  MOVF   x71,W
068E2:  SUBLW  04
068E4:  BNZ   693C
068E6:  DECFSZ x76,W
068E8:  BRA    693C
068EA:  MOVF   x73,W
068EC:  SUBLW  01
068EE:  BC    693C
068F0:  MOVLB  9
068F2:  DECFSZ x05,W
068F4:  BRA    68FC
068F6:  MOVLB  2
068F8:  BRA    693C
068FA:  MOVLB  9
....................  hrs=hrs+1; 
068FC:  MOVLW  01
068FE:  MOVLB  2
06900:  ADDWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
06902:  MOVFF  270,906
06906:  MOVFF  271,907
0690A:  MOVFF  272,908
0690E:  MOVFF  276,909
06912:  MOVFF  273,90A
06916:  MOVFF  274,90B
0691A:  MOVFF  275,90C
0691E:  MOVLB  0
06920:  RCALL  6380
....................  di2=1; 
06922:  MOVLW  01
06924:  MOVLB  9
06926:  MOVWF  x05
....................  write_ext_eeprom(14,di2);//(1,0)horario de invierno 
06928:  CLRF   x07
0692A:  MOVLW  0E
0692C:  MOVWF  x06
0692E:  MOVFF  905,908
06932:  MOVLB  0
06934:  CALL   140A
.................... } 
06938:  BRA    69A2
0693A:  MOVLB  2
.................... //if((month==10)&&(dow==1)&&(day==resultado)&&(hrs==3)&&(di2!=day)){//cambia a horario de invierno 
.................... else if((month==10)&&(day==resultado)&&(hrs>=3)&&(hrs<=5)&&(di2!=day)){//cambia a horario de invierno 
0693C:  MOVF   x71,W
0693E:  SUBLW  0A
06940:  BNZ   69A4
06942:  MOVLB  9
06944:  MOVF   x04,W
06946:  MOVLB  2
06948:  SUBWF  x70,W
0694A:  BNZ   69A4
0694C:  MOVF   x73,W
0694E:  SUBLW  02
06950:  BC    69A4
06952:  MOVF   x73,W
06954:  SUBLW  05
06956:  BNC   69A4
06958:  MOVF   x70,W
0695A:  MOVLB  9
0695C:  SUBWF  x05,W
0695E:  BTFSS  FD8.2
06960:  BRA    6966
06962:  MOVLB  2
06964:  BRA    69A4
....................  hrs=hrs-1; 
06966:  MOVLW  01
06968:  MOVLB  2
0696A:  SUBWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
0696C:  MOVFF  270,906
06970:  MOVFF  271,907
06974:  MOVFF  272,908
06978:  MOVFF  276,909
0697C:  MOVFF  273,90A
06980:  MOVFF  274,90B
06984:  MOVFF  275,90C
06988:  MOVLB  0
0698A:  RCALL  6380
....................  di2=day; 
0698C:  MOVFF  270,905
....................  write_ext_eeprom(14,di2); 
06990:  MOVLB  9
06992:  CLRF   x07
06994:  MOVLW  0E
06996:  MOVWF  x06
06998:  MOVFF  905,908
0699C:  MOVLB  0
0699E:  CALL   140A
069A2:  MOVLB  2
....................  } 
069A4:  MOVLB  0
069A6:  GOTO   737A (RETURN)
.................... } 
.................... //////////////////// 
.................... void sensores(){ 
.................... if(en1!=input(entrada01) ){//SENSOR 1 bobina DE ENTRADA 
*
058B2:  BSF    F95.4
058B4:  MOVLW  00
058B6:  BTFSC  F83.4
058B8:  MOVLW  01
058BA:  MOVLB  2
058BC:  SUBWF  x83,W
058BE:  BZ    5900
....................    delay_ms(20); 
058C0:  MOVLW  14
058C2:  MOVLB  8
058C4:  MOVWF  xFD
058C6:  MOVLB  0
058C8:  CALL   05B4
....................    if(en1!=input(entrada01)){ 
058CC:  BSF    F95.4
058CE:  MOVLW  00
058D0:  BTFSC  F83.4
058D2:  MOVLW  01
058D4:  MOVLB  2
058D6:  SUBWF  x83,W
058D8:  BZ    5900
....................       en1=input(entrada01); 
058DA:  BSF    F95.4
058DC:  CLRF   x83
058DE:  BTFSC  F83.4
058E0:  INCF   x83,F
....................       //fen4=0; 
....................       if(en1==1){ 
058E2:  DECFSZ x83,W
058E4:  BRA    58FA
....................          lcd_putc("\f\n     BIENVENIDO"); 
058E6:  MOVLW  5A
058E8:  MOVWF  FF6
058EA:  MOVLW  03
058EC:  MOVWF  FF7
058EE:  MOVLB  0
058F0:  CALL   0696
....................          re_bol=0; 
058F4:  MOVLB  2
058F6:  CLRF   x8A
....................          //strcpy(txtcp,"EN1-ENTRADA"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
058F8:  BRA    5900
....................       else { 
....................          output_low(salida04); 
058FA:  BCF    F95.3
058FC:  BCF    F8C.3
....................          re_bol=0; 
058FE:  CLRF   x8A
....................          //lcd_putc("\fEN1-SINDETECCION"); 
....................          //strcpy(txtcp,"EN1-SINDETECCION"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................    } 
.................... }//end S1 
....................  
.................... if(en4!=input(entrada04) ){//BOTON DE TICKET 
05900:  BSF    F95.0
05902:  MOVLW  00
05904:  BTFSC  F83.0
05906:  MOVLW  01
05908:  SUBWF  x86,W
0590A:  BZ    595A
....................    //delay_ms(10); 
....................    if(en4!=input(entrada04)){ 
0590C:  BSF    F95.0
0590E:  MOVLW  00
05910:  BTFSC  F83.0
05912:  MOVLW  01
05914:  SUBWF  x86,W
05916:  BZ    595A
....................       en4=input(entrada04); 
05918:  BSF    F95.0
0591A:  CLRF   x86
0591C:  BTFSC  F83.0
0591E:  INCF   x86,F
....................       //printf(lcd_putc,"\fbot:%d au:%d hbot:%d cpo:%d "en3,en1,fen3,cupo ); 
....................       //if( (en4)&&(en1)&&(fen4!=1)&&(cupo!=1) ){ 
....................       if( (en4)&&(en1)&&(!re_bol) ){ 
05920:  MOVF   x86,F
05922:  BZ    595A
05924:  MOVF   x83,F
05926:  BZ    595A
05928:  MOVF   x8A,F
0592A:  BNZ   595A
....................       //if( (en4)&&(en1) ){ 
....................          time_boleto=0; 
0592C:  CLRF   x89
....................          //re_bol=1; 
....................          sprintf(txtcp,"BOTON_BOLETO");//01-id de camion  
0592E:  MOVLW  01
05930:  MOVLB  8
05932:  MOVWF  xF4
05934:  MOVLW  06
05936:  MOVWF  xF3
05938:  MOVLW  6C
0593A:  MOVWF  FF6
0593C:  MOVLW  03
0593E:  MOVWF  FF7
05940:  MOVLB  0
05942:  BRA    5890
....................          size_tx_tcp=strlen(txtcp); 
05944:  MOVLW  01
05946:  MOVLB  9
05948:  MOVWF  x0C
0594A:  MOVLW  06
0594C:  MOVWF  x0B
0594E:  MOVLB  0
05950:  RCALL  561A
05952:  MOVFF  01,48
....................          enviar_tcp(); 
05956:  RCALL  5656
05958:  MOVLB  2
....................       }//end boton activado 
....................       /*else if( (en4==1)&&(cupo) ){ 
....................             lcd_gotoxy(1,2); 
....................             lcd_putc("     CUPO LLENO     "); 
....................       }*/ 
....................    }//verificacion boton 
.................... }//en boton ticket 
0595A:  MOVLB  0
0595C:  GOTO   6EB8 (RETURN)
.................... ///////////////////// 
.................... /*if(en5!=input(entrada05) ){//SENSOR DE BARRERA ENTRADA 
....................    delay_ms(200); 
....................    if(en5!=input(entrada05) ){ 
....................       en5=input(entrada05); 
....................       if( (en5==0)&&(flag_pluma==0) ){ 
....................          espera_tcp(); 
....................          for(i=0;i<16;i++) tcp_XX[i]=barrera[i];//BARRERAABIERTAS2 
....................          size_tx_tcp=i; 
....................          enviar_tcp();//enviar a pc//avisar por tcp 
....................       } 
....................       else if(en5==1) flag_pluma=0; 
....................    } 
.................... }*/ 
.................... ///////////////////// 
.................... } 
.................... //EPSON 
.................... void ticket(){//U1PRINTER //HHMMSSFFFFFFFFZ 
....................    // 1-Direccion1 para Folio 
....................    // 2-Direccion2 para Folio 
....................    // 3-Direccion3 para Folio 
....................    //int cta_l,cta_m,cta_h; 
....................    char fol_bol[20]; 
....................    /*//leer 
....................    cta_l=read_ext_eeprom(3); 
....................    cta_m=read_ext_eeprom(2); 
....................    cta_h=read_ext_eeprom(1); 
....................    folio=0;//24bits 16,777,215 
....................    folio=cta_h;// 
....................    folio=(folio<<8)|cta_m; 
....................    folio=(folio<<8)|cta_l; 
....................    //fin de leer 
....................    folio++; 
....................    //printf("Total:%Ld\r\n",folio); 
....................    write_ext_eeprom(3,folio);//graba 
....................    write_ext_eeprom(2,folio>>8);//graba 
....................    write_ext_eeprom(1,folio>>16);//graba 
....................    */ 
....................    //////////////////////////////// 
....................    ds1307_get_date(day,month,yr,dow); 
....................    ds1307_get_time(hrs,min,sec); 
....................    ////////texto////// 
....................    //inicializa el envio de codigos esc/pos 
....................    fputc(27, U1PRINTER); 
*
05F66:  MOVLW  1B
05F68:  MOVLB  9
05F6A:  MOVWF  x10
05F6C:  MOVLB  0
05F6E:  RCALL  5B2A
....................    fputc('@', U1PRINTER); 
05F70:  MOVLW  40
05F72:  MOVLB  9
05F74:  MOVWF  x10
05F76:  MOVLB  0
05F78:  RCALL  5B2A
....................    //linea de justificacion 1B "a" 0izquierda 1centrado 2derecha 
....................    fputc(27, U1PRINTER); 
05F7A:  MOVLW  1B
05F7C:  MOVLB  9
05F7E:  MOVWF  x10
05F80:  MOVLB  0
05F82:  RCALL  5B2A
....................    fputc(97, U1PRINTER); 
05F84:  MOVLW  61
05F86:  MOVLB  9
05F88:  MOVWF  x10
05F8A:  MOVLB  0
05F8C:  RCALL  5B2A
....................    fputc(1, U1PRINTER); 
05F8E:  MOVLW  01
05F90:  MOVLB  9
05F92:  MOVWF  x10
05F94:  MOVLB  0
05F96:  RCALL  5B2A
....................    //////interlineado//////// 
....................    //fprintf(U1PRINTER,"\x1B"); 
....................    //fprintf(U1PRINTER,"3"); 
....................    fputc(27, U1PRINTER); 
05F98:  MOVLW  1B
05F9A:  MOVLB  9
05F9C:  MOVWF  x10
05F9E:  MOVLB  0
05FA0:  RCALL  5B2A
....................    fputc(51, U1PRINTER); 
05FA2:  MOVLW  33
05FA4:  MOVLB  9
05FA6:  MOVWF  x10
05FA8:  MOVLB  0
05FAA:  RCALL  5B2A
....................    fputc(40, U1PRINTER); 
05FAC:  MOVLW  28
05FAE:  MOVLB  9
05FB0:  MOVWF  x10
05FB2:  MOVLB  0
05FB4:  RCALL  5B2A
....................    //////////// 
....................    /////negritas activas 
....................    fprintf(U1PRINTER,"\x1B"); 
05FB6:  MOVLW  1B
05FB8:  MOVLB  9
05FBA:  MOVWF  x10
05FBC:  MOVLB  0
05FBE:  RCALL  5B2A
....................    fprintf(U1PRINTER,"G"); 
05FC0:  MOVLW  47
05FC2:  MOVLB  9
05FC4:  MOVWF  x10
05FC6:  MOVLB  0
05FC8:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\x01"); 
05FCA:  MOVLW  01
05FCC:  MOVLB  9
05FCE:  MOVWF  x10
05FD0:  MOVLB  0
05FD2:  RCALL  5B2A
....................    /////Tipo de fuente 
....................    fprintf(U1PRINTER,"\x1B"); 
05FD4:  MOVLW  1B
05FD6:  MOVLB  9
05FD8:  MOVWF  x10
05FDA:  MOVLB  0
05FDC:  RCALL  5B2A
....................    fprintf(U1PRINTER,"!"); 
05FDE:  MOVLW  21
05FE0:  MOVLB  9
05FE2:  MOVWF  x10
05FE4:  MOVLB  0
05FE6:  RCALL  5B2A
....................    fputc(1, U1PRINTER); 
05FE8:  MOVLW  01
05FEA:  MOVLB  9
05FEC:  MOVWF  x10
05FEE:  MOVLB  0
05FF0:  RCALL  5B2A
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
05FF2:  MOVLW  1D
05FF4:  MOVLB  9
05FF6:  MOVWF  x10
05FF8:  MOVLB  0
05FFA:  RCALL  5B2A
....................    fprintf(U1PRINTER,"!"); 
05FFC:  MOVLW  21
05FFE:  MOVLB  9
06000:  MOVWF  x10
06002:  MOVLB  0
06004:  RCALL  5B2A
....................    fputc(17, U1PRINTER); 
06006:  MOVLW  11
06008:  MOVLB  9
0600A:  MOVWF  x10
0600C:  MOVLB  0
0600E:  RCALL  5B2A
....................    //printf("\x0A");//limpia la justificación 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    memset(fol_bol, 0, sizeof(fol_bol)); 
06010:  MOVLW  08
06012:  MOVWF  FEA
06014:  MOVLW  F6
06016:  MOVWF  FE9
06018:  CLRF   00
0601A:  CLRF   02
0601C:  MOVLW  14
0601E:  MOVWF  01
06020:  CALL   56F2
....................    for(i=0;i<strlen(XX);i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
06024:  CLRF   41
06026:  CLRF   40
06028:  MOVLB  9
0602A:  CLRF   x0C
0602C:  MOVLW  52
0602E:  MOVWF  x0B
06030:  MOVLB  0
06032:  CALL   561A
06036:  MOVFF  02,03
0603A:  MOVF   41,W
0603C:  SUBWF  02,W
0603E:  BNC   6082
06040:  BNZ   6048
06042:  MOVF   01,W
06044:  SUBWF  40,W
06046:  BC    6082
06048:  MOVLW  F6
0604A:  ADDWF  40,W
0604C:  MOVWF  01
0604E:  MOVLW  08
06050:  ADDWFC 41,W
06052:  MOVWF  03
06054:  MOVFF  01,90A
06058:  MOVLB  9
0605A:  MOVWF  x0B
0605C:  MOVLW  5C
0605E:  ADDWF  40,W
06060:  MOVWF  FE9
06062:  MOVLW  00
06064:  ADDWFC 41,W
06066:  MOVWF  FEA
06068:  MOVFF  FEF,90E
0606C:  MOVFF  03,FEA
06070:  MOVFF  01,FE9
06074:  MOVFF  90E,FEF
06078:  INCF   40,F
0607A:  BTFSC  FD8.2
0607C:  INCF   41,F
0607E:  BRA    602A
06080:  MOVLB  0
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //folio = atoi32(fol_bol); 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    fprintf(U1PRINTER,"Folio:%s",fol_bol); 
06082:  MOVLW  7A
06084:  MOVWF  FF6
06086:  MOVLW  03
06088:  MOVWF  FF7
0608A:  MOVLW  06
0608C:  MOVLB  9
0608E:  MOVWF  x0A
06090:  MOVLB  0
06092:  RCALL  5B3A
06094:  MOVLW  08
06096:  MOVWF  FEA
06098:  MOVLW  F6
0609A:  MOVWF  FE9
0609C:  RCALL  5B62
....................    strcpy(barra_codi,fol_bol); 
0609E:  MOVLW  02
060A0:  MOVWF  FEA
060A2:  MOVLW  4E
060A4:  MOVWF  FE9
060A6:  MOVLW  08
060A8:  MOVWF  FE2
060AA:  MOVLW  F6
060AC:  MOVWF  FE1
060AE:  MOVF   FE7,F
060B0:  MOVFF  FE6,FEE
060B4:  BNZ   60AE
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
060B6:  MOVLW  0A
060B8:  MOVLB  9
060BA:  MOVWF  x10
060BC:  MOVLB  0
060BE:  RCALL  5B2A
....................    LF(); 
060C0:  RCALL  5B86
....................    /////////////////////////////////////////////////////////// 
....................    fprintf(U1PRINTER,"MARIA TERESA BAEZ MONROY"); 
060C2:  MOVLW  84
060C4:  MOVWF  FF6
060C6:  MOVLW  03
060C8:  MOVWF  FF7
060CA:  RCALL  5B92
....................    //printf("\x0A");//limpia la justificación  
....................    ////desactiva negritas 
....................    fprintf(U1PRINTER,"\x1B"); 
060CC:  MOVLW  1B
060CE:  MOVLB  9
060D0:  MOVWF  x10
060D2:  MOVLB  0
060D4:  RCALL  5B2A
....................    fprintf(U1PRINTER,"G"); 
060D6:  MOVLW  47
060D8:  MOVLB  9
060DA:  MOVWF  x10
060DC:  MOVLB  0
060DE:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\x00"); 
....................    /////////////////////////////////////////////////////////// 
....................    LF(); 
060E0:  RCALL  5B86
....................    LF(); 
060E2:  RCALL  5B86
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
060E4:  MOVLW  1D
060E6:  MOVLB  9
060E8:  MOVWF  x10
060EA:  MOVLB  0
060EC:  RCALL  5B2A
....................    fprintf(U1PRINTER,"!"); 
060EE:  MOVLW  21
060F0:  MOVLB  9
060F2:  MOVWF  x10
060F4:  MOVLB  0
060F6:  RCALL  5B2A
....................    fputc(0, U1PRINTER); 
060F8:  MOVLB  9
060FA:  CLRF   x10
060FC:  MOVLB  0
060FE:  RCALL  5B2A
....................    ///// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06100:  MOVLW  0A
06102:  MOVLB  9
06104:  MOVWF  x10
06106:  MOVLB  0
06108:  RCALL  5B2A
....................    fprintf(U1PRINTER,"RFC:BAMT97052884A\x0A"); 
0610A:  MOVLW  9E
0610C:  MOVWF  FF6
0610E:  MOVLW  03
06110:  MOVWF  FF7
06112:  RCALL  5B92
....................    fprintf(U1PRINTER,"4 poniente 1302, colonia Centro  CP 72000\x0APuebla, Puebla\x0A"); 
06114:  MOVLW  B2
06116:  MOVWF  FF6
06118:  MOVLW  03
0611A:  MOVWF  FF7
0611C:  RCALL  5B92
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
0611E:  MOVLW  1D
06120:  MOVLB  9
06122:  MOVWF  x10
06124:  MOVLB  0
06126:  RCALL  5B2A
....................    fprintf(U1PRINTER,"!"); 
06128:  MOVLW  21
0612A:  MOVLB  9
0612C:  MOVWF  x10
0612E:  MOVLB  0
06130:  RCALL  5B2A
....................    fputc(17, U1PRINTER); 
06132:  MOVLW  11
06134:  MOVLB  9
06136:  MOVWF  x10
06138:  MOVLB  0
0613A:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0613C:  MOVLW  0A
0613E:  MOVLB  9
06140:  MOVWF  x10
06142:  MOVLB  0
06144:  RCALL  5B2A
....................    fprintf(U1PRINTER,"%02d/%02d/20%02d %02d:%02d:%02d",day,month,yr,hrs,min,sec); 
06146:  MOVFF  270,90A
0614A:  MOVLW  01
0614C:  MOVLB  9
0614E:  MOVWF  x0B
06150:  MOVLB  0
06152:  RCALL  5BB2
06154:  MOVLW  2F
06156:  MOVLB  9
06158:  MOVWF  x10
0615A:  MOVLB  0
0615C:  RCALL  5B2A
0615E:  MOVFF  271,90A
06162:  MOVLW  01
06164:  MOVLB  9
06166:  MOVWF  x0B
06168:  MOVLB  0
0616A:  RCALL  5BB2
0616C:  MOVLW  F5
0616E:  MOVWF  FF6
06170:  MOVLW  03
06172:  MOVWF  FF7
06174:  MOVLW  03
06176:  MOVLB  9
06178:  MOVWF  x0A
0617A:  MOVLB  0
0617C:  RCALL  5B3A
0617E:  MOVFF  272,90A
06182:  MOVLW  01
06184:  MOVLB  9
06186:  MOVWF  x0B
06188:  MOVLB  0
0618A:  RCALL  5BB2
0618C:  MOVLW  20
0618E:  MOVLB  9
06190:  MOVWF  x10
06192:  MOVLB  0
06194:  RCALL  5B2A
06196:  MOVFF  273,90A
0619A:  MOVLW  01
0619C:  MOVLB  9
0619E:  MOVWF  x0B
061A0:  MOVLB  0
061A2:  RCALL  5BB2
061A4:  MOVLW  3A
061A6:  MOVLB  9
061A8:  MOVWF  x10
061AA:  MOVLB  0
061AC:  RCALL  5B2A
061AE:  MOVFF  274,90A
061B2:  MOVLW  01
061B4:  MOVLB  9
061B6:  MOVWF  x0B
061B8:  MOVLB  0
061BA:  RCALL  5BB2
061BC:  MOVLW  3A
061BE:  MOVLB  9
061C0:  MOVWF  x10
061C2:  MOVLB  0
061C4:  RCALL  5B2A
061C6:  MOVFF  275,90A
061CA:  MOVLW  01
061CC:  MOVLB  9
061CE:  MOVWF  x0B
061D0:  MOVLB  0
061D2:  RCALL  5BB2
....................    LF(); 
061D4:  RCALL  5B86
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
061D6:  MOVLW  1D
061D8:  MOVLB  9
061DA:  MOVWF  x10
061DC:  MOVLB  0
061DE:  RCALL  5B2A
....................    fprintf(U1PRINTER,"!"); 
061E0:  MOVLW  21
061E2:  MOVLB  9
061E4:  MOVWF  x10
061E6:  MOVLB  0
061E8:  RCALL  5B2A
....................    fputc(0, U1PRINTER); 
061EA:  MOVLB  9
061EC:  CLRF   x10
061EE:  MOVLB  0
061F0:  RCALL  5B2A
....................    ///// 
....................    barra1(); 
061F2:  BRA    5C72
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
061F4:  MOVLW  0A
061F6:  MOVLB  9
061F8:  MOVWF  x10
061FA:  MOVLB  0
061FC:  RCALL  5B2A
....................    fprintf(U1PRINTER,"TARIFA:$15 Hora o Fraccion                     \x0A"); 
061FE:  MOVLW  0C
06200:  MOVWF  FF6
06202:  MOVLW  04
06204:  MOVWF  FF7
06206:  RCALL  5B92
....................    fprintf(U1PRINTER,"TOLERANCIA:5 min. la primera hora              \x0A"); 
06208:  MOVLW  3E
0620A:  MOVWF  FF6
0620C:  MOVLW  04
0620E:  MOVWF  FF7
06210:  RCALL  5B92
....................    fprintf(U1PRINTER,"Horarios:de 7:00 a 21:00hrs. de lunes a viernes\x0A"); 
06212:  MOVLW  70
06214:  MOVWF  FF6
06216:  MOVLW  04
06218:  MOVWF  FF7
0621A:  RCALL  5B92
....................    fprintf(U1PRINTER,"Sabados  de 7:00 a 14:00hrs.                   \x0A"); 
0621C:  MOVLW  A2
0621E:  MOVWF  FF6
06220:  MOVLW  04
06222:  MOVWF  FF7
06224:  RCALL  5B92
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06226:  MOVLW  0A
06228:  MOVLB  9
0622A:  MOVWF  x10
0622C:  MOVLB  0
0622E:  RCALL  5B2A
....................    //////////////////// 
....................    barra2(); 
06230:  BRA    5D20
....................    //////////////////// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06232:  MOVLW  0A
06234:  MOVLB  9
06236:  MOVWF  x10
06238:  MOVLB  0
0623A:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0623C:  MOVLW  0A
0623E:  MOVLB  9
06240:  MOVWF  x10
06242:  MOVLB  0
06244:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\"ACCESA\" automatizacion "); 
06246:  MOVLW  D4
06248:  MOVWF  FF6
0624A:  MOVLW  04
0624C:  MOVWF  FF7
0624E:  RCALL  5B92
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06250:  MOVLW  0A
06252:  MOVLB  9
06254:  MOVWF  x10
06256:  MOVLB  0
06258:  RCALL  5B2A
....................    fprintf(U1PRINTER,"www.accesa.me  automatizacion@accesa.me"); 
0625A:  MOVLW  EE
0625C:  MOVWF  FF6
0625E:  MOVLW  04
06260:  MOVWF  FF7
06262:  RCALL  5B92
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
06264:  MOVLW  0A
06266:  MOVLB  9
06268:  MOVWF  x10
0626A:  MOVLB  0
0626C:  RCALL  5B2A
....................    /////////feed para corte de papel////////////// 
....................    fprintf(U1PRINTER,"\x1B"); 
0626E:  MOVLW  1B
06270:  MOVLB  9
06272:  MOVWF  x10
06274:  MOVLB  0
06276:  RCALL  5B2A
....................    fprintf(U1PRINTER,"J"); 
06278:  MOVLW  4A
0627A:  MOVLB  9
0627C:  MOVWF  x10
0627E:  MOVLB  0
06280:  RCALL  5B2A
....................    //fputc(190, U1PRINTER); 
....................    fputc(250, U1PRINTER); 
06282:  MOVLW  FA
06284:  MOVLB  9
06286:  MOVWF  x10
06288:  MOVLB  0
0628A:  RCALL  5B2A
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación  
0628C:  MOVLW  0A
0628E:  MOVLB  9
06290:  MOVWF  x10
06292:  MOVLB  0
06294:  RCALL  5B2A
....................    LF(); 
06296:  RCALL  5B86
....................    ///////// 
....................    //ESC i 69 Corte total de papel 
....................    //ESC m 6D Corte parcial de papel 
....................    fprintf(U1PRINTER,"\x1B"); 
06298:  MOVLW  1B
0629A:  MOVLB  9
0629C:  MOVWF  x10
0629E:  MOVLB  0
062A0:  RCALL  5B2A
....................    fprintf(U1PRINTER,"m"); 
062A2:  MOVLW  6D
062A4:  MOVLB  9
062A6:  MOVWF  x10
062A8:  MOVLB  0
062AA:  RCALL  5B2A
062AC:  GOTO   6F8A (RETURN)
....................    //////////////////////////////////////// 
.................... } 
....................  
.................... void LF(){ 
.................... fprintf(U1PRINTER,"\x0A"); 
*
05B86:  MOVLW  0A
05B88:  MOVLB  9
05B8A:  MOVWF  x10
05B8C:  MOVLB  0
05B8E:  RCALL  5B2A
05B90:  RETURN 0
.................... } 
....................  
.................... void CR(){ 
.................... fprintf(U1PRINTER,"\x0D");//enter 
.................... } 
....................  
.................... void barra1(){ 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d",folio,yr,month,day,hrs,min,sec);// 
....................    //sprintf(con_barra,"%08Ld%d",folio,idbar);//01-id de camion 
....................     
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //fprintf(U1PRINTER,"%08Ld/%02d/%02d/%02d/%02d/%02d/%02d/%d/",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi)+2; 
*
05C72:  MOVLW  02
05C74:  MOVLB  9
05C76:  MOVWF  x0C
05C78:  MOVLW  4E
05C7A:  MOVWF  x0B
05C7C:  MOVLB  0
05C7E:  RCALL  561A
05C80:  MOVLW  02
05C82:  MOVLB  9
05C84:  ADDWF  01,W
05C86:  MOVWF  x0A
....................    //printf (lcd_putc,"\fsize_bar:%u",size_bar); 
....................    //delay_ms(2000); 
.................... //////bar code/////// 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05C88:  MOVLW  16
05C8A:  MOVWF  FF6
05C8C:  MOVLW  05
05C8E:  MOVWF  FF7
05C90:  MOVLB  0
05C92:  RCALL  5B92
....................    fprintf(U1PRINTER,"\x1D\x77\x01");// 
05C94:  MOVLW  1A
05C96:  MOVWF  FF6
05C98:  MOVLW  05
05C9A:  MOVWF  FF7
05C9C:  RCALL  5B92
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05C9E:  MOVLW  1D
05CA0:  MOVLB  9
05CA2:  MOVWF  x10
05CA4:  MOVLB  0
05CA6:  RCALL  5B2A
....................    fputc(72,U1PRINTER);// 
05CA8:  MOVLW  48
05CAA:  MOVLB  9
05CAC:  MOVWF  x10
05CAE:  MOVLB  0
05CB0:  RCALL  5B2A
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05CB2:  MOVLW  02
05CB4:  MOVLB  9
05CB6:  MOVWF  x10
05CB8:  MOVLB  0
05CBA:  RCALL  5B2A
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05CBC:  MOVLW  1D
05CBE:  MOVLB  9
05CC0:  MOVWF  x10
05CC2:  MOVLB  0
05CC4:  RCALL  5B2A
....................    fputc(102,U1PRINTER);// 
05CC6:  MOVLW  66
05CC8:  MOVLB  9
05CCA:  MOVWF  x10
05CCC:  MOVLB  0
05CCE:  RCALL  5B2A
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05CD0:  MOVLW  01
05CD2:  MOVLB  9
05CD4:  MOVWF  x10
05CD6:  MOVLB  0
05CD8:  RCALL  5B2A
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05CDA:  MOVLW  1D
05CDC:  MOVLB  9
05CDE:  MOVWF  x10
05CE0:  MOVLB  0
05CE2:  RCALL  5B2A
....................    fputc('k',U1PRINTER); 
05CE4:  MOVLW  6B
05CE6:  MOVLB  9
05CE8:  MOVWF  x10
05CEA:  MOVLB  0
05CEC:  RCALL  5B2A
....................    fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
05CEE:  MOVLW  49
05CF0:  MOVLB  9
05CF2:  MOVWF  x10
05CF4:  MOVLB  0
05CF6:  RCALL  5B2A
....................    //fputc(23,U1PRINTER); //numero de caracteres+2 (solo code128) 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05CF8:  MOVFF  90A,910
05CFC:  RCALL  5B2A
....................    fputc(123,U1PRINTER);// d1 (solo code128) 
05CFE:  MOVLW  7B
05D00:  MOVLB  9
05D02:  MOVWF  x10
05D04:  MOVLB  0
05D06:  RCALL  5B2A
....................    fputc(65,U1PRINTER); // d2 (solo code128) 
05D08:  MOVLW  41
05D0A:  MOVLB  9
05D0C:  MOVWF  x10
05D0E:  MOVLB  0
05D10:  RCALL  5B2A
....................     
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05D12:  MOVLW  02
05D14:  MOVWF  FEA
05D16:  MOVLW  4E
05D18:  MOVWF  FE9
05D1A:  RCALL  5B62
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05D1C:  GOTO   61F4 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void barra2(){ 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi); 
05D20:  MOVLW  02
05D22:  MOVLB  9
05D24:  MOVWF  x0C
05D26:  MOVLW  4E
05D28:  MOVWF  x0B
05D2A:  MOVLB  0
05D2C:  RCALL  561A
05D2E:  MOVFF  01,90A
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    //CODIGO DE BARRAS 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
05D32:  MOVLW  1E
05D34:  MOVWF  FF6
05D36:  MOVLW  05
05D38:  MOVWF  FF7
05D3A:  RCALL  5B92
....................    fprintf(U1PRINTER,"\x1D\x77\x01");//setea ancho 
05D3C:  MOVLW  22
05D3E:  MOVWF  FF6
05D40:  MOVLW  05
05D42:  MOVWF  FF7
05D44:  RCALL  5B92
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
05D46:  MOVLW  1D
05D48:  MOVLB  9
05D4A:  MOVWF  x10
05D4C:  MOVLB  0
05D4E:  RCALL  5B2A
....................    fputc(72,U1PRINTER);// 
05D50:  MOVLW  48
05D52:  MOVLB  9
05D54:  MOVWF  x10
05D56:  MOVLB  0
05D58:  RCALL  5B2A
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
05D5A:  MOVLW  02
05D5C:  MOVLB  9
05D5E:  MOVWF  x10
05D60:  MOVLB  0
05D62:  RCALL  5B2A
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
05D64:  MOVLW  1D
05D66:  MOVLB  9
05D68:  MOVWF  x10
05D6A:  MOVLB  0
05D6C:  RCALL  5B2A
....................    fputc(102,U1PRINTER);// 
05D6E:  MOVLW  66
05D70:  MOVLB  9
05D72:  MOVWF  x10
05D74:  MOVLB  0
05D76:  RCALL  5B2A
....................    fputc(1,U1PRINTER);//0,1 Y 2 
05D78:  MOVLW  01
05D7A:  MOVLB  9
05D7C:  MOVWF  x10
05D7E:  MOVLB  0
05D80:  RCALL  5B2A
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
05D82:  MOVLW  1D
05D84:  MOVLB  9
05D86:  MOVWF  x10
05D88:  MOVLB  0
05D8A:  RCALL  5B2A
....................    fputc('k',U1PRINTER); 
05D8C:  MOVLW  6B
05D8E:  MOVLB  9
05D90:  MOVWF  x10
05D92:  MOVLB  0
05D94:  RCALL  5B2A
....................    fputc(69,U1PRINTER);//69=code39//72=code93//73=code128//70=ITF(solo cantidades pares)// 
05D96:  MOVLW  45
05D98:  MOVLB  9
05D9A:  MOVWF  x10
05D9C:  MOVLB  0
05D9E:  RCALL  5B2A
....................    //fputc(21,U1PRINTER);//numero de caracteres 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
05DA0:  MOVFF  90A,910
05DA4:  RCALL  5B2A
....................    fprintf(U1PRINTER,"%s",barra_codi); 
05DA6:  MOVLW  02
05DA8:  MOVWF  FEA
05DAA:  MOVLW  4E
05DAC:  MOVWF  FE9
05DAE:  RCALL  5B62
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
05DB0:  GOTO   6232 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void encri(){ 
....................  int tem; 
....................  //fprintf(U1PRINTER,"con_barra:%Lu\r\n",strlen(con_barra)); 
....................   
....................  for(tem=0;tem<=strlen(con_barra);tem++){ 
....................          if(con_barra[tem]=='0') barra_codi[tem]='5'; 
....................     else if(con_barra[tem]=='1') barra_codi[tem]='7'; 
....................     else if(con_barra[tem]=='2') barra_codi[tem]='8'; 
....................     else if(con_barra[tem]=='3') barra_codi[tem]='2'; 
....................     else if(con_barra[tem]=='4') barra_codi[tem]='9'; 
....................     else if(con_barra[tem]=='5') barra_codi[tem]='0'; 
....................     else if(con_barra[tem]=='6') barra_codi[tem]='6'; 
....................     else if(con_barra[tem]=='7') barra_codi[tem]='4'; 
....................     else if(con_barra[tem]=='8') barra_codi[tem]='1'; 
....................     else if(con_barra[tem]=='9') barra_codi[tem]='3'; 
....................  }//end for 
.................... } 
....................  
.................... ///////////////////// 
.................... void llaves(){ 
....................    int tem; 
....................    char texto[12]; 
....................    ////////////////llaves//////////// 
....................    ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
*
0073A:  MOVLW  01
0073C:  MOVLB  8
0073E:  MOVWF  xF6
00740:  MOVF   xF6,W
00742:  SUBLW  0E
00744:  BTFSS  FD8.0
00746:  BRA    0A02
....................       switch (tem) { 
00748:  MOVLW  01
0074A:  SUBWF  xF6,W
0074C:  ADDLW  F2
0074E:  BTFSC  FD8.0
00750:  BRA    0900
00752:  ADDLW  0E
00754:  MOVLB  0
00756:  GOTO   0A08
....................            case 1: {// 
....................                strcpy(texto,texto1); 
0075A:  MOVLW  08
0075C:  MOVWF  FEA
0075E:  MOVLW  F7
00760:  MOVWF  FE9
00762:  MOVLW  02
00764:  MOVWF  FE2
00766:  MOVLW  8D
00768:  MOVWF  FE1
0076A:  MOVF   FE7,F
0076C:  MOVFF  FE6,FEE
00770:  BNZ   076A
....................                break;} 
00772:  MOVLB  8
00774:  BRA    0900
00776:  MOVLB  0
....................            case 2: {// 
....................                strcpy(texto,texto2); 
00778:  MOVLW  08
0077A:  MOVWF  FEA
0077C:  MOVLW  F7
0077E:  MOVWF  FE9
00780:  MOVLW  02
00782:  MOVWF  FE2
00784:  MOVLW  99
00786:  MOVWF  FE1
00788:  MOVF   FE7,F
0078A:  MOVFF  FE6,FEE
0078E:  BNZ   0788
....................                break;} 
00790:  MOVLB  8
00792:  BRA    0900
00794:  MOVLB  0
....................            case 3: {// 
....................                strcpy(texto,texto3); 
00796:  MOVLW  08
00798:  MOVWF  FEA
0079A:  MOVLW  F7
0079C:  MOVWF  FE9
0079E:  MOVLW  02
007A0:  MOVWF  FE2
007A2:  MOVLW  A5
007A4:  MOVWF  FE1
007A6:  MOVF   FE7,F
007A8:  MOVFF  FE6,FEE
007AC:  BNZ   07A6
....................                break;} 
007AE:  MOVLB  8
007B0:  BRA    0900
007B2:  MOVLB  0
....................            case 4: {// 
....................                strcpy(texto,texto4); 
007B4:  MOVLW  08
007B6:  MOVWF  FEA
007B8:  MOVLW  F7
007BA:  MOVWF  FE9
007BC:  MOVLW  02
007BE:  MOVWF  FE2
007C0:  MOVLW  B1
007C2:  MOVWF  FE1
007C4:  MOVF   FE7,F
007C6:  MOVFF  FE6,FEE
007CA:  BNZ   07C4
....................                break;} 
007CC:  MOVLB  8
007CE:  BRA    0900
007D0:  MOVLB  0
....................            case 5: {// 
....................                strcpy(texto,texto5); 
007D2:  MOVLW  08
007D4:  MOVWF  FEA
007D6:  MOVLW  F7
007D8:  MOVWF  FE9
007DA:  MOVLW  02
007DC:  MOVWF  FE2
007DE:  MOVLW  BD
007E0:  MOVWF  FE1
007E2:  MOVF   FE7,F
007E4:  MOVFF  FE6,FEE
007E8:  BNZ   07E2
....................                break;} 
007EA:  MOVLB  8
007EC:  BRA    0900
007EE:  MOVLB  0
....................            case 6: {// 
....................                strcpy(texto,texto6); 
007F0:  MOVLW  08
007F2:  MOVWF  FEA
007F4:  MOVLW  F7
007F6:  MOVWF  FE9
007F8:  MOVLW  02
007FA:  MOVWF  FE2
007FC:  MOVLW  C9
007FE:  MOVWF  FE1
00800:  MOVF   FE7,F
00802:  MOVFF  FE6,FEE
00806:  BNZ   0800
....................                break;} 
00808:  MOVLB  8
0080A:  BRA    0900
0080C:  MOVLB  0
....................            case 7: {// 
....................                strcpy(texto,texto7); 
0080E:  MOVLW  08
00810:  MOVWF  FEA
00812:  MOVLW  F7
00814:  MOVWF  FE9
00816:  MOVLW  02
00818:  MOVWF  FE2
0081A:  MOVLW  D5
0081C:  MOVWF  FE1
0081E:  MOVF   FE7,F
00820:  MOVFF  FE6,FEE
00824:  BNZ   081E
....................                break;} 
00826:  MOVLB  8
00828:  BRA    0900
0082A:  MOVLB  0
....................            case 8: {// 
....................                strcpy(texto,texto8); 
0082C:  MOVLW  08
0082E:  MOVWF  FEA
00830:  MOVLW  F7
00832:  MOVWF  FE9
00834:  MOVLW  02
00836:  MOVWF  FE2
00838:  MOVLW  E1
0083A:  MOVWF  FE1
0083C:  MOVF   FE7,F
0083E:  MOVFF  FE6,FEE
00842:  BNZ   083C
....................                break;} 
00844:  MOVLB  8
00846:  BRA    0900
00848:  MOVLB  0
....................            case 9: {// 
....................                strcpy(texto,texto9); 
0084A:  MOVLW  08
0084C:  MOVWF  FEA
0084E:  MOVLW  F7
00850:  MOVWF  FE9
00852:  MOVLW  02
00854:  MOVWF  FE2
00856:  MOVLW  ED
00858:  MOVWF  FE1
0085A:  MOVF   FE7,F
0085C:  MOVFF  FE6,FEE
00860:  BNZ   085A
....................                break;} 
00862:  MOVLB  8
00864:  BRA    0900
00866:  MOVLB  0
....................            case 10: {// 
....................                strcpy(texto,texto10); 
00868:  MOVLW  08
0086A:  MOVWF  FEA
0086C:  MOVLW  F7
0086E:  MOVWF  FE9
00870:  MOVLW  02
00872:  MOVWF  FE2
00874:  MOVLW  F9
00876:  MOVWF  FE1
00878:  MOVF   FE7,F
0087A:  MOVFF  FE6,FEE
0087E:  BNZ   0878
....................                break;} 
00880:  MOVLB  8
00882:  BRA    0900
00884:  MOVLB  0
....................            case 11: {// 
....................                strcpy(texto,texto11); 
00886:  MOVLW  08
00888:  MOVWF  FEA
0088A:  MOVLW  F7
0088C:  MOVWF  FE9
0088E:  MOVLW  03
00890:  MOVWF  FE2
00892:  MOVLW  05
00894:  MOVWF  FE1
00896:  MOVF   FE7,F
00898:  MOVFF  FE6,FEE
0089C:  BNZ   0896
....................                break;} 
0089E:  MOVLB  8
008A0:  BRA    0900
008A2:  MOVLB  0
....................            case 12: {// 
....................                strcpy(texto,texto12); 
008A4:  MOVLW  08
008A6:  MOVWF  FEA
008A8:  MOVLW  F7
008AA:  MOVWF  FE9
008AC:  MOVLW  03
008AE:  MOVWF  FE2
008B0:  MOVLW  11
008B2:  MOVWF  FE1
008B4:  MOVF   FE7,F
008B6:  MOVFF  FE6,FEE
008BA:  BNZ   08B4
....................                break;} 
008BC:  MOVLB  8
008BE:  BRA    0900
008C0:  MOVLB  0
....................            case 13: {// 
....................                strcpy(texto,texto13); 
008C2:  MOVLW  08
008C4:  MOVWF  FEA
008C6:  MOVLW  F7
008C8:  MOVWF  FE9
008CA:  MOVLW  03
008CC:  MOVWF  FE2
008CE:  MOVLW  1D
008D0:  MOVWF  FE1
008D2:  MOVF   FE7,F
008D4:  MOVFF  FE6,FEE
008D8:  BNZ   08D2
....................                break;} 
008DA:  MOVLB  8
008DC:  BRA    0900
008DE:  MOVLB  0
....................            case 14: {// 
....................                strcpy(texto,texto14); 
008E0:  MOVLW  08
008E2:  MOVWF  FEA
008E4:  MOVLW  F7
008E6:  MOVWF  FE9
008E8:  MOVLW  03
008EA:  MOVWF  FE2
008EC:  MOVLW  29
008EE:  MOVWF  FE1
008F0:  MOVF   FE7,F
008F2:  MOVFF  FE6,FEE
008F6:  BNZ   08F0
....................                break;} 
008F8:  MOVLB  8
008FA:  BRA    0900
008FC:  MOVLB  0
008FE:  MOVLB  8
....................       } 
....................       a=i=0; 
00900:  CLRF   41
00902:  CLRF   40
00904:  MOVFF  40,1B
....................       while (i < instruccion_size) {  //word_size=8 
00908:  MOVF   41,F
0090A:  BNZ   098C
0090C:  MOVF   40,W
0090E:  SUBLW  09
00910:  BNC   098C
....................            memory[i] = read_eeprom( (tem*instruccion_size)+i); 
00912:  MOVLW  22
00914:  ADDWF  40,W
00916:  MOVWF  FE9
00918:  MOVLW  00
0091A:  ADDWFC 41,W
0091C:  MOVWF  FEA
0091E:  MOVF   xF6,W
00920:  MULLW  0A
00922:  MOVF   FF3,W
00924:  ADDWF  40,W
00926:  MOVLB  9
00928:  MOVWF  x05
0092A:  MOVLW  00
0092C:  ADDWFC 41,W
0092E:  MOVWF  x06
00930:  MOVFF  FF2,907
00934:  BCF    FF2.7
00936:  MOVFF  906,FAA
0093A:  MOVFF  905,FA9
0093E:  BCF    FA6.6
00940:  BCF    FA6.7
00942:  BSF    FA6.0
00944:  MOVF   FA8,W
00946:  BTFSC  x07.7
00948:  BSF    FF2.7
0094A:  MOVWF  FEF
....................            if (memory[i] != texto[i])  break; 
0094C:  MOVLW  22
0094E:  ADDWF  40,W
00950:  MOVWF  FE9
00952:  MOVLW  00
00954:  ADDWFC 41,W
00956:  MOVWF  FEA
00958:  MOVFF  FEF,903
0095C:  MOVLW  F7
0095E:  ADDWF  40,W
00960:  MOVWF  FE9
00962:  MOVLW  08
00964:  ADDWFC 41,W
00966:  MOVWF  FEA
00968:  MOVF   FEF,W
0096A:  SUBWF  x03,W
0096C:  BZ    0974
0096E:  MOVLB  8
00970:  BRA    098C
00972:  MOVLB  9
....................            i++; 
00974:  INCF   40,F
00976:  BTFSC  FD8.2
00978:  INCF   41,F
....................            if (i==instruccion_size) a=1; 
0097A:  MOVF   40,W
0097C:  SUBLW  0A
0097E:  BNZ   0988
00980:  MOVF   41,F
00982:  BNZ   0988
00984:  MOVLW  01
00986:  MOVWF  1B
00988:  MOVLB  8
0098A:  BRA    0908
....................       } 
....................       //fprintf(U1PRINTER,"\r\n"); 
....................       if (a==0){ 
0098C:  MOVF   1B,F
0098E:  BNZ   09FE
....................          i=0; 
00990:  CLRF   41
00992:  CLRF   40
....................          while (texto[i] != 0x00){ 
00994:  MOVLW  F7
00996:  ADDWF  40,W
00998:  MOVWF  FE9
0099A:  MOVLW  08
0099C:  ADDWFC 41,W
0099E:  MOVWF  FEA
009A0:  MOVF   FEF,F
009A2:  BZ    09FE
....................             write_eeprom(i+(tem*instruccion_size),texto[i]); 
009A4:  MOVF   xF6,W
009A6:  MULLW  0A
009A8:  MOVF   FF3,W
009AA:  ADDWF  40,W
009AC:  MOVLB  9
009AE:  MOVWF  x03
009B0:  MOVLW  00
009B2:  ADDWFC 41,W
009B4:  MOVWF  x04
009B6:  MOVLW  F7
009B8:  ADDWF  40,W
009BA:  MOVWF  FE9
009BC:  MOVLW  08
009BE:  ADDWFC 41,W
009C0:  MOVWF  FEA
009C2:  MOVFF  FEF,905
009C6:  MOVF   FF2,W
009C8:  MOVWF  00
009CA:  BCF    FF2.7
009CC:  MOVFF  904,FAA
009D0:  MOVFF  903,FA9
009D4:  MOVFF  905,FA8
009D8:  BCF    FA6.6
009DA:  BCF    FA6.7
009DC:  BSF    FA6.2
009DE:  MOVLB  F
009E0:  MOVLW  55
009E2:  MOVWF  FA7
009E4:  MOVLW  AA
009E6:  MOVWF  FA7
009E8:  BSF    FA6.1
009EA:  BTFSC  FA6.1
009EC:  BRA    09EA
009EE:  BCF    FA6.2
009F0:  MOVF   00,W
009F2:  IORWF  FF2,F
....................             //fprintf(U1PRINTER,"%c",texto[i]); 
....................             i++; 
009F4:  INCF   40,F
009F6:  BTFSC  FD8.2
009F8:  INCF   41,F
009FA:  MOVLB  8
009FC:  BRA    0994
....................          }//end grabar 
....................       }//END a 
009FE:  INCF   xF6,F
00A00:  BRA    0740
....................    }//end for 
00A02:  MOVLB  0
00A04:  GOTO   6C3C (RETURN)
.................... } 
....................  
.................... void rd_eeprom(){ 
.................... n=a=b=0; 
*
05960:  CLRF   45
05962:  CLRF   44
05964:  MOVFF  44,1B
05968:  CLRF   43
0596A:  MOVFF  1B,42
.................... n=instruccion_size;// 
0596E:  CLRF   43
05970:  MOVLW  0A
05972:  MOVWF  42
.................... i=0; 
05974:  CLRF   41
05976:  CLRF   40
.................... while ((b <=data_numbers)&&(a==0)){//NUMERO TOTAL DE TARJETAS 
05978:  MOVF   45,F
0597A:  BNZ   5A1C
0597C:  MOVF   44,W
0597E:  SUBLW  0E
05980:  BNC   5A1C
05982:  MOVF   1B,F
05984:  BNZ   5A1C
....................     i=0; 
05986:  CLRF   41
05988:  CLRF   40
....................     b++; 
0598A:  INCF   44,F
0598C:  BTFSC  FD8.2
0598E:  INCF   45,F
....................     while (i < instruccion_size) {//WORD_SIZE_2=10 
05990:  MOVF   41,F
05992:  BNZ   5A10
05994:  MOVF   40,W
05996:  SUBLW  09
05998:  BNC   5A10
....................         memory[i] = read_eeprom(n+i); 
0599A:  MOVLW  22
0599C:  ADDWF  40,W
0599E:  MOVWF  FE9
059A0:  MOVLW  00
059A2:  ADDWFC 41,W
059A4:  MOVWF  FEA
059A6:  MOVF   40,W
059A8:  ADDWF  42,W
059AA:  MOVLB  8
059AC:  MOVWF  xF8
059AE:  MOVF   41,W
059B0:  ADDWFC 43,W
059B2:  MOVWF  xF9
059B4:  MOVFF  FF2,8FA
059B8:  BCF    FF2.7
059BA:  MOVFF  8F9,FAA
059BE:  MOVFF  8F8,FA9
059C2:  BCF    FA6.6
059C4:  BCF    FA6.7
059C6:  BSF    FA6.0
059C8:  MOVF   FA8,W
059CA:  BTFSC  xFA.7
059CC:  BSF    FF2.7
059CE:  MOVWF  FEF
....................         //fprintf(U1PRINTER,"m[%Ld]=%c",i,memory[i]); 
....................         //fprintf(U1PRINTER,"X[%Ld]=%c",i,XX[i]); 
....................         if (memory[i] != XX[i]) 
059D0:  MOVLW  22
059D2:  ADDWF  40,W
059D4:  MOVWF  FE9
059D6:  MOVLW  00
059D8:  ADDWFC 41,W
059DA:  MOVWF  FEA
059DC:  MOVFF  FEF,8F6
059E0:  MOVLW  52
059E2:  ADDWF  40,W
059E4:  MOVWF  FE9
059E6:  MOVLW  00
059E8:  ADDWFC 41,W
059EA:  MOVWF  FEA
059EC:  MOVF   FEF,W
059EE:  SUBWF  xF6,W
059F0:  BZ    59F8
....................             break; 
059F2:  MOVLB  0
059F4:  BRA    5A10
059F6:  MOVLB  8
....................         i++; 
059F8:  INCF   40,F
059FA:  BTFSC  FD8.2
059FC:  INCF   41,F
....................         if (i==instruccion_size) a=1; 
059FE:  MOVF   40,W
05A00:  SUBLW  0A
05A02:  BNZ   5A0C
05A04:  MOVF   41,F
05A06:  BNZ   5A0C
05A08:  MOVLW  01
05A0A:  MOVWF  1B
05A0C:  MOVLB  0
05A0E:  BRA    5990
....................     } 
....................     //fprintf(PRINTER," \r\n"); 
....................     //fprintf(PRINTER," n=%Ld ",n); 
....................     n=n+instruccion_size;//WORD_SIZE=30 
05A10:  MOVLW  0A
05A12:  ADDWF  42,F
05A14:  MOVLW  00
05A16:  ADDWFC 43,F
....................     restart_wdt(); 
05A18:  CLRWDT
05A1A:  BRA    5978
....................     //fprintf(U1PRINTER," \r\n"); 
....................     //fprintf(U1PRINTER,"b=%Ld",b); 
....................     } 
05A1C:  GOTO   6EDA (RETURN)
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) 
*
016B2:  MOVF   FD0,W
016B4:  ANDLW  0F
016B6:  BTFSS  FD0.4
016B8:  MOVLW  00
016BA:  BSF    FD0.0
016BC:  BSF    FD0.1
016BE:  BSF    FD0.4
016C0:  BSF    FD8.3
016C2:  BSF    FD8.4
016C4:  XORLW  07
016C6:  BZ    16D6
016C8:  XORLW  08
016CA:  BZ    16D8
016CC:  XORLW  01
016CE:  BZ    16DA
016D0:  XORLW  02
016D2:  BZ    16DC
016D4:  BRA    16DC
....................    { 
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-WD"); 
....................          break;} 
016D6:  BRA    16DC
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          //fprintf(U1PRINTER,"\r\nREINICIO-MCLR"); 
....................          break;} 
016D8:  BRA    16DC
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-VOLTAJE_BAJO"); 
....................          break; 
016DA:  BRA    16DC
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          //fprintf(U1PRINTER,"\r\nPOWER_UP"); 
....................          /* 
....................          #define WDT_TIMEOUT       7      
....................          #define MCLR_FROM_SLEEP  11      
....................          #define MCLR_FROM_RUN    15      
....................          #define NORMAL_POWER_UP  12      
....................          #define BROWNOUT_RESTART 14      
....................          #define WDT_FROM_SLEEP    3      
....................          #define RESET_INSTRUCTION 0     */ 
....................          break; 
....................       } 
....................    } 
016DC:  GOTO   6DD0 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1918   PUT NOBROWNOUT BORV21 WDT WDT4096
   Word  3: 8000   NOPBADEN NOLPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
