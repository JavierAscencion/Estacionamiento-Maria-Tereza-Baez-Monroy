CCS PCH C Compiler, Version 5.025, 24934               01-abr.-22 11:49

               Filename:   D:\PROYECTOS\PARKING\MARIA TERESA BAEZ MONROY(matanzo)\ENTRADA_V3\ENTRADA_CLIENTE.lst

               ROM used:   33864 bytes (52%)
                           Largest free fragment is 31670
               RAM used:   2301 (69%) at main() level
                           2503 (75%) worst case
               Stack used: 10 locations (9 in main + 1 for interrupts)
               Stack size: 31

*
00000:  GOTO   78E8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  BTFSS  FF2.5
00056:  GOTO   0060
0005A:  BTFSC  FF2.2
0005C:  GOTO   0106
00060:  BTFSS  F9D.0
00062:  GOTO   006C
00066:  BTFSC  F9E.0
00068:  GOTO   01AA
0006C:  BTFSS  FF2.4
0006E:  GOTO   0078
00072:  BTFSC  FF2.1
00074:  GOTO   01C6
00078:  BTFSS  FF0.3
0007A:  GOTO   0084
0007E:  BTFSC  FF0.0
00080:  GOTO   01FA
00084:  MOVFF  0E,00
00088:  MOVFF  0F,01
0008C:  MOVFF  10,02
00090:  MOVFF  11,03
00094:  MOVFF  0C,FE9
00098:  MOVFF  07,FEA
0009C:  BSF    07.7
0009E:  MOVFF  08,FE1
000A2:  MOVFF  09,FE2
000A6:  MOVFF  0A,FD9
000AA:  MOVFF  0B,FDA
000AE:  MOVFF  12,FF3
000B2:  MOVFF  13,FF4
000B6:  MOVFF  14,FFA
000BA:  MOVFF  15,FF5
000BE:  MOVFF  16,FF6
000C2:  MOVFF  17,FF7
000C6:  MOVF   04,W
000C8:  MOVFF  06,FE0
000CC:  MOVFF  05,FD8
000D0:  RETFIE 0
.................... //2019/01/23 Se cambio la razon social 
.................... //2018/06/21 //Version 1.2- serie MATE11.2 Se disminuyo tiempo de rebotes de auto 
.................... //2018/06/21 //Version 1.1- serie MATE11.1 Se modifico boleto, se agrego tolerancia y cambio hora de apertura 
.................... //2018/06/19 //Version 1- serie MATE11, 3 primeras letras de estacion, numero de entrada/cambios realizados 
.................... // Basado en: Programa de ejemplo 10 para comunicarme con el módulo ENC28J60. 
.................... // Cliente TCP. 
.................... // Incluimos las definiciones necesarias de la placa utilizada. 
.................... #include "Plantilla_Inicio.c" 
.................... // Controlador ETHERNET 
.................... // Fecha: 2018/02/19. 
.................... // Versión del compilador: v5.070 
.................... // Versión del programa: v0.1 
.................... // Revisión del programa: 0.00 
.................... // Definimos el microcontrolador utilizado. 
.................... #include <18F4680.h> // Definición de registros internos del PIC18F4520. 
.................... //////////// Standard Header file for the PIC18F4680 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F4680 
000D2:  CLRF   FF7
000D4:  ADDLW  E2
000D6:  MOVWF  FF6
000D8:  MOVLW  00
000DA:  ADDWFC FF7,F
000DC:  TBLRD*+
000DE:  MOVF   FF5,W
000E0:  RETURN 0
000E2:  DATA 28,0C
000E4:  DATA 01,06
000E6:  CLRF   FF7
000E8:  ADDLW  F6
000EA:  MOVWF  FF6
000EC:  MOVLW  00
000EE:  ADDWFC FF7,F
000F0:  TBLRD*+
000F2:  MOVF   FF5,W
000F4:  RETURN 0
000F6:  DATA 42,4F
000F8:  DATA 4C,45
000FA:  DATA 54,45
000FC:  DATA 52,41
000FE:  DATA 5F,50
00100:  DATA 41,47
00102:  DATA 41,44
00104:  DATA 4F,00
*
0012A:  DATA 53,6F
0012C:  DATA 6C,69
0012E:  DATA 63,69
00130:  DATA 74,75
00132:  DATA 64,20
00134:  DATA 41,52
00136:  DATA 50,2E
00138:  DATA 20,20
0013A:  DATA 20,20
0013C:  DATA 20,20
0013E:  DATA 00,00
00140:  DATA 43,4F
00142:  DATA 4E,45
00144:  DATA 43,54
00146:  DATA 41,4E
00148:  DATA 44,4F
0014A:  DATA 2E,2E
0014C:  DATA 2E,20
0014E:  DATA 20,20
00150:  DATA 20,20
00152:  DATA 20,20
00154:  DATA 00,00
00156:  DATA 45,72
00158:  DATA 72,6F
0015A:  DATA 72,20
0015C:  DATA 65,6E
0015E:  DATA 20,65
00160:  DATA 6C,20
00162:  DATA 73,6F
00164:  DATA 63,6B
00166:  DATA 65,74
00168:  DATA 2E,20
0016A:  DATA 00,00
0016C:  DATA 43,4F
0016E:  DATA 4E,45
00170:  DATA 43,54
00172:  DATA 41,44
00174:  DATA 4F,20
00176:  DATA 20,20
00178:  DATA 20,20
0017A:  DATA 20,20
0017C:  DATA 20,20
0017E:  DATA 20,20
00180:  DATA 00,00
00182:  DATA 44,45
00184:  DATA 53,43
00186:  DATA 4F,4E
00188:  DATA 45,43
0018A:  DATA 54,41
0018C:  DATA 44,4F
0018E:  DATA 20,20
00190:  DATA 20,20
00192:  DATA 20,20
00194:  DATA 20,00
00196:  DATA 44,45
00198:  DATA 53,43
0019A:  DATA 4F,4E
0019C:  DATA 45,43
0019E:  DATA 54,41
001A0:  DATA 44,4F
001A2:  DATA 20,20
001A4:  DATA 20,20
001A6:  DATA 20,20
001A8:  DATA 20,00
*
0022C:  DATA 0C,49
0022E:  DATA 4E,49
00230:  DATA 43,49
00232:  DATA 41,4E
00234:  DATA 44,4F
00236:  DATA 00,00
00238:  DATA 44,69
0023A:  DATA 61,73
0023C:  DATA 3A,25
0023E:  DATA 75,20
00240:  DATA 50,41
00242:  DATA 47,4F
00244:  DATA 3A,25
00246:  DATA 64,00
00248:  DATA 52,65
0024A:  DATA 73,74
0024C:  DATA 61,6E
0024E:  DATA 3A,25
00250:  DATA 75,20
00252:  DATA 00,00
00254:  DATA 54,49
00256:  DATA 45,4D
00258:  DATA 50,4F
0025A:  DATA 20,44
0025C:  DATA 45,20
0025E:  DATA 50,52
00260:  DATA 55,45
00262:  DATA 42,41
00264:  DATA 00,00
00266:  DATA 20,20
00268:  DATA 48,41
0026A:  DATA 20,45
0026C:  DATA 58,50
0026E:  DATA 49,52
00270:  DATA 41,44
00272:  DATA 4F,20
00274:  DATA 20,20
00276:  DATA 00,00
00278:  DATA 0C,0A
0027A:  DATA 20,20
0027C:  DATA 20,54
0027E:  DATA 4F,4D
00280:  DATA 45,20
00282:  DATA 53,55
00284:  DATA 20,42
00286:  DATA 4F,4C
00288:  DATA 45,54
0028A:  DATA 4F,0A
0028C:  DATA 20,59
0028E:  DATA 20,41
00290:  DATA 56,41
00292:  DATA 4E,43
00294:  DATA 45,20
00296:  DATA 50,4F
00298:  DATA 52,20
0029A:  DATA 46,41
0029C:  DATA 56,4F
0029E:  DATA 52,00
002A0:  DATA 0C,00
002A2:  DATA 20,20
002A4:  DATA 20,20
002A6:  DATA 20,20
002A8:  DATA 20,20
002AA:  DATA 20,20
002AC:  DATA 20,20
002AE:  DATA 20,20
002B0:  DATA 20,20
002B2:  DATA 20,20
002B4:  DATA 20,20
002B6:  DATA 00,00
002B8:  DATA 20,20
002BA:  DATA 20,25
002BC:  DATA 30,32
002BE:  DATA 64,20
002C0:  DATA 25,30
002C2:  DATA 32,64
002C4:  DATA 20,25
002C6:  DATA 30,32
002C8:  DATA 64,2F
002CA:  DATA 25,30
002CC:  DATA 32,64
002CE:  DATA 2F,25
002D0:  DATA 30,32
002D2:  DATA 64,20
002D4:  DATA 20,20
002D6:  DATA 20,00
002D8:  DATA 20,20
002DA:  DATA 20,25
002DC:  DATA 30,32
002DE:  DATA 64,3A
002E0:  DATA 25,30
002E2:  DATA 32,64
002E4:  DATA 20,25
002E6:  DATA 30,32
002E8:  DATA 64,2F
002EA:  DATA 25,30
002EC:  DATA 32,64
002EE:  DATA 2F,25
002F0:  DATA 30,32
002F2:  DATA 64,20
002F4:  DATA 20,20
002F6:  DATA 20,00
002F8:  DATA 20,20
002FA:  DATA 20,57
002FC:  DATA 57,57
002FE:  DATA 2E,41
00300:  DATA 43,43
00302:  DATA 45,53
00304:  DATA 41,2E
00306:  DATA 4D,45
00308:  DATA 20,20
0030A:  DATA 20,20
0030C:  DATA 00,00
0030E:  DATA 20,20
00310:  DATA 20,20
00312:  DATA 20,20
00314:  DATA 20,41
00316:  DATA 43,43
00318:  DATA 45,53
0031A:  DATA 41,20
0031C:  DATA 20,20
0031E:  DATA 20,20
00320:  DATA 20,20
00322:  DATA 00,00
00324:  DATA 20,20
00326:  DATA 20,20
00328:  DATA 20,20
0032A:  DATA 20,20
0032C:  DATA 20,20
0032E:  DATA 20,20
00330:  DATA 20,20
00332:  DATA 20,20
00334:  DATA 20,20
00336:  DATA 20,20
00338:  DATA 00,00
0033A:  DATA 20,20
0033C:  DATA 48,6F
0033E:  DATA 72,61
00340:  DATA 20,41
00342:  DATA 63,74
00344:  DATA 75,61
00346:  DATA 6C,69
00348:  DATA 7A,61
0034A:  DATA 64,61
0034C:  DATA 20,20
0034E:  DATA 00,00
00350:  DATA 45,4E
00352:  DATA 31,2D
00354:  DATA 25,30
00356:  DATA 38,4C
00358:  DATA 58,00
0035A:  DATA 0C,0A
0035C:  DATA 20,20
0035E:  DATA 20,20
00360:  DATA 20,42
00362:  DATA 49,45
00364:  DATA 4E,56
00366:  DATA 45,4E
00368:  DATA 49,44
0036A:  DATA 4F,00
0036C:  DATA 42,4F
0036E:  DATA 54,4F
00370:  DATA 4E,5F
00372:  DATA 42,4F
00374:  DATA 4C,45
00376:  DATA 54,4F
00378:  DATA 00,00
0037A:  DATA 46,6F
0037C:  DATA 6C,69
0037E:  DATA 6F,3A
00380:  DATA 25,73
00382:  DATA 00,00
00384:  DATA 4D,41
00386:  DATA 52,49
00388:  DATA 41,20
0038A:  DATA 54,45
0038C:  DATA 52,45
0038E:  DATA 53,41
00390:  DATA 20,42
00392:  DATA 41,45
00394:  DATA 5A,20
00396:  DATA 4D,4F
00398:  DATA 4E,52
0039A:  DATA 4F,59
0039C:  DATA 00,00
0039E:  DATA 52,46
003A0:  DATA 43,3A
003A2:  DATA 42,41
003A4:  DATA 4D,54
003A6:  DATA 39,37
003A8:  DATA 30,35
003AA:  DATA 32,38
003AC:  DATA 38,34
003AE:  DATA 41,0A
003B0:  DATA 00,00
003B2:  DATA 34,20
003B4:  DATA 70,6F
003B6:  DATA 6E,69
003B8:  DATA 65,6E
003BA:  DATA 74,65
003BC:  DATA 20,31
003BE:  DATA 33,30
003C0:  DATA 32,2C
003C2:  DATA 20,63
003C4:  DATA 6F,6C
003C6:  DATA 6F,6E
003C8:  DATA 69,61
003CA:  DATA 20,43
003CC:  DATA 65,6E
003CE:  DATA 74,72
003D0:  DATA 6F,20
003D2:  DATA 20,43
003D4:  DATA 50,20
003D6:  DATA 37,32
003D8:  DATA 30,30
003DA:  DATA 30,0A
003DC:  DATA 50,75
003DE:  DATA 65,62
003E0:  DATA 6C,61
003E2:  DATA 2C,20
003E4:  DATA 50,75
003E6:  DATA 65,62
003E8:  DATA 6C,61
003EA:  DATA 0A,00
003EC:  DATA 20,20
003EE:  DATA 20,45
003F0:  DATA 73,74
003F2:  DATA 61,63
003F4:  DATA 69,6F
003F6:  DATA 6E,61
003F8:  DATA 6D,69
003FA:  DATA 65,6E
003FC:  DATA 74,6F
003FE:  DATA 20,70
00400:  DATA 6F,72
00402:  DATA 20,41
00404:  DATA 75,74
00406:  DATA 6F,73
00408:  DATA 65,72
0040A:  DATA 76,69
0040C:  DATA 63,69
0040E:  DATA 6F,0A
00410:  DATA 00,00
00412:  DATA 25,30
00414:  DATA 32,64
00416:  DATA 2F,25
00418:  DATA 30,32
0041A:  DATA 64,2F
0041C:  DATA 32,30
0041E:  DATA 25,30
00420:  DATA 32,64
00422:  DATA 20,25
00424:  DATA 30,32
00426:  DATA 64,3A
00428:  DATA 25,30
0042A:  DATA 32,64
0042C:  DATA 3A,25
0042E:  DATA 30,32
00430:  DATA 64,00
00432:  DATA 54,41
00434:  DATA 52,49
00436:  DATA 46,41
00438:  DATA 3A,24
0043A:  DATA 31,39
0043C:  DATA 2E,30
0043E:  DATA 30,2F
00440:  DATA 31,30
00442:  DATA 30,20
00444:  DATA 48,6F
00446:  DATA 72,61
00448:  DATA 20,6F
0044A:  DATA 20,46
0044C:  DATA 72,61
0044E:  DATA 63,63
00450:  DATA 69,6F
00452:  DATA 6E,20
00454:  DATA 20,20
00456:  DATA 20,20
00458:  DATA 20,20
0045A:  DATA 20,20
0045C:  DATA 20,20
0045E:  DATA 20,20
00460:  DATA 20,0A
00462:  DATA 00,00
00464:  DATA 54,4F
00466:  DATA 4C,45
00468:  DATA 52,41
0046A:  DATA 4E,43
0046C:  DATA 49,41
0046E:  DATA 3A,35
00470:  DATA 20,6D
00472:  DATA 69,6E
00474:  DATA 2E,20
00476:  DATA 6C,61
00478:  DATA 20,70
0047A:  DATA 72,69
0047C:  DATA 6D,65
0047E:  DATA 72,61
00480:  DATA 20,68
00482:  DATA 6F,72
00484:  DATA 61,20
00486:  DATA 20,20
00488:  DATA 20,20
0048A:  DATA 20,20
0048C:  DATA 20,20
0048E:  DATA 20,20
00490:  DATA 20,20
00492:  DATA 20,0A
00494:  DATA 00,00
00496:  DATA 48,6F
00498:  DATA 72,61
0049A:  DATA 72,69
0049C:  DATA 6F,73
0049E:  DATA 3A,64
004A0:  DATA 65,20
004A2:  DATA 37,3A
004A4:  DATA 30,30
004A6:  DATA 20,61
004A8:  DATA 20,32
004AA:  DATA 31,3A
004AC:  DATA 30,30
004AE:  DATA 68,72
004B0:  DATA 73,2E
004B2:  DATA 20,64
004B4:  DATA 65,20
004B6:  DATA 6C,75
004B8:  DATA 6E,65
004BA:  DATA 73,20
004BC:  DATA 61,20
004BE:  DATA 76,69
004C0:  DATA 65,72
004C2:  DATA 6E,65
004C4:  DATA 73,0A
004C6:  DATA 00,00
004C8:  DATA 53,61
004CA:  DATA 62,61
004CC:  DATA 64,6F
004CE:  DATA 20,79
004D0:  DATA 20,64
004D2:  DATA 6F,6D
004D4:  DATA 69,6E
004D6:  DATA 67,6F
004D8:  DATA 20,64
004DA:  DATA 65,20
004DC:  DATA 38,3A
004DE:  DATA 30,30
004E0:  DATA 20,61
004E2:  DATA 20,32
004E4:  DATA 30,3A
004E6:  DATA 30,30
004E8:  DATA 68,72
004EA:  DATA 73,2E
004EC:  DATA 20,20
004EE:  DATA 20,20
004F0:  DATA 20,20
004F2:  DATA 20,20
004F4:  DATA 20,20
004F6:  DATA 20,0A
004F8:  DATA 00,00
004FA:  DATA 20,20
004FC:  DATA 20,20
004FE:  DATA 43,4F
00500:  DATA 4E,54
00502:  DATA 52,41
00504:  DATA 54,4F
00506:  DATA 20,44
00508:  DATA 45,20
0050A:  DATA 50,52
0050C:  DATA 45,53
0050E:  DATA 54,41
00510:  DATA 43,49
00512:  DATA 4F,4E
00514:  DATA 20,44
00516:  DATA 45,20
00518:  DATA 53,45
0051A:  DATA 52,56
0051C:  DATA 49,43
0051E:  DATA 49,4F
00520:  DATA 53,20
00522:  DATA 44,45
00524:  DATA 20,20
00526:  DATA 20,20
00528:  DATA 20,0A
0052A:  DATA 00,00
0052C:  DATA 20,20
0052E:  DATA 20,20
00530:  DATA 20,20
00532:  DATA 20,45
00534:  DATA 53,54
00536:  DATA 41,43
00538:  DATA 49,4F
0053A:  DATA 4E,41
0053C:  DATA 4D,49
0053E:  DATA 45,4E
00540:  DATA 54,4F
00542:  DATA 20,50
00544:  DATA 4F,52
00546:  DATA 20,41
00548:  DATA 55,54
0054A:  DATA 4F,53
0054C:  DATA 45,52
0054E:  DATA 56,49
00550:  DATA 43,49
00552:  DATA 4F,20
00554:  DATA 20,20
00556:  DATA 20,20
00558:  DATA 20,20
0055A:  DATA 20,0A
0055C:  DATA 00,00
0055E:  DATA 20,20
00560:  DATA 20,20
00562:  DATA 20,20
00564:  DATA 20,20
00566:  DATA 20,20
00568:  DATA 20,20
0056A:  DATA 20,20
0056C:  DATA 20,20
0056E:  DATA 20,20
00570:  DATA 43,4C
00572:  DATA 41,55
00574:  DATA 53,55
00576:  DATA 4C,41
00578:  DATA 53,20
0057A:  DATA 20,20
0057C:  DATA 20,20
0057E:  DATA 20,20
00580:  DATA 20,20
00582:  DATA 20,20
00584:  DATA 20,20
00586:  DATA 20,20
00588:  DATA 20,20
0058A:  DATA 20,20
0058C:  DATA 20,0A
0058E:  DATA 00,00
00590:  DATA 50,52
00592:  DATA 49,4D
00594:  DATA 45,52
00596:  DATA 41,2E
00598:  DATA 2D,20
0059A:  DATA 45,6C
0059C:  DATA 20,76
0059E:  DATA 65,68
005A0:  DATA ED,63
005A2:  DATA 75,6C
005A4:  DATA 6F,20
005A6:  DATA 73,65
005A8:  DATA 72,E1
005AA:  DATA 20,72
005AC:  DATA 65,73
005AE:  DATA 67,75
005B0:  DATA 61,72
005B2:  DATA 64,61
005B4:  DATA 64,6F
005B6:  DATA 20,65
005B8:  DATA 6E,20
005BA:  DATA 65,6C
005BC:  DATA 20,20
005BE:  DATA 20,0A
005C0:  DATA 00,00
005C2:  DATA 65,73
005C4:  DATA 74,61
005C6:  DATA 63,69
005C8:  DATA 6F,6E
005CA:  DATA 61,6D
005CC:  DATA 69,65
005CE:  DATA 6E,74
005D0:  DATA 6F,2E
005D2:  DATA 20,53
005D4:  DATA 6F,6C
005D6:  DATA 6F,20
005D8:  DATA 61,6C
005DA:  DATA 20,70
005DC:  DATA 6F,72
005DE:  DATA 74,61
005E0:  DATA 64,6F
005E2:  DATA 72,20
005E4:  DATA 64,65
005E6:  DATA 20,65
005E8:  DATA 73,74
005EA:  DATA 65,20
005EC:  DATA 64,6F
005EE:  DATA 63,75
005F0:  DATA 2D,0A
005F2:  DATA 00,00
005F4:  DATA 6D,65
005F6:  DATA 6E,74
005F8:  DATA 6F,20
005FA:  DATA 73,65
005FC:  DATA 20,6C
005FE:  DATA 65,20
00600:  DATA 68,61
00602:  DATA 72,E1
00604:  DATA 20,65
00606:  DATA 6E,74
00608:  DATA 72,65
0060A:  DATA 67,61
0060C:  DATA 20,64
0060E:  DATA 65,20
00610:  DATA 6C,61
00612:  DATA 20,75
00614:  DATA 6E,69
00616:  DATA 64,61
00618:  DATA 64,2C
0061A:  DATA 20,65
0061C:  DATA 6E,20
0061E:  DATA 63,61
00620:  DATA 73,6F
00622:  DATA 20,0A
00624:  DATA 00,00
00626:  DATA 64,65
00628:  DATA 20,65
0062A:  DATA 78,74
0062C:  DATA 72,61
0062E:  DATA 76,69
00630:  DATA F3,20
00632:  DATA 64,65
00634:  DATA 6C,20
00636:  DATA 6D,69
00638:  DATA 73,6D
0063A:  DATA 6F,20
0063C:  DATA 73,65
0063E:  DATA 20,68
00640:  DATA 61,72
00642:  DATA E1,20
00644:  DATA 65,6E
00646:  DATA 74,72
00648:  DATA 65,67
0064A:  DATA 61,20
0064C:  DATA 61,20
0064E:  DATA 71,75
00650:  DATA 69,65
00652:  DATA 6E,20
00654:  DATA 20,0A
00656:  DATA 00,00
00658:  DATA 61,63
0065A:  DATA 72,65
0065C:  DATA 64,69
0065E:  DATA 74,65
00660:  DATA 20,73
00662:  DATA 75,20
00664:  DATA 70,72
00666:  DATA 6F,70
00668:  DATA 69,65
0066A:  DATA 64,61
0066C:  DATA 64,2E
0066E:  DATA 20,45
00670:  DATA 6E,20
00672:  DATA 65,73
00674:  DATA 74,65
00676:  DATA 20,73
00678:  DATA 75,70
0067A:  DATA 75,65
0067C:  DATA 73,74
0067E:  DATA 6F,2C
00680:  DATA 65,6C
00682:  DATA 20,6D
00684:  DATA 6F,6E
00686:  DATA 2D,0A
00688:  DATA 00,00
0068A:  DATA 74,6F
0068C:  DATA 20,61
0068E:  DATA 20,70
00690:  DATA 61,67
00692:  DATA 61,72
00694:  DATA 20,73
00696:  DATA 65,20
00698:  DATA 63,61
0069A:  DATA 6C,63
0069C:  DATA 75,6C
0069E:  DATA 61,72
006A0:  DATA 61,20
006A2:  DATA 64,65
006A4:  DATA 73,64
006A6:  DATA 65,20
006A8:  DATA 6C,61
006AA:  DATA 73,20
006AC:  DATA 37,3A
006AE:  DATA 30,30
006B0:  DATA 20,68
006B2:  DATA 6F,72
006B4:  DATA 61,73
006B6:  DATA 20,20
006B8:  DATA 20,0A
006BA:  DATA 00,00
006BC:  DATA 64,65
006BE:  DATA 6C,20
006C0:  DATA 64,ED
006C2:  DATA 61,20
006C4:  DATA 65,6E
006C6:  DATA 20,71
006C8:  DATA 75,65
006CA:  DATA 20,69
006CC:  DATA 6E,67
006CE:  DATA 72,65
006D0:  DATA 73,6F
006D2:  DATA 20,65
006D4:  DATA 6C,20
006D6:  DATA 76,65
006D8:  DATA 68,ED
006DA:  DATA 63,75
006DC:  DATA 6C,6F
006DE:  DATA 20,68
006E0:  DATA 61,73
006E2:  DATA 74,61
006E4:  DATA 20,73
006E6:  DATA 75,20
006E8:  DATA 68,6F
006EA:  DATA 2D,0A
006EC:  DATA 00,00
006EE:  DATA 72,61
006F0:  DATA 20,64
006F2:  DATA 65,20
006F4:  DATA 73,61
006F6:  DATA 6C,69
006F8:  DATA 64,61
006FA:  DATA 2C,20
006FC:  DATA 73,69
006FE:  DATA 6E,20
00700:  DATA 63,61
00702:  DATA 72,67
00704:  DATA 6F,20
00706:  DATA 65,63
00708:  DATA 6F,6E
0070A:  DATA F3,6D
0070C:  DATA 69,63
0070E:  DATA 6F,20
00710:  DATA 61,64
00712:  DATA 69,63
00714:  DATA 69,6F
00716:  DATA 6E,61
00718:  DATA 6C,2E
0071A:  DATA 20,20
0071C:  DATA 20,0A
0071E:  DATA 00,00
00720:  DATA 45,6C
00722:  DATA 20,70
00724:  DATA 72,6F
00726:  DATA 76,65
00728:  DATA 65,64
0072A:  DATA 6F,72
0072C:  DATA 20,6E
0072E:  DATA 6F,20
00730:  DATA 70,6F
00732:  DATA 64,72
00734:  DATA E1,20
00736:  DATA 63,6F
00738:  DATA 62,72
0073A:  DATA 61,72
0073C:  DATA 20,6E
0073E:  DATA 69,6E
00740:  DATA 67,FA
00742:  DATA 6E,20
00744:  DATA 70,61
00746:  DATA 67,6F
00748:  DATA 20,73
0074A:  DATA 69,6E
0074C:  DATA 20,65
0074E:  DATA 6C,0A
00750:  DATA 00,00
00752:  DATA 63,6F
00754:  DATA 6E,73
00756:  DATA 65,6E
00758:  DATA 74,69
0075A:  DATA 6D,69
0075C:  DATA 65,6E
0075E:  DATA 74,6F
00760:  DATA 20,64
00762:  DATA 65,6C
00764:  DATA 20,63
00766:  DATA 6F,6E
00768:  DATA 73,75
0076A:  DATA 6D,69
0076C:  DATA 64,6F
0076E:  DATA 72,20
00770:  DATA 6F,20
00772:  DATA 71,75
00774:  DATA 65,20
00776:  DATA E9,73
00778:  DATA 74,65
0077A:  DATA 20,6E
0077C:  DATA 6F,20
0077E:  DATA 64,65
00780:  DATA 2D,0A
00782:  DATA 00,00
00784:  DATA 76,65
00786:  DATA 6E,67
00788:  DATA 61,20
0078A:  DATA 64,65
0078C:  DATA 20,65
0078E:  DATA 73,74
00790:  DATA 65,20
00792:  DATA 63,6F
00794:  DATA 6E,74
00796:  DATA 72,61
00798:  DATA 74,6F
0079A:  DATA 2E,20
0079C:  DATA 20,20
0079E:  DATA 20,20
007A0:  DATA 20,20
007A2:  DATA 20,20
007A4:  DATA 20,20
007A6:  DATA 20,20
007A8:  DATA 20,20
007AA:  DATA 20,20
007AC:  DATA 20,20
007AE:  DATA 20,20
007B0:  DATA 20,20
007B2:  DATA 20,0A
007B4:  DATA 00,00
007B6:  DATA 53,45
007B8:  DATA 47,55
007BA:  DATA 4E,44
007BC:  DATA 41,2E
007BE:  DATA 2D,20
007C0:  DATA 53,65
007C2:  DATA 20,6F
007C4:  DATA 74,6F
007C6:  DATA 72,67
007C8:  DATA 61,72
007CA:  DATA E1,6E
007CC:  DATA 20,63
007CE:  DATA 69,6E
007D0:  DATA 63,6F
007D2:  DATA 20,6D
007D4:  DATA 69,6E
007D6:  DATA 75,74
007D8:  DATA 6F,73
007DA:  DATA 20,64
007DC:  DATA 65,20
007DE:  DATA 74,6F
007E0:  DATA 6C,65
007E2:  DATA 2D,20
007E4:  DATA 20,0A
007E6:  DATA 00,00
007E8:  DATA 72,61
007EA:  DATA 6E,63
007EC:  DATA 69,61
007EE:  DATA 20,73
007F0:  DATA F3,6C
007F2:  DATA 6F,20
007F4:  DATA 65,6E
007F6:  DATA 20,6C
007F8:  DATA 61,20
007FA:  DATA 70,72
007FC:  DATA 69,6D
007FE:  DATA 65,72
00800:  DATA 61,20
00802:  DATA 68,6F
00804:  DATA 72,61
00806:  DATA 2C,20
00808:  DATA 65,6E
0080A:  DATA 20,6C
0080C:  DATA 61,73
0080E:  DATA 20,68
00810:  DATA 6F,72
00812:  DATA 61,73
00814:  DATA 20,20
00816:  DATA 20,0A
00818:  DATA 00,00
0081A:  DATA 73,75
0081C:  DATA 62,73
0081E:  DATA 65,63
00820:  DATA 75,65
00822:  DATA 6E,74
00824:  DATA 65,73
00826:  DATA 20,6E
00828:  DATA 6F,20
0082A:  DATA 68,61
0082C:  DATA 62,72
0082E:  DATA E1,20
00830:  DATA 74,6F
00832:  DATA 6C,65
00834:  DATA 72,61
00836:  DATA 6E,63
00838:  DATA 69,61
0083A:  DATA 2E,20
0083C:  DATA 45,6C
0083E:  DATA 20,70
00840:  DATA 72,6F
00842:  DATA 76,65
00844:  DATA 65,64
00846:  DATA 6F,72
00848:  DATA 20,0A
0084A:  DATA 00,00
0084C:  DATA 68,69
0084E:  DATA 7A,6F
00850:  DATA 20,64
00852:  DATA 65,6C
00854:  DATA 20,63
00856:  DATA 6F,6E
00858:  DATA 6F,63
0085A:  DATA 69,6D
0085C:  DATA 69,65
0085E:  DATA 6E,74
00860:  DATA 6F,20
00862:  DATA 61,6C
00864:  DATA 20,63
00866:  DATA 6F,6E
00868:  DATA 73,75
0086A:  DATA 6D,69
0086C:  DATA 64,6F
0086E:  DATA 72,20
00870:  DATA 6C,61
00872:  DATA 73,20
00874:  DATA 72,65
00876:  DATA 73,2D
00878:  DATA 20,20
0087A:  DATA 20,0A
0087C:  DATA 00,00
0087E:  DATA 74,72
00880:  DATA 69,63
00882:  DATA 63,69
00884:  DATA 6F,6E
00886:  DATA 65,73
00888:  DATA 20,71
0088A:  DATA 75,65
0088C:  DATA 2C,20
0088E:  DATA 65,6E
00890:  DATA 20,73
00892:  DATA 75,20
00894:  DATA 63,61
00896:  DATA 73,6F
00898:  DATA 2C,20
0089A:  DATA 6F,70
0089C:  DATA 65,72
0089E:  DATA 65,6E
008A0:  DATA 20,73
008A2:  DATA 6F,62
008A4:  DATA 72,65
008A6:  DATA 20,65
008A8:  DATA 6C,20
008AA:  DATA 20,20
008AC:  DATA 20,0A
008AE:  DATA 00,00
008B0:  DATA 73,65
008B2:  DATA 72,76
008B4:  DATA 69,63
008B6:  DATA 69,6F
008B8:  DATA 20,6F
008BA:  DATA 62,6A
008BC:  DATA 65,74
008BE:  DATA 6F,20
008C0:  DATA 64,65
008C2:  DATA 20,65
008C4:  DATA 73,74
008C6:  DATA 65,20
008C8:  DATA 63,6F
008CA:  DATA 6E,74
008CC:  DATA 72,61
008CE:  DATA 74,6F
008D0:  DATA 2E,20
008D2:  DATA 20,20
008D4:  DATA 20,20
008D6:  DATA 20,20
008D8:  DATA 20,20
008DA:  DATA 20,20
008DC:  DATA 20,20
008DE:  DATA 20,0A
008E0:  DATA 00,00
008E2:  DATA 54,45
008E4:  DATA 52,43
008E6:  DATA 45,52
008E8:  DATA 41,2E
008EA:  DATA 2D,50
008EC:  DATA 61,72
008EE:  DATA 61,20
008F0:  DATA 65,6C
008F2:  DATA 20,63
008F4:  DATA 61,73
008F6:  DATA 6F,20
008F8:  DATA 64,65
008FA:  DATA 20,72
008FC:  DATA 6F,62
008FE:  DATA 6F,20
00900:  DATA 74,6F
00902:  DATA 74,61
00904:  DATA 6C,2C
00906:  DATA 65,6C
00908:  DATA 20,70
0090A:  DATA 72,6F
0090C:  DATA 76,65
0090E:  DATA 65,64
00910:  DATA 6F,0A
00912:  DATA 00,00
00914:  DATA 6F,72
00916:  DATA 20,63
00918:  DATA 75,65
0091A:  DATA 6E,74
0091C:  DATA 61,20
0091E:  DATA 63,6F
00920:  DATA 6E,20
00922:  DATA 75,6E
00924:  DATA 20,73
00926:  DATA 65,67
00928:  DATA 75,72
0092A:  DATA 6F,20
0092C:  DATA 71,75
0092E:  DATA 65,20
00930:  DATA 63,75
00932:  DATA 62,72
00934:  DATA 65,20
00936:  DATA 64,69
00938:  DATA 63,68
0093A:  DATA 6F,20
0093C:  DATA 65,76
0093E:  DATA 65,6E
00940:  DATA 74,6F
00942:  DATA 2E,0A
00944:  DATA 00,00
00946:  DATA 43,55
00948:  DATA 41,52
0094A:  DATA 54,41
0094C:  DATA 2E,2D
0094E:  DATA 20,45
00950:  DATA 6C,20
00952:  DATA 70,72
00954:  DATA 6F,76
00956:  DATA 65,65
00958:  DATA 64,6F
0095A:  DATA 72,20
0095C:  DATA 6E,6F
0095E:  DATA 20,73
00960:  DATA 65,72
00962:  DATA E1,20
00964:  DATA 72,65
00966:  DATA 73,70
00968:  DATA 6F,6E
0096A:  DATA 73,61
0096C:  DATA 62,6C
0096E:  DATA 65,20
00970:  DATA 70,6F
00972:  DATA 72,3A
00974:  DATA 20,0A
00976:  DATA 00,00
00978:  DATA 76,65
0097A:  DATA 68,ED
0097C:  DATA 63,75
0097E:  DATA 6C,6F
00980:  DATA 28,73
00982:  DATA 29,20
00984:  DATA 61,62
00986:  DATA 61,6E
00988:  DATA 64,6F
0098A:  DATA 6E,61
0098C:  DATA 64,6F
0098E:  DATA 28,73
00990:  DATA 29,20
00992:  DATA 6D,E1
00994:  DATA 73,20
00996:  DATA 64,65
00998:  DATA 20,33
0099A:  DATA 30,20
0099C:  DATA 64,ED
0099E:  DATA 61,73
009A0:  DATA 2C,65
009A2:  DATA 6E,20
009A4:  DATA 63,75
009A6:  DATA 2D,0A
009A8:  DATA 00,00
009AA:  DATA 79,6F
009AC:  DATA 20,63
009AE:  DATA 61,73
009B0:  DATA 6F,20
009B2:  DATA 73,65
009B4:  DATA 20,70
009B6:  DATA 72,6F
009B8:  DATA 63,65
009BA:  DATA 64,65
009BC:  DATA 72,E1
009BE:  DATA 20,65
009C0:  DATA 6E,20
009C2:  DATA 74,E9
009C4:  DATA 72,6D
009C6:  DATA 69,6E
009C8:  DATA 6F,73
009CA:  DATA 20,64
009CC:  DATA 65,6C
009CE:  DATA 20,52
009D0:  DATA 65,67
009D2:  DATA 6C,61
009D4:  DATA 6D,65
009D6:  DATA 6E,74
009D8:  DATA 6F,0A
009DA:  DATA 00,00
009DC:  DATA 64,65
009DE:  DATA 20,45
009E0:  DATA 73,74
009E2:  DATA 61,63
009E4:  DATA 69,6F
009E6:  DATA 6E,61
009E8:  DATA 6D,69
009EA:  DATA 65,6E
009EC:  DATA 74,6F
009EE:  DATA 73,20
009F0:  DATA 50,FA
009F2:  DATA 62,6C
009F4:  DATA 69,63
009F6:  DATA 6F,73
009F8:  DATA 20,64
009FA:  DATA 65,20
009FC:  DATA 6C,61
009FE:  DATA 20,43
00A00:  DATA 69,75
00A02:  DATA 64,61
00A04:  DATA 64,20
00A06:  DATA 64,65
00A08:  DATA 20,20
00A0A:  DATA 20,0A
00A0C:  DATA 00,00
00A0E:  DATA 4D,E9
00A10:  DATA 78,69
00A12:  DATA 63,6F
00A14:  DATA 2E,20
00A16:  DATA 20,20
00A18:  DATA 20,20
00A1A:  DATA 20,20
00A1C:  DATA 20,20
00A1E:  DATA 20,20
00A20:  DATA 20,20
00A22:  DATA 20,20
00A24:  DATA 20,20
00A26:  DATA 20,20
00A28:  DATA 20,20
00A2A:  DATA 20,20
00A2C:  DATA 20,20
00A2E:  DATA 20,20
00A30:  DATA 20,20
00A32:  DATA 20,20
00A34:  DATA 20,20
00A36:  DATA 20,20
00A38:  DATA 20,20
00A3A:  DATA 20,20
00A3C:  DATA 20,0A
00A3E:  DATA 00,00
00A40:  DATA 51,55
00A42:  DATA 49,4E
00A44:  DATA 54,41
00A46:  DATA 2E,2D
00A48:  DATA 20,4C
00A4A:  DATA 61,20
00A4C:  DATA 65,6E
00A4E:  DATA 74,72
00A50:  DATA 65,67
00A52:  DATA 61,20
00A54:  DATA 79,20
00A56:  DATA 72,65
00A58:  DATA 63,69
00A5A:  DATA 62,6F
00A5C:  DATA 20,64
00A5E:  DATA 65,6C
00A60:  DATA 20,70
00A62:  DATA 72,65
00A64:  DATA 73,65
00A66:  DATA 6E,74
00A68:  DATA 65,20
00A6A:  DATA 63,6F
00A6C:  DATA 6E,2D
00A6E:  DATA 20,0A
00A70:  DATA 00,00
00A72:  DATA 74,72
00A74:  DATA 61,74
00A76:  DATA 6F,20
00A78:  DATA 69,6D
00A7A:  DATA 70,6C
00A7C:  DATA 69,63
00A7E:  DATA 61,20
00A80:  DATA 6C,61
00A82:  DATA 20,61
00A84:  DATA 63,65
00A86:  DATA 70,74
00A88:  DATA 61,63
00A8A:  DATA 69,F3
00A8C:  DATA 6E,20
00A8E:  DATA 64,65
00A90:  DATA 20,6C
00A92:  DATA 6F,73
00A94:  DATA 20,64
00A96:  DATA 65,72
00A98:  DATA 65,63
00A9A:  DATA 68,6F
00A9C:  DATA 73,20
00A9E:  DATA 79,20
00AA0:  DATA 20,0A
00AA2:  DATA 00,00
00AA4:  DATA 6F,62
00AA6:  DATA 6C,69
00AA8:  DATA 67,61
00AAA:  DATA 63,69
00AAC:  DATA 6F,6E
00AAE:  DATA 65,73
00AB0:  DATA 20,65
00AB2:  DATA 73,74
00AB4:  DATA 69,70
00AB6:  DATA 75,6C
00AB8:  DATA 61,64
00ABA:  DATA 6F,73
00ABC:  DATA 20,65
00ABE:  DATA 6E,20
00AC0:  DATA E9,6C
00AC2:  DATA 2E,20
00AC4:  DATA 20,20
00AC6:  DATA 20,20
00AC8:  DATA 20,20
00ACA:  DATA 20,20
00ACC:  DATA 20,20
00ACE:  DATA 20,20
00AD0:  DATA 20,20
00AD2:  DATA 20,0A
00AD4:  DATA 00,00
00AD6:  DATA 53,45
00AD8:  DATA 58,54
00ADA:  DATA 41,2E
00ADC:  DATA 2D,20
00ADE:  DATA 4C,61
00AE0:  DATA 20,50
00AE2:  DATA 72,6F
00AE4:  DATA 63,75
00AE6:  DATA 72,61
00AE8:  DATA 64,75
00AEA:  DATA 72,ED
00AEC:  DATA 61,20
00AEE:  DATA 46,65
00AF0:  DATA 64,65
00AF2:  DATA 72,61
00AF4:  DATA 6C,20
00AF6:  DATA 64,65
00AF8:  DATA 6C,20
00AFA:  DATA 43,6F
00AFC:  DATA 6E,73
00AFE:  DATA 75,6D
00B00:  DATA 69,64
00B02:  DATA 6F,72
00B04:  DATA 20,0A
00B06:  DATA 00,00
00B08:  DATA 65,73
00B0A:  DATA 20,63
00B0C:  DATA 6F,6D
00B0E:  DATA 70,65
00B10:  DATA 74,65
00B12:  DATA 6E,74
00B14:  DATA 65,20
00B16:  DATA 65,6E
00B18:  DATA 20,6C
00B1A:  DATA 61,20
00B1C:  DATA 76,ED
00B1E:  DATA 61,20
00B20:  DATA 61,64
00B22:  DATA 6D,69
00B24:  DATA 6E,69
00B26:  DATA 73,74
00B28:  DATA 72,61
00B2A:  DATA 74,69
00B2C:  DATA 76,61
00B2E:  DATA 20,70
00B30:  DATA 61,72
00B32:  DATA 61,20
00B34:  DATA 72,65
00B36:  DATA 2D,0A
00B38:  DATA 00,00
00B3A:  DATA 73,6F
00B3C:  DATA 6C,76
00B3E:  DATA 65,72
00B40:  DATA 20,63
00B42:  DATA 75,61
00B44:  DATA 6C,71
00B46:  DATA 75,69
00B48:  DATA 65,72
00B4A:  DATA 20,63
00B4C:  DATA 6F,6E
00B4E:  DATA 74,72
00B50:  DATA 6F,76
00B52:  DATA 65,72
00B54:  DATA 73,69
00B56:  DATA 61,20
00B58:  DATA 71,75
00B5A:  DATA 65,20
00B5C:  DATA 73,65
00B5E:  DATA 20,73
00B60:  DATA 75,73
00B62:  DATA 63,69
00B64:  DATA 74,65
00B66:  DATA 20,20
00B68:  DATA 20,0A
00B6A:  DATA 00,00
00B6C:  DATA 73,6F
00B6E:  DATA 62,72
00B70:  DATA 65,20
00B72:  DATA 6C,61
00B74:  DATA 20,69
00B76:  DATA 6E,74
00B78:  DATA 65,72
00B7A:  DATA 70,72
00B7C:  DATA 65,74
00B7E:  DATA 61,63
00B80:  DATA 69,F3
00B82:  DATA 6E,20
00B84:  DATA 6F,20
00B86:  DATA 63,75
00B88:  DATA 6D,70
00B8A:  DATA 6C,69
00B8C:  DATA 6D,69
00B8E:  DATA 65,6E
00B90:  DATA 74,6F
00B92:  DATA 20,64
00B94:  DATA 65,6C
00B96:  DATA 20,70
00B98:  DATA 72,65
00B9A:  DATA 2D,0A
00B9C:  DATA 00,00
00B9E:  DATA 73,65
00BA0:  DATA 6E,74
00BA2:  DATA 65,20
00BA4:  DATA 63,6F
00BA6:  DATA 6E,74
00BA8:  DATA 72,61
00BAA:  DATA 74,6F
00BAC:  DATA 2E,20
00BAE:  DATA 53,69
00BB0:  DATA 6E,20
00BB2:  DATA 70,65
00BB4:  DATA 72,6A
00BB6:  DATA 75,69
00BB8:  DATA 63,69
00BBA:  DATA 6F,20
00BBC:  DATA 64,65
00BBE:  DATA 20,6C
00BC0:  DATA 6F,20
00BC2:  DATA 61,6E
00BC4:  DATA 74,65
00BC6:  DATA 72,69
00BC8:  DATA 6F,72
00BCA:  DATA 2C,20
00BCC:  DATA 20,0A
00BCE:  DATA 00,00
00BD0:  DATA 6C,61
00BD2:  DATA 73,20
00BD4:  DATA 70,61
00BD6:  DATA 72,74
00BD8:  DATA 65,73
00BDA:  DATA 20,73
00BDC:  DATA 65,20
00BDE:  DATA 73,6F
00BE0:  DATA 6D,65
00BE2:  DATA 74,65
00BE4:  DATA 6E,20
00BE6:  DATA 61,20
00BE8:  DATA 6C,61
00BEA:  DATA 20,6A
00BEC:  DATA 75,72
00BEE:  DATA 69,73
00BF0:  DATA 64,69
00BF2:  DATA 63,63
00BF4:  DATA 69,F3
00BF6:  DATA 6E,20
00BF8:  DATA 64,65
00BFA:  DATA 20,6C
00BFC:  DATA 6F,73
00BFE:  DATA 20,0A
00C00:  DATA 00,00
00C02:  DATA 54,72
00C04:  DATA 69,62
00C06:  DATA 75,6E
00C08:  DATA 61,6C
00C0A:  DATA 65,73
00C0C:  DATA 20,63
00C0E:  DATA 6F,6D
00C10:  DATA 70,65
00C12:  DATA 74,65
00C14:  DATA 6E,74
00C16:  DATA 65,73
00C18:  DATA 20,65
00C1A:  DATA 6E,20
00C1C:  DATA 50,75
00C1E:  DATA 65,62
00C20:  DATA 6C,61
00C22:  DATA 2C,20
00C24:  DATA 72,65
00C26:  DATA 6E,75
00C28:  DATA 6E,63
00C2A:  DATA 69,61
00C2C:  DATA 6E,64
00C2E:  DATA 6F,20
00C30:  DATA 20,0A
00C32:  DATA 00,00
00C34:  DATA 65,78
00C36:  DATA 70,72
00C38:  DATA 65,73
00C3A:  DATA 61,6D
00C3C:  DATA 65,6E
00C3E:  DATA 74,65
00C40:  DATA 20,61
00C42:  DATA 20,63
00C44:  DATA 75,61
00C46:  DATA 6C,71
00C48:  DATA 75,69
00C4A:  DATA 65,72
00C4C:  DATA 20,6F
00C4E:  DATA 74,72
00C50:  DATA 61,20
00C52:  DATA 6A,75
00C54:  DATA 72,69
00C56:  DATA 73,64
00C58:  DATA 69,63
00C5A:  DATA 63,69
00C5C:  DATA F3,6E
00C5E:  DATA 20,71
00C60:  DATA 75,65
00C62:  DATA 20,0A
00C64:  DATA 00,00
00C66:  DATA 70,75
00C68:  DATA 64,69
00C6A:  DATA 65,72
00C6C:  DATA 61,20
00C6E:  DATA 63,6F
00C70:  DATA 72,72
00C72:  DATA 65,73
00C74:  DATA 70,6F
00C76:  DATA 6E,64
00C78:  DATA 65,72
00C7A:  DATA 6C,65
00C7C:  DATA 73,2C
00C7E:  DATA 20,70
00C80:  DATA 6F,72
00C82:  DATA 20,72
00C84:  DATA 61,7A
00C86:  DATA F3,6E
00C88:  DATA 20,64
00C8A:  DATA 65,20
00C8C:  DATA 73,75
00C8E:  DATA 73,20
00C90:  DATA 64,6F
00C92:  DATA 6D,69
00C94:  DATA 2D,0A
00C96:  DATA 00,00
00C98:  DATA 63,69
00C9A:  DATA 6C,69
00C9C:  DATA 6F,73
00C9E:  DATA 20,70
00CA0:  DATA 72,65
00CA2:  DATA 73,65
00CA4:  DATA 6E,74
00CA6:  DATA 65,73
00CA8:  DATA 20,6F
00CAA:  DATA 20,66
00CAC:  DATA 75,74
00CAE:  DATA 75,72
00CB0:  DATA 6F,73
00CB2:  DATA 20,6F
00CB4:  DATA 20,70
00CB6:  DATA 6F,72
00CB8:  DATA 20,63
00CBA:  DATA 75,61
00CBC:  DATA 6C,71
00CBE:  DATA 75,69
00CC0:  DATA 65,72
00CC2:  DATA 20,6F
00CC4:  DATA 74,72
00CC6:  DATA 61,0A
00CC8:  DATA 00,00
00CCA:  DATA 72,61
00CCC:  DATA 7A,F3
00CCE:  DATA 6E,2E
00CD0:  DATA 20,20
00CD2:  DATA 20,20
00CD4:  DATA 20,20
00CD6:  DATA 20,20
00CD8:  DATA 20,20
00CDA:  DATA 20,20
00CDC:  DATA 20,20
00CDE:  DATA 20,20
00CE0:  DATA 20,20
00CE2:  DATA 20,20
00CE4:  DATA 20,20
00CE6:  DATA 20,20
00CE8:  DATA 20,20
00CEA:  DATA 20,20
00CEC:  DATA 20,20
00CEE:  DATA 20,20
00CF0:  DATA 20,20
00CF2:  DATA 20,20
00CF4:  DATA 20,20
00CF6:  DATA 20,20
00CF8:  DATA 20,0A
00CFA:  DATA 00,00
00CFC:  DATA 44,65
00CFE:  DATA 20,6E
00D00:  DATA 6F,20
00D02:  DATA 65,73
00D04:  DATA 74,61
00D06:  DATA 72,20
00D08:  DATA 64,65
00D0A:  DATA 20,61
00D0C:  DATA 63,75
00D0E:  DATA 65,72
00D10:  DATA 64,6F
00D12:  DATA 20,63
00D14:  DATA 6F,6E
00D16:  DATA 20,6C
00D18:  DATA 61,73
00D1A:  DATA 20,63
00D1C:  DATA 6C,61
00D1E:  DATA 75,73
00D20:  DATA 75,6C
00D22:  DATA 61,73
00D24:  DATA 20,61
00D26:  DATA 6E,74
00D28:  DATA 65,20
00D2A:  DATA 2D,0A
00D2C:  DATA 00,00
00D2E:  DATA 72,69
00D30:  DATA 6F,72
00D32:  DATA 65,73
00D34:  DATA 20,66
00D36:  DATA 61,76
00D38:  DATA 6F,72
00D3A:  DATA 20,64
00D3C:  DATA 65,20
00D3E:  DATA 72,65
00D40:  DATA 74,69
00D42:  DATA 72,61
00D44:  DATA 72,20
00D46:  DATA 73,75
00D48:  DATA 20,61
00D4A:  DATA 75,74
00D4C:  DATA 6F,6D
00D4E:  DATA F3,76
00D50:  DATA 69,6C
00D52:  DATA 2E,20
00D54:  DATA 20,20
00D56:  DATA 20,20
00D58:  DATA 20,20
00D5A:  DATA 20,20
00D5C:  DATA 20,0A
00D5E:  DATA 00,00
00D60:  DATA 45,73
00D62:  DATA 74,65
00D64:  DATA 20,63
00D66:  DATA 6F,6E
00D68:  DATA 74,72
00D6A:  DATA 61,74
00D6C:  DATA 6F,20
00D6E:  DATA 66,75
00D70:  DATA 65,20
00D72:  DATA 61,70
00D74:  DATA 72,6F
00D76:  DATA 62,61
00D78:  DATA 64,6F
00D7A:  DATA 20,79
00D7C:  DATA 20,72
00D7E:  DATA 65,67
00D80:  DATA 69,73
00D82:  DATA 74,72
00D84:  DATA 61,64
00D86:  DATA 6F,20
00D88:  DATA 70,6F
00D8A:  DATA 72,20
00D8C:  DATA 6C,61
00D8E:  DATA 20,0A
00D90:  DATA 00,00
00D92:  DATA 50,72
00D94:  DATA 6F,63
00D96:  DATA 75,72
00D98:  DATA 61,64
00D9A:  DATA 75,72
00D9C:  DATA ED,61
00D9E:  DATA 20,46
00DA0:  DATA 65,64
00DA2:  DATA 65,72
00DA4:  DATA 61,6C
00DA6:  DATA 20,64
00DA8:  DATA 65,6C
00DAA:  DATA 20,43
00DAC:  DATA 6F,6E
00DAE:  DATA 73,75
00DB0:  DATA 6D,69
00DB2:  DATA 64,6F
00DB4:  DATA 72,20
00DB6:  DATA 62,61
00DB8:  DATA 6A,6F
00DBA:  DATA 20,65
00DBC:  DATA 6C,20
00DBE:  DATA 6E,FA
00DC0:  DATA 2D,0A
00DC2:  DATA 00,00
00DC4:  DATA 6D,65
00DC6:  DATA 72,6F
00DC8:  DATA 20,3C
00DCA:  DATA 3C,4E
00DCC:  DATA DA,4D
00DCE:  DATA 45,52
00DD0:  DATA 4F,20
00DD2:  DATA 44,45
00DD4:  DATA 20,52
00DD6:  DATA 45,47
00DD8:  DATA 49,53
00DDA:  DATA 54,52
00DDC:  DATA 4F,3E
00DDE:  DATA 3E,20
00DE0:  DATA 64,65
00DE2:  DATA 20,66
00DE4:  DATA 65,63
00DE6:  DATA 68,61
00DE8:  DATA 20,3C
00DEA:  DATA 3C,46
00DEC:  DATA 45,43
00DEE:  DATA 48,41
00DF0:  DATA 20,44
00DF2:  DATA 45,0A
00DF4:  DATA 00,00
00DF6:  DATA 52,45
00DF8:  DATA 47,49
00DFA:  DATA 53,54
00DFC:  DATA 52,4F
00DFE:  DATA 3E,3E
00E00:  DATA 2E,20
00E02:  DATA 43,75
00E04:  DATA 61,6C
00E06:  DATA 71,75
00E08:  DATA 69,65
00E0A:  DATA 72,20
00E0C:  DATA 76,61
00E0E:  DATA 72,69
00E10:  DATA 61,63
00E12:  DATA 69,F3
00E14:  DATA 6E,20
00E16:  DATA 64,65
00E18:  DATA 6C,20
00E1A:  DATA 70,72
00E1C:  DATA 65,73
00E1E:  DATA 65,6E
00E20:  DATA 74,65
00E22:  DATA 20,20
00E24:  DATA 20,0A
00E26:  DATA 00,00
00E28:  DATA 63,6F
00E2A:  DATA 6E,74
00E2C:  DATA 72,61
00E2E:  DATA 74,6F
00E30:  DATA 20,65
00E32:  DATA 6E,20
00E34:  DATA 70,65
00E36:  DATA 72,6A
00E38:  DATA 75,69
00E3A:  DATA 63,69
00E3C:  DATA 6F,20
00E3E:  DATA 64,65
00E40:  DATA 20,45
00E42:  DATA 4C,20
00E44:  DATA 43,4F
00E46:  DATA 4E,53
00E48:  DATA 55,4D
00E4A:  DATA 49,44
00E4C:  DATA 4F,52
00E4E:  DATA 2C,20
00E50:  DATA 66,72
00E52:  DATA 65,6E
00E54:  DATA 74,65
00E56:  DATA 20,0A
00E58:  DATA 00,00
00E5A:  DATA 61,6C
00E5C:  DATA 20,63
00E5E:  DATA 6F,6E
00E60:  DATA 74,72
00E62:  DATA 61,74
00E64:  DATA 6F,20
00E66:  DATA 64,65
00E68:  DATA 20,61
00E6A:  DATA 64,68
00E6C:  DATA 65,73
00E6E:  DATA 69,F3
00E70:  DATA 6E,20
00E72:  DATA 72,65
00E74:  DATA 67,69
00E76:  DATA 73,74
00E78:  DATA 72,61
00E7A:  DATA 64,6F
00E7C:  DATA 2C,20
00E7E:  DATA 73,65
00E80:  DATA 20,74
00E82:  DATA 65,6E
00E84:  DATA 64,72
00E86:  DATA E1,20
00E88:  DATA 20,0A
00E8A:  DATA 00,00
00E8C:  DATA 70,6F
00E8E:  DATA 72,20
00E90:  DATA 6E,6F
00E92:  DATA 20,70
00E94:  DATA 75,65
00E96:  DATA 73,74
00E98:  DATA 61,2E
00E9A:  DATA 20,20
00E9C:  DATA 20,20
00E9E:  DATA 20,20
00EA0:  DATA 20,20
00EA2:  DATA 20,20
00EA4:  DATA 20,20
00EA6:  DATA 20,20
00EA8:  DATA 20,20
00EAA:  DATA 20,20
00EAC:  DATA 20,20
00EAE:  DATA 20,20
00EB0:  DATA 20,20
00EB2:  DATA 20,20
00EB4:  DATA 20,20
00EB6:  DATA 20,20
00EB8:  DATA 20,20
00EBA:  DATA 20,0A
00EBC:  DATA 00,00
00EBE:  DATA 22,51
00EC0:  DATA 55,45
00EC2:  DATA 4A,41
00EC4:  DATA 53,20
00EC6:  DATA 41,4C
00EC8:  DATA 20,54
00ECA:  DATA 45,4C
00ECC:  DATA 45,46
00ECE:  DATA 4F,4E
00ED0:  DATA 4F,3A
00ED2:  DATA 00,00
00ED4:  DATA 20,20
00ED6:  DATA 20,20
00ED8:  DATA 28,32
00EDA:  DATA 32,32
00EDC:  DATA 29,32
00EDE:  DATA 2D,34
00EE0:  DATA 36,2D
00EE2:  DATA 31,35
00EE4:  DATA 2D,32
00EE6:  DATA 32,20
00EE8:  DATA 45,4E
00EEA:  DATA 20,4C
00EEC:  DATA 41,20
00EEE:  DATA 43,49
00EF0:  DATA 55,44
00EF2:  DATA 41,44
00EF4:  DATA 20,44
00EF6:  DATA 45,20
00EF8:  DATA 50,55
00EFA:  DATA 45,42
00EFC:  DATA 4C,41
00EFE:  DATA 20,20
00F00:  DATA 20,20
00F02:  DATA 0A,00
00F04:  DATA 59,20
00F06:  DATA 41,4C
00F08:  DATA 20,20
00F0A:  DATA 30,31
00F0C:  DATA 2D,38
00F0E:  DATA 30,30
00F10:  DATA 2D,34
00F12:  DATA 36,38
00F14:  DATA 2D,38
00F16:  DATA 37,32
00F18:  DATA 32,20
00F1A:  DATA 20,44
00F1C:  DATA 45,4C
00F1E:  DATA 20,20
00F20:  DATA 49,4E
00F22:  DATA 54,45
00F24:  DATA 52,49
00F26:  DATA 4F,52
00F28:  DATA 20,28
00F2A:  DATA 50,52
00F2C:  DATA 4F,46
00F2E:  DATA 45,43
00F30:  DATA 4F,29
00F32:  DATA 0A,00
00F34:  DATA 20,41
00F36:  DATA 43,43
00F38:  DATA 45,53
00F3A:  DATA 41,61
00F3C:  DATA 75,74
00F3E:  DATA 6F,6D
00F40:  DATA 61,74
00F42:  DATA 69,7A
00F44:  DATA 61,63
00F46:  DATA 69,6F
00F48:  DATA 6E,20
00F4A:  DATA 64,65
00F4C:  DATA 20,65
00F4E:  DATA 73,74
00F50:  DATA 61,63
00F52:  DATA 69,6F
00F54:  DATA 6E,61
00F56:  DATA 6D,69
00F58:  DATA 65,6E
00F5A:  DATA 74,6F
00F5C:  DATA 73,0A
00F5E:  DATA 00,00
00F60:  DATA 20,20
00F62:  DATA 20,77
00F64:  DATA 77,77
00F66:  DATA 2E,61
00F68:  DATA 63,63
00F6A:  DATA 65,73
00F6C:  DATA 61,2E
00F6E:  DATA 6D,65
00F70:  DATA 20,61
00F72:  DATA 75,74
00F74:  DATA 6F,6D
00F76:  DATA 61,74
00F78:  DATA 69,7A
00F7A:  DATA 61,63
00F7C:  DATA 69,6F
00F7E:  DATA 6E,40
00F80:  DATA 61,63
00F82:  DATA 63,65
00F84:  DATA 73,61
00F86:  DATA 2E,6D
00F88:  DATA 65,20
00F8A:  DATA 20,20
00F8C:  DATA 20,20
00F8E:  DATA 0A,00
00F90:  DATA 1D,68
00F92:  DATA 8C,00
00F94:  DATA 1D,78
00F96:  DATA 01,00
00F98:  DATA 1D,68
00F9A:  DATA 8C,00
00F9C:  DATA 1D,77
00F9E:  DATA 01,00
*
0110C:  TBLRD*+
0110E:  MOVF   FF5,F
01110:  BZ    112A
01112:  MOVFF  FF6,8FC
01116:  MOVFF  FF7,8FD
0111A:  MOVFF  FF5,8FF
0111E:  RCALL  10A8
01120:  MOVFF  8FC,FF6
01124:  MOVFF  8FD,FF7
01128:  BRA    110C
0112A:  RETURN 0
*
01480:  ADDWF  FE8,W
01482:  CLRF   FF7
01484:  RLCF   FF7,F
01486:  ADDLW  9B
01488:  MOVWF  FF6
0148A:  MOVLW  14
0148C:  ADDWFC FF7,F
0148E:  TBLRD*-
01490:  MOVF   FF5,W
01492:  MOVWF  FFA
01494:  TBLRD*
01496:  MOVF   FF5,W
01498:  MOVWF  FF9
0149A:  DATA D2,11
0149C:  DATA F0,11
0149E:  DATA 0E,12
014A0:  DATA 2C,12
014A2:  DATA 4A,12
014A4:  DATA 68,12
014A6:  DATA 86,12
014A8:  DATA A4,12
014AA:  DATA C2,12
014AC:  DATA E0,12
014AE:  DATA FE,12
014B0:  DATA 1C,13
014B2:  DATA 3A,13
014B4:  DATA 58,13
*
01A40:  MOVLB  9
01A42:  MOVF   x4A,W
01A44:  MULWF  x4C
01A46:  MOVFF  FF3,01
01A4A:  MOVFF  FF4,00
01A4E:  MULWF  x4D
01A50:  MOVF   FF3,W
01A52:  ADDWF  00,F
01A54:  MOVF   x4B,W
01A56:  MULWF  x4C
01A58:  MOVF   FF3,W
01A5A:  ADDWFC 00,W
01A5C:  MOVWF  02
01A5E:  MOVLB  0
01A60:  RETURN 0
*
01A76:  MOVLB  9
01A78:  CLRF   x04
01A7A:  CLRF   x05
01A7C:  MOVLW  01
01A7E:  MOVWF  x06
01A80:  CLRF   FDA
01A82:  CLRF   FD9
01A84:  MOVLW  08
01A86:  MOVWF  x09
01A88:  MOVLW  FC
01A8A:  MOVWF  x08
01A8C:  MOVLW  09
01A8E:  MOVWF  FEA
01A90:  CLRF   FE9
01A92:  MOVFF  909,FE2
01A96:  MOVFF  908,FE1
01A9A:  MOVFF  906,907
01A9E:  BCF    FD8.0
01AA0:  MOVF   FE5,W
01AA2:  MULWF  FEE
01AA4:  MOVF   FF3,W
01AA6:  ADDWFC x04,F
01AA8:  MOVF   FF4,W
01AAA:  ADDWFC x05,F
01AAC:  DECFSZ x07,F
01AAE:  BRA    1A9E
01AB0:  MOVFF  904,FDE
01AB4:  MOVFF  905,904
01AB8:  CLRF   x05
01ABA:  BTFSC  FD8.0
01ABC:  INCF   x05,F
01ABE:  INCF   x08,F
01AC0:  BTFSC  FD8.2
01AC2:  INCF   x09,F
01AC4:  INCF   x06,F
01AC6:  MOVF   x06,W
01AC8:  SUBLW  05
01ACA:  BNZ   1A8C
01ACC:  MOVLB  0
01ACE:  GOTO   1B3E (RETURN)
01AD2:  CLRF   01
01AD4:  CLRF   02
01AD6:  CLRF   00
01AD8:  CLRF   03
01ADA:  MOVLB  9
01ADC:  MOVF   x0E,W
01ADE:  BNZ   1AE4
01AE0:  MOVF   x0D,W
01AE2:  BZ    1B14
01AE4:  MOVLW  10
01AE6:  MOVWF  x0F
01AE8:  BCF    FD8.0
01AEA:  RLCF   x0B,F
01AEC:  RLCF   x0C,F
01AEE:  RLCF   00,F
01AF0:  RLCF   03,F
01AF2:  MOVF   x0E,W
01AF4:  SUBWF  03,W
01AF6:  BNZ   1AFC
01AF8:  MOVF   x0D,W
01AFA:  SUBWF  00,W
01AFC:  BNC   1B0C
01AFE:  MOVF   x0D,W
01B00:  SUBWF  00,F
01B02:  BTFSS  FD8.0
01B04:  DECF   03,F
01B06:  MOVF   x0E,W
01B08:  SUBWF  03,F
01B0A:  BSF    FD8.0
01B0C:  RLCF   01,F
01B0E:  RLCF   02,F
01B10:  DECFSZ x0F,F
01B12:  BRA    1AE8
01B14:  MOVLB  0
01B16:  RETURN 0
*
01E1C:  TSTFSZ 01
01E1E:  BRA    1E26
01E20:  TSTFSZ 02
01E22:  BRA    1E28
01E24:  BRA    1E34
01E26:  INCF   02,F
01E28:  MOVFF  00,FEE
01E2C:  DECFSZ 01,F
01E2E:  BRA    1E28
01E30:  DECFSZ 02,F
01E32:  BRA    1E28
01E34:  RETURN 0
*
01E70:  TBLRD*+
01E72:  MOVFF  FF6,90E
01E76:  MOVFF  FF7,90F
01E7A:  MOVFF  FF5,913
01E7E:  RCALL  1E0C
01E80:  MOVFF  90E,FF6
01E84:  MOVFF  90F,FF7
01E88:  MOVLB  9
01E8A:  DECFSZ x0D,F
01E8C:  BRA    1E90
01E8E:  BRA    1E94
01E90:  MOVLB  0
01E92:  BRA    1E70
01E94:  MOVLB  0
01E96:  RETURN 0
01E98:  MOVF   FEF,F
01E9A:  BZ    1EBA
01E9C:  MOVFF  FEA,90F
01EA0:  MOVFF  FE9,90E
01EA4:  MOVFF  FEF,913
01EA8:  RCALL  1E0C
01EAA:  MOVFF  90F,FEA
01EAE:  MOVFF  90E,FE9
01EB2:  INCF   FE9,F
01EB4:  BTFSC  FD8.2
01EB6:  INCF   FEA,F
01EB8:  BRA    1E98
01EBA:  RETURN 0
*
01EC8:  TBLRD*+
01ECA:  MOVF   FF5,F
01ECC:  BZ    1EE6
01ECE:  MOVFF  FF6,90E
01ED2:  MOVFF  FF7,90F
01ED6:  MOVFF  FF5,913
01EDA:  RCALL  1E0C
01EDC:  MOVFF  90E,FF6
01EE0:  MOVFF  90F,FF7
01EE4:  BRA    1EC8
01EE6:  RETURN 0
01EE8:  MOVLB  9
01EEA:  MOVF   x14,W
01EEC:  CLRF   01
01EEE:  SUBWF  x13,W
01EF0:  BC    1EF8
01EF2:  MOVFF  913,00
01EF6:  BRA    1F10
01EF8:  CLRF   00
01EFA:  MOVLW  08
01EFC:  MOVWF  x15
01EFE:  RLCF   x13,F
01F00:  RLCF   00,F
01F02:  MOVF   x14,W
01F04:  SUBWF  00,W
01F06:  BTFSC  FD8.0
01F08:  MOVWF  00
01F0A:  RLCF   01,F
01F0C:  DECFSZ x15,F
01F0E:  BRA    1EFE
01F10:  MOVLB  0
01F12:  RETURN 0
01F14:  MOVLW  20
01F16:  MOVLB  9
01F18:  BTFSS  x0E.4
01F1A:  MOVLW  30
01F1C:  MOVWF  x0F
01F1E:  MOVFF  90D,00
01F22:  BTFSS  x0D.7
01F24:  BRA    1F36
01F26:  COMF   00,F
01F28:  INCF   00,F
01F2A:  MOVFF  00,90D
01F2E:  MOVLW  2D
01F30:  MOVWF  x0F
01F32:  BSF    x0E.7
01F34:  BSF    x0E.0
01F36:  MOVF   01,W
01F38:  MOVFF  90D,913
01F3C:  MOVLW  64
01F3E:  MOVWF  x14
01F40:  MOVLB  0
01F42:  RCALL  1EE8
01F44:  MOVFF  00,90D
01F48:  MOVLW  30
01F4A:  ADDWF  01,W
01F4C:  MOVLB  9
01F4E:  MOVWF  x10
01F50:  MOVFF  90D,913
01F54:  MOVLW  0A
01F56:  MOVWF  x14
01F58:  MOVLB  0
01F5A:  RCALL  1EE8
01F5C:  MOVLW  30
01F5E:  ADDWF  00,W
01F60:  MOVLB  9
01F62:  MOVWF  x12
01F64:  MOVLW  30
01F66:  ADDWF  01,W
01F68:  MOVWF  x11
01F6A:  MOVFF  90F,00
01F6E:  MOVLW  30
01F70:  SUBWF  x10,W
01F72:  BZ    1F7C
01F74:  BSF    x0E.1
01F76:  BTFSC  x0E.7
01F78:  BSF    x0E.2
01F7A:  BRA    1FA0
01F7C:  BTFSC  x0E.2
01F7E:  BRA    1FA0
01F80:  MOVFF  90F,910
01F84:  BTFSC  x0E.1
01F86:  BRA    1F90
01F88:  MOVLW  30
01F8A:  SUBWF  x11,W
01F8C:  BZ    1F96
01F8E:  BSF    x0E.0
01F90:  BTFSC  x0E.7
01F92:  BSF    x0E.1
01F94:  BRA    1FA0
01F96:  BTFSS  FD8.2
01F98:  BSF    x0E.0
01F9A:  BTFSC  FD8.2
01F9C:  MOVFF  910,911
01FA0:  BTFSC  x0E.2
01FA2:  BRA    1FAE
01FA4:  BTFSC  x0E.1
01FA6:  BRA    1FB6
01FA8:  BTFSC  x0E.0
01FAA:  BRA    1FBE
01FAC:  BRA    1FC6
01FAE:  MOVFF  90F,913
01FB2:  MOVLB  0
01FB4:  RCALL  1E0C
01FB6:  MOVFF  910,913
01FBA:  MOVLB  0
01FBC:  RCALL  1E0C
01FBE:  MOVFF  911,913
01FC2:  MOVLB  0
01FC4:  RCALL  1E0C
01FC6:  MOVFF  912,913
01FCA:  MOVLB  0
01FCC:  RCALL  1E0C
01FCE:  RETURN 0
*
02A5A:  TBLRD*+
02A5C:  MOVFF  FF6,8FB
02A60:  MOVFF  FF7,8FC
02A64:  MOVFF  FF5,8FF
02A68:  CALL   10A8
02A6C:  MOVFF  8FB,FF6
02A70:  MOVFF  8FC,FF7
02A74:  MOVLB  8
02A76:  DECFSZ xFA,F
02A78:  BRA    2A7C
02A7A:  BRA    2A80
02A7C:  MOVLB  0
02A7E:  BRA    2A5A
02A80:  MOVLB  0
02A82:  RETURN 0
02A84:  MOVF   01,W
02A86:  MOVFF  8FA,913
02A8A:  MOVLW  64
02A8C:  MOVLB  9
02A8E:  MOVWF  x14
02A90:  MOVLB  0
02A92:  CALL   1EE8
02A96:  MOVFF  00,8FA
02A9A:  MOVF   01,W
02A9C:  MOVLW  30
02A9E:  BNZ   2AB0
02AA0:  MOVLB  8
02AA2:  BTFSS  xFB.1
02AA4:  BRA    2AC4
02AA6:  BTFSC  xFB.3
02AA8:  BRA    2AC4
02AAA:  BTFSC  xFB.4
02AAC:  MOVLW  20
02AAE:  BRA    2AB8
02AB0:  MOVLB  8
02AB2:  BCF    xFB.3
02AB4:  BCF    xFB.4
02AB6:  BSF    xFB.0
02AB8:  ADDWF  01,F
02ABA:  MOVFF  01,8FF
02ABE:  MOVLB  0
02AC0:  CALL   10A8
02AC4:  MOVFF  8FA,913
02AC8:  MOVLW  0A
02ACA:  MOVLB  9
02ACC:  MOVWF  x14
02ACE:  MOVLB  0
02AD0:  CALL   1EE8
02AD4:  MOVFF  00,8FA
02AD8:  MOVF   01,W
02ADA:  MOVLW  30
02ADC:  BNZ   2AEE
02ADE:  MOVLB  8
02AE0:  BTFSC  xFB.3
02AE2:  BRA    2AFA
02AE4:  BTFSS  xFB.0
02AE6:  BRA    2AFA
02AE8:  BTFSC  xFB.4
02AEA:  MOVLW  20
02AEC:  MOVLB  0
02AEE:  ADDWF  01,F
02AF0:  MOVFF  01,8FF
02AF4:  CALL   10A8
02AF8:  MOVLB  8
02AFA:  MOVLW  30
02AFC:  ADDWF  xFA,F
02AFE:  MOVFF  8FA,8FF
02B02:  MOVLB  0
02B04:  CALL   10A8
02B08:  RETURN 0
02B0A:  MOVLW  20
02B0C:  MOVLB  8
02B0E:  BTFSS  xFA.4
02B10:  MOVLW  30
02B12:  MOVWF  xFB
02B14:  MOVFF  8F9,00
02B18:  BTFSS  xF9.7
02B1A:  BRA    2B2C
02B1C:  COMF   00,F
02B1E:  INCF   00,F
02B20:  MOVFF  00,8F9
02B24:  MOVLW  2D
02B26:  MOVWF  xFB
02B28:  BSF    xFA.7
02B2A:  BSF    xFA.0
02B2C:  MOVF   01,W
02B2E:  MOVFF  8F9,913
02B32:  MOVLW  64
02B34:  MOVLB  9
02B36:  MOVWF  x14
02B38:  MOVLB  0
02B3A:  CALL   1EE8
02B3E:  MOVFF  00,8F9
02B42:  MOVLW  30
02B44:  ADDWF  01,W
02B46:  MOVLB  8
02B48:  MOVWF  xFC
02B4A:  MOVFF  8F9,913
02B4E:  MOVLW  0A
02B50:  MOVLB  9
02B52:  MOVWF  x14
02B54:  MOVLB  0
02B56:  CALL   1EE8
02B5A:  MOVLW  30
02B5C:  ADDWF  00,W
02B5E:  MOVLB  8
02B60:  MOVWF  xFE
02B62:  MOVLW  30
02B64:  ADDWF  01,W
02B66:  MOVWF  xFD
02B68:  MOVFF  8FB,00
02B6C:  MOVLW  30
02B6E:  SUBWF  xFC,W
02B70:  BZ    2B7A
02B72:  BSF    xFA.1
02B74:  BTFSC  xFA.7
02B76:  BSF    xFA.2
02B78:  BRA    2B9E
02B7A:  MOVFF  8FB,8FC
02B7E:  MOVLW  20
02B80:  MOVWF  xFB
02B82:  MOVLW  30
02B84:  SUBWF  xFD,W
02B86:  BZ    2B90
02B88:  BSF    xFA.0
02B8A:  BTFSC  xFA.7
02B8C:  BSF    xFA.1
02B8E:  BRA    2B9E
02B90:  BTFSS  FD8.2
02B92:  BSF    xFA.0
02B94:  BNZ   2B9E
02B96:  MOVFF  8FC,8FD
02B9A:  MOVLW  20
02B9C:  MOVWF  xFC
02B9E:  BTFSC  xFA.2
02BA0:  BRA    2BAC
02BA2:  BTFSC  xFA.1
02BA4:  BRA    2BB6
02BA6:  BTFSC  xFA.0
02BA8:  BRA    2BC0
02BAA:  BRA    2BCA
02BAC:  MOVFF  8FB,8FF
02BB0:  MOVLB  0
02BB2:  CALL   10A8
02BB6:  MOVFF  8FC,8FF
02BBA:  MOVLB  0
02BBC:  CALL   10A8
02BC0:  MOVFF  8FD,8FF
02BC4:  MOVLB  0
02BC6:  CALL   10A8
02BCA:  MOVFF  8FE,8FF
02BCE:  MOVLB  0
02BD0:  CALL   10A8
02BD4:  GOTO   7BB2 (RETURN)
*
05A7C:  ADDWF  FE8,W
05A7E:  CLRF   FF7
05A80:  RLCF   FF7,F
05A82:  ADDLW  97
05A84:  MOVWF  FF6
05A86:  MOVLW  5A
05A88:  ADDWFC FF7,F
05A8A:  TBLRD*-
05A8C:  MOVF   FF5,W
05A8E:  MOVWF  FFA
05A90:  TBLRD*
05A92:  MOVF   FF5,W
05A94:  MOVWF  FF9
05A96:  DATA EA,57
05A98:  DATA F2,57
05A9A:  DATA 3A,58
05A9C:  DATA E2,58
05A9E:  DATA 0E,59
05AA0:  DATA 0E,59
05AA2:  DATA 1E,59
05AA4:  DATA 2E,59
05AA6:  DATA 42,59
*
05C6A:  ADDWF  FE8,W
05C6C:  CLRF   FF7
05C6E:  RLCF   FF7,F
05C70:  ADDLW  85
05C72:  MOVWF  FF6
05C74:  MOVLW  5C
05C76:  ADDWFC FF7,F
05C78:  TBLRD*-
05C7A:  MOVF   FF5,W
05C7C:  MOVWF  FFA
05C7E:  TBLRD*
05C80:  MOVF   FF5,W
05C82:  MOVWF  FF9
05C84:  DATA BE,5A
05C86:  DATA BE,5A
05C88:  DATA 1A,5B
05C8A:  DATA B0,5B
05C8C:  DATA 14,5C
05C8E:  DATA 08,5B
05C90:  DATA 7E,5B
*
06CE8:  ADDWF  FE8,W
06CEA:  CLRF   FF7
06CEC:  RLCF   FF7,F
06CEE:  ADDLW  03
06CF0:  MOVWF  FF6
06CF2:  MOVLW  6D
06CF4:  ADDWFC FF7,F
06CF6:  TBLRD*-
06CF8:  MOVF   FF5,W
06CFA:  MOVWF  FFA
06CFC:  TBLRD*
06CFE:  MOVF   FF5,W
06D00:  MOVWF  FF9
06D02:  DATA B8,69
06D04:  DATA 00,6A
06D06:  DATA 34,6A
06D08:  DATA DA,6A
06D0A:  DATA 40,6B
06D0C:  DATA DE,6B
06D0E:  DATA 0E,6C
06D10:  DATA A8,6C
*
06D1E:  MOVFF  8F7,FEA
06D22:  MOVFF  8F6,FE9
06D26:  MOVLB  8
06D28:  MOVFF  8FC,FEF
06D2C:  INCF   FE9,F
06D2E:  BTFSC  FD8.2
06D30:  INCF   FEA,F
06D32:  CLRF   FEF
06D34:  INCF   xF6,F
06D36:  BTFSC  FD8.2
06D38:  INCF   xF7,F
06D3A:  MOVLB  0
06D3C:  RETURN 0
06D3E:  MOVLB  8
06D40:  BTFSC  xFA.7
06D42:  BRA    6D66
06D44:  MOVLW  0F
06D46:  MOVWF  00
06D48:  SWAPF  xF9,W
06D4A:  ANDWF  00,F
06D4C:  MOVLW  0A
06D4E:  SUBWF  00,W
06D50:  BC    6D58
06D52:  MOVLW  30
06D54:  ADDWF  00,F
06D56:  BRA    6D5C
06D58:  MOVF   xFA,W
06D5A:  ADDWF  00,F
06D5C:  MOVFF  00,8FC
06D60:  MOVLB  0
06D62:  RCALL  6D1E
06D64:  MOVLB  8
06D66:  MOVLW  0F
06D68:  ANDWF  xF9,F
06D6A:  MOVLW  0A
06D6C:  SUBWF  xF9,W
06D6E:  BC    6D74
06D70:  MOVLW  30
06D72:  BRA    6D78
06D74:  BCF    xFA.7
06D76:  MOVF   xFA,W
06D78:  ADDWF  xF9,F
06D7A:  MOVFF  8F9,8FC
06D7E:  MOVLB  0
06D80:  RCALL  6D1E
06D82:  RETURN 0
06D84:  TBLRD*+
06D86:  MOVFF  FF6,8FA
06D8A:  MOVFF  FF7,8FB
06D8E:  MOVFF  FF5,8FC
06D92:  RCALL  6D1E
06D94:  MOVFF  8FA,FF6
06D98:  MOVFF  8FB,FF7
06D9C:  MOVLB  8
06D9E:  DECFSZ xF9,F
06DA0:  BRA    6DA4
06DA2:  BRA    6DA8
06DA4:  MOVLB  0
06DA6:  BRA    6D84
06DA8:  MOVLB  0
06DAA:  GOTO   6E72 (RETURN)
*
06F36:  TBLRD*+
06F38:  MOVF   FF5,F
06F3A:  BZ    6F54
06F3C:  MOVFF  FF6,8F9
06F40:  MOVFF  FF7,8FA
06F44:  MOVFF  FF5,8FC
06F48:  RCALL  6D1E
06F4A:  MOVFF  8F9,FF6
06F4E:  MOVFF  8FA,FF7
06F52:  BRA    6F36
06F54:  GOTO   7008 (RETURN)
*
077FC:  MOVLW  20
077FE:  MOVLB  8
07800:  BTFSS  xFA.4
07802:  MOVLW  30
07804:  MOVWF  xFB
07806:  MOVFF  8F9,00
0780A:  BTFSS  xF9.7
0780C:  BRA    781E
0780E:  COMF   00,F
07810:  INCF   00,F
07812:  MOVFF  00,8F9
07816:  MOVLW  2D
07818:  MOVWF  xFB
0781A:  BSF    xFA.7
0781C:  BSF    xFA.0
0781E:  MOVF   01,W
07820:  MOVFF  8F9,913
07824:  MOVLW  64
07826:  MOVLB  9
07828:  MOVWF  x14
0782A:  MOVLB  0
0782C:  CALL   1EE8
07830:  MOVFF  00,8F9
07834:  MOVLW  30
07836:  ADDWF  01,W
07838:  MOVLB  8
0783A:  MOVWF  xFC
0783C:  MOVFF  8F9,913
07840:  MOVLW  0A
07842:  MOVLB  9
07844:  MOVWF  x14
07846:  MOVLB  0
07848:  CALL   1EE8
0784C:  MOVLW  30
0784E:  ADDWF  00,W
07850:  MOVLB  8
07852:  MOVWF  xFE
07854:  MOVLW  30
07856:  ADDWF  01,W
07858:  MOVWF  xFD
0785A:  MOVFF  8FB,00
0785E:  MOVLW  30
07860:  SUBWF  xFC,W
07862:  BZ    786C
07864:  BSF    xFA.1
07866:  BTFSC  xFA.7
07868:  BSF    xFA.2
0786A:  BRA    7890
0786C:  BTFSC  xFA.2
0786E:  BRA    7890
07870:  MOVFF  8FB,8FC
07874:  BTFSC  xFA.1
07876:  BRA    7880
07878:  MOVLW  30
0787A:  SUBWF  xFD,W
0787C:  BZ    7886
0787E:  BSF    xFA.0
07880:  BTFSC  xFA.7
07882:  BSF    xFA.1
07884:  BRA    7890
07886:  BTFSS  FD8.2
07888:  BSF    xFA.0
0788A:  BTFSC  FD8.2
0788C:  MOVFF  8FC,8FD
07890:  BTFSC  xFA.2
07892:  BRA    789E
07894:  BTFSC  xFA.1
07896:  BRA    78A8
07898:  BTFSC  xFA.0
0789A:  BRA    78B2
0789C:  BRA    78BC
0789E:  MOVFF  8FB,8FF
078A2:  MOVLB  0
078A4:  CALL   10A8
078A8:  MOVFF  8FC,8FF
078AC:  MOVLB  0
078AE:  CALL   10A8
078B2:  MOVFF  8FD,8FF
078B6:  MOVLB  0
078B8:  CALL   10A8
078BC:  MOVFF  8FE,8FF
078C0:  MOVLB  0
078C2:  CALL   10A8
078C6:  RETURN 0
....................  
.................... #list 
....................  
.................... // Conversor de 10 bits con justificación a la derecha. 
.................... //#device ADC=10 
.................... // Configuramos velocidad de operación. 
.................... #use delay(clock=40000000) // Trabajamos a 20.00Mhz.  
*
0102E:  MOVLW  09
01030:  MOVWF  FEA
01032:  CLRF   FE9
01034:  MOVF   FEF,W
01036:  BZ    1054
01038:  MOVLW  0C
0103A:  MOVWF  01
0103C:  CLRF   00
0103E:  DECFSZ 00,F
01040:  BRA    103E
01042:  DECFSZ 01,F
01044:  BRA    103C
01046:  MOVLW  F7
01048:  MOVWF  00
0104A:  DECFSZ 00,F
0104C:  BRA    104A
0104E:  BRA    1050
01050:  DECFSZ FEF,F
01052:  BRA    1038
01054:  RETURN 0
.................... // Configuramos fusibles de programación. 
.................... //#FUSES NOWDT                    // No utilizamos el perro guardían. 
.................... #FUSES WDT4096 
.................... #FUSES H4                       // Oscilador de alta velocidad 40Mhz. 
.................... #FUSES FCMEN                    // Monitor de reloj activado. 
.................... #FUSES PUT                      // Temporizador de encendido. 
.................... #FUSES NOBROWNOUT               // No activamos el reset por bajo voltaje. 
.................... #FUSES NOPBADEN                 // Deshabilitamos el módulo conversor ADC del puerto B. 
.................... #FUSES NOLPT1OSC                // Timer 1 configurado para una alta potencia de operación. 
.................... //#FUSES NOMCLR                   // Pin Master Clear deshabilitado. 
.................... #FUSES MCLR                     // Pin Master Clear habilitado. 
.................... #FUSES STVREN                   // Si se rebalsa o llena el stack el microcontrolador se resetea. 
.................... #FUSES NOLVP                    // No utilizamos bajo voltaje para programación. 
.................... #FUSES NOXINST                  // Set de instruccciones ampliado, desactivado. 
.................... #FUSES NODEBUG                  // No utilizamos código para debug. 
.................... #FUSES PROTECT                  // Código protejido contra lecturas. 
.................... #FUSES NOCPB                    // Sector de booteo no protejido. 
.................... #FUSES NOCPD                    // Sin protección de código en la EEPROM. 
.................... #FUSES NOWRT                    // Memoria de programa no protejida contra escrituras. 
.................... #FUSES NOWRTC                   // Registros de configuración no protegido contra escritura. 
.................... #FUSES NOWRTB                   // Bloque de booteo no protejido contra escritura. 
.................... #FUSES NOWRTD                   // Memoria EEPROM no protejida contra escritura. 
.................... #FUSES NOEBTR                   // Memoria no protejida contra lectuas de tablas de memoria. 
.................... #FUSES NOEBTRB                  // Bloque de booteo no protejido contra lectura de tablas de memoria. 
....................  
.................... // Configuramos los puertos RS232 utilizados. 
.................... #use RS232(uart1, baud=38400,RESTART_WDT,stream=U1PRINTER,TIMEOUT=40,DISABLE_INTS) 
*
01E0C:  CLRWDT
01E0E:  BTFSS  F9E.4
01E10:  BRA    1E0C
01E12:  MOVLB  9
01E14:  MOVFF  913,FAD
01E18:  MOVLB  0
01E1A:  RETURN 0
....................  
.................... const int data_set=14;//CANTIDAD DE INSTRUCCIONES GRABADAS 
.................... const int port_size=90; 
.................... const int tag_size = 8; 
.................... const int word_size_reg =12;//TAMAÑO DE REGISTRO 
.................... const int16 lim_reg=300; 
.................... const int16 data_numbers_ext=2000;//maximo de tags en eeprom 
.................... const int instruccion_size = 10; 
....................  
.................... int envia_pc,a,b2,relay1,tcp_recibe,time_relay1,falla_grabar,f_graba; 
.................... char memory[30]; 
.................... int16 i,n,b,c_envia; 
.................... int size_tx_tcp,con_activas; 
.................... unsigned int16 m,dir; 
....................  
.................... int edo_str, reintento_envio,inicializado,socket2; 
.................... char XX[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RECIBIDOS DE TCP) 
.................... char YY[port_size];// ARREGLO GENERICO(ALMACENA LECTURAS TARJETAS Y DATOS RESPALDO EN RAM) 
.................... char txtcp[port_size];//ARREGLO DE TRANSMICION 
.................... char rxtcp[port_size];//1536->112 tags,se direcciona mal la ram con valores mas grandes 
.................... //500-alcanza para 54 tags, mas no alcanza la ram, 700au cabe 
.................... char lcd_men[port_size-10]; 
.................... ////////VARIABLES WIEGAND///////// 
.................... const int wieg_size=26;//34;// 
.................... int deteccion_nulo,pre_cuenta; 
.................... int wieg,wigmal,tecla; 
.................... int sub_indice=0; 
.................... int wieg_full=0; 
.................... int wiegand_cuenta; 
.................... unsigned int32 deci; 
.................... char data[wieg_size]; 
.................... char con_barra[30],barra_codi[30]; 
.................... int32 folio; 
.................... const int idbar=1; 
.................... const int data_numbers=14; 
.................... //RELOJ/CALENDARIO 
.................... int day,month,yr,hrs,min,sec,dow,puntos,cambio_msj; 
.................... int dias_prueba,dia_temp,pago,cuenta,espera,hrs2; 
.................... int16 mes2,dia; 
.................... const int dia_limite=90; 
.................... //variables de entradas 
.................... int en1,en2,en3,en4,en5,flag_pluma; 
.................... //boleto 
.................... int time_boleto,re_bol,cta_lcd; 
.................... // Definimos macros hardware: 
.................... #include "LCD_4x20.c" 
.................... // Flex_LCD420.c  
....................  
.................... // These pins are for my Microchip PicDem2-Plus board,  
.................... // which I used to test this driver.  
.................... // An external 20x4 LCD is connected to these pins.  
.................... // Change these pins to match your own board's connections.  
....................  
.................... #define LCD_DB4   PIN_A4 
.................... #define LCD_DB5   PIN_A2 
.................... #define LCD_DB6   PIN_A1 
.................... #define LCD_DB7   PIN_A0 
....................  
.................... #define LCD_RS    PIN_E2 
.................... #define LCD_RW    PIN_C1 
.................... #define LCD_E     PIN_A3 
.................... /* 
.................... #define LCD_DB4   PIN_B4  
.................... #define LCD_DB5   PIN_B5  
.................... #define LCD_DB6   PIN_B6  
.................... #define LCD_DB7   PIN_B7  
....................  
.................... #define LCD_RS    PIN_B0  
.................... #define LCD_RW    PIN_B1  
.................... #define LCD_E     PIN_B2  
.................... */ 
....................  
.................... /*  
.................... // To prove that the driver can be used with random  
.................... // pins, I also tested it with these pins:  
.................... #define LCD_DB4   PIN_D4  
.................... #define LCD_DB5   PIN_B1  
.................... #define LCD_DB6   PIN_C5  
.................... #define LCD_DB7   PIN_B5  
....................  
.................... #define LCD_RS    PIN_E2  
.................... #define LCD_RW    PIN_B2  
.................... #define LCD_E     PIN_D6  
.................... */  
....................  
.................... // If you want only a 6-pin interface to your LCD, then  
.................... // connect the R/W pin on the LCD to ground, and comment  
.................... // out the following line.  Doing so will save one PIC  
.................... // pin, but at the cost of losing the ability to read from  
.................... // the LCD.  It also makes the write time a little longer  
.................... // because a static delay must be used, instead of polling  
.................... // the LCD's busy bit.  Normally a 6-pin interface is only  
.................... // used if you are running out of PIC pins, and you need  
.................... // to use as few as possible for the LCD.  
.................... //#define USE_RW_PIN   1       
....................  
....................  
.................... // These are the line addresses for most 4x20 LCDs.  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x40  
.................... #define LCD_LINE_3_ADDRESS 0x14  
.................... #define LCD_LINE_4_ADDRESS 0x54  
....................  
.................... // These are the line addresses for LCD's which use  
.................... // the Hitachi HD66712U controller chip.  
.................... /*  
.................... #define LCD_LINE_1_ADDRESS 0x00  
.................... #define LCD_LINE_2_ADDRESS 0x20  
.................... #define LCD_LINE_3_ADDRESS 0x40  
.................... #define LCD_LINE_4_ADDRESS 0x60  
.................... */  
....................  
.................... //========================================  
.................... #define lcd_type 2   // 0=5x7, 1=5x10, 2=2 lines(or more)  
....................  
.................... int8 lcd_line;  
....................  
.................... int8 const LCD_INIT_STRING[4] =  
.................... {  
....................  0x20 | (lcd_type << 2),  // Set mode: 4-bit, 2+ lines, 5x8 dots  
....................  0xc,                     // Display on  
....................  1,                       // Clear display  
....................  6                        // Increment cursor  
....................  };  
....................                                
....................  
.................... //-------------------------------------  
.................... void lcd_send_nibble(int8 nibble)  
.................... {  
.................... // Note:  !! converts an integer expression  
.................... // to a boolean (1 or 0).  
....................  output_bit(LCD_DB4, !!(nibble & 1));  
*
00FA0:  MOVLB  9
00FA2:  BTFSC  x07.0
00FA4:  BRA    0FAA
00FA6:  BCF    F89.4
00FA8:  BRA    0FAC
00FAA:  BSF    F89.4
00FAC:  BCF    F92.4
....................  output_bit(LCD_DB5, !!(nibble & 2));   
00FAE:  BTFSC  x07.1
00FB0:  BRA    0FB6
00FB2:  BCF    F89.2
00FB4:  BRA    0FB8
00FB6:  BSF    F89.2
00FB8:  BCF    F92.2
....................  output_bit(LCD_DB6, !!(nibble & 4));     
00FBA:  BTFSC  x07.2
00FBC:  BRA    0FC2
00FBE:  BCF    F89.1
00FC0:  BRA    0FC4
00FC2:  BSF    F89.1
00FC4:  BCF    F92.1
....................  output_bit(LCD_DB7, !!(nibble & 8));     
00FC6:  BTFSC  x07.3
00FC8:  BRA    0FCE
00FCA:  BCF    F89.0
00FCC:  BRA    0FD0
00FCE:  BSF    F89.0
00FD0:  BCF    F92.0
....................  
....................  delay_cycles(1);  
00FD2:  NOP   
....................  output_high(LCD_E);  
00FD4:  BCF    F92.3
00FD6:  BSF    F89.3
....................  delay_us(2);  
00FD8:  MOVLW  06
00FDA:  MOVWF  00
00FDC:  DECFSZ 00,F
00FDE:  BRA    0FDC
00FE0:  NOP   
....................  output_low(LCD_E);  
00FE2:  BCF    F92.3
00FE4:  BCF    F89.3
00FE6:  MOVLB  0
00FE8:  RETURN 0
.................... } 
....................  
.................... //-----------------------------------  
.................... // This sub-routine is only called by lcd_read_byte().  
.................... // It's not a stand-alone routine.  For example, the  
.................... // R/W signal is set high by lcd_read_byte() before  
.................... // this routine is called.       
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_nibble(void)  
.................... {  
.................... int8 retval;  
.................... // Create bit variables so that we can easily set  
.................... // individual bits in the retval variable.  
.................... #bit retval_0 = retval.0  
.................... #bit retval_1 = retval.1  
.................... #bit retval_2 = retval.2  
.................... #bit retval_3 = retval.3  
....................  
.................... retval = 0;  
....................      
.................... output_high(LCD_E);  
.................... delay_us(1);  
....................  
.................... retval_0 = input(LCD_DB4);  
.................... retval_1 = input(LCD_DB5);  
.................... retval_2 = input(LCD_DB6);  
.................... retval_3 = input(LCD_DB7);  
....................    
.................... output_low(LCD_E);  
.................... delay_us(1);  
....................      
.................... return(retval);     
.................... }     
.................... #endif  
....................  
.................... //---------------------------------------  
.................... // Read a byte from the LCD and return it.  
....................  
.................... #ifdef USE_RW_PIN  
.................... int8 lcd_read_byte(void)  
.................... {  
.................... int8 low;  
.................... int8 high;  
....................  
.................... output_high(LCD_RW);  
.................... delay_cycles(1);  
....................  
.................... high = lcd_read_nibble();  
....................  
.................... low = lcd_read_nibble();  
....................  
.................... return( (high<<4) | low);  
.................... }  
.................... #endif  
....................  
.................... //----------------------------------------  
.................... // Send a byte to the LCD.  
.................... void lcd_send_byte(int8 address, int8 n)  
.................... {  
.................... output_low(LCD_RS);  
00FEA:  BCF    F96.2
00FEC:  BCF    F8D.2
....................  
.................... #ifdef USE_RW_PIN  
.................... while(bit_test(lcd_read_byte(),7)) ;  
.................... #else  
.................... delay_us(60);   
00FEE:  MOVLW  C7
00FF0:  MOVWF  00
00FF2:  DECFSZ 00,F
00FF4:  BRA    0FF2
00FF6:  BRA    0FF8
.................... #endif  
....................  
.................... if(address)  
00FF8:  MOVLB  9
00FFA:  MOVF   x04,F
00FFC:  BZ    1004
....................    output_high(LCD_RS);  
00FFE:  BCF    F96.2
01000:  BSF    F8D.2
01002:  BRA    1008
.................... else  
....................    output_low(LCD_RS);  
01004:  BCF    F96.2
01006:  BCF    F8D.2
....................        
....................  delay_cycles(1);  
01008:  NOP   
....................  
.................... #ifdef USE_RW_PIN  
.................... output_low(LCD_RW);  
.................... delay_cycles(1);  
.................... #endif  
....................  
.................... output_low(LCD_E);  
0100A:  BCF    F92.3
0100C:  BCF    F89.3
....................  
.................... lcd_send_nibble(n >> 4);  
0100E:  SWAPF  x05,W
01010:  MOVWF  x06
01012:  MOVLW  0F
01014:  ANDWF  x06,F
01016:  MOVFF  906,907
0101A:  MOVLB  0
0101C:  RCALL  0FA0
.................... lcd_send_nibble(n & 0xf);  
0101E:  MOVLB  9
01020:  MOVF   x05,W
01022:  ANDLW  0F
01024:  MOVWF  x06
01026:  MOVWF  x07
01028:  MOVLB  0
0102A:  RCALL  0FA0
0102C:  RETURN 0
.................... }  
.................... //----------------------------  
....................  
.................... void lcd_init(void)  
.................... {  
....................    int8 i;  
....................  
....................    lcd_line = 1;  
*
01134:  MOVLW  01
01136:  MOVLB  2
01138:  MOVWF  x8C
....................  
....................    output_low(LCD_RS);  
0113A:  BCF    F96.2
0113C:  BCF    F8D.2
....................  
....................    #ifdef USE_RW_PIN  
....................       output_low(LCD_RW);  
....................    #endif  
....................  
....................    output_low(LCD_E);  
0113E:  BCF    F92.3
01140:  BCF    F89.3
....................  
....................    // Some LCDs require 15 ms minimum delay after  
....................    // power-up.  Others require 30 ms.  I'm going  
....................    // to set it to 35 ms, so it should work with  
....................    // all of them.  
....................    delay_ms(35);           
01142:  MOVLW  23
01144:  MOVLB  9
01146:  MOVWF  x00
01148:  MOVLB  0
0114A:  RCALL  102E
....................  
....................    for(i=0 ;i < 3; i++)  
0114C:  MOVLB  8
0114E:  CLRF   xF9
01150:  MOVF   xF9,W
01152:  SUBLW  02
01154:  BNC   1170
....................    {  
....................       lcd_send_nibble(0x03);  
01156:  MOVLW  03
01158:  MOVLB  9
0115A:  MOVWF  x07
0115C:  MOVLB  0
0115E:  RCALL  0FA0
....................       delay_ms(5);  
01160:  MOVLW  05
01162:  MOVLB  9
01164:  MOVWF  x00
01166:  MOVLB  0
01168:  RCALL  102E
0116A:  MOVLB  8
0116C:  INCF   xF9,F
0116E:  BRA    1150
....................    }  
....................  
....................    lcd_send_nibble(0x02);  
01170:  MOVLW  02
01172:  MOVLB  9
01174:  MOVWF  x07
01176:  MOVLB  0
01178:  RCALL  0FA0
....................  
....................    for(i=0; i < sizeof(LCD_INIT_STRING); i++)  
0117A:  MOVLB  8
0117C:  CLRF   xF9
0117E:  MOVF   xF9,W
01180:  SUBLW  03
01182:  BNC   11AC
....................    {  
....................       lcd_send_byte(0, LCD_INIT_STRING[i]);  
01184:  CLRF   03
01186:  MOVF   xF9,W
01188:  MOVLB  0
0118A:  CALL   00D2
0118E:  MOVLB  8
01190:  MOVWF  xFA
01192:  MOVLB  9
01194:  CLRF   x04
01196:  MOVWF  x05
01198:  MOVLB  0
0119A:  RCALL  0FEA
....................      
....................       // If the R/W signal is not used, then  
....................       // the busy bit can't be polled.  One of  
....................       // the init commands takes longer than  
....................       // the hard-coded delay of 50 us, so in  
....................       // that case, lets just do a 5 ms delay  
....................       // after all four of them.  
....................       #ifndef USE_RW_PIN  
....................          delay_ms(5);  
0119C:  MOVLW  05
0119E:  MOVLB  9
011A0:  MOVWF  x00
011A2:  MOVLB  0
011A4:  RCALL  102E
....................       #endif  
011A6:  MOVLB  8
011A8:  INCF   xF9,F
011AA:  BRA    117E
....................    }  
011AC:  MOVLB  0
011AE:  GOTO   7A8A (RETURN)
....................  
.................... }  
....................  
.................... //----------------------------  
....................  
.................... void lcd_gotoxy(int8 x, int8 y)  
.................... {  
.................... int8 address;  
....................  
....................  
.................... switch(y)  
*
01056:  MOVLB  9
01058:  MOVF   x01,W
0105A:  XORLW  01
0105C:  MOVLB  0
0105E:  BZ    106E
01060:  XORLW  03
01062:  BZ    1074
01064:  XORLW  01
01066:  BZ    107C
01068:  XORLW  07
0106A:  BZ    1084
0106C:  BRA    108E
....................   {  
....................    case 1:  
....................      address = LCD_LINE_1_ADDRESS;  
0106E:  MOVLB  9
01070:  CLRF   x02
....................      break;  
01072:  BRA    1092
....................  
....................    case 2:  
....................      address = LCD_LINE_2_ADDRESS;  
01074:  MOVLW  40
01076:  MOVLB  9
01078:  MOVWF  x02
....................      break;  
0107A:  BRA    1092
....................  
....................    case 3:  
....................      address = LCD_LINE_3_ADDRESS;  
0107C:  MOVLW  14
0107E:  MOVLB  9
01080:  MOVWF  x02
....................      break;  
01082:  BRA    1092
....................  
....................    case 4:  
....................      address = LCD_LINE_4_ADDRESS;  
01084:  MOVLW  54
01086:  MOVLB  9
01088:  MOVWF  x02
....................      break;  
0108A:  BRA    1092
0108C:  MOVLB  0
....................  
....................    default:  
....................      address = LCD_LINE_1_ADDRESS;  
0108E:  MOVLB  9
01090:  CLRF   x02
....................      break;  
....................        
....................   }  
....................  
.................... address += x-1;  
01092:  MOVLW  01
01094:  SUBWF  x00,W
01096:  ADDWF  x02,F
.................... lcd_send_byte(0, 0x80 | address);  
01098:  MOVF   x02,W
0109A:  IORLW  80
0109C:  MOVWF  x03
0109E:  CLRF   x04
010A0:  MOVWF  x05
010A2:  MOVLB  0
010A4:  RCALL  0FEA
010A6:  RETURN 0
.................... }  
....................  
.................... //-----------------------------  
.................... void lcd_putc(char c)  
.................... {  
....................  switch(c)  
010A8:  MOVLB  8
010AA:  MOVF   xFF,W
010AC:  XORLW  0C
010AE:  MOVLB  0
010B0:  BZ    10BC
010B2:  XORLW  06
010B4:  BZ    10DA
010B6:  XORLW  02
010B8:  BZ    10EE
010BA:  BRA    10FC
....................    {  
....................     case '\f':  
....................       lcd_send_byte(0,1);  
010BC:  MOVLB  9
010BE:  CLRF   x04
010C0:  MOVLW  01
010C2:  MOVWF  x05
010C4:  MOVLB  0
010C6:  RCALL  0FEA
....................       lcd_line = 1;  
010C8:  MOVLW  01
010CA:  MOVLB  2
010CC:  MOVWF  x8C
....................       delay_ms(2);  
010CE:  MOVLW  02
010D0:  MOVLB  9
010D2:  MOVWF  x00
010D4:  MOVLB  0
010D6:  RCALL  102E
....................       break;  
010D8:  BRA    110A
....................      
....................     case '\n':  
....................        lcd_gotoxy(1, ++lcd_line);  
010DA:  MOVLB  2
010DC:  INCF   x8C,F
010DE:  MOVLW  01
010E0:  MOVLB  9
010E2:  MOVWF  x00
010E4:  MOVFF  28C,901
010E8:  MOVLB  0
010EA:  RCALL  1056
....................        break;  
010EC:  BRA    110A
....................      
....................     case '\b':  
....................        lcd_send_byte(0,0x10);  
010EE:  MOVLB  9
010F0:  CLRF   x04
010F2:  MOVLW  10
010F4:  MOVWF  x05
010F6:  MOVLB  0
010F8:  RCALL  0FEA
....................        break;  
010FA:  BRA    110A
....................      
....................     default:  
....................        lcd_send_byte(1,c);  
010FC:  MOVLW  01
010FE:  MOVLB  9
01100:  MOVWF  x04
01102:  MOVFF  8FF,905
01106:  MOVLB  0
01108:  RCALL  0FEA
....................        break;  
....................    }  
0110A:  RETURN 0
.................... }  
....................  
.................... //------------------------------  
.................... #ifdef USE_RW_PIN  
.................... char lcd_getc(int8 x, int8 y)  
.................... {  
.................... char value;  
....................  
.................... lcd_gotoxy(x,y);  
....................  
.................... // Wait until busy flag is low.  
.................... while(bit_test(lcd_read_byte(),7));   
....................  
.................... output_high(LCD_RS);  
.................... value = lcd_read_byte();  
.................... output_low(LCD_RS);  
....................  
.................... return(value);  
.................... }  
.................... #endif 
....................  
.................... #include "24256_SEGUINT.c" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////   Library for a 24LC256 serial EEPROM                             //// 
.................... ////                                                                   //// 
.................... ////   init_ext_eeprom();    Call before the other functions are used  //// 
.................... ////                                                                   //// 
.................... ////   write_ext_eeprom(a, d);  Write the byte d to the address a      //// 
.................... ////                                                                   //// 
.................... ////   d = read_ext_eeprom(a);   Read the byte d from the address a    //// 
.................... ////                                                                   //// 
.................... ////   The main program may define eeprom_sda                          //// 
.................... ////   and eeprom_scl to override the defaults below.                  //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef EEPROM_SDA 
....................  
.................... #define EEPROM_SDA  PIN_B5//PIN_B7 
.................... #define EEPROM_SCL  PIN_B4//PIN_B6 
....................  
.................... #endif 
....................  
.................... #use i2c(master, sda=EEPROM_SDA, scl=EEPROM_SCL) 
*
027CA:  MOVLW  08
027CC:  MOVWF  01
027CE:  MOVLW  0E
027D0:  MOVWF  00
027D2:  DECFSZ 00,F
027D4:  BRA    27D2
027D6:  BCF    F8A.4
027D8:  BCF    F93.4
027DA:  MOVLW  0E
027DC:  MOVWF  00
027DE:  DECFSZ 00,F
027E0:  BRA    27DE
027E2:  MOVLB  9
027E4:  RLCF   x0F,F
027E6:  BCF    F8A.5
027E8:  BTFSC  FD8.0
027EA:  BSF    F93.5
027EC:  BTFSS  FD8.0
027EE:  BCF    F93.5
027F0:  BSF    F93.4
027F2:  BTFSS  F81.4
027F4:  BRA    27F2
027F6:  DECFSZ 01,F
027F8:  BRA    27FC
027FA:  BRA    2800
027FC:  MOVLB  0
027FE:  BRA    27CE
02800:  MOVLW  0E
02802:  MOVWF  00
02804:  DECFSZ 00,F
02806:  BRA    2804
02808:  BCF    F8A.4
0280A:  BCF    F93.4
0280C:  NOP   
0280E:  BSF    F93.5
02810:  MOVLW  0E
02812:  MOVWF  00
02814:  DECFSZ 00,F
02816:  BRA    2814
02818:  MOVLW  0E
0281A:  MOVWF  00
0281C:  DECFSZ 00,F
0281E:  BRA    281C
02820:  BSF    F93.4
02822:  BTFSS  F81.4
02824:  BRA    2822
02826:  CLRF   01
02828:  MOVLW  0E
0282A:  MOVWF  00
0282C:  DECFSZ 00,F
0282E:  BRA    282C
02830:  BTFSC  F81.5
02832:  BSF    01.0
02834:  BCF    F8A.4
02836:  BCF    F93.4
02838:  BCF    F8A.5
0283A:  BCF    F93.5
0283C:  MOVLB  0
0283E:  RETURN 0
02840:  MOVLW  08
02842:  MOVLB  9
02844:  MOVWF  x0D
02846:  MOVFF  00,90E
0284A:  BSF    F93.5
0284C:  MOVLW  0E
0284E:  MOVWF  00
02850:  DECFSZ 00,F
02852:  BRA    2850
02854:  BSF    F93.4
02856:  BTFSS  F81.4
02858:  BRA    2856
0285A:  BTFSC  F81.5
0285C:  BSF    FD8.0
0285E:  BTFSS  F81.5
02860:  BCF    FD8.0
02862:  RLCF   01,F
02864:  MOVLW  0E
02866:  MOVWF  00
02868:  DECFSZ 00,F
0286A:  BRA    2868
0286C:  BCF    F93.4
0286E:  BCF    F8A.4
02870:  DECFSZ x0D,F
02872:  BRA    284A
02874:  BSF    F93.5
02876:  MOVLW  0E
02878:  MOVWF  00
0287A:  DECFSZ 00,F
0287C:  BRA    287A
0287E:  BCF    F8A.5
02880:  MOVF   x0E,W
02882:  BTFSS  FD8.2
02884:  BCF    F93.5
02886:  NOP   
02888:  BSF    F93.4
0288A:  BTFSS  F81.4
0288C:  BRA    288A
0288E:  MOVLW  0E
02890:  MOVWF  00
02892:  DECFSZ 00,F
02894:  BRA    2892
02896:  BCF    F8A.4
02898:  BCF    F93.4
0289A:  MOVLW  0E
0289C:  MOVWF  00
0289E:  DECFSZ 00,F
028A0:  BRA    289E
028A2:  BCF    F8A.5
028A4:  BCF    F93.5
028A6:  MOVLB  0
028A8:  GOTO   2926 (RETURN)
....................  
.................... #define EEPROM_ADDRESS long int 
.................... #define EEPROM_SIZE   32768 
....................  
.................... void init_ext_eeprom() 
.................... { 
....................    output_float(EEPROM_SCL); 
*
0112C:  BSF    F93.4
....................    output_float(EEPROM_SDA); 
0112E:  BSF    F93.5
01130:  GOTO   7A86 (RETURN)
....................  
.................... } 
....................  
....................  
.................... void write_ext_eeprom(long int address, BYTE data){ 
....................    short int status; 
....................    i2c_start(); 
*
02954:  BSF    F93.5
02956:  MOVLW  0E
02958:  MOVWF  00
0295A:  DECFSZ 00,F
0295C:  BRA    295A
0295E:  BSF    F93.4
02960:  MOVLW  0E
02962:  MOVWF  00
02964:  DECFSZ 00,F
02966:  BRA    2964
02968:  BCF    F8A.5
0296A:  BCF    F93.5
0296C:  MOVLW  0E
0296E:  MOVWF  00
02970:  DECFSZ 00,F
02972:  BRA    2970
02974:  BCF    F8A.4
02976:  BCF    F93.4
....................    i2c_write(0xa0); 
02978:  MOVLW  A0
0297A:  MOVLB  9
0297C:  MOVWF  x0F
0297E:  MOVLB  0
02980:  RCALL  27CA
....................    i2c_write(address>>8); 
02982:  MOVFF  90A,90D
02986:  MOVLB  9
02988:  CLRF   x0E
0298A:  MOVFF  90A,90F
0298E:  MOVLB  0
02990:  RCALL  27CA
....................    i2c_write(address); 
02992:  MOVFF  909,90F
02996:  RCALL  27CA
....................    i2c_write(data); 
02998:  MOVFF  90B,90F
0299C:  RCALL  27CA
....................    i2c_stop(); 
0299E:  BCF    F93.5
029A0:  NOP   
029A2:  BSF    F93.4
029A4:  BTFSS  F81.4
029A6:  BRA    29A4
029A8:  MOVLW  0E
029AA:  MOVWF  00
029AC:  DECFSZ 00,F
029AE:  BRA    29AC
029B0:  BRA    29B2
029B2:  NOP   
029B4:  BSF    F93.5
029B6:  MOVLW  0E
029B8:  MOVWF  00
029BA:  DECFSZ 00,F
029BC:  BRA    29BA
....................    i2c_start(); 
029BE:  BSF    F93.5
029C0:  MOVLW  0E
029C2:  MOVWF  00
029C4:  DECFSZ 00,F
029C6:  BRA    29C4
029C8:  BSF    F93.4
029CA:  MOVLW  0E
029CC:  MOVWF  00
029CE:  DECFSZ 00,F
029D0:  BRA    29CE
029D2:  BCF    F8A.5
029D4:  BCF    F93.5
029D6:  MOVLW  0E
029D8:  MOVWF  00
029DA:  DECFSZ 00,F
029DC:  BRA    29DA
029DE:  BCF    F8A.4
029E0:  BCF    F93.4
....................    status=i2c_write(0xa0); 
029E2:  MOVLW  A0
029E4:  MOVLB  9
029E6:  MOVWF  x0F
029E8:  MOVLB  0
029EA:  RCALL  27CA
029EC:  MOVF   01,W
029EE:  MOVLB  9
029F0:  BCF    x0C.0
029F2:  BTFSC  01.0
029F4:  BSF    x0C.0
....................    while(status==1) 
029F6:  BTFSS  x0C.0
029F8:  BRA    2A36
....................    { 
....................    i2c_start(); 
029FA:  BSF    F93.5
029FC:  MOVLW  0E
029FE:  MOVWF  00
02A00:  DECFSZ 00,F
02A02:  BRA    2A00
02A04:  BSF    F93.4
02A06:  MOVLW  0E
02A08:  MOVWF  00
02A0A:  DECFSZ 00,F
02A0C:  BRA    2A0A
02A0E:  BTFSS  F81.4
02A10:  BRA    2A0E
02A12:  BCF    F8A.5
02A14:  BCF    F93.5
02A16:  MOVLW  0E
02A18:  MOVWF  00
02A1A:  DECFSZ 00,F
02A1C:  BRA    2A1A
02A1E:  BCF    F8A.4
02A20:  BCF    F93.4
....................    status=i2c_write(0xa0); 
02A22:  MOVLW  A0
02A24:  MOVWF  x0F
02A26:  MOVLB  0
02A28:  RCALL  27CA
02A2A:  MOVF   01,W
02A2C:  MOVLB  9
02A2E:  BCF    x0C.0
02A30:  BTFSC  01.0
02A32:  BSF    x0C.0
02A34:  BRA    29F6
....................    } 
....................    i2c_stop(); 
02A36:  BCF    F93.5
02A38:  NOP   
02A3A:  BSF    F93.4
02A3C:  BTFSS  F81.4
02A3E:  BRA    2A3C
02A40:  MOVLW  0E
02A42:  MOVWF  00
02A44:  DECFSZ 00,F
02A46:  BRA    2A44
02A48:  BRA    2A4A
02A4A:  NOP   
02A4C:  BSF    F93.5
02A4E:  MOVLW  0E
02A50:  MOVWF  00
02A52:  DECFSZ 00,F
02A54:  BRA    2A52
02A56:  MOVLB  0
02A58:  RETURN 0
.................... } 
....................  
.................... BYTE read_ext_eeprom(long int address) { 
....................    BYTE data; 
....................    i2c_start(); 
*
028AC:  BSF    F93.5
028AE:  MOVLW  0E
028B0:  MOVWF  00
028B2:  DECFSZ 00,F
028B4:  BRA    28B2
028B6:  BSF    F93.4
028B8:  MOVLW  0E
028BA:  MOVWF  00
028BC:  DECFSZ 00,F
028BE:  BRA    28BC
028C0:  BCF    F8A.5
028C2:  BCF    F93.5
028C4:  MOVLW  0E
028C6:  MOVWF  00
028C8:  DECFSZ 00,F
028CA:  BRA    28C8
028CC:  BCF    F8A.4
028CE:  BCF    F93.4
....................    i2c_write(0xa0); 
028D0:  MOVLW  A0
028D2:  MOVLB  9
028D4:  MOVWF  x0F
028D6:  MOVLB  0
028D8:  RCALL  27CA
....................    i2c_write(address>>8); 
028DA:  MOVFF  90A,90C
028DE:  MOVLB  9
028E0:  CLRF   x0D
028E2:  MOVFF  90A,90F
028E6:  MOVLB  0
028E8:  RCALL  27CA
....................    i2c_write(address); 
028EA:  MOVFF  909,90F
028EE:  RCALL  27CA
....................    i2c_start(); 
028F0:  BSF    F93.5
028F2:  MOVLW  0E
028F4:  MOVWF  00
028F6:  DECFSZ 00,F
028F8:  BRA    28F6
028FA:  BSF    F93.4
028FC:  MOVLW  0E
028FE:  MOVWF  00
02900:  DECFSZ 00,F
02902:  BRA    2900
02904:  BTFSS  F81.4
02906:  BRA    2904
02908:  BCF    F8A.5
0290A:  BCF    F93.5
0290C:  MOVLW  0E
0290E:  MOVWF  00
02910:  DECFSZ 00,F
02912:  BRA    2910
02914:  BCF    F8A.4
02916:  BCF    F93.4
....................    i2c_write(0xa1); 
02918:  MOVLW  A1
0291A:  MOVLB  9
0291C:  MOVWF  x0F
0291E:  MOVLB  0
02920:  RCALL  27CA
....................    data=i2c_read(0); 
02922:  CLRF   00
02924:  BRA    2840
02926:  MOVFF  01,90B
....................    i2c_stop(); 
0292A:  BCF    F93.5
0292C:  NOP   
0292E:  BSF    F93.4
02930:  BTFSS  F81.4
02932:  BRA    2930
02934:  MOVLW  0E
02936:  MOVWF  00
02938:  DECFSZ 00,F
0293A:  BRA    2938
0293C:  BRA    293E
0293E:  NOP   
02940:  BSF    F93.5
02942:  MOVLW  0E
02944:  MOVWF  00
02946:  DECFSZ 00,F
02948:  BRA    2946
....................    return(data); 
0294A:  MOVLB  9
0294C:  MOVFF  90B,01
02950:  MOVLB  0
02952:  RETURN 0
.................... } 
....................  
.................... #include "ds1307_3.c" //reloj 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////  
.................... ///                               DS1307.C                                   ///  
.................... ///                     Driver for Real Time Clock                           ///  
.................... ///                                                                          ///  
.................... /// ds1307_init() - Enable oscillator without clearing the seconds register -///  
.................... ///                 used when PIC loses power and DS1307 run from 3V BAT     ///  
.................... ///               - Disable squarewave output                                ///  
.................... ///                                                                          ///  
.................... /// ds1307_set_date_time(day,mth,year,dow,hour,min,sec)  Set the date/time   ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_date(day,mth,year,dow)               Get the date             ///  
.................... ///                                                                          ///  
.................... /// ds1307_get_time(hr,min,sec)                     Get the time             ///  
.................... ///                                                                          ///  
.................... ////////////////////////////////////////////////////////////////////////////////  
....................  
.................... #define RTC_SDA  PIN_D6 
.................... #define RTC_SCL  PIN_E1 
....................  
.................... #use i2c(master, sda=RTC_SDA, scl=RTC_SCL)  
*
01D02:  MOVLW  08
01D04:  MOVWF  01
01D06:  MOVLW  0E
01D08:  MOVWF  00
01D0A:  DECFSZ 00,F
01D0C:  BRA    1D0A
01D0E:  BCF    F8D.1
01D10:  BCF    F96.1
01D12:  MOVLW  0E
01D14:  MOVWF  00
01D16:  DECFSZ 00,F
01D18:  BRA    1D16
01D1A:  MOVLB  9
01D1C:  RLCF   x11,F
01D1E:  BCF    F8C.6
01D20:  BTFSC  FD8.0
01D22:  BSF    F95.6
01D24:  BTFSS  FD8.0
01D26:  BCF    F95.6
01D28:  BSF    F96.1
01D2A:  BTFSS  F84.1
01D2C:  BRA    1D2A
01D2E:  DECFSZ 01,F
01D30:  BRA    1D34
01D32:  BRA    1D38
01D34:  MOVLB  0
01D36:  BRA    1D06
01D38:  MOVLW  0E
01D3A:  MOVWF  00
01D3C:  DECFSZ 00,F
01D3E:  BRA    1D3C
01D40:  BCF    F8D.1
01D42:  BCF    F96.1
01D44:  NOP   
01D46:  BSF    F95.6
01D48:  MOVLW  0E
01D4A:  MOVWF  00
01D4C:  DECFSZ 00,F
01D4E:  BRA    1D4C
01D50:  MOVLW  0E
01D52:  MOVWF  00
01D54:  DECFSZ 00,F
01D56:  BRA    1D54
01D58:  BSF    F96.1
01D5A:  BTFSS  F84.1
01D5C:  BRA    1D5A
01D5E:  CLRF   01
01D60:  MOVLW  0E
01D62:  MOVWF  00
01D64:  DECFSZ 00,F
01D66:  BRA    1D64
01D68:  BTFSC  F83.6
01D6A:  BSF    01.0
01D6C:  BCF    F8D.1
01D6E:  BCF    F96.1
01D70:  BCF    F8C.6
01D72:  BCF    F95.6
01D74:  MOVLB  0
01D76:  RETURN 0
01D78:  MOVLW  08
01D7A:  MOVLB  9
01D7C:  MOVWF  x12
01D7E:  MOVFF  00,913
01D82:  BSF    F95.6
01D84:  MOVLW  0E
01D86:  MOVWF  00
01D88:  DECFSZ 00,F
01D8A:  BRA    1D88
01D8C:  BSF    F96.1
01D8E:  BTFSS  F84.1
01D90:  BRA    1D8E
01D92:  BTFSC  F83.6
01D94:  BSF    FD8.0
01D96:  BTFSS  F83.6
01D98:  BCF    FD8.0
01D9A:  RLCF   01,F
01D9C:  MOVLW  0E
01D9E:  MOVWF  00
01DA0:  DECFSZ 00,F
01DA2:  BRA    1DA0
01DA4:  BCF    F96.1
01DA6:  BCF    F8D.1
01DA8:  DECFSZ x12,F
01DAA:  BRA    1D82
01DAC:  BSF    F95.6
01DAE:  MOVLW  0E
01DB0:  MOVWF  00
01DB2:  DECFSZ 00,F
01DB4:  BRA    1DB2
01DB6:  BCF    F8C.6
01DB8:  MOVF   x13,W
01DBA:  BTFSS  FD8.2
01DBC:  BCF    F95.6
01DBE:  NOP   
01DC0:  BSF    F96.1
01DC2:  BTFSS  F84.1
01DC4:  BRA    1DC2
01DC6:  MOVLW  0E
01DC8:  MOVWF  00
01DCA:  DECFSZ 00,F
01DCC:  BRA    1DCA
01DCE:  BCF    F8D.1
01DD0:  BCF    F96.1
01DD2:  MOVLW  0E
01DD4:  MOVWF  00
01DD6:  DECFSZ 00,F
01DD8:  BRA    1DD6
01DDA:  BCF    F8C.6
01DDC:  BCF    F95.6
01DDE:  MOVLB  0
01DE0:  RETURN 0
....................  
.................... BYTE bin2bcd(BYTE binary_value);  
.................... BYTE bcd2bin(BYTE bcd_value);  
....................  
.................... void ds1307_init(void)  
.................... {  
....................    #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
....................    #endif 
....................    BYTE seconds = 0; 
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_start();  
....................    i2c_write(0xD1);      // RD from RTC  
....................    seconds = bcd2bin(i2c_read(0)); // Read current "seconds" in DS1307  
....................    i2c_stop();  
....................    seconds &= 0x7F;  
....................  
....................    delay_us(3);  
....................  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x00);      // REG 0  
....................    i2c_write(bin2bcd(seconds));     // Start oscillator with current "seconds value  
....................    i2c_start();  
....................    i2c_write(0xD0);      // WR to RTC  
....................    i2c_write(0x07);      // Control Register  
....................    i2c_write(0x80);     // Disable squarewave output pin  
....................    i2c_stop();  
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
.................... #endif 
.................... }  
....................  
.................... void ds1307_set_date_time(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min, BYTE sec)  
.................... { 
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
071B6:  BCF    FF2.6
071B8:  BCF    FF2.7
071BA:  BTFSC  FF2.7
071BC:  BRA    71B8
....................   #endif 
....................   sec &= 0x7F; 
071BE:  MOVLB  9
071C0:  BCF    x0F.7
....................   hr &= 0x3F;  
071C2:  MOVLW  3F
071C4:  ANDWF  x0D,F
....................  
....................   i2c_start();  
071C6:  BSF    F95.6
071C8:  MOVLW  0E
071CA:  MOVWF  00
071CC:  DECFSZ 00,F
071CE:  BRA    71CC
071D0:  BSF    F96.1
071D2:  MOVLW  0E
071D4:  MOVWF  00
071D6:  DECFSZ 00,F
071D8:  BRA    71D6
071DA:  BCF    F8C.6
071DC:  BCF    F95.6
071DE:  MOVLW  0E
071E0:  MOVWF  00
071E2:  DECFSZ 00,F
071E4:  BRA    71E2
071E6:  BCF    F8D.1
071E8:  BCF    F96.1
....................   i2c_write(0xD0);            // I2C write address  
071EA:  MOVLW  D0
071EC:  MOVWF  x11
071EE:  MOVLB  0
071F0:  CALL   1D02
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
071F4:  MOVLB  9
071F6:  CLRF   x11
071F8:  MOVLB  0
071FA:  CALL   1D02
....................   i2c_write(bin2bcd(sec));      // REG 0  
071FE:  MOVFF  90F,910
07202:  RCALL  718E
07204:  MOVFF  01,910
07208:  MOVFF  01,911
0720C:  CALL   1D02
....................   i2c_write(bin2bcd(min));      // REG 1  
07210:  MOVFF  90E,910
07214:  RCALL  718E
07216:  MOVFF  01,910
0721A:  MOVFF  01,911
0721E:  CALL   1D02
....................   i2c_write(bin2bcd(hr));      // REG 2  
07222:  MOVFF  90D,910
07226:  RCALL  718E
07228:  MOVFF  01,910
0722C:  MOVFF  01,911
07230:  CALL   1D02
....................   i2c_write(bin2bcd(dow));      // REG 3  
07234:  MOVFF  90C,910
07238:  RCALL  718E
0723A:  MOVFF  01,910
0723E:  MOVFF  01,911
07242:  CALL   1D02
....................   i2c_write(bin2bcd(day));      // REG 4  
07246:  MOVFF  909,910
0724A:  RCALL  718E
0724C:  MOVFF  01,910
07250:  MOVFF  01,911
07254:  CALL   1D02
....................   i2c_write(bin2bcd(mth));      // REG 5  
07258:  MOVFF  90A,910
0725C:  RCALL  718E
0725E:  MOVFF  01,910
07262:  MOVFF  01,911
07266:  CALL   1D02
....................   i2c_write(bin2bcd(year));      // REG 6  
0726A:  MOVFF  90B,910
0726E:  RCALL  718E
07270:  MOVFF  01,910
07274:  MOVFF  01,911
07278:  CALL   1D02
....................   i2c_write(0x80);            // REG 7 - Disable squarewave output pin  
0727C:  MOVLW  80
0727E:  MOVLB  9
07280:  MOVWF  x11
07282:  MOVLB  0
07284:  CALL   1D02
....................   i2c_stop();  
07288:  BCF    F95.6
0728A:  NOP   
0728C:  BSF    F96.1
0728E:  BTFSS  F84.1
07290:  BRA    728E
07292:  MOVLW  0E
07294:  MOVWF  00
07296:  DECFSZ 00,F
07298:  BRA    7296
0729A:  BRA    729C
0729C:  NOP   
0729E:  BSF    F95.6
072A0:  MOVLW  0E
072A2:  MOVWF  00
072A4:  DECFSZ 00,F
072A6:  BRA    72A4
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
072A8:  MOVLW  C0
072AA:  IORWF  FF2,F
.................... #endif 
072AC:  RETURN 0
.................... } 
....................  
.................... void ds1307_get_date(BYTE &day, BYTE &mth, BYTE &year, BYTE &dow)  
.................... {  
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0207E:  BCF    FF2.6
02080:  BCF    FF2.7
02082:  BTFSC  FF2.7
02084:  BRA    2080
*
0752E:  BCF    FF2.6
07530:  BCF    FF2.7
07532:  BTFSC  FF2.7
07534:  BRA    7530
*
080BC:  BCF    FF2.6
080BE:  BCF    FF2.7
080C0:  BTFSC  FF2.7
080C2:  BRA    80BE
....................   #endif 
....................    
....................   i2c_start(); 
*
02086:  BSF    F95.6
02088:  MOVLW  0E
0208A:  MOVWF  00
0208C:  DECFSZ 00,F
0208E:  BRA    208C
02090:  BSF    F96.1
02092:  MOVLW  0E
02094:  MOVWF  00
02096:  DECFSZ 00,F
02098:  BRA    2096
0209A:  BCF    F8C.6
0209C:  BCF    F95.6
0209E:  MOVLW  0E
020A0:  MOVWF  00
020A2:  DECFSZ 00,F
020A4:  BRA    20A2
020A6:  BCF    F8D.1
020A8:  BCF    F96.1
*
07536:  BSF    F95.6
07538:  MOVLW  0E
0753A:  MOVWF  00
0753C:  DECFSZ 00,F
0753E:  BRA    753C
07540:  BSF    F96.1
07542:  MOVLW  0E
07544:  MOVWF  00
07546:  DECFSZ 00,F
07548:  BRA    7546
0754A:  BCF    F8C.6
0754C:  BCF    F95.6
0754E:  MOVLW  0E
07550:  MOVWF  00
07552:  DECFSZ 00,F
07554:  BRA    7552
07556:  BCF    F8D.1
07558:  BCF    F96.1
*
080C4:  BSF    F95.6
080C6:  MOVLW  0E
080C8:  MOVWF  00
080CA:  DECFSZ 00,F
080CC:  BRA    80CA
080CE:  BSF    F96.1
080D0:  MOVLW  0E
080D2:  MOVWF  00
080D4:  DECFSZ 00,F
080D6:  BRA    80D4
080D8:  BCF    F8C.6
080DA:  BCF    F95.6
080DC:  MOVLW  0E
080DE:  MOVWF  00
080E0:  DECFSZ 00,F
080E2:  BRA    80E0
080E4:  BCF    F8D.1
080E6:  BCF    F96.1
....................   i2c_write(0xD0);  
*
020AA:  MOVLW  D0
020AC:  MOVLB  9
020AE:  MOVWF  x11
020B0:  MOVLB  0
020B2:  RCALL  1D02
*
0755A:  MOVLW  D0
0755C:  MOVWF  x11
0755E:  MOVLB  0
07560:  CALL   1D02
*
080E8:  MOVLW  D0
080EA:  MOVLB  9
080EC:  MOVWF  x11
080EE:  MOVLB  0
080F0:  CALL   1D02
....................   i2c_write(0x03);            // Start at REG 3 - Day of week  
*
020B4:  MOVLW  03
020B6:  MOVLB  9
020B8:  MOVWF  x11
020BA:  MOVLB  0
020BC:  RCALL  1D02
*
07564:  MOVLW  03
07566:  MOVLB  9
07568:  MOVWF  x11
0756A:  MOVLB  0
0756C:  CALL   1D02
*
080F4:  MOVLW  03
080F6:  MOVLB  9
080F8:  MOVWF  x11
080FA:  MOVLB  0
080FC:  CALL   1D02
....................   i2c_start();  
*
020BE:  BSF    F95.6
020C0:  MOVLW  0E
020C2:  MOVWF  00
020C4:  DECFSZ 00,F
020C6:  BRA    20C4
020C8:  BSF    F96.1
020CA:  MOVLW  0E
020CC:  MOVWF  00
020CE:  DECFSZ 00,F
020D0:  BRA    20CE
020D2:  BTFSS  F84.1
020D4:  BRA    20D2
020D6:  BCF    F8C.6
020D8:  BCF    F95.6
020DA:  MOVLW  0E
020DC:  MOVWF  00
020DE:  DECFSZ 00,F
020E0:  BRA    20DE
020E2:  BCF    F8D.1
020E4:  BCF    F96.1
*
07570:  BSF    F95.6
07572:  MOVLW  0E
07574:  MOVWF  00
07576:  DECFSZ 00,F
07578:  BRA    7576
0757A:  BSF    F96.1
0757C:  MOVLW  0E
0757E:  MOVWF  00
07580:  DECFSZ 00,F
07582:  BRA    7580
07584:  BTFSS  F84.1
07586:  BRA    7584
07588:  BCF    F8C.6
0758A:  BCF    F95.6
0758C:  MOVLW  0E
0758E:  MOVWF  00
07590:  DECFSZ 00,F
07592:  BRA    7590
07594:  BCF    F8D.1
07596:  BCF    F96.1
*
08100:  BSF    F95.6
08102:  MOVLW  0E
08104:  MOVWF  00
08106:  DECFSZ 00,F
08108:  BRA    8106
0810A:  BSF    F96.1
0810C:  MOVLW  0E
0810E:  MOVWF  00
08110:  DECFSZ 00,F
08112:  BRA    8110
08114:  BTFSS  F84.1
08116:  BRA    8114
08118:  BCF    F8C.6
0811A:  BCF    F95.6
0811C:  MOVLW  0E
0811E:  MOVWF  00
08120:  DECFSZ 00,F
08122:  BRA    8120
08124:  BCF    F8D.1
08126:  BCF    F96.1
....................   i2c_write(0xD1);  
*
020E6:  MOVLW  D1
020E8:  MOVLB  9
020EA:  MOVWF  x11
020EC:  MOVLB  0
020EE:  RCALL  1D02
*
07598:  MOVLW  D1
0759A:  MOVLB  9
0759C:  MOVWF  x11
0759E:  MOVLB  0
075A0:  CALL   1D02
*
08128:  MOVLW  D1
0812A:  MOVLB  9
0812C:  MOVWF  x11
0812E:  MOVLB  0
08130:  CALL   1D02
....................   dow  = bcd2bin(i2c_read() & 0x7f);   // REG 3  
*
020F0:  MOVLW  01
020F2:  MOVWF  00
020F4:  RCALL  1D78
020F6:  MOVF   01,W
020F8:  ANDLW  7F
020FA:  MOVLB  9
020FC:  MOVWF  x0D
020FE:  MOVWF  x12
02100:  MOVLB  0
02102:  RCALL  1DE2
02104:  MOVFF  01,276
*
075A4:  MOVLW  01
075A6:  MOVWF  00
075A8:  CALL   1D78
075AC:  MOVF   01,W
075AE:  ANDLW  7F
075B0:  MOVLB  9
075B2:  MOVWF  x0D
075B4:  MOVWF  x12
075B6:  MOVLB  0
075B8:  CALL   1DE2
075BC:  MOVFF  01,276
*
08134:  MOVLW  01
08136:  MOVWF  00
08138:  CALL   1D78
0813C:  MOVF   01,W
0813E:  ANDLW  7F
08140:  MOVLB  9
08142:  MOVWF  x0D
08144:  MOVWF  x12
08146:  MOVLB  0
08148:  CALL   1DE2
0814C:  MOVFF  01,276
....................   day  = bcd2bin(i2c_read() & 0x3f);   // REG 4  
*
02108:  MOVLW  01
0210A:  MOVWF  00
0210C:  RCALL  1D78
0210E:  MOVF   01,W
02110:  ANDLW  3F
02112:  MOVLB  9
02114:  MOVWF  x0D
02116:  MOVWF  x12
02118:  MOVLB  0
0211A:  RCALL  1DE2
0211C:  MOVFF  01,270
*
075C0:  MOVLW  01
075C2:  MOVWF  00
075C4:  CALL   1D78
075C8:  MOVF   01,W
075CA:  ANDLW  3F
075CC:  MOVLB  9
075CE:  MOVWF  x0D
075D0:  MOVWF  x12
075D2:  MOVLB  0
075D4:  CALL   1DE2
075D8:  MOVFF  01,270
*
08150:  MOVLW  01
08152:  MOVWF  00
08154:  CALL   1D78
08158:  MOVF   01,W
0815A:  ANDLW  3F
0815C:  MOVLB  9
0815E:  MOVWF  x0D
08160:  MOVWF  x12
08162:  MOVLB  0
08164:  CALL   1DE2
08168:  MOVFF  01,270
....................   mth  = bcd2bin(i2c_read() & 0x1f);   // REG 5  
*
02120:  MOVLW  01
02122:  MOVWF  00
02124:  RCALL  1D78
02126:  MOVF   01,W
02128:  ANDLW  1F
0212A:  MOVLB  9
0212C:  MOVWF  x0D
0212E:  MOVWF  x12
02130:  MOVLB  0
02132:  RCALL  1DE2
02134:  MOVFF  01,271
*
075DC:  MOVLW  01
075DE:  MOVWF  00
075E0:  CALL   1D78
075E4:  MOVF   01,W
075E6:  ANDLW  1F
075E8:  MOVLB  9
075EA:  MOVWF  x0D
075EC:  MOVWF  x12
075EE:  MOVLB  0
075F0:  CALL   1DE2
075F4:  MOVFF  01,271
*
0816C:  MOVLW  01
0816E:  MOVWF  00
08170:  CALL   1D78
08174:  MOVF   01,W
08176:  ANDLW  1F
08178:  MOVLB  9
0817A:  MOVWF  x0D
0817C:  MOVWF  x12
0817E:  MOVLB  0
08180:  CALL   1DE2
08184:  MOVFF  01,271
....................   year = bcd2bin(i2c_read(0));            // REG 6  
*
02138:  CLRF   00
0213A:  RCALL  1D78
0213C:  MOVFF  01,90D
02140:  MOVFF  01,912
02144:  RCALL  1DE2
02146:  MOVFF  01,272
*
075F8:  CLRF   00
075FA:  CALL   1D78
075FE:  MOVFF  01,90D
07602:  MOVFF  01,912
07606:  CALL   1DE2
0760A:  MOVFF  01,272
*
08188:  CLRF   00
0818A:  CALL   1D78
0818E:  MOVFF  01,90D
08192:  MOVFF  01,912
08196:  CALL   1DE2
0819A:  MOVFF  01,272
....................   i2c_stop();  
*
0214A:  BCF    F95.6
0214C:  NOP   
0214E:  BSF    F96.1
02150:  BTFSS  F84.1
02152:  BRA    2150
02154:  MOVLW  0E
02156:  MOVWF  00
02158:  DECFSZ 00,F
0215A:  BRA    2158
0215C:  BRA    215E
0215E:  NOP   
02160:  BSF    F95.6
02162:  MOVLW  0E
02164:  MOVWF  00
02166:  DECFSZ 00,F
02168:  BRA    2166
*
0760E:  BCF    F95.6
07610:  NOP   
07612:  BSF    F96.1
07614:  BTFSS  F84.1
07616:  BRA    7614
07618:  MOVLW  0E
0761A:  MOVWF  00
0761C:  DECFSZ 00,F
0761E:  BRA    761C
07620:  BRA    7622
07622:  NOP   
07624:  BSF    F95.6
07626:  MOVLW  0E
07628:  MOVWF  00
0762A:  DECFSZ 00,F
0762C:  BRA    762A
*
0819E:  BCF    F95.6
081A0:  NOP   
081A2:  BSF    F96.1
081A4:  BTFSS  F84.1
081A6:  BRA    81A4
081A8:  MOVLW  0E
081AA:  MOVWF  00
081AC:  DECFSZ 00,F
081AE:  BRA    81AC
081B0:  BRA    81B2
081B2:  NOP   
081B4:  BSF    F95.6
081B6:  MOVLW  0E
081B8:  MOVWF  00
081BA:  DECFSZ 00,F
081BC:  BRA    81BA
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
0216A:  MOVLW  C0
0216C:  IORWF  FF2,F
*
0762E:  MOVLW  C0
07630:  IORWF  FF2,F
*
081BE:  MOVLW  C0
081C0:  IORWF  FF2,F
.................... #endif 
.................... } 
....................  
.................... void ds1307_get_time(BYTE &hr, BYTE &min, BYTE &sec)  
.................... {  
....................   #ifndef USE_INTERRUPTS 
....................    disable_interrupts(global); 
*
0216E:  BCF    FF2.6
02170:  BCF    FF2.7
02172:  BTFSC  FF2.7
02174:  BRA    2170
*
07632:  BCF    FF2.6
07634:  BCF    FF2.7
07636:  BTFSC  FF2.7
07638:  BRA    7634
*
07FD0:  BCF    FF2.6
07FD2:  BCF    FF2.7
07FD4:  BTFSC  FF2.7
07FD6:  BRA    7FD2
....................   #endif 
....................   i2c_start(); 
*
02176:  BSF    F95.6
02178:  MOVLW  0E
0217A:  MOVWF  00
0217C:  DECFSZ 00,F
0217E:  BRA    217C
02180:  BSF    F96.1
02182:  MOVLW  0E
02184:  MOVWF  00
02186:  DECFSZ 00,F
02188:  BRA    2186
0218A:  BCF    F8C.6
0218C:  BCF    F95.6
0218E:  MOVLW  0E
02190:  MOVWF  00
02192:  DECFSZ 00,F
02194:  BRA    2192
02196:  BCF    F8D.1
02198:  BCF    F96.1
*
0763A:  BSF    F95.6
0763C:  MOVLW  0E
0763E:  MOVWF  00
07640:  DECFSZ 00,F
07642:  BRA    7640
07644:  BSF    F96.1
07646:  MOVLW  0E
07648:  MOVWF  00
0764A:  DECFSZ 00,F
0764C:  BRA    764A
0764E:  BCF    F8C.6
07650:  BCF    F95.6
07652:  MOVLW  0E
07654:  MOVWF  00
07656:  DECFSZ 00,F
07658:  BRA    7656
0765A:  BCF    F8D.1
0765C:  BCF    F96.1
*
07FD8:  BSF    F95.6
07FDA:  MOVLW  0E
07FDC:  MOVWF  00
07FDE:  DECFSZ 00,F
07FE0:  BRA    7FDE
07FE2:  BSF    F96.1
07FE4:  MOVLW  0E
07FE6:  MOVWF  00
07FE8:  DECFSZ 00,F
07FEA:  BRA    7FE8
07FEC:  BCF    F8C.6
07FEE:  BCF    F95.6
07FF0:  MOVLW  0E
07FF2:  MOVWF  00
07FF4:  DECFSZ 00,F
07FF6:  BRA    7FF4
07FF8:  BCF    F8D.1
07FFA:  BCF    F96.1
....................   i2c_write(0xD0);  
*
0219A:  MOVLW  D0
0219C:  MOVLB  9
0219E:  MOVWF  x11
021A0:  MOVLB  0
021A2:  RCALL  1D02
*
0765E:  MOVLW  D0
07660:  MOVLB  9
07662:  MOVWF  x11
07664:  MOVLB  0
07666:  CALL   1D02
*
07FFC:  MOVLW  D0
07FFE:  MOVLB  9
08000:  MOVWF  x11
08002:  MOVLB  0
08004:  CALL   1D02
....................   i2c_write(0x00);            // Start at REG 0 - Seconds  
*
021A4:  MOVLB  9
021A6:  CLRF   x11
021A8:  MOVLB  0
021AA:  RCALL  1D02
*
0766A:  MOVLB  9
0766C:  CLRF   x11
0766E:  MOVLB  0
07670:  CALL   1D02
*
08008:  MOVLB  9
0800A:  CLRF   x11
0800C:  MOVLB  0
0800E:  CALL   1D02
....................   i2c_start();  
*
021AC:  BSF    F95.6
021AE:  MOVLW  0E
021B0:  MOVWF  00
021B2:  DECFSZ 00,F
021B4:  BRA    21B2
021B6:  BSF    F96.1
021B8:  MOVLW  0E
021BA:  MOVWF  00
021BC:  DECFSZ 00,F
021BE:  BRA    21BC
021C0:  BTFSS  F84.1
021C2:  BRA    21C0
021C4:  BCF    F8C.6
021C6:  BCF    F95.6
021C8:  MOVLW  0E
021CA:  MOVWF  00
021CC:  DECFSZ 00,F
021CE:  BRA    21CC
021D0:  BCF    F8D.1
021D2:  BCF    F96.1
*
07674:  BSF    F95.6
07676:  MOVLW  0E
07678:  MOVWF  00
0767A:  DECFSZ 00,F
0767C:  BRA    767A
0767E:  BSF    F96.1
07680:  MOVLW  0E
07682:  MOVWF  00
07684:  DECFSZ 00,F
07686:  BRA    7684
07688:  BTFSS  F84.1
0768A:  BRA    7688
0768C:  BCF    F8C.6
0768E:  BCF    F95.6
07690:  MOVLW  0E
07692:  MOVWF  00
07694:  DECFSZ 00,F
07696:  BRA    7694
07698:  BCF    F8D.1
0769A:  BCF    F96.1
*
08012:  BSF    F95.6
08014:  MOVLW  0E
08016:  MOVWF  00
08018:  DECFSZ 00,F
0801A:  BRA    8018
0801C:  BSF    F96.1
0801E:  MOVLW  0E
08020:  MOVWF  00
08022:  DECFSZ 00,F
08024:  BRA    8022
08026:  BTFSS  F84.1
08028:  BRA    8026
0802A:  BCF    F8C.6
0802C:  BCF    F95.6
0802E:  MOVLW  0E
08030:  MOVWF  00
08032:  DECFSZ 00,F
08034:  BRA    8032
08036:  BCF    F8D.1
08038:  BCF    F96.1
....................   i2c_write(0xD1);  
*
021D4:  MOVLW  D1
021D6:  MOVLB  9
021D8:  MOVWF  x11
021DA:  MOVLB  0
021DC:  RCALL  1D02
*
0769C:  MOVLW  D1
0769E:  MOVLB  9
076A0:  MOVWF  x11
076A2:  MOVLB  0
076A4:  CALL   1D02
*
0803A:  MOVLW  D1
0803C:  MOVLB  9
0803E:  MOVWF  x11
08040:  MOVLB  0
08042:  CALL   1D02
....................   sec = bcd2bin(i2c_read() & 0x7f);  
*
021DE:  MOVLW  01
021E0:  MOVWF  00
021E2:  RCALL  1D78
021E4:  MOVF   01,W
021E6:  ANDLW  7F
021E8:  MOVLB  9
021EA:  MOVWF  x0D
021EC:  MOVWF  x12
021EE:  MOVLB  0
021F0:  RCALL  1DE2
021F2:  MOVFF  01,275
*
076A8:  MOVLW  01
076AA:  MOVWF  00
076AC:  CALL   1D78
076B0:  MOVF   01,W
076B2:  ANDLW  7F
076B4:  MOVLB  9
076B6:  MOVWF  x0D
076B8:  MOVWF  x12
076BA:  MOVLB  0
076BC:  CALL   1DE2
076C0:  MOVFF  01,275
*
08046:  MOVLW  01
08048:  MOVWF  00
0804A:  CALL   1D78
0804E:  MOVF   01,W
08050:  ANDLW  7F
08052:  MOVLB  9
08054:  MOVWF  x0D
08056:  MOVWF  x12
08058:  MOVLB  0
0805A:  CALL   1DE2
0805E:  MOVFF  01,275
....................   min = bcd2bin(i2c_read() & 0x7f);  
*
021F6:  MOVLW  01
021F8:  MOVWF  00
021FA:  RCALL  1D78
021FC:  MOVF   01,W
021FE:  ANDLW  7F
02200:  MOVLB  9
02202:  MOVWF  x0D
02204:  MOVWF  x12
02206:  MOVLB  0
02208:  RCALL  1DE2
0220A:  MOVFF  01,274
*
076C4:  MOVLW  01
076C6:  MOVWF  00
076C8:  CALL   1D78
076CC:  MOVF   01,W
076CE:  ANDLW  7F
076D0:  MOVLB  9
076D2:  MOVWF  x0D
076D4:  MOVWF  x12
076D6:  MOVLB  0
076D8:  CALL   1DE2
076DC:  MOVFF  01,274
*
08062:  MOVLW  01
08064:  MOVWF  00
08066:  CALL   1D78
0806A:  MOVF   01,W
0806C:  ANDLW  7F
0806E:  MOVLB  9
08070:  MOVWF  x0D
08072:  MOVWF  x12
08074:  MOVLB  0
08076:  CALL   1DE2
0807A:  MOVFF  01,274
....................   hr  = bcd2bin(i2c_read(0) & 0x3f);  
*
0220E:  CLRF   00
02210:  RCALL  1D78
02212:  MOVF   01,W
02214:  ANDLW  3F
02216:  MOVLB  9
02218:  MOVWF  x0D
0221A:  MOVWF  x12
0221C:  MOVLB  0
0221E:  RCALL  1DE2
02220:  MOVFF  01,273
*
076E0:  CLRF   00
076E2:  CALL   1D78
076E6:  MOVF   01,W
076E8:  ANDLW  3F
076EA:  MOVLB  9
076EC:  MOVWF  x0D
076EE:  MOVWF  x12
076F0:  MOVLB  0
076F2:  CALL   1DE2
076F6:  MOVFF  01,273
*
0807E:  CLRF   00
08080:  CALL   1D78
08084:  MOVF   01,W
08086:  ANDLW  3F
08088:  MOVLB  9
0808A:  MOVWF  x0D
0808C:  MOVWF  x12
0808E:  MOVLB  0
08090:  CALL   1DE2
08094:  MOVFF  01,273
....................   i2c_stop();  
*
02224:  BCF    F95.6
02226:  NOP   
02228:  BSF    F96.1
0222A:  BTFSS  F84.1
0222C:  BRA    222A
0222E:  MOVLW  0E
02230:  MOVWF  00
02232:  DECFSZ 00,F
02234:  BRA    2232
02236:  BRA    2238
02238:  NOP   
0223A:  BSF    F95.6
0223C:  MOVLW  0E
0223E:  MOVWF  00
02240:  DECFSZ 00,F
02242:  BRA    2240
*
076FA:  BCF    F95.6
076FC:  NOP   
076FE:  BSF    F96.1
07700:  BTFSS  F84.1
07702:  BRA    7700
07704:  MOVLW  0E
07706:  MOVWF  00
07708:  DECFSZ 00,F
0770A:  BRA    7708
0770C:  BRA    770E
0770E:  NOP   
07710:  BSF    F95.6
07712:  MOVLW  0E
07714:  MOVWF  00
07716:  DECFSZ 00,F
07718:  BRA    7716
*
08098:  BCF    F95.6
0809A:  NOP   
0809C:  BSF    F96.1
0809E:  BTFSS  F84.1
080A0:  BRA    809E
080A2:  MOVLW  0E
080A4:  MOVWF  00
080A6:  DECFSZ 00,F
080A8:  BRA    80A6
080AA:  BRA    80AC
080AC:  NOP   
080AE:  BSF    F95.6
080B0:  MOVLW  0E
080B2:  MOVWF  00
080B4:  DECFSZ 00,F
080B6:  BRA    80B4
.................... #ifndef USE_INTERRUPTS 
....................    enable_interrupts(global); 
*
02244:  MOVLW  C0
02246:  IORWF  FF2,F
*
0771A:  MOVLW  C0
0771C:  IORWF  FF2,F
*
080B8:  MOVLW  C0
080BA:  IORWF  FF2,F
.................... #endif 
.................... } 
....................  
.................... BYTE bin2bcd(BYTE binary_value)  
.................... {  
....................  
....................   BYTE temp; 
....................   BYTE retval;  
....................  
....................   temp = binary_value;  
*
0718E:  MOVFF  910,911
....................   retval = 0;  
07192:  MOVLB  9
07194:  CLRF   x12
....................  
....................   while(TRUE)  
....................   {  
....................     // Get the tens digit by doing multiple subtraction  
....................     // of 10 from the binary value.  
....................     if(temp >= 10)  
07196:  MOVF   x11,W
07198:  SUBLW  09
0719A:  BC    71A6
....................     {  
....................       temp -= 10;  
0719C:  MOVLW  0A
0719E:  SUBWF  x11,F
....................       retval += 0x10;  
071A0:  MOVLW  10
071A2:  ADDWF  x12,F
....................     }  
071A4:  BRA    71AC
....................     else // Get the ones digit by adding the remainder.  
....................     {  
....................       retval += temp;  
071A6:  MOVF   x11,W
071A8:  ADDWF  x12,F
....................       break;  
071AA:  BRA    71AE
....................     }  
071AC:  BRA    7196
....................   }  
....................  
....................   return(retval); 
071AE:  MOVFF  912,01
071B2:  MOVLB  0
071B4:  RETURN 0
.................... }  
....................  
.................... // Input range - 00 to 99.  
.................... BYTE bcd2bin(BYTE bcd_value)  
.................... {  
....................   BYTE temp; 
....................  
....................   temp = bcd_value;  
*
01DE2:  MOVFF  912,913
....................   // Shifting upper digit right by 1 is same as multiplying by 8.  
....................   temp >>= 1;  
01DE6:  BCF    FD8.0
01DE8:  MOVLB  9
01DEA:  RRCF   x13,F
....................   // Isolate the bits for the upper digit.  
....................   temp &= 0x78;  
01DEC:  MOVLW  78
01DEE:  ANDWF  x13,F
....................  
....................   // Now return: (Tens * 8) + (Tens * 2) + Ones  
....................  
....................   return(temp + (temp >> 2) + (bcd_value & 0x0f)); 
01DF0:  RRCF   x13,W
01DF2:  MOVWF  00
01DF4:  RRCF   00,F
01DF6:  MOVLW  3F
01DF8:  ANDWF  00,F
01DFA:  MOVF   00,W
01DFC:  ADDWF  x13,W
01DFE:  MOVWF  x14
01E00:  MOVF   x12,W
01E02:  ANDLW  0F
01E04:  ADDWF  x14,W
01E06:  MOVWF  01
01E08:  MOVLB  0
01E0A:  RETURN 0
.................... } 
....................  
.................... // Entradas. 
.................... #define entrada01 PIN_D4// 
.................... #define entrada02 PIN_B0//DATA1  
.................... #define entrada03 PIN_B1//DATA0 
.................... #define entrada04 PIN_D0// 
.................... #define entrada05 PIN_D1//SENSOR BARRERA 
....................  
.................... // Salidas. 
.................... #define salida01 PIN_A5//abre entrada 
.................... #define salida02 PIN_E0//abre entrada 
.................... #define salida03 PIN_D2//abre salida 
.................... #define salida04 PIN_D3//indicador de cupo lleno 
.................... #define salida05 PIN_D7// 
.................... #define salida06 PIN_C2//indicador de conexion 
.................... // Macros de entrada: 
.................... char texto1[12]= "BOLETO_FOL";// 
.................... char texto2[12]= "BORRARTODO";// 
.................... char texto3[12]= "BORRAR_TAG";// 
.................... char texto4[12]= "ABRIR_ENTR";// 
.................... char texto5[12]= "CUPO_LLENO";//CANCELA BOLETOS 
.................... char texto6[12]= "CUPO_DISPO";//ACTIVA BOLETOS 
.................... char texto7[12]= "MENSAJEEN1";// 
.................... char texto8[12]= "          ";// 
.................... char texto9[12]= "CONSULTA01";// 
.................... char texto10[12]="CONFIGDATE";// 
.................... char texto11[12]="CONFIGURAB";// 
.................... char texto12[12]="BORRA_CON1";// 
.................... char texto13[12]="FOLIORESET";//REINICIAR FOLIOS 
.................... char texto14[12]="PAGADO0000";// 
.................... char boleto[]= "BOLETO"; // 
.................... char barrera[] ="BARRERAABIERTAE1"; 
.................... int fmensaje; 
.................... int16 time_lcd; 
.................... //int en5,flag_pluma; 
....................  
....................  
.................... int flag_time; 
.................... int16 time_bot; 
....................  
.................... // Define el stack usado: ENC28J60. 
.................... #define STACK_USE_CCS_PICENS   1 
.................... // Utilizamos el stack para el protocolo ICPM. 
.................... #define STACK_USE_ICMP  1 
.................... // Utilizamos el stack para el protocolo ARP. 
.................... #define STACK_USE_ARP 1 
.................... // Utilizamos el stack para el protocolo TCP. 
.................... #define STACK_USE_TCP 1 
.................... #if STACK_USE_CCS_PICENS 
....................  #define STACK_USE_MCPENC 1 
.................... #endif 
....................  
.................... // Definimos los pines utilizados. 
.................... #define  PIN_ENC_MAC_SO    PIN_C4 
.................... #define  PIN_ENC_MAC_SI    PIN_C5 
.................... #define  PIN_ENC_MAC_CLK   PIN_C3 
....................  
.................... #define  PIN_ENC_MAC_CS    PIN_C1 
.................... #define  PIN_ENC_MAC_RST   PIN_C0 
.................... #define  PIN_ENC_MAC_INT   PIN_D2 
.................... #define  PIN_ENC_MAC_WOL   PIN_D3 
....................  
.................... // Incluimos las definiciones necesarias para utilizar el stack TCP/IP. 
.................... #include "tcpip/stacktsk.c"  
.................... /********************************************************************* 
....................  * 
....................  *               Microchip TCP/IP Stack FSM Implementation on PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.c 
....................  * Dependencies:    StackTsk.H 
....................  *                  ARPTsk.h 
....................  *                  MAC.h 
....................  *                  IP.h 
....................  *                  ICMP.h 
....................  *                  Tcp.h 
....................  *                  http.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/14/01  Original (Rev. 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Nilesh Rajbharti     12/5/02     Modified UDPProcess() and TCPProcess() 
....................  *                                  to include localIP as third param. 
....................  *                                  This was done to allow these functions 
....................  *                                  to calculate checksum correctly. 
....................  * Nilesh Rajbharti     7/26/04     Added code in StackTask() to not 
....................  *                                  clear statically IP address if link is 
....................  *                                  removed and DHCP module is disabled 
....................  *                                  at runtime. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A break; added to StackTask() after handling an ARP, else it would goto IP handler. 
....................  * Darren Rook (CCS)    06/28/04 Added 2.20 improvement that resets DHCP after unlink of ethernet 
....................  * Darren Rook (CCS)    06/29/04 A fix for 2.20 improvement (see above) if DHCP was dynamically disabled 
....................  * Darren Rook (CCS)    06/29/04 smStack no longer static 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    04/08/05 Task() and Init() execute any needed HTTP code 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #define STACK_USE_FTP_SERVER STACK_USE_FTP 
....................  
.................... #define STACK_INCLUDE 
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC18 SFR Definitions 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        pic18.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or later 
....................  * 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     11/14/01 Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  ********************************************************************/ 
.................... #ifndef COMPILER_H 
.................... #define COMPILER_H 
....................  
.................... #if !defined(__PCH__) 
.................... #error "This version only works with CCS PCH or PCWH" 
.................... #endif 
....................  
.................... // ** I/O PORT REGISTERS 
....................  
.................... #byte PORTA    =  0xF80 
.................... #byte PORTB    =  0xF81 
.................... #byte PORTC    =  0xF82 
.................... #byte PORTD    =  0xF83 
.................... #byte PORTE    =  0xF84 
.................... #byte PORTF    =  0xF85 
....................  
.................... #bit PORTA_RA5 =  0xF80.5 
.................... #bit PORTA_RA4 =  0xF80.4 
.................... #bit PORTA_RA3 =  0xF80.3 
.................... #bit PORTA_RA2 =  0xF80.2 
.................... #bit PORTA_RA1 =  0xF80.1 
.................... #bit PORTA_RA0 =  0xF80.0 
....................  
.................... #bit PORTB_RB7 =  0xF81.7 
.................... #bit PORTB_RB6 =  0xF81.6 
.................... #bit PORTB_RB5 =  0xF81.5 
.................... #bit PORTB_RB4 =  0xF81.4 
.................... #bit PORTB_RB3 =  0xF81.3 
.................... #bit PORTB_RB2 =  0xF81.2 
.................... #bit PORTB_RB1 =  0xF81.1 
.................... #bit PORTB_RB0 =  0xF81.0 
....................  
.................... #bit PORTC_RC7 =  0xF82.7 
.................... #bit PORTC_RC6 =  0xF82.6 
.................... #bit PORTC_RC5 =  0xF82.5 
.................... #bit PORTC_RC4 =  0xF82.4 
.................... #bit PORTC_RC3 =  0xF82.3 
.................... #bit PORTC_RC2 =  0xF82.2 
.................... #bit PORTC_RC1 =  0xF82.1 
.................... #bit PORTC_RC0 =  0xF82.0 
....................  
.................... #bit PORTD_RD7 =  0xF83.7 
.................... #bit PORTD_RD6 =  0xF83.6 
.................... #bit PORTD_RD5 =  0xF83.5 
.................... #bit PORTD_RD4 =  0xF83.4 
.................... #bit PORTD_RD3 =  0xF83.3 
.................... #bit PORTD_RD2 =  0xF83.2 
.................... #bit PORTD_RD1 =  0xF83.1 
.................... #bit PORTD_RD0 =  0xF83.0 
....................  
.................... #bit PORTE_RE7 =  0xF84.7 
.................... #bit PORTE_RE6 =  0xF84.6 
.................... #bit PORTE_RE5 =  0xF84.5 
.................... #bit PORTE_RE4 =  0xF84.4 
.................... #bit PORTE_RE3 =  0xF84.3 
.................... #bit PORTE_RE2 =  0xF84.2 
.................... #bit PORTE_RE1 =  0xF84.1 
.................... #bit PORTE_RE0 =  0xF84.0 
....................  
.................... #bit PORTF_RF7 =  0xF85.7 
.................... #bit PORTF_RF6 =  0xF85.6 
.................... #bit PORTF_RF5 =  0xF85.5 
.................... #bit PORTF_RF4 =  0xF85.4 
.................... #bit PORTF_RF3 =  0xF85.3 
.................... #bit PORTF_RF2 =  0xF85.2 
.................... #bit PORTF_RF1 =  0xF85.1 
.................... #bit PORTF_RF0 =  0xF85.0 
....................  
....................  
.................... // *** TRIS REGISTERS 
....................  
.................... #byte TRISA    =  0xF92 
.................... #byte TRISB    =  0xF93 
.................... #byte TRISC    =  0xF94 
.................... #byte TRISD    =  0xF95 
.................... #byte TRISE    =  0xF96 
.................... #byte TRISF    =  0xF97 
....................  
.................... #bit TRISA_RA7 =  0xF92.7 
.................... #bit TRISA_RA6 =  0xF92.6 
.................... #bit TRISA_RA5 =  0xF92.5 
.................... #bit TRISA_RA4 =  0xF92.4 
.................... #bit TRISA_RA3 =  0xF92.3 
.................... #bit TRISA_RA2 =  0xF92.2 
.................... #bit TRISA_RA1 =  0xF92.1 
.................... #bit TRISA_RA0 =  0xF92.0 
....................  
.................... #bit TRISB_RB7 =  0xF93.7 
.................... #bit TRISB_RB6 =  0xF93.6 
.................... #bit TRISB_RB5 =  0xF93.5 
.................... #bit TRISB_RB4 =  0xF93.4 
.................... #bit TRISB_RB3 =  0xF93.3 
.................... #bit TRISB_RB2 =  0xF93.2 
.................... #bit TRISB_RB1 =  0xF93.1 
.................... #bit TRISB_RB0 =  0xF93.0 
....................  
.................... #bit TRISC_RC7 =  0xF94.7 
.................... #bit TRISC_RC6 =  0xF94.6 
.................... #bit TRISC_RC5 =  0xF94.5 
.................... #bit TRISC_RC4 =  0xF94.4 
.................... #bit TRISC_RC3 =  0xF94.3 
.................... #bit TRISC_RC2 =  0xF94.2 
.................... #bit TRISC_RC1 =  0xF94.1 
.................... #bit TRISC_RC0 =  0xF94.0 
....................  
.................... #bit TRISD_RD7 =  0xF95.7 
.................... #bit TRISD_RD6 =  0xF95.6 
.................... #bit TRISD_RD5 =  0xF95.5 
.................... #bit TRISD_RD4 =  0xF95.4 
.................... #bit TRISD_RD3 =  0xF95.3 
.................... #bit TRISD_RD2 =  0xF95.2 
.................... #bit TRISD_RD1 =  0xF95.1 
.................... #bit TRISD_RD0 =  0xF95.0 
....................  
.................... #bit TRISE_RE7 =  0xF96.7 
.................... #bit TRISE_RE6 =  0xF96.6 
.................... #bit TRISE_RE5 =  0xF96.5 
.................... #bit TRISE_RE4 =  0xF96.4 
.................... #bit TRISE_RE3 =  0xF96.3 
.................... #bit TRISE_RE2 =  0xF96.2 
.................... #bit TRISE_RE1 =  0xF96.1 
.................... #bit TRISE_RE0 =  0xF96.0 
....................  
.................... #bit TRISF_RF7 =  0xF97.7 
.................... #bit TRISF_RF6 =  0xF97.6 
.................... #bit TRISF_RF5 =  0xF97.5 
.................... #bit TRISF_RF4 =  0xF97.4 
.................... #bit TRISF_RF3 =  0xF97.3 
.................... #bit TRISF_RF2 =  0xF97.2 
.................... #bit TRISF_RF1 =  0xF97.1 
.................... #bit TRISF_RF0 =  0xF97.0 
....................  
....................  
.................... // *** LAT REGISTERS 
.................... #byte LATA    =  0xF89 
.................... #byte LATB    =  0xF8A 
.................... #byte LATC    =  0xF8B 
.................... #byte LATD    =  0xF8C 
.................... #byte LATE    =  0xF8D 
.................... #byte LATF    =  0xF8E 
....................  
.................... #bit LATA_RA7 =  0xF89.7 
.................... #bit LATA_RA6 =  0xF89.6 
.................... #bit LATA_RA5 =  0xF89.5 
.................... #bit LATA_RA4 =  0xF89.4 
.................... #bit LATA_RA3 =  0xF89.3 
.................... #bit LATA_RA2 =  0xF89.2 
.................... #bit LATA_RA1 =  0xF89.1 
.................... #bit LATA_RA0 =  0xF89.0 
....................  
.................... #bit LATB_RB7 =  0xF8A.7 
.................... #bit LATB_RB6 =  0xF8A.6 
.................... #bit LATB_RB5 =  0xF8A.5 
.................... #bit LATB_RB4 =  0xF8A.4 
.................... #bit LATB_RB3 =  0xF8A.3 
.................... #bit LATB_RB2 =  0xF8A.2 
.................... #bit LATB_RB1 =  0xF8A.1 
.................... #bit LATB_RB0 =  0xF8A.0 
....................  
.................... #bit LATC_RC7 =  0xF8B.7 
.................... #bit LATC_RC6 =  0xF8B.6 
.................... #bit LATC_RC5 =  0xF8B.5 
.................... #bit LATC_RC4 =  0xF8B.4 
.................... #bit LATC_RC3 =  0xF8B.3 
.................... #bit LATC_RC2 =  0xF8B.2 
.................... #bit LATC_RC1 =  0xF8B.1 
.................... #bit LATC_RC0 =  0xF8B.0 
....................  
.................... #bit LATD_RD7 =  0xF8C.7 
.................... #bit LATD_RD6 =  0xF8C.6 
.................... #bit LATD_RD5 =  0xF8C.5 
.................... #bit LATD_RD4 =  0xF8C.4 
.................... #bit LATD_RD3 =  0xF8C.3 
.................... #bit LATD_RD2 =  0xF8C.2 
.................... #bit LATD_RD1 =  0xF8C.1 
.................... #bit LATD_RD0 =  0xF8C.0 
....................  
.................... #bit LATE_RE7 =  0xF8D.7 
.................... #bit LATE_RE6 =  0xF8D.6 
.................... #bit LATE_RE5 =  0xF8D.5 
.................... #bit LATE_RE4 =  0xF8D.4 
.................... #bit LATE_RE3 =  0xF8D.3 
.................... #bit LATE_RE2 =  0xF8D.2 
.................... #bit LATE_RE1 =  0xF8D.1 
.................... #bit LATE_RE0 =  0xF8D.0 
....................  
.................... #bit LATF_RF7 =  0xF8E.7 
.................... #bit LATF_RF6 =  0xF8E.6 
.................... #bit LATF_RF5 =  0xF8E.5 
.................... #bit LATF_RF4 =  0xF8E.4 
.................... #bit LATF_RF3 =  0xF8E.3 
.................... #bit LATF_RF2 =  0xF8E.2 
.................... #bit LATF_RF1 =  0xF8E.1 
.................... #bit LATF_RF0 =  0xF8E.0 
....................  
....................  
.................... // ** OTHER SPECIAL FILE REGISTERS USED BY SLIP 
....................  
.................... #bit  PIE1_TXIE       =  0xF9D.4 
.................... #bit  PIE1_RCIE       =  0xF9D.5 
.................... #bit  PIR1_TXIF       =  0xF9E.4 
.................... #bit  PIR1_RCIF       =  0xF9E.5 
.................... #byte TXSTA           =  0xFAC 
.................... #byte RCSTA           =  0xFAB 
.................... #bit  RCSTA_CREN      =  0xFAB.4 
.................... #byte RCREG           =  0xFAE 
.................... #byte SPBRG           =  0xFAF 
.................... #byte TXREG           =  0xFAD 
....................  
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                         HARDWARE.H                                //// 
.................... ////                                                                   //// 
.................... //// Hardware I/O definitions and TCP/IP stack configuration settings. //// 
.................... ////                                                                   //// 
.................... //// These values will probably change with each application.          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// RELEASE HISTORY:                                                  //// 
.................... ////                                                                   //// 
.................... ////    Jan 15, 2004: MODEM_RESPONSE_TIMEOUT and MODEM_CONNECT_TIMEOUT //// 
.................... ////                  moved to here.                                   //// 
.................... ////                                                                   //// 
.................... ////    Jan 09, 2004: Initial Public Release                           //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF ___TCPIP_STACK_CONFIGURATION 
.................... #define ___TCPIP_STACK_CONFIGURATION 
....................  
....................  
.................... #ifndef STACK_USE_CCS_PICNET 
.................... #define STACK_USE_CCS_PICNET  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_CCS_PICENS 
.................... #define STACK_USE_CCS_PICENS  FALSE 
.................... #endif 
....................  
.................... /* 
.................... #use fast_io(A) 
.................... #use fast_io(B) 
.................... #use fast_io(C) 
.................... #if STACK_USE_CCS_PICNET || STACK_USE_CCS_PICEEC || STACK_USE_CCS_EWL3V 
....................  #use fast_io(F) 
.................... #endif 
....................  
....................  
.................... //// VARIOUS MODEM SETTINGS. 
....................    #DEFINE  MODEM_DCD         PIN_G3 
....................    #DEFINE  MODEM_RESET       PIN_G4 
....................    #define  MODEM_TX          PIN_G1 
....................    #define  MODEM_RX          PIN_G2 
....................    #DEFINE  MODEM_INIT_STR    "ATM1L3&K0"   //speaker on, volume high, no hw flow control 
....................    #DEFINE  MODEM_DIAL_STR    "ATDT" 
....................    #DEFINE  MODEM_BAUD_RATE   115200 
....................  
....................    #DEFINE  MODEM_RESPONSE_TIMEOUT  2000     //time to wait for a response to an AT command (in ms) 
....................    #DEFINE  MODEM_CONNECT_TIMEOUT   120000    //time to wait for modem to make a connection (in ms) 
....................  
....................  
.................... //// VARIOUS MAC/NIC SETTINGS. 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_C0 
....................       #define PIN_ENC_MAC_RST PIN_C1 
....................       #define PIN_ENC_MAC_INT PIN_C6 
....................       #define PIN_ENC_MAC_WOL PIN_C7 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()//  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................       
....................    #if STACK_USE_CCS_PICNET 
....................       //Latch and Directional control SFR locations for the 3 control pins 
....................       #define NIC_RESET_LAT       LATE_RE7 
....................       #define NIC_IOW_LAT         LATE_RE6 
....................       #define NIC_IOR_LAT         LATE_RE5 
....................       #define NIC_RESET_TRIS      TRISE_RE7 
....................       #define NIC_IOW_TRIS        TRISE_RE6 
....................       #define NIC_IOR_TRIS        TRISE_RE5 
....................  
....................       //Latch and Directional control SFR locations for the 5bit address port 
....................       #define NIC_ADDR_LAT        LATE 
....................       #define NIC_ADDR_TRIS       TRISE 
....................  
....................       //Latch, Directional and I/O SFR locations for the 8bit data port 
....................       #define NIC_DATA_IO         PORTF 
....................       #define NIC_DATA_LAT        LATF 
....................       #define NIC_DATA_TRIS       TRISF 
....................  
....................       //This macro takes an address and properly outputs it on the latch register, and sets proper pins to output. 
....................       //Leaves other pins alone. 
....................       #define WRITE_NIC_ADDR(a)   NIC_ADDR_LAT = (NIC_ADDR_LAT & 0xE0)|a; \ 
....................                                 NIC_ADDR_TRIS = NIC_ADDR_TRIS & 0xE0 
....................    #elif STACK_USE_MCPENC 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b11); TRISC = (TRISC & 0b11010111) | 0x10; TRISD=TRISD & 0xF4//was 0xFC 
....................    #elif STACK_USE_CCS_EWL5V 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_A4 
....................       #define PIN_ENC_MAC_RST PIN_B5 
....................       #define PIN_ENC_MAC_INT PIN_B2 
....................       #define PIN_ENC_MAC_WOL PIN_B3 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  TRISB=(TRISB | 0b00001100)&0b11011111; TRISC = (TRISC & 0b11010111) | 0x10; TRISA=TRISA & 0b11101111 
....................    #else 
....................       #error Please define your MAC/NIC I/O settings 
....................    #endif 
.................... */ 
....................  
....................  
.................... //// SET TCP_NO_WAIT_FOR_ACK TO FALSE IF TCP STACK SHOULD WAIT FOR ACK FROM 
.................... //// REMOTE HOST BEFORE TRANSMITTING ANOTHER PACKET.  THIS MAY REDUCE THROUGHPUT. 
.................... //// DEFAULT VALUE (TRUE) GETS LOADED IN TCP.H IF THIS LINE IS REMOVED. 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
....................  
....................  
.................... ///DEFAULT HARDCODED IP ADDRESSES. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THESE TO AN EEPROM. 
.................... ///  OR USE AUTO IP ASSIGNMENT (DHCP). 
.................... ///  NO TWO DEVICES ON A NETwORK CAN HAVE THE SAME IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE1        10   //IP ADDRESS 
....................    #define MY_DEFAULT_IP_ADDR_BYTE2        10   // This unit's IP address. 
....................    #define MY_DEFAULT_IP_ADDR_BYTE3        5 
....................    #define MY_DEFAULT_IP_ADDR_BYTE4        15 
....................  
....................    #define MY_DEFAULT_MASK_BYTE1           0xff //NETMASK 
....................    #define MY_DEFAULT_MASK_BYTE2           0xff // Netmask tells the IP / ARP stack which 
....................    #define MY_DEFAULT_MASK_BYTE3           0xff // IP's are on your local network. 
....................    #define MY_DEFAULT_MASK_BYTE4           0x00 
....................  
....................    #define MY_DEFAULT_GATE_BYTE1           192  //GATEWAY IP ADDRESS 
....................    #define MY_DEFAULT_GATE_BYTE2           168  // Gateway acts as a conduit between two networks. 
....................    #define MY_DEFAULT_GATE_BYTE3           100 
....................    #define MY_DEFAULT_GATE_BYTE4           1 
....................  
.................... ///DEFAULT HARDCODED MAC ADDRESS. 
.................... ///  FUTURE APPLICATIONS MAY WANT TO SAVE THIS TO AN EEPROM, OR GENERATE 
.................... ///  A DYNAMIC ONE BASED UPON UNIT'S SERIAL NUMBER. 
.................... ///  NO TWO DEVICES ON THE SAME ETHERNET NETWORK CAN HAVE THE SAME MAC ADDRESS. 
.................... #define MY_DEFAULT_MAC_BYTE1            0x00 
.................... #define MY_DEFAULT_MAC_BYTE2            0x04 
.................... #define MY_DEFAULT_MAC_BYTE3            0xa3 
.................... #define MY_DEFAULT_MAC_BYTE4            0x00 
.................... #define MY_DEFAULT_MAC_BYTE5            0x00 
.................... #define MY_DEFAULT_MAC_BYTE6            0x00 
....................  
.................... ///Maximum sockets to be defined. 
.................... /// Note that each socket consumes 36 bytes of RAM. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_SOCKETS 
....................    #define MAX_SOCKETS                     35 
....................    #endif 
....................  
.................... ///Avaialble UDP Socket 
.................... /// DCHP takes 1 socket. 
.................... /// If you remove this, a default value will be loaded in stacktsk.h 
....................    #ifndef MAX_UDP_SOCKETS 
....................    #define MAX_UDP_SOCKETS                 2 
....................    #endif 
....................  
.................... ///BUFFER SIZE DEFINITIONS 
.................... /// 
.................... /// For SLIP, there can only be one transmit and one receive buffer. 
.................... /// Both buffer must fit in one bank.  If bigger buffer is required, 
.................... /// you must manually locate tx and rx buffer in different bank 
.................... /// or modify your linker script file to support arrays bigger than 
.................... /// 256 bytes. 
.................... /// I think Microchip needs MAC_RX_BUFFER_SIZE to equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For PPP, there can only be one transmit and one receive buffer. 
.................... /// You can receive messages larger than the receive buffer if your 
.................... /// routines are fast enough.  You cannot transmit messages larger 
.................... /// than the TX buffer.  The larger the buffer you can make, the better. 
.................... /// BUG: MAC_RX_BUFFER_SIZE must equal MAC_TX_BUFFER_SIZE 
.................... /// 
.................... /// For Ethernet, the Ethernet controler has many buffers that are 
.................... /// 1k in size.   Only one buffer is used for TX, rest are for RX. 
.................... /// Unlike SLIP and PPP, no RAM is used for these buffers. 
....................    #if STACK_USE_MAC 
....................        #define MAC_TX_BUFFER_SIZE          1024 //do not modify this line 
....................        #define MAC_TX_BUFFER_COUNT         1    //do not modify this line 
....................    #elif STACK_USE_PPP 
....................        #define MAC_TX_BUFFER_SIZE          1024 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #elif STACK_USE_SLIP 
....................        #define MAC_TX_BUFFER_SIZE          250 
....................        #define MAC_TX_BUFFER_COUNT         1 
....................    #endif 
....................  
....................    #define MAC_RX_BUFFER_SIZE              MAC_TX_BUFFER_SIZE  //do not modify this line unless you are certain you know what you're doing 
....................  
.................... #endif 
....................  
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
*
01E36:  MOVFF  90F,911
01E3A:  MOVFF  90E,910
01E3E:  MOVFF  911,03
01E42:  MOVLB  9
01E44:  MOVFF  910,FE9
01E48:  MOVFF  911,FEA
01E4C:  MOVF   FEF,F
01E4E:  BZ    1E5C
01E50:  INCF   x10,F
01E52:  BTFSC  FD8.2
01E54:  INCF   x11,F
01E56:  MOVLB  0
01E58:  BRA    1E3E
01E5A:  MOVLB  9
....................    return(sc - s); 
01E5C:  MOVF   x0E,W
01E5E:  SUBWF  x10,W
01E60:  MOVWF  00
01E62:  MOVF   x0F,W
01E64:  SUBWFB x11,W
01E66:  MOVWF  03
01E68:  MOVFF  00,01
01E6C:  MOVLB  0
01E6E:  RETURN 0
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
*
01B18:  MOVFF  389,8FF
01B1C:  MOVFF  388,8FE
01B20:  MOVFF  387,8FD
01B24:  MOVFF  386,8FC
01B28:  MOVLW  41
01B2A:  MOVLB  9
01B2C:  MOVWF  x03
01B2E:  MOVLW  C6
01B30:  MOVWF  x02
01B32:  MOVLW  4E
01B34:  MOVWF  x01
01B36:  MOVLW  6D
01B38:  MOVWF  x00
01B3A:  MOVLB  0
01B3C:  BRA    1A76
01B3E:  MOVLW  39
01B40:  MOVLB  8
01B42:  ADDWF  00,W
01B44:  MOVLB  3
01B46:  MOVWF  x86
01B48:  MOVLW  30
01B4A:  MOVLB  8
01B4C:  ADDWFC 01,W
01B4E:  MOVLB  3
01B50:  MOVWF  x87
01B52:  MOVLW  00
01B54:  MOVLB  8
01B56:  ADDWFC 02,W
01B58:  MOVLB  3
01B5A:  MOVWF  x88
01B5C:  MOVLW  00
01B5E:  MOVLB  8
01B60:  ADDWFC 03,W
01B62:  MOVLB  3
01B64:  MOVWF  x89
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
01B66:  MOVFF  388,00
01B6A:  MOVFF  389,01
01B6E:  CLRF   02
01B70:  CLRF   03
01B72:  MOVFF  389,8FE
01B76:  MOVFF  388,8FD
01B7A:  MOVFF  389,90C
01B7E:  MOVFF  388,90B
01B82:  MOVLW  7F
01B84:  MOVLB  9
01B86:  MOVWF  x0E
01B88:  SETF   x0D
01B8A:  MOVLB  0
01B8C:  RCALL  1AD2
01B8E:  MOVFF  00,01
01B92:  MOVFF  03,02
01B96:  GOTO   1CB8 (RETURN)
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
*
01A62:  MOVFF  8FF,389
01A66:  MOVFF  8FE,388
01A6A:  MOVFF  8FD,387
01A6E:  MOVFF  8FC,386
01A72:  GOTO   1CB6 (RETURN)
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Functions for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.C 
....................  * Dependencies:    compiler.h 
....................  *                  helpers.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     6/25/02  Rewritten CalcIPChecksum() to avoid 
....................  *                               multi-byte shift operation. 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Howard Schlunder      2/9/05   Added hexatob(), btohexa_high(), and 
....................  *                        btohexa_low() 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        BYTE hexatob(WORD_VAL AsciiChars) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           Two ascii bytes; each ranged '0'-'9', 'A'-'F', or 
.................... *                  'a'-'f' 
.................... * 
.................... * Output:          The resulting packed byte: 0x00-0xFF 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:         None 
.................... ********************************************************************/ 
.................... BYTE hexatob(WORD_VAL AsciiChars) 
.................... { 
....................    // Convert lowercase to uppercase 
....................    if(AsciiChars.v[1] > 'F') 
....................       AsciiChars.v[1] -= 'a'-'A'; 
....................    if(AsciiChars.v[0] > 'F') 
....................       AsciiChars.v[0] -= 'a'-'A'; 
....................  
....................    // Convert 0-9, A-F to 0x0-0xF 
....................    if(AsciiChars.v[1] > '9') 
....................       AsciiChars.v[1] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[1] -= '0'; 
....................  
....................    if(AsciiChars.v[0] > '9') 
....................       AsciiChars.v[0] -= 'A' - 10; 
....................    else 
....................       AsciiChars.v[0] -= '0'; 
....................  
....................    // Concatenate 
....................    return (AsciiChars.v[1]<<4) |  AsciiChars.v[0]; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_high(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the upper 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_high() returns 'A' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_high(BYTE b) 
.................... { 
....................    b >>= 4; 
....................    return (b>0x9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        BYTE btohexa_low(BYTE b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           One byte ranged 0x00-0xFF 
....................  * 
....................  * Output:          An ascii byte (always uppercase) between '0'-'9' 
....................  *               or 'A'-'F' that corresponds to the lower 4 bits of 
....................  *               the input byte. 
....................  *               ex: b = 0xAE, btohexa_low() returns 'E' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:         None 
....................  ********************************************************************/ 
.................... BYTE btohexa_low(BYTE b) 
.................... { 
....................    b &= 0x0F; 
....................    return (b>9) ? b+'A'-10:b+'0'; 
.................... } 
....................  
.................... WORD swaps(WORD_VAL v) 
.................... { 
....................     WORD_VAL new; 
....................  
....................     new.v[0]=v.v[1]; 
*
02CE0:  MOVFF  9A6,9A7
....................     new.v[1]=v.v[0]; 
02CE4:  MOVFF  9A5,9A8
....................  
....................     return(new.Val); 
02CE8:  MOVLB  9
02CEA:  MOVFF  9A7,01
02CEE:  MOVFF  9A8,02
02CF2:  MOVLB  0
02CF4:  RETURN 0
.................... } 
....................  
.................... DWORD swapl(DWORD_VAL v) 
.................... { 
....................     DWORD_VAL new; 
....................  
....................     new.v[0]=v.v[3]; 
*
03C6C:  MOVFF  991,992
....................     new.v[1]=v.v[2]; 
03C70:  MOVFF  990,993
....................     new.v[2]=v.v[1]; 
03C74:  MOVFF  98F,994
....................     new.v[3]=v.v[0]; 
03C78:  MOVFF  98E,995
....................  
....................     return(new.Val); 
03C7C:  MOVFF  992,00
03C80:  MOVFF  993,01
03C84:  MOVFF  994,02
03C88:  MOVFF  995,03
03C8C:  RETURN 0
.................... } 
....................  
.................... WORD CalcIPChecksum(BYTE* buffer, WORD count) 
.................... { 
....................    WORD i; 
....................    WORD *val; 
....................  
....................    union 
....................    { 
....................       DWORD Val; 
....................       struct 
....................       { 
....................          WORD_VAL LSB; 
....................          WORD_VAL MSB; 
....................       } words; 
....................    } tempSum, sum; 
....................  
....................    sum.Val = 0; 
*
039D6:  MOVLB  9
039D8:  CLRF   x97
039DA:  CLRF   x96
039DC:  CLRF   x95
039DE:  CLRF   x94
....................  
....................    i = count >> 1; 
039E0:  BCF    FD8.0
039E2:  RRCF   x8B,W
039E4:  MOVWF  x8D
039E6:  RRCF   x8A,W
039E8:  MOVWF  x8C
....................    val = (WORD *)buffer; 
039EA:  MOVFF  989,98F
039EE:  MOVFF  988,98E
....................  
....................    while( i-- ) 
039F2:  MOVFF  98D,03
039F6:  MOVF   x8C,W
039F8:  BTFSC  FD8.2
039FA:  DECF   x8D,F
039FC:  DECF   x8C,F
039FE:  IORWF  03,W
03A00:  BZ    3A30
....................       sum.Val += *val++; 
03A02:  MOVFF  98F,03
03A06:  MOVFF  98E,00
03A0A:  MOVLW  02
03A0C:  ADDWF  x8E,F
03A0E:  BTFSC  FD8.0
03A10:  INCF   x8F,F
03A12:  MOVFF  00,FE9
03A16:  MOVFF  03,FEA
03A1A:  MOVFF  FEC,03
03A1E:  MOVF   FED,F
03A20:  MOVF   FEF,W
03A22:  ADDWF  x94,F
03A24:  MOVF   03,W
03A26:  ADDWFC x95,F
03A28:  MOVLW  00
03A2A:  ADDWFC x96,F
03A2C:  ADDWFC x97,F
03A2E:  BRA    39F2
....................  
....................    if ( count & 1 ) 
03A30:  MOVF   x8A,W
03A32:  ANDLW  01
03A34:  MOVWF  00
03A36:  CLRF   03
03A38:  MOVF   00,W
03A3A:  IORWF  03,W
03A3C:  BZ    3A52
....................       sum.Val += *(BYTE *)val; 
03A3E:  MOVFF  98E,FE9
03A42:  MOVFF  98F,FEA
03A46:  MOVF   FEF,W
03A48:  ADDWF  x94,F
03A4A:  MOVLW  00
03A4C:  ADDWFC x95,F
03A4E:  ADDWFC x96,F
03A50:  ADDWFC x97,F
....................  
....................    tempSum.Val = sum.Val; 
03A52:  MOVFF  997,993
03A56:  MOVFF  996,992
03A5A:  MOVFF  995,991
03A5E:  MOVFF  994,990
....................    i = tempSum.words.MSB.Val; 
03A62:  MOVFF  993,98D
03A66:  MOVFF  992,98C
....................  
....................    while( i != 0u ) 
03A6A:  MOVF   x8C,F
03A6C:  BNZ   3A72
03A6E:  MOVF   x8D,F
03A70:  BZ    3AB8
....................    { 
....................       sum.words.MSB.Val = 0; 
03A72:  CLRF   x97
03A74:  CLRF   x96
....................       sum.Val = (DWORD)sum.words.LSB.Val + (DWORD)i; 
03A76:  CLRF   x9B
03A78:  CLRF   x9A
03A7A:  MOVFF  995,999
03A7E:  MOVFF  994,998
03A82:  CLRF   02
03A84:  CLRF   03
03A86:  MOVF   x8C,W
03A88:  ADDWF  x94,W
03A8A:  MOVWF  x94
03A8C:  MOVF   x8D,W
03A8E:  ADDWFC x95,W
03A90:  MOVWF  x95
03A92:  MOVF   02,W
03A94:  ADDWFC x9A,W
03A96:  MOVWF  x96
03A98:  MOVF   03,W
03A9A:  ADDWFC x9B,W
03A9C:  MOVWF  x97
....................       tempSum.Val = sum.Val; 
03A9E:  MOVFF  997,993
03AA2:  MOVFF  996,992
03AA6:  MOVFF  995,991
03AAA:  MOVFF  994,990
....................       i = tempSum.words.MSB.Val; 
03AAE:  MOVFF  993,98D
03AB2:  MOVFF  992,98C
03AB6:  BRA    3A6A
....................    } 
....................  
....................    return (~sum.words.LSB.Val); 
03AB8:  MOVFF  995,03
03ABC:  COMF   03,F
03ABE:  MOVF   x94,W
03AC0:  XORLW  FF
03AC2:  MOVWF  01
03AC4:  MOVFF  03,02
03AC8:  MOVLB  0
03ACA:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  MAC buffer pointer set to starting of buffer 
....................  * 
....................  * Input:           len     - Total number of bytes to calculate 
....................  *                          checksum for. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs checksum calculation in 
....................  *                  MAC buffer itself. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #if !defined(MCHP_MAC) 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................     BOOL lbMSB; 
....................     WORD_VAL checkSum; 
....................     BYTE Checkbyte; 
....................  
....................     lbMSB = TRUE; 
....................     checkSum.Val = 0; 
....................  
....................     while( len-- ) 
....................     { 
....................         Checkbyte = MACGet(); 
....................  
....................         if ( !lbMSB ) 
....................         { 
....................             if ( (checkSum.v[0] = Checkbyte+checkSum.v[0]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[1] == 0 ) 
....................                     checkSum.v[0]++; 
....................             } 
....................         } 
....................         else 
....................         { 
....................             if ( (checkSum.v[1] = Checkbyte+checkSum.v[1]) < Checkbyte) 
....................             { 
....................                 if ( ++checkSum.v[0] == 0 ) 
....................                     checkSum.v[1]++; 
....................             } 
....................         } 
....................  
....................         lbMSB = !lbMSB; 
....................     } 
....................  
....................     checkSum.v[1] = ~checkSum.v[1]; 
....................     checkSum.v[0] = ~checkSum.v[0]; 
....................     return checkSum.Val; 
.................... } 
.................... #endif 
....................  
.................... /* 
.................... char *strupr (char *s) 
.................... { 
....................     char c; 
....................     char *t; 
....................  
....................     t = s; 
....................     while( (c = *t) ) 
....................     { 
....................         if ( (c >= 'a' && c <= 'z') ) 
....................             *t -= ('a' - 'A'); 
....................     t++; 
....................     } 
....................     return s; 
.................... } 
....................  
.................... void delay_s(int8 s) { 
....................    while(s) { 
....................       restart_wdt(); 
....................       delay_ms(1000); 
....................       s--; 
....................    } 
.................... } 
.................... */ 
....................  
.................... #include "tcpip/tick.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.c 
....................  * Dependencies:    stackTSK.h 
....................  *                  Tick.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    01/16/04 Intermediate counter vars added 
....................  * R. Shelquist (CCS)   09/23/04 TickGet() temporarily disables Timer0 interrupt 
....................  ********************************************************************/ 
....................  
.................... #define TICK_INCLUDE 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... TICKTYPE TickCount = 0;  //increment every 100ms 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void) 
.................... { 
....................     setup_timer_0(RTCC_INTERNAL | RTCC_DIV_16); 
*
01518:  MOVLW  83
0151A:  MOVWF  FD5
....................     set_timer0(TICK_COUNTER); 
0151C:  MOVLW  34
0151E:  MOVWF  FD7
01520:  MOVLW  8C
01522:  MOVWF  FD6
....................  
....................     enable_interrupts(INT_TIMER0); 
01524:  BSF    FF2.5
....................     enable_interrupts(GLOBAL); 
01526:  MOVLW  C0
01528:  IORWF  FF2,F
0152A:  GOTO   1CF8 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void) 
.................... { 
....................     int16 ret; 
....................     disable_interrupts(INT_TIMER0); 
*
040BA:  BCF    FF2.5
....................     ret=TickCount; 
040BC:  MOVFF  38C,94D
040C0:  MOVFF  38B,94C
....................     enable_interrupts(INT_TIMER0); 
040C4:  BSF    FF2.5
....................     return ret; 
040C6:  MOVLB  9
040C8:  MOVFF  94C,01
040CC:  MOVFF  94D,02
040D0:  MOVLB  0
040D2:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int8 second_counter=0;  //increment this every 1s 
.................... int8 second_counter_intermediate=0; 
....................  
.................... #if STACK_USE_PPP 
....................  int8 ppp_second_counter=0; 
....................  int8 ppp_second_counter_intermediate=0; 
.................... #endif 
....................  
.................... #int_timer0 
.................... void Tick_Isr(void) 
.................... { 
....................         TickCount++;    //increment this every 100ms 
*
00106:  MOVLB  3
00108:  INCF   x8B,F
0010A:  BTFSC  FD8.2
0010C:  INCF   x8C,F
....................  
....................         second_counter_intermediate++; 
0010E:  INCF   x8E,F
....................         if (second_counter_intermediate >= TICKS_PER_SECOND) { 
00110:  MOVF   x8E,W
00112:  SUBLW  0B
00114:  BC    011A
....................             second_counter++; //increment this ever 1s 
00116:  INCF   x8D,F
....................             second_counter_intermediate=0; 
00118:  CLRF   x8E
....................         } 
....................  
....................  
....................        #if STACK_USE_PPP 
....................         ppp_second_counter_intermediate++; 
....................         if (ppp_second_counter_intermediate >= TICKS_PER_SECOND) { 
....................             ppp_second_counter_intermediate=0; 
....................             ppp_second_counter++; 
....................         } 
....................        #endif 
....................  
....................  
....................     set_timer0(TICK_COUNTER); //set timer0 to properly interrupt every 100ms 
0011A:  MOVLW  34
0011C:  MOVWF  FD7
0011E:  MOVLW  8C
00120:  MOVWF  FD6
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_stack 
.................... //#define debug_stack  debug_printf 
.................... #define debug_stack(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... #if STACK_USE_MAC 
....................    #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................    #if STACK_USE_MCPENC 
....................     #include "tcpip/enc28j60.c" 
.................... /********************************************************************* 
....................  * 
....................  *     MAC Module (Microchip ENC28J60) for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.c 
....................  * Dependencies:    ENC28J60.h 
....................  *                    MAC.h 
....................  *                    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                    Delay.h 
....................  * Processor:       PIC18 
....................  * Complier:        MCC18 v3.00 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date         Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder      6/28/04   Original 
....................  * Howard Schlunder      10/8/04   Cleanup 
....................  * Howard Schlunder      10/19/04 Small optimizations and more cleanup 
....................  * Howard Schlunder      11/29/04 Added Set/GetCLKOUT 
....................  * Howard Schlunder      12/23/05 Added B1 silicon errata workarounds 
....................  * Howard Schlunder      1/09/06   Added comments and minor mods 
....................  * Howard Schlunder      1/18/06 Added more silicon errata workarounds 
....................  * Howard Schlunder      2/20/06 Fixed TXSTART, RXSTOP 
....................  * Darren Rook          7/11/06  CCS Port 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
.................... ********************************************************************/ 
.................... #define THIS_IS_MAC_LAYER 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/StackTsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/Helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/MAC.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ENC28J60.h" 
.................... /********************************************************************* 
....................  * 
....................  *            ENC28J60 registers/bits 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ENC28J60.h 
....................  * Description: 	Include file for ENC28J60 control registers 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Howard Schlunder		06/01/04	Original 
....................  * Howard Schlunder		06/29/04	Fixed byte boundary problems on a  
....................  *									couple of PHY register structs. 
....................  * Howard Schlunder		09/29/04	Matched with data sheet 
....................  * Howard Schlunder		01/04/06	Matched with new data sheet 
....................  * Howard Schlunder		06/29/06	Changed MACON3.PHDRLEN to PHDREN 
....................  * Howard Schlunder		07/21/06	Several bits removed to match now  
....................  *									reserved bits in rev. B data sheet  
....................  *									(DS39662B) 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef ENC28J60_H 
.................... #define ENC28J60_H 
....................  
.................... typedef union { 
.................... 	BYTE v[7]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 CollisionCount:4; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 Done:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 PacketDefer:1; 
.................... 		int8 ExcessiveDefer:1; 
.................... 		int8 MaximumCollisions:1; 
.................... 		int8 LateCollision:1; 
.................... 		int8 Giant:1; 
.................... 		int8 Underrun:1; 
.................... 		int16 	 BytesTransmittedOnWire; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PAUSEControlFrame:1; 
.................... 		int8 BackpressureApplied:1; 
.................... 		int8 VLANTaggedFrame:1; 
.................... 		int8 Zeros:4; 
.................... 	} bits; 
.................... } TXSTATUS; 
....................  
.................... typedef union { 
.................... 	char v[4]; 
.................... 	struct { 
.................... 		int16	 ByteCount; 
.................... 		int8 PreviouslyIgnored:1; 
.................... 		int8 RXDCPreviouslySeen:1; 
.................... 		int8 CarrierPreviouslySeen:1; 
.................... 		int8 CodeViolation:1; 
.................... 		int8 CRCError:1; 
.................... 		int8 LengthCheckError:1; 
.................... 		int8 LengthOutOfRange:1; 
.................... 		int8 ReceiveOk:1; 
.................... 		int8 Multicast:1; 
.................... 		int8 Broadcast:1; 
.................... 		int8 DribbleNibble:1; 
.................... 		int8 ControlFrame:1; 
.................... 		int8 PauseControlFrame:1; 
.................... 		int8 UnsupportedOpcode:1; 
.................... 		int8 VLANType:1; 
.................... 		int8 Zero:1; 
.................... 	} bits; 
.................... } RXSTATUS; 
....................  
.................... /****************************************************************************** 
.................... * Register locations 
.................... ******************************************************************************/ 
.................... // Bank 0 registers -------- 
.................... #define ERDPTL		0x00 
.................... #define ERDPTH		0x01 
.................... #define EWRPTL		0x02 
.................... #define EWRPTH		0x03 
.................... #define ETXSTL		0x04 
.................... #define ETXSTH		0x05 
.................... #define ETXNDL		0x06 
.................... #define ETXNDH		0x07 
.................... #define ERXSTL		0x08 
.................... #define ERXSTH		0x09 
.................... #define ERXNDL		0x0A 
.................... #define ERXNDH		0x0B 
.................... #define ERXRDPTL	0x0C 
.................... #define ERXRDPTH	0x0D 
.................... #define ERXWRPTL	0x0E 
.................... #define ERXWRPTH	0x0F 
.................... #define EDMASTL		0x10 
.................... #define EDMASTH		0x11 
.................... #define EDMANDL		0x12 
.................... #define EDMANDH		0x13 
.................... #define EDMADSTL	0x14 
.................... #define EDMADSTH	0x15 
.................... #define EDMACSL		0x16 
.................... #define EDMACSH		0x17 
.................... //#define			0x18 
.................... //#define			0x19 
.................... //#define r			0x1A 
.................... #define EIE			0x1B 
.................... #define EIR			0x1C 
.................... #define ESTAT		0x1D 
.................... #define ECON2		0x1E 
.................... #define ECON1		0x1F 
....................  
.................... // Bank 1 registers ----- 
.................... #define EHT0		0x100 
.................... #define EHT1		0x101 
.................... #define EHT2		0x102 
.................... #define EHT3		0x103 
.................... #define EHT4		0x104 
.................... #define EHT5		0x105 
.................... #define EHT6		0x106 
.................... #define EHT7		0x107 
.................... #define EPMM0		0x108 
.................... #define EPMM1		0x109 
.................... #define EPMM2		0x10A 
.................... #define EPMM3		0x10B 
.................... #define EPMM4		0x10C 
.................... #define EPMM5		0x10D 
.................... #define EPMM6		0x10E 
.................... #define EPMM7		0x10F 
.................... #define EPMCSL		0x110 
.................... #define EPMCSH		0x111 
.................... //#define			0x112 
.................... //#define			0x113 
.................... #define EPMOL		0x114 
.................... #define EPMOH		0x115 
.................... //#define r			0x116 
.................... //#define r			0x117 
.................... #define ERXFCON		0x118 
.................... #define EPKTCNT		0x119 
.................... //#define r			0x11A 
.................... //#define EIE		0x11B 
.................... //#define EIR		0x11C 
.................... //#define ESTAT		0x11D 
.................... //#define ECON2		0x11E 
.................... //#define ECON1		0x11F 
....................  
.................... // Bank 2 registers ----- 
.................... #define MACON1		0x200 
.................... #define MACON2    0x201 
.................... //#define r			0x201 
.................... #define MACON3		0x202 
.................... #define MACON4		0x203 
.................... #define MABBIPG		0x204 
.................... //#define			0x205 
.................... #define MAIPGL		0x206 
.................... #define MAIPGH		0x207 
.................... #define MACLCON1	0x208 
.................... #define MACLCON2	0x209 
.................... #define MAMXFLL		0x20A 
.................... #define MAMXFLH		0x20B 
.................... //#define r			0x20C 
.................... //#define r			0x20D 
.................... //#define r			0x20E 
.................... //#define			0x20F 
.................... //#define r			0x210 
.................... //#define r			0x211 
.................... #define MICMD		0x212 
.................... //#define r			0x213 
.................... #define MIREGADR	0x214 
.................... //#define r			0x215 
.................... #define MIWRL		0x216 
.................... #define MIWRH		0x217 
.................... #define MIRDL		0x218 
.................... #define MIRDH		0x219 
.................... //#define r			0x21A 
.................... //#define EIE		0x21B 
.................... //#define EIR		0x21C 
.................... //#define ESTAT		0x21D 
.................... //#define ECON2		0x21E 
.................... //#define ECON1		0x21F 
....................  
.................... // Bank 3 registers ----- 
.................... #define MAADR5		0x300 
.................... #define MAADR6		0x301 
.................... #define MAADR3		0x302 
.................... #define MAADR4		0x303 
.................... #define MAADR1		0x304 
.................... #define MAADR2		0x305 
.................... #define EBSTSD		0x306 
.................... #define EBSTCON		0x307 
.................... #define EBSTCSL		0x308 
.................... #define EBSTCSH		0x309 
.................... #define MISTAT		0x30A 
.................... //#define			0x30B 
.................... //#define			0x30C 
.................... //#define			0x30D 
.................... //#define			0x30E 
.................... //#define			0x30F 
.................... //#define			0x310 
.................... //#define			0x311 
.................... #define EREVID		0x312 
.................... //#define			0x313 
.................... //#define			0x314 
.................... #define ECOCON		0x315 
.................... //#define 			0x316 
.................... #define EFLOCON		0x317 
.................... #define EPAUSL		0x318 
.................... #define EPAUSH		0x319 
.................... //#define r			0x31A 
.................... //#define EIE		0x31B 
.................... //#define EIR		0x31C 
.................... //#define ESTAT		0x31D 
.................... //#define ECON2		0x31E 
.................... //#define ECON1		0x31F 
....................  
....................  
....................  
.................... // Structures 
.................... typedef union _REG 
.................... { 
.................... 	char Val; 
....................  
.................... 	// EIE bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIE:1; 
.................... 		unsigned char TXERIE:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIE:1; 
.................... 		unsigned char LINKIE:1; 
.................... 		unsigned char DMAIE:1; 
.................... 		unsigned char PKTIE:1; 
.................... 		unsigned char INTIE:1; 
.................... 	} EIEbits; 
....................  
.................... 	// EIR bits ---------- 
.................... 	struct { 
.................... 		unsigned char RXERIF:1; 
.................... 		unsigned char TXERIF:1; 
.................... 		unsigned char :1; 
.................... 		unsigned char TXIF:1; 
.................... 		unsigned char LINKIF:1; 
.................... 		unsigned char DMAIF:1; 
.................... 		unsigned char PKTIF:1; 
.................... 		unsigned char blank1:1; 
.................... 	} EIRbits; 
....................  
.................... 	// ESTAT bits --------- 
.................... 	struct { 
.................... 		unsigned char CLKRDY:1; 
.................... 		unsigned char TXABRT:1; 
.................... 		unsigned char RXBUSY:1; 
.................... 		unsigned char blank1:1; 
.................... 		unsigned char LATECOL:1; 
.................... 		unsigned char blank2:2; 
.................... 		unsigned char INTR:1; 
.................... 	} ESTATbits; 
....................  
.................... 	// ECON2 bits -------- 
.................... 	struct { 
.................... 		unsigned char blank3:3; 
.................... 		unsigned char VRPS:1; 
.................... 		unsigned char VRTP:1; 
.................... 		unsigned char PWRSV:1; 
.................... 		unsigned char PKTDEC:1; 
.................... 		unsigned char AUTOINC:1; 
.................... 	} ECON2bits; 
....................  
.................... 	// ECON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char BSEL0:1; 
.................... 		unsigned char BSEL1:1; 
.................... 		unsigned char RXEN:1; 
.................... 		unsigned char TXRTS:1; 
.................... 		unsigned char CSUMEN:1; 
.................... 		unsigned char DMAST:1; 
.................... 		unsigned char RXRST:1; 
.................... 		unsigned char TXRST:1; 
.................... 	} ECON1bits; 
....................  
.................... 	// ERXFCON bits ------ 
.................... 	struct { 
.................... 		unsigned char BCEN:1; 
.................... 		unsigned char MCEN:1; 
.................... 		unsigned char HTEN:1; 
.................... 		unsigned char MPEN:1; 
.................... 		unsigned char PMEN:1; 
.................... 		unsigned char CRCEN:1; 
.................... 		unsigned char ANDOR:1; 
.................... 		unsigned char UCEN:1; 
.................... 	} ERXFCONbits; 
....................  
.................... 	// MACON1 bits -------- 
.................... 	struct { 
.................... 		unsigned char MARXEN:1; 
.................... 		unsigned char PASSALL:1; 
.................... 		unsigned char RXPAUS:1; 
.................... 		unsigned char TXPAUS:1; 
.................... 		unsigned char :4; 
.................... 	} MACON1bits; 
....................  
....................  
.................... 	// MACON3 bits -------- 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG0:1; 
.................... 		unsigned char PADCFG1:1; 
.................... 		unsigned char PADCFG2:1; 
.................... 	} MACON3bits; 
.................... 	struct { 
.................... 		unsigned char FULDPX:1; 
.................... 		unsigned char FRMLNEN:1; 
.................... 		unsigned char HFRMEN:1; 
.................... 		unsigned char PHDRLEN:1; 
.................... 		unsigned char TXCRCEN:1; 
.................... 		unsigned char PADCFG:3; 
.................... 	} MACON3bits2; 
....................  
.................... 	// MACON4 bits -------- 
.................... 	struct { 
.................... 		unsigned char :4; 
.................... 		unsigned char NOBKOFF:1; 
.................... 		unsigned char BPEN:1; 
.................... 		unsigned char DEFER:1; 
.................... 		unsigned char blank1:1; 
.................... 	} MACON4bits; 
....................  
.................... 	// MICMD bits --------- 
.................... 	struct { 
.................... 		unsigned char MIIRD:1; 
.................... 		unsigned char MIISCAN:1; 
.................... 		unsigned char blank6:6; 
.................... 	} MICMDbits; 
....................  
.................... 	// EBSTCON bits ----- 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL0:1; 
.................... 		unsigned char TMSEL1:1; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV0:1; 
.................... 		unsigned char PSV1:1; 
.................... 		unsigned char PSV2:1; 
.................... 	} EBSTCONbits; 
.................... 	struct { 
.................... 		unsigned char BISTST:1; 
.................... 		unsigned char TME:1; 
.................... 		unsigned char TMSEL:2; 
.................... 		unsigned char PSEL:1; 
.................... 		unsigned char PSV:3; 
.................... 	} EBSTCONbits2; 
....................  
.................... 	// MISTAT bits -------- 
.................... 	struct { 
.................... 		unsigned char BUSY:1; 
.................... 		unsigned char SCAN:1; 
.................... 		unsigned char NVALID:1; 
.................... 		unsigned char blank5:5; 
.................... 	} MISTATbits; 
....................  
.................... 	// ECOCON bits ------- 
.................... 	struct { 
.................... 		unsigned char COCON0:1; 
.................... 		unsigned char COCON1:1; 
.................... 		unsigned char COCON2:1; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits; 
.................... 	struct { 
.................... 		unsigned char COCON:3; 
.................... 		unsigned char blank5:5; 
.................... 	} ECOCONbits2; 
....................  
.................... 	// EFLOCON bits ----- 
.................... 	struct { 
.................... 		unsigned char FCEN0:1; 
.................... 		unsigned char FCEN1:1; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits; 
.................... 	struct { 
.................... 		unsigned char FCEN:2; 
.................... 		unsigned char FULDPXS:1; 
.................... 		unsigned char blank5:5; 
.................... 	} EFLOCONbits2; 
.................... } REG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * PH Register Locations 
.................... ******************************************************************************/ 
.................... #define PHCON1	0x00 
.................... #define PHSTAT1	0x01 
.................... #define PHID1	0x02 
.................... #define PHID2	0x03 
.................... #define PHCON2	0x10 
.................... #define PHSTAT2	0x11 
.................... #define PHIE	0x12 
.................... #define PHIR	0x13 
.................... #define PHLCON	0x14 
....................  
....................  
.................... typedef union { 
.................... 	int16 Val; 
.................... 	WORD_VAL VAL; 
....................  
.................... 	// PHCON1 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 PDPXMD:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PPWRSV:1; 
.................... 		int8 blank22:2; 
.................... 		int8 PLOOPBK:1; 
.................... 		int8 PRST:1; 
.................... 	} PHCON1bits; 
....................  
.................... 	// PHSTAT1 bits -------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 JBSTAT:1; 
.................... 		int8 LLSTAT:1; 
.................... 		int8 blank5:5; 
.................... 		int8 blank3:3; 
.................... 		int8 PHDPX:1; 
.................... 		int8 PFDPX:1; 
.................... 		int8 blank33:3; 
.................... 	} PHSTAT1bits; 
....................  
.................... 	// PHID2 bits ---------- 
.................... 	struct { 
.................... 		int8 PREV0:1; 
.................... 		int8 PREV1:1; 
.................... 		int8 PREV2:1; 
.................... 		int8 PREV3:1; 
.................... 		int8 PPN0:1; 
.................... 		int8 PPN1:1; 
.................... 		int8 PPN2:1; 
.................... 		int8 PPN3:1; 
.................... 		int8 PPN4:1; 
.................... 		int8 PPN5:1; 
.................... 		int8 PID19:1; 
.................... 		int8 PID20:1; 
.................... 		int8 PID21:1; 
.................... 		int8 PID22:1; 
.................... 		int8 PID23:1; 
.................... 		int8 PID24:1; 
.................... 	} PHID2bits; 
.................... 	struct { 
.................... 		int8 PREV:4; 
.................... 		int8 PPNL:4; 
.................... 		int8 PPNH:2; 
.................... 		int8 PID:6; 
.................... 	} PHID2bits2; 
....................  
.................... 	// PHCON2 bits ---------- 
.................... 	struct { 
.................... 		int8 blank8:8; 
.................... 		int8 HDLDIS:1; 
.................... 		int8 blank1:1; 
.................... 		int8 JABBER:1; 
.................... 		int8 blank2:2; 
.................... 		int8 TXDIS:1; 
.................... 		int8 FRCLNK:1; 
.................... 		int8 blank11:1; 
.................... 	} PHCON2bits; 
....................  
.................... 	// PHSTAT2 bits -------- 
.................... 	struct { 
.................... 		int8 blank5:5; 
.................... 		int8 PLRITY:1; 
.................... 		int8 blank2:2; 
.................... 		int8 blank11:1; 
.................... 		int8 DPXSTAT:1; 
.................... 		int8 LSTAT:1; 
.................... 		int8 COLSTAT:1; 
.................... 		int8 RXSTAT:1; 
.................... 		int8 TXSTAT:1; 
.................... 		int8 blank22:2; 
.................... 	} PHSTAT2bits; 
....................  
.................... 	// PHIE bits ----------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 PGEIE:1; 
.................... 		int8 blank2:2; 
.................... 		int8 PLNKIE:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIEbits; 
....................  
.................... 	// PHIR bits ----------- 
.................... 	struct { 
.................... 		int8 blank2:2; 
.................... 		int8 PGIF:1; 
.................... 		int8 blank1:1; 
.................... 		int8 PLNKIF:1; 
.................... 		int8 blank3:3; 
.................... 		int8 blank8:8; 
.................... 	} PHIRbits; 
....................  
.................... 	// PHLCON bits ------- 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ0:1; 
.................... 		int8 LFRQ1:1; 
.................... 		int8 LBCFG0:1; 
.................... 		int8 LBCFG1:1; 
.................... 		int8 LBCFG2:1; 
.................... 		int8 LBCFG3:1; 
.................... 		int8 LACFG0:1; 
.................... 		int8 LACFG1:1; 
.................... 		int8 LACFG2:1; 
.................... 		int8 LACFG3:1; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits; 
.................... 	struct { 
.................... 		int8 blank1:1; 
.................... 		int8 STRCH:1; 
.................... 		int8 LFRQ:2; 
.................... 		int8 LBCFG:4; 
.................... 		int8 LACFG:4; 
.................... 		int8 blank4:4; 
.................... 	} PHLCONbits2; 
.................... } PHYREG; 
....................  
....................  
.................... /****************************************************************************** 
.................... * Individual Register Bits 
.................... ******************************************************************************/ 
.................... // ETH/MAC/MII bits 
....................  
.................... // EIE bits ---------- 
.................... #define	EIE_INTIE		(1<<7) 
.................... #define	EIE_PKTIE		(1<<6) 
.................... #define	EIE_DMAIE		(1<<5) 
.................... #define	EIE_LINKIE		(1<<4) 
.................... #define	EIE_TXIE		(1<<3) 
.................... #define	EIE_TXERIE		(1<<1) 
.................... #define	EIE_RXERIE		(1) 
....................  
.................... // EIR bits ---------- 
.................... #define	EIR_PKTIF		(1<<6) 
.................... #define	EIR_DMAIF		(1<<5) 
.................... #define	EIR_LINKIF		(1<<4) 
.................... #define	EIR_TXIF		(1<<3) 
.................... #define	EIR_TXERIF		(1<<1) 
.................... #define	EIR_RXERIF		(1) 
....................  
.................... // ESTAT bits --------- 
.................... #define	ESTAT_INT		(1<<7) 
.................... #define ESTAT_BUFFER	(1<<6) 
.................... #define	ESTAT_LATECOL	(1<<4) 
.................... #define	ESTAT_RXBUSY	(1<<2) 
.................... #define	ESTAT_TXABRT	(1<<1) 
.................... #define	ESTAT_CLKRDY	(1) 
....................  
.................... // ECON2 bits -------- 
.................... #define	ECON2_AUTOINC	(1<<7) 
.................... #define	ECON2_PKTDEC	(1<<6) 
.................... #define	ECON2_PWRSV		(1<<5) 
.................... #define	ECON2_VRPS		(1<<3) 
....................  
.................... // ECON1 bits -------- 
.................... #define	ECON1_TXRST		(1<<7) 
.................... #define	ECON1_RXRST		(1<<6) 
.................... #define	ECON1_DMAST		(1<<5) 
.................... #define	ECON1_CSUMEN	(1<<4) 
.................... #define	ECON1_TXRTS		(1<<3) 
.................... #define	ECON1_RXEN		(1<<2) 
.................... #define	ECON1_BSEL1		(1<<1) 
.................... #define	ECON1_BSEL0		(1) 
....................  
.................... // ERXFCON bits ------ 
.................... #define	ERXFCON_UCEN	(1<<7) 
.................... #define	ERXFCON_ANDOR	(1<<6) 
.................... #define	ERXFCON_CRCEN	(1<<5) 
.................... #define	ERXFCON_PMEN	(1<<4) 
.................... #define	ERXFCON_MPEN	(1<<3) 
.................... #define	ERXFCON_HTEN	(1<<2) 
.................... #define	ERXFCON_MCEN	(1<<1) 
.................... #define	ERXFCON_BCEN	(1) 
....................  
.................... // MACON1 bits -------- 
.................... #define	MACON1_TXPAUS	(1<<3) 
.................... #define	MACON1_RXPAUS	(1<<2) 
.................... #define	MACON1_PASSALL	(1<<1) 
.................... #define	MACON1_MARXEN	(1) 
....................  
.................... // MACON3 bits -------- 
.................... #define	MACON3_PADCFG2	(1<<7) 
.................... #define	MACON3_PADCFG1	(1<<6) 
.................... #define	MACON3_PADCFG0	(1<<5) 
.................... #define	MACON3_TXCRCEN	(1<<4) 
.................... #define	MACON3_PHDRLEN	(1<<3) 
.................... #define	MACON3_HFRMEN	(1<<2) 
.................... #define	MACON3_FRMLNEN	(1<<1) 
.................... #define	MACON3_FULDPX	(1) 
....................  
.................... // MACON4 bits -------- 
.................... #define	MACON4_DEFER	(1<<6) 
.................... #define	MACON4_BPEN		(1<<5) 
.................... #define	MACON4_NOBKOFF	(1<<4) 
....................  
....................  
.................... // MICMD bits --------- 
.................... #define	MICMD_MIISCAN	(1<<1) 
.................... #define	MICMD_MIIRD		(1) 
....................  
.................... // EBSTCON bits ----- 
.................... #define	EBSTCON_PSV2	(1<<7) 
.................... #define	EBSTCON_PSV1	(1<<6) 
.................... #define	EBSTCON_PSV0	(1<<5) 
.................... #define	EBSTCON_PSEL	(1<<4) 
.................... #define	EBSTCON_TMSEL1	(1<<3) 
.................... #define	EBSTCON_TMSEL0	(1<<2) 
.................... #define	EBSTCON_TME		(1<<1) 
.................... #define	EBSTCON_BISTST	(1) 
....................  
.................... // MISTAT bits -------- 
.................... #define	MISTAT_NVALID	(1<<2) 
.................... #define	MISTAT_SCAN		(1<<1) 
.................... #define	MISTAT_BUSY		(1) 
....................  
.................... // ECOCON bits ------- 
.................... #define	ECOCON_COCON2	(1<<2) 
.................... #define	ECOCON_COCON1	(1<<1) 
.................... #define	ECOCON_COCON0	(1) 
....................  
.................... // EFLOCON bits ----- 
.................... #define	EFLOCON_FULDPXS	(1<<2) 
.................... #define	EFLOCON_FCEN1	(1<<1) 
.................... #define	EFLOCON_FCEN0	(1) 
....................  
....................  
....................  
.................... // PHY bits 
....................  
.................... // PHCON1 bits ---------- 
.................... #define	PHCON1_PRST		(1ul<<15) 
.................... #define	PHCON1_PLOOPBK	(1ul<<14) 
.................... #define	PHCON1_PPWRSV	(1ul<<11) 
.................... #define	PHCON1_PDPXMD	(1ul<<8) 
....................  
.................... // PHSTAT1 bits -------- 
.................... #define	PHSTAT1_PFDPX	(1ul<<12) 
.................... #define	PHSTAT1_PHDPX	(1ul<<11) 
.................... #define	PHSTAT1_LLSTAT	(1ul<<2) 
.................... #define	PHSTAT1_JBSTAT	(1ul<<1) 
....................  
.................... // PHID2 bits -------- 
.................... #define	PHID2_PID24		(1ul<<15) 
.................... #define	PHID2_PID23		(1ul<<14) 
.................... #define	PHID2_PID22		(1ul<<13) 
.................... #define	PHID2_PID21		(1ul<<12) 
.................... #define	PHID2_PID20		(1ul<<11) 
.................... #define	PHID2_PID19		(1ul<<10) 
.................... #define	PHID2_PPN5		(1ul<<9) 
.................... #define	PHID2_PPN4		(1ul<<8) 
.................... #define	PHID2_PPN3		(1ul<<7) 
.................... #define	PHID2_PPN2		(1ul<<6) 
.................... #define	PHID2_PPN1		(1ul<<5) 
.................... #define	PHID2_PPN0		(1ul<<4) 
.................... #define	PHID2_PREV3		(1ul<<3) 
.................... #define	PHID2_PREV2		(1ul<<2) 
.................... #define	PHID2_PREV1		(1ul<<1) 
.................... #define	PHID2_PREV0		(1ul) 
....................  
.................... // PHCON2 bits ---------- 
.................... #define	PHCON2_FRCLNK	(1ul<<14) 
.................... #define	PHCON2_TXDIS	(1ul<<13) 
.................... #define	PHCON2_JABBER	(1ul<<10) 
.................... #define	PHCON2_HDLDIS	(1ul<<8) 
....................  
.................... // PHSTAT2 bits -------- 
.................... #define	PHSTAT2_TXSTAT	(1ul<<13) 
.................... #define	PHSTAT2_RXSTAT	(1ul<<12) 
.................... #define	PHSTAT2_COLSTAT	(1ul<<11) 
.................... #define	PHSTAT2_LSTAT	(1ul<<10) 
.................... #define	PHSTAT2_DPXSTAT	(1ul<<9) 
.................... #define	PHSTAT2_PLRITY	(1ul<<5) 
....................  
.................... // PHIE bits ----------- 
.................... #define	PHIE_PLNKIE		(1ul<<4) 
.................... #define	PHIE_PGEIE		(1ul<<1) 
....................  
.................... // PHIR bits ----------- 
.................... #define	PHIR_PLNKIF		(1ul<<4) 
.................... #define	PHIR_PGIF		(1ul<<2) 
....................  
.................... // PHLCON bits ------- 
.................... #define	PHLCON_LACFG3	(1ul<<11) 
.................... #define	PHLCON_LACFG2	(1ul<<10) 
.................... #define	PHLCON_LACFG1	(1ul<<9) 
.................... #define	PHLCON_LACFG0	(1ul<<8) 
.................... #define	PHLCON_LBCFG3	(1ul<<7) 
.................... #define	PHLCON_LBCFG2	(1ul<<6) 
.................... #define	PHLCON_LBCFG1	(1ul<<5) 
.................... #define	PHLCON_LBCFG0	(1ul<<4) 
.................... #define	PHLCON_LFRQ1	(1ul<<3) 
.................... #define	PHLCON_LFRQ0	(1ul<<2) 
.................... #define	PHLCON_STRCH	(1ul<<1) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if STACK_USE_SLIP 
.................... #error Unexpected module is detected. 
.................... #error This file must be linked when SLIP module is not in use. 
.................... #endif 
....................  
.................... #define debug_mac 
.................... //#define debug_mac debug_printf 
....................  
.................... /* 
....................    #ifndef PIN_ENC_MAC_SO 
....................       #define PIN_ENC_MAC_SO  PIN_C4   // PIC <<<< ENC 
....................       #define PIN_ENC_MAC_SI  PIN_C5   // PIC >>>> ENC 
....................       #define PIN_ENC_MAC_CLK PIN_C3 
....................       #define PIN_ENC_MAC_CS  PIN_D1 
....................       #define PIN_ENC_MAC_RST PIN_D0 
....................       #define PIN_ENC_MAC_INT PIN_B0 
....................       #define PIN_ENC_MAC_WOL PIN_B1 
....................       #define ENC_MAC_USE_SPI TRUE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................       #define mac_enc_spi_tris_init()  *0xF93=(*0xF93 | 0b11); *0xF94 = (*0xF94 & 0b11010111) | 0x10; *0xF95=*0xF95 & 0xFC 
....................      #endif 
.................... */  
....................  
.................... #define ENC_MAC_USE_SPI FALSE      //due to an errata in the ENC28J60, you should always use HW SPI to assure that SPI clock is over 8MHz! 
....................                                    // MiE: SPI Hard is not working on SPI2. Soft is working OK on SPI2 
.................... #define mac_enc_spi_tris_init()      
....................  
.................... #define SPISelectEthernet()     output_low(PIN_ENC_MAC_CS)  //changed by ccs 
.................... #define SPIUnselectEthernet()   output_high(PIN_ENC_MAC_CS) //changed by ccs 
....................  
.................... /** D E F I N I T I O N S ****************************************************/ 
.................... /* Hardware interface to NIC. */ 
.................... //#define MCP_RESET_TRIS   (TRISB_RB5)   //CCS wont use these 
.................... //#define MCP_RESET_IO   (LATB5)          //CCS wont use these 
.................... //#define MCP_CS_TRIS      (TRISB_RB3)   //CCS wont use these 
.................... //#define MCP_CS_IO      (LATB3)          //CCS wont use these 
.................... // The following SPI pins are used but are not configurable 
.................... //   RC3 is used for the SCK pin and is an output 
.................... //   RC4 is used for the SDI pin and is an input 
.................... //   RC5 is used for the SDO pin and is an output 
.................... // IMPORTANT SPI NOTE: The code in this file expects that the SPI interrupt 
.................... //      flag (PIR1_SSPIF) be clear at all times.  If the SPI is shared with 
.................... //      other hardware, the other code should clear the PIR1_SSPIF when it is 
.................... //      done using the SPI. 
....................  
.................... // Since the ENC28J60 doesn't support auto-negotiation, full-duplex mode is 
.................... // not compatible with most switches/routers.  If a dedicated network is used 
.................... // where the duplex of the remote node can be manually configured, you may 
.................... // change this configuration.  Otherwise, half duplex should always be used. 
.................... #define HALF_DUPLEX 
.................... //#define FULL_DUPLEX 
.................... //#define LEDB_DUPLEX 
....................  
.................... // Pseudo Functions 
.................... #define LOW(a)                (a & 0xFF) 
.................... #define HIGH(a)             ((a>>8) & 0xFF) 
....................  
.................... // NIC RAM definitions 
.................... #define RAMSIZE   8192ul 
.................... #define TXSTART (RAMSIZE-(MAC_TX_BUFFER_COUNT * (MAC_TX_BUFFER_SIZE + 8ul))) 
.................... #define RXSTART   (0ul)                  // Should be an even memory address 
.................... #define RXSTOP   ((TXSTART-2ul) | 0x0001ul)   // Odd for errata workaround 
.................... #define RXSIZE   (RXSTOP-RXSTART+1ul) 
....................  
.................... // ENC28J60 Opcodes (to be ORed with a 5 bit address) 
.................... #define  WCR (0b010<<5)         // Write Control Register command 
.................... #define  BFS (0b100<<5)         // Bit Field Set command 
.................... #define  BFC (0b101<<5)         // Bit Field Clear command 
.................... #define  RCR (0b000<<5)         // Read Control Register command 
.................... #define  RBM ((0b001<<5) | 0x1A)   // Read Buffer Memory command 
.................... #define  WBM ((0b011<<5) | 0x1A) // Write Buffer Memory command 
.................... #define  SR  ((0b111<<5) | 0x1F)   // System Reset command does not use an address. 
....................                         //   It requires 0x1F, however. 
....................  
.................... #define ETHER_IP   (0x00u) 
.................... #define ETHER_ARP   (0x06u) 
....................  
00122:  BCF    FF2.2
00124:  MOVLB  0
00126:  GOTO   0084
.................... #define MAXFRAMEC   (1500u+sizeof(ETHER_HEADER)+4u) 
....................  
.................... // A generic structure representing the Ethernet header starting all Ethernet 
.................... // frames 
.................... typedef struct _ETHER_HEADER 
.................... { 
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ETHER_HEADER; 
....................  
.................... // A header appended at the start of all RX frames by the hardware 
.................... typedef struct _ENC_PREAMBLE 
.................... { 
....................     int16         NextPacketPointer; 
....................     RXSTATUS      StatusVector; 
....................  
....................     MAC_ADDR        DestMACAddr; 
....................     MAC_ADDR        SourceMACAddr; 
....................     WORD_VAL        Type; 
.................... } ENC_PREAMBLE; 
....................  
.................... typedef struct _DATA_BUFFER 
.................... { 
....................    WORD_VAL StartAddress; 
....................    WORD_VAL EndAddress; 
....................    struct 
....................    { 
....................       unsigned char bFree : 1; 
....................       unsigned char bTransmitted : 1; 
....................    } Flags; 
.................... } DATA_BUFFER; 
....................  
.................... void MACSetDuplex(DUPLEX DuplexState); 
....................  
.................... // Prototypes of functions intended for MAC layer use only. 
.................... static void BankSel(WORD Register); 
.................... static REG ReadETHReg(BYTE Address); 
.................... static REG ReadMACReg(BYTE Address); 
.................... static void WriteReg(BYTE Address, BYTE Data); 
.................... static void BFCReg(BYTE Address, BYTE Data); 
.................... static void BFSReg(BYTE Address, BYTE Data); 
.................... static void SendSystemReset(void); 
.................... //static void GetRegs(void); 
.................... #ifdef MAC_POWER_ON_TEST 
.................... static BOOL TestMemory(void); 
.................... #endif 
....................  
.................... /* Internal and externally used MAC level variables */ 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... #endif 
....................  
.................... // Internal and externally used MAC level variables. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
.................... static DATA_BUFFER TxBuffers[MAC_TX_BUFFER_COUNT]; 
.................... BUFFER LastTXedBuffer; 
.................... #endif 
....................  
....................  
.................... // Internal MAC level variables and flags. 
.................... WORD_VAL NextPacketLocation; 
.................... WORD_VAL CurrentPacketLocation; 
.................... BOOL WasDiscarded; 
.................... BYTE ENCRevID; 
....................  
.................... //ENCSPIInit() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... void ENCSPIInit(void) 
.................... { 
....................    mac_enc_spi_tris_init();  //MCP_RESET_TRIS = 0; 
....................  #if ENC_MAC_USE_SPI 
....................    setup_spi(SPI_MASTER | SPI_L_TO_H | SPI_XMIT_L_TO_H | SPI_CLK_DIV_4); 
....................  #else 
....................    output_low(PIN_ENC_MAC_CLK); 
*
0152E:  BCF    F94.3
01530:  BCF    F8B.3
....................    output_float(PIN_ENC_MAC_SO); 
01532:  BSF    F94.4
....................  #endif 
....................    // 
....................    // Set up the SPI module on the PIC for communications with the ENC28J60 
....................    // 
....................    SPIUnselectEthernet(); 
01534:  BCF    F94.1
01536:  BSF    F8B.1
....................  
....................    // Deassert the nRESET pin on the ENC28J60.  The internal 
....................    // weak pull on the nRESET pin will get the job done anyway, 
....................    // so this isn't necessary, but it may provide extra noise immunity, 
....................    // should someone put their finger on the pin or otherwise cause a leakage 
....................    // path to ground on this pin. 
....................    output_high(PIN_ENC_MAC_RST);            //MCP_RESET_IO = 1; 
01538:  BCF    F94.0
0153A:  BSF    F8B.0
0153C:  GOTO   1848 (RETURN)
.................... } 
....................  
.................... //ENCSPIXfer() added by CCS. 
.................... //A wrapper to the SPI routine, so you can use HW or SW SPI 
.................... char ENCSPIXfer(char c) 
.................... { 
....................  #if ENC_MAC_USE_SPI 
....................    return(spi_read(c)); 
....................  #else 
....................    int8 i, in; 
....................    for (i=0;i<8;i++) { 
01540:  MOVLB  9
01542:  CLRF   xB1
01544:  MOVF   xB1,W
01546:  SUBLW  07
01548:  BNC   1572
....................       output_bit(PIN_ENC_MAC_SI, shift_left(&c, 1, 0)); 
0154A:  BCF    FD8.0
0154C:  RLCF   xB0,F
0154E:  BC    1554
01550:  BCF    F8B.5
01552:  BRA    1556
01554:  BSF    F8B.5
01556:  BCF    F94.5
....................       output_high(PIN_ENC_MAC_CLK); 
01558:  BCF    F94.3
0155A:  BSF    F8B.3
....................       shift_left(&in, 1, input(PIN_ENC_MAC_SO)); 
0155C:  BSF    F94.4
0155E:  BTFSC  F82.4
01560:  BRA    1566
01562:  BCF    FD8.0
01564:  BRA    1568
01566:  BSF    FD8.0
01568:  RLCF   xB2,F
....................       output_low(PIN_ENC_MAC_CLK); 
0156A:  BCF    F94.3
0156C:  BCF    F8B.3
0156E:  INCF   xB1,F
01570:  BRA    1544
....................    } 
....................    return(in); 
01572:  MOVFF  9B2,01
....................  #endif 
01576:  MOVLB  0
01578:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACInit sets up the PIC's SPI module and all the 
....................  *               registers in the ENC28J60 so that normal operation can 
....................  *               begin. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACInit(void) 
.................... { 
....................    BYTE i; 
....................  
....................    ENCSPIInit(); 
*
01846:  BRA    152E
....................  
....................    // Wait for CLKRDY to become set. 
....................    // Bit 3 in ESTAT is an unimplemented bit.  If it reads out as '1' that 
....................    // means the part is in RESET or otherwise our SPI pin is being driven 
....................    // incorrectly.  Make sure it is working before proceeding. 
....................    do 
....................    { 
....................       i = ReadETHReg(ESTAT).Val; 
01848:  MOVLW  1D
0184A:  MOVLB  9
0184C:  MOVWF  xA5
0184E:  MOVLB  0
01850:  RCALL  157A
01852:  MOVFF  01,8F9
....................    } while((i & 0x08) || (~i & ESTAT_CLKRDY)); 
01856:  MOVLB  8
01858:  BTFSS  xF9.3
0185A:  BRA    1860
0185C:  MOVLB  0
0185E:  BRA    1848
01860:  MOVF   xF9,W
01862:  XORLW  FF
01864:  ANDLW  01
01866:  BTFSC  FD8.2
01868:  BRA    186E
0186A:  MOVLB  0
0186C:  BRA    1848
....................  
....................  
.................... #ifdef MAC_POWER_ON_TEST 
....................    // Do the memory test and enter a while always trap if a hardware error 
....................    // occured.  The LEDA and LEDB pins will be configured to blink 
....................    // periodically in an abnormal manner to indicate to the user that the 
....................    // error occured. 
....................    if( !TestMemory() ) 
....................    { 
....................       SetLEDConfig(0x0AA2);      // Set LEDs to blink periodically 
....................       while(1); 
....................    } 
.................... #endif 
....................  
....................    // RESET the entire ENC28J60, clearing all registers 
....................    SendSystemReset(); 
0186E:  MOVLB  0
01870:  BRA    15A4
....................     delay_ms(1); 
01872:  MOVLW  01
01874:  MOVLB  9
01876:  MOVWF  x00
01878:  MOVLB  0
0187A:  CALL   102E
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................     // On Init, all transmit buffers are free. 
....................     for (i = 0; i < MAC_TX_BUFFER_COUNT; i++ ) 
....................     { 
....................         TxBuffers[i].StartAddress.Val = TXSTART + ((WORD)i * (MAC_TX_BUFFER_SIZE+8)); 
....................         TxBuffers[i].Flags.bFree = TRUE; 
....................     } 
.................... #endif 
....................     CurrentTxBuffer = 0; 
0187E:  MOVLB  3
01880:  CLRF   x8A
....................  
....................    // Start up in Bank 0 and configure the receive buffer boundary pointers 
....................    // and the buffer write protect pointer (receive buffer read pointer) 
....................    WasDiscarded = TRUE; 
01882:  BSF    x93.0
....................    NextPacketLocation.Val = RXSTART; 
01884:  CLRF   x90
01886:  CLRF   x8F
....................    WriteReg(ERXSTL, LOW(RXSTART)); 
01888:  MOVLW  08
0188A:  MOVLB  9
0188C:  MOVWF  xAB
0188E:  CLRF   xAC
01890:  MOVLB  0
01892:  RCALL  15B8
....................    WriteReg(ERXSTH, HIGH(RXSTART)); 
01894:  MOVLW  09
01896:  MOVLB  9
01898:  MOVWF  xAB
0189A:  CLRF   xAC
0189C:  MOVLB  0
0189E:  RCALL  15B8
....................    WriteReg(ERXRDPTL, LOW(RXSTOP));   // Write low byte first 
018A0:  MOVLW  0C
018A2:  MOVLB  9
018A4:  MOVWF  xAB
018A6:  MOVLW  F7
018A8:  MOVWF  xAC
018AA:  MOVLB  0
018AC:  RCALL  15B8
....................    WriteReg(ERXRDPTH, HIGH(RXSTOP));   // Write high byte last 
018AE:  MOVLW  0D
018B0:  MOVLB  9
018B2:  MOVWF  xAB
018B4:  MOVLW  1B
018B6:  MOVWF  xAC
018B8:  MOVLB  0
018BA:  RCALL  15B8
.................... #if RXSTOP != 0x1FFF   // The RESET default ERXND is 0x1FFF 
....................    WriteReg(ERXNDL, LOW(RXSTOP)); 
018BC:  MOVLW  0A
018BE:  MOVLB  9
018C0:  MOVWF  xAB
018C2:  MOVLW  F7
018C4:  MOVWF  xAC
018C6:  MOVLB  0
018C8:  RCALL  15B8
....................    WriteReg(ERXNDH, HIGH(RXSTOP)); 
018CA:  MOVLW  0B
018CC:  MOVLB  9
018CE:  MOVWF  xAB
018D0:  MOVLW  1B
018D2:  MOVWF  xAC
018D4:  MOVLB  0
018D6:  RCALL  15B8
.................... #endif 
.................... #if TXSTART != 0      // The RESET default ETXST is 0 
....................    WriteReg(ETXSTL, LOW(TXSTART)); 
018D8:  MOVLW  04
018DA:  MOVLB  9
018DC:  MOVWF  xAB
018DE:  MOVLW  F8
018E0:  MOVWF  xAC
018E2:  MOVLB  0
018E4:  RCALL  15B8
....................    WriteReg(ETXSTH, HIGH(TXSTART)); 
018E6:  MOVLW  05
018E8:  MOVLB  9
018EA:  MOVWF  xAB
018EC:  MOVLW  1B
018EE:  MOVWF  xAC
018F0:  MOVLB  0
018F2:  RCALL  15B8
.................... #endif 
....................  
....................    // Enter Bank 1 and configure Receive Filters 
....................    // (No need to reconfigure - Unicast OR Broadcast with CRC checking is 
....................    // acceptable) 
....................    // Write ERXFCON_CRCEN only to ERXFCON to enter promiscuous mode 
....................    //BankSel(ERXFCON); 
....................    //WriteReg((BYTE)ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN | ERXFCON_HTEN); 
....................  
....................    // Enter Bank 2 and configure the MAC 
....................    BankSel(MACON1); 
018F4:  MOVLW  02
018F6:  MOVLB  9
018F8:  MOVWF  xA9
018FA:  CLRF   xA8
018FC:  MOVLB  0
018FE:  RCALL  1612
....................  
....................    // Enable the receive portion of the MAC 
....................    WriteReg((BYTE)MACON1, MACON1_TXPAUS | MACON1_RXPAUS | MACON1_MARXEN); 
01900:  MOVLB  9
01902:  CLRF   xAB
01904:  MOVLW  0D
01906:  MOVWF  xAC
01908:  MOVLB  0
0190A:  RCALL  15B8
....................  
....................    // Pad packets to 60 bytes, add CRC, and check Type/Length field. 
....................    WriteReg((BYTE)MACON3, MACON3_PADCFG0 | MACON3_TXCRCEN | MACON3_FRMLNEN); 
0190C:  MOVLW  02
0190E:  MOVLB  9
01910:  MOVWF  xAB
01912:  MOVLW  32
01914:  MOVWF  xAC
01916:  MOVLB  0
01918:  RCALL  15B8
....................  
....................     // Allow infinite deferals if the medium is continuously busy 
....................     // (do not time out a transmission if the half duplex medium is 
....................     // completely saturated with other people's data) 
....................     WriteReg((BYTE)MACON4, MACON4_DEFER); 
0191A:  MOVLW  03
0191C:  MOVLB  9
0191E:  MOVWF  xAB
01920:  MOVLW  40
01922:  MOVWF  xAC
01924:  MOVLB  0
01926:  RCALL  15B8
....................  
....................    // Late collisions occur beyond 63+8 bytes (8 bytes for preamble/start of frame delimiter) 
....................    // 55 is all that is needed for IEEE 802.3, but ENC28J60 B5 errata for improper link pulse 
....................    // collisions will occur less often with a larger number. 
....................     WriteReg((BYTE)MACLCON2, 63); 
01928:  MOVLW  09
0192A:  MOVLB  9
0192C:  MOVWF  xAB
0192E:  MOVLW  3F
01930:  MOVWF  xAC
01932:  MOVLB  0
01934:  RCALL  15B8
....................  
....................    // Set non-back-to-back inter-packet gap to 9.6us.  The back-to-back 
....................    // inter-packet gap (MABBIPG) is set by MACSetDuplex() which is called 
....................    // later. 
....................    WriteReg((BYTE)MAIPGL, 0x12); 
01936:  MOVLW  06
01938:  MOVLB  9
0193A:  MOVWF  xAB
0193C:  MOVLW  12
0193E:  MOVWF  xAC
01940:  MOVLB  0
01942:  RCALL  15B8
....................    WriteReg((BYTE)MAIPGH, 0x0C); 
01944:  MOVLW  07
01946:  MOVLB  9
01948:  MOVWF  xAB
0194A:  MOVLW  0C
0194C:  MOVWF  xAC
0194E:  MOVLB  0
01950:  RCALL  15B8
....................  
....................    // Set the maximum packet size which the controller will accept 
....................    WriteReg((BYTE)MAMXFLL, LOW(MAXFRAMEC)); 
01952:  MOVLW  0A
01954:  MOVLB  9
01956:  MOVWF  xAB
01958:  MOVLW  EE
0195A:  MOVWF  xAC
0195C:  MOVLB  0
0195E:  RCALL  15B8
....................    WriteReg((BYTE)MAMXFLH, HIGH(MAXFRAMEC)); 
01960:  MOVLW  0B
01962:  MOVLB  9
01964:  MOVWF  xAB
01966:  MOVLW  05
01968:  MOVWF  xAC
0196A:  MOVLB  0
0196C:  RCALL  15B8
....................  
....................     // Enter Bank 3 and initialize physical MAC address registers 
....................    BankSel(MAADR1); 
0196E:  MOVLW  03
01970:  MOVLB  9
01972:  MOVWF  xA9
01974:  MOVLW  04
01976:  MOVWF  xA8
01978:  MOVLB  0
0197A:  RCALL  1612
....................     WriteReg((BYTE)MAADR1, AppConfig.MyMACAddr.v[0]); 
0197C:  MOVLW  04
0197E:  MOVLB  9
01980:  MOVWF  xAB
01982:  MOVFF  357,9AC
01986:  MOVLB  0
01988:  RCALL  15B8
....................     WriteReg((BYTE)MAADR2, AppConfig.MyMACAddr.v[1]); 
0198A:  MOVLW  05
0198C:  MOVLB  9
0198E:  MOVWF  xAB
01990:  MOVFF  358,9AC
01994:  MOVLB  0
01996:  RCALL  15B8
....................     WriteReg((BYTE)MAADR3, AppConfig.MyMACAddr.v[2]); 
01998:  MOVLW  02
0199A:  MOVLB  9
0199C:  MOVWF  xAB
0199E:  MOVFF  359,9AC
019A2:  MOVLB  0
019A4:  RCALL  15B8
....................     WriteReg((BYTE)MAADR4, AppConfig.MyMACAddr.v[3]); 
019A6:  MOVLW  03
019A8:  MOVLB  9
019AA:  MOVWF  xAB
019AC:  MOVFF  35A,9AC
019B0:  MOVLB  0
019B2:  RCALL  15B8
....................     WriteReg((BYTE)MAADR5, AppConfig.MyMACAddr.v[4]); 
019B4:  MOVLB  9
019B6:  CLRF   xAB
019B8:  MOVFF  35B,9AC
019BC:  MOVLB  0
019BE:  RCALL  15B8
....................     WriteReg((BYTE)MAADR6, AppConfig.MyMACAddr.v[5]); 
019C0:  MOVLW  01
019C2:  MOVLB  9
019C4:  MOVWF  xAB
019C6:  MOVFF  35C,9AC
019CA:  MOVLB  0
019CC:  RCALL  15B8
....................  
....................    // Get the Rev ID so that we can implement the correct errata workarounds 
....................    ENCRevID = ReadETHReg((BYTE)EREVID).Val; 
019CE:  MOVLW  12
019D0:  MOVLB  9
019D2:  MOVWF  xA5
019D4:  MOVLB  0
019D6:  RCALL  157A
019D8:  MOVFF  01,394
....................  
....................    // Disable half duplex loopback in PHY.  Bank bits changed to Bank 2 as a 
....................    // side effect. 
....................    WritePHYReg(PHCON2, PHCON2_HDLDIS); 
019DC:  MOVLW  10
019DE:  MOVLB  8
019E0:  MOVWF  xFE
019E2:  MOVLW  01
019E4:  MOVLB  9
019E6:  MOVWF  x00
019E8:  MOVLB  8
019EA:  CLRF   xFF
019EC:  MOVLB  0
019EE:  RCALL  167A
....................  
....................    // Configure LEDA to display LINK status, LEDB to display TX/RX activity 
....................    SetLEDConfig(0x0472); 
019F0:  MOVLW  14
019F2:  MOVLB  8
019F4:  MOVWF  xFE
019F6:  MOVLW  04
019F8:  MOVLB  9
019FA:  MOVWF  x00
019FC:  MOVLW  72
019FE:  MOVLB  8
01A00:  MOVWF  xFF
01A02:  MOVLB  0
01A04:  RCALL  167A
....................  
....................    // Set the MAC and PHY into the proper duplex state 
.................... #if defined(FULL_DUPLEX) 
....................    MACSetDuplex(FULL);      // Function exits with Bank 2 selected 
.................... #elif defined(HALF_DUPLEX) 
....................    MACSetDuplex(HALF);      // Function exits with Bank 2 selected 
01A06:  MOVLB  8
01A08:  CLRF   xFA
01A0A:  MOVLB  0
01A0C:  BRA    17A4
.................... #else 
....................    // Use the external LEDB polarity to determine weather full or half duplex 
....................    // communication mode should be set. 
....................    MACSetDuplex(USE_PHY);   // Function exits with Bank 2 selected 
.................... #endif 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
01A0E:  MOVLW  1F
01A10:  MOVLB  9
01A12:  MOVWF  xAD
01A14:  MOVLW  04
01A16:  MOVWF  xAE
01A18:  MOVLB  0
01A1A:  RCALL  15F4
01A1C:  GOTO   1CFA (RETURN)
.................... }//end MACInit 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsLinked(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE: If the PHY reports that a link partner is present 
....................  *                    and the link has been up continuously since the last 
....................  *                    call to MACIsLinked() 
....................  *               FALSE: If the PHY reports no link partner, or the link went 
....................  *                     down momentarily since the last call to MACIsLinked() 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the PHSTAT1.LLSTAT bit. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsLinked(void) 
.................... { 
....................    // LLSTAT is a latching low link status bit.  Therefore, if the link 
....................    // goes down and comes back up before a higher level stack program calls 
....................    // MACIsLinked(), MACIsLinked() will still return FALSE.  The next 
....................    // call to MACIsLinked() will return TRUE (unless the link goes down 
....................    // again). 
....................    return ReadPHYReg(PHSTAT1).PHSTAT1bits.LLSTAT; 
*
078C8:  MOVLW  01
078CA:  MOVLB  8
078CC:  MOVWF  xFE
078CE:  MOVLB  0
078D0:  CALL   170A
078D4:  MOVFF  01,8F9
078D8:  MOVLW  00
078DA:  MOVLB  8
078DC:  BTFSC  01.2
078DE:  MOVLW  01
078E0:  MOVWF  01
078E2:  MOVLB  0
078E4:  GOTO   8420 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           HighPriority: TRUE: Check the hardware ECON1.TXRTS bit 
....................  *                          FALSE: Check if a TX buffer is free 
....................  * 
....................  * Output:          TRUE: If no Ethernet transmission is in progress 
....................  *               FALSE: If a previous transmission was started, and it has 
....................  *                     not completed yet.  While FALSE, the data in the 
....................  *                     transmit buffer and the TXST/TXND pointers must not 
....................  *                     be changed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the ECON1.TXRTS bit 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACIsTxReady(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
*
041D6:  MOVLW  1F
041D8:  MOVLB  9
041DA:  MOVWF  xA5
041DC:  MOVLB  0
041DE:  CALL   157A
041E2:  MOVFF  01,987
041E6:  MOVLW  00
041E8:  MOVLB  9
041EA:  BTFSC  01.3
041EC:  MOVLW  01
041EE:  XORLW  00
041F0:  BZ    41F6
041F2:  MOVLW  00
041F4:  BRA    41F8
041F6:  MOVLW  01
041F8:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
041FA:  MOVLB  0
041FC:  RETURN 0
....................  
....................    // Check if the current buffer can be modified.  It cannot be modified if 
....................    // the TX hardware is currently transmitting it. 
....................    if(CurrentTxBuffer == LastTXedBuffer) 
....................    { 
....................        return !ReadETHReg(ECON1).ECON1bits.TXRTS; 
....................    } 
....................  
....................    // Check if a buffer is available for a new packet 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          return TRUE; 
....................       } 
....................    } 
....................  
....................    return FALSE; 
.................... #endif 
.................... } 
....................  
.................... BUFFER MACGetTxBuffer(BOOL HighPriority) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    BUFFER i; 
....................  
....................    if(HighPriority) 
.................... #endif 
....................    { 
....................       return !ReadETHReg(ECON1).ECON1bits.TXRTS ? 0 : INVALID_BUFFER; 
*
0300C:  MOVLW  1F
0300E:  MOVLB  9
03010:  MOVWF  xA5
03012:  MOVLB  0
03014:  CALL   157A
03018:  MOVFF  01,987
0301C:  MOVLW  00
0301E:  MOVLB  9
03020:  BTFSC  01.3
03022:  MOVLW  01
03024:  XORLW  00
03026:  BNZ   302C
03028:  MOVLW  00
0302A:  BRA    302E
0302C:  MOVLW  FF
0302E:  MOVWF  01
....................    } 
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
03030:  MOVLB  0
03032:  RETURN 0
....................    // Find a free buffer.  Do not use buffer 0, it is reserved for 
....................    // high priority messages that don't need to be acknowledged 
....................    // before being discarded (TCP control packets, all ICMP 
....................    // packets, all UDP packets, etc.) 
....................    for(i = 1; i < MAC_TX_BUFFER_COUNT; i++) 
....................    { 
....................       // If this buffer is free, then mark it as used and return with it 
....................       if(TxBuffers[i].Flags.bFree) 
....................       { 
....................          TxBuffers[i].Flags.bFree = FALSE; 
....................          TxBuffers[i].Flags.bTransmitted = FALSE; 
....................          return i; 
....................       } 
....................    } 
....................  
....................    return INVALID_BUFFER; 
.................... #endif 
.................... } 
....................  
....................  
.................... void MACDiscardTx(BUFFER buffer) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
*
00004:  RETURN 0
....................    if(buffer < sizeof(TxBuffers)/sizeof(TxBuffers[0])) 
....................    { 
....................        TxBuffers[buffer].Flags.bFree = TRUE; 
....................        CurrentTxBuffer = buffer; 
....................    } 
.................... #endif 
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDiscardRx(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Marks the last received packet (obtained using 
....................  *               MACGetHeader())as being processed and frees the buffer 
....................  *               memory associated with it 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDiscardRx(void) 
.................... { 
....................    WORD_VAL NewRXRDLocation; 
....................  
....................    // Make sure the current packet was not already discarded 
....................    if( WasDiscarded ) 
*
02C06:  MOVLB  3
02C08:  BTFSS  x93.0
02C0A:  BRA    2C0E
....................       return; 
02C0C:  BRA    2C78
....................    WasDiscarded = TRUE; 
02C0E:  BSF    x93.0
....................  
....................    // Decrement the next packet pointer before writing it into 
....................    // the ERXRDPT registers.  This is a silicon errata workaround. 
....................    // RX buffer wrapping must be taken into account if the 
....................    // NextPacketLocation is precisely RXSTART. 
....................    NewRXRDLocation.Val = NextPacketLocation.Val - 1; 
02C10:  MOVLW  01
02C12:  SUBWF  x8F,W
02C14:  MOVLB  9
02C16:  MOVWF  x4C
02C18:  MOVLW  00
02C1A:  MOVLB  3
02C1C:  SUBWFB x90,W
02C1E:  MOVLB  9
02C20:  MOVWF  x4D
.................... #if RXSTART == 0 
....................    if(NewRXRDLocation.Val > RXSTOP) 
02C22:  MOVF   x4D,W
02C24:  SUBLW  1A
02C26:  BC    2C3A
02C28:  XORLW  FF
02C2A:  BNZ   2C32
02C2C:  MOVF   x4C,W
02C2E:  SUBLW  F7
02C30:  BC    2C3A
.................... #else 
....................    if(NewRXRDLocation.Val < RXSTART || NewRXRDLocation.Val > RXSTOP) 
.................... #endif 
....................    { 
....................       NewRXRDLocation.Val = RXSTOP; 
02C32:  MOVLW  1B
02C34:  MOVWF  x4D
02C36:  MOVLW  F7
02C38:  MOVWF  x4C
....................    } 
....................  
....................    // Decrement the RX packet counter register, EPKTCNT 
....................    BFSReg(ECON2, ECON2_PKTDEC); 
02C3A:  MOVLW  1E
02C3C:  MOVWF  xAD
02C3E:  MOVLW  40
02C40:  MOVWF  xAE
02C42:  MOVLB  0
02C44:  CALL   15F4
....................  
....................    // Move the receive read pointer to unwrite-protect the memory used by the 
....................    // last packet.  The writing order is important: set the low byte first, 
....................    // high byte last. 
....................    BankSel(ERXRDPTL); 
02C48:  MOVLB  9
02C4A:  CLRF   xA9
02C4C:  MOVLW  0C
02C4E:  MOVWF  xA8
02C50:  MOVLB  0
02C52:  CALL   1612
....................    WriteReg(ERXRDPTL, NewRXRDLocation.v[0]); 
02C56:  MOVLW  0C
02C58:  MOVLB  9
02C5A:  MOVWF  xAB
02C5C:  MOVFF  94C,9AC
02C60:  MOVLB  0
02C62:  CALL   15B8
....................    WriteReg(ERXRDPTH, NewRXRDLocation.v[1]); 
02C66:  MOVLW  0D
02C68:  MOVLB  9
02C6A:  MOVWF  xAB
02C6C:  MOVFF  94D,9AC
02C70:  MOVLB  0
02C72:  CALL   15B8
02C76:  MOVLB  3
02C78:  MOVLB  0
02C7A:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetFreeRxSize(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          A WORD estimate of how much RX buffer space is free at 
....................  *               the present time. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetFreeRxSize(void) 
.................... { 
....................    WORD_VAL ReadPT, WritePT; 
....................  
....................    // Read the Ethernet hardware buffer write pointer.  Because packets can be 
....................    // received at any time, it can change between reading the low and high 
....................    // bytes.  A loop is necessary to make certain a proper low/high byte pair 
....................    // is read. 
....................    BankSel(EPKTCNT); 
*
041FE:  MOVLW  01
04200:  MOVLB  9
04202:  MOVWF  xA9
04204:  MOVLW  19
04206:  MOVWF  xA8
04208:  MOVLB  0
0420A:  CALL   1612
....................    do { 
....................       // Save EPKTCNT in a temporary location 
....................       ReadPT.v[0] = ReadETHReg((BYTE)EPKTCNT).Val; 
0420E:  MOVLW  19
04210:  MOVLB  9
04212:  MOVWF  xA5
04214:  MOVLB  0
04216:  CALL   157A
0421A:  MOVFF  01,986
....................  
....................       BankSel(ERXWRPTL); 
0421E:  MOVLB  9
04220:  CLRF   xA9
04222:  MOVLW  0E
04224:  MOVWF  xA8
04226:  MOVLB  0
04228:  CALL   1612
....................       WritePT.v[0] = ReadETHReg(ERXWRPTL).Val; 
0422C:  MOVLW  0E
0422E:  MOVLB  9
04230:  MOVWF  xA5
04232:  MOVLB  0
04234:  CALL   157A
04238:  MOVFF  01,988
....................       WritePT.v[1] = ReadETHReg(ERXWRPTH).Val; 
0423C:  MOVLW  0F
0423E:  MOVLB  9
04240:  MOVWF  xA5
04242:  MOVLB  0
04244:  CALL   157A
04248:  MOVFF  01,989
....................  
....................       BankSel(EPKTCNT); 
0424C:  MOVLW  01
0424E:  MOVLB  9
04250:  MOVWF  xA9
04252:  MOVLW  19
04254:  MOVWF  xA8
04256:  MOVLB  0
04258:  CALL   1612
....................    } while(ReadETHReg((BYTE)EPKTCNT).Val != ReadPT.v[0]); 
0425C:  MOVLW  19
0425E:  MOVLB  9
04260:  MOVWF  xA5
04262:  MOVLB  0
04264:  CALL   157A
04268:  MOVFF  01,98A
0426C:  MOVLB  9
0426E:  MOVF   x86,W
04270:  SUBWF  01,W
04272:  BTFSC  FD8.2
04274:  BRA    427A
04276:  MOVLB  0
04278:  BRA    420E
....................  
....................    // Determine where the write protection pointer is 
....................    BankSel(ERXRDPTL); 
0427A:  CLRF   xA9
0427C:  MOVLW  0C
0427E:  MOVWF  xA8
04280:  MOVLB  0
04282:  CALL   1612
....................    ReadPT.v[0] = ReadETHReg(ERXRDPTL).Val; 
04286:  MOVLW  0C
04288:  MOVLB  9
0428A:  MOVWF  xA5
0428C:  MOVLB  0
0428E:  CALL   157A
04292:  MOVFF  01,986
....................    ReadPT.v[1] = ReadETHReg(ERXRDPTH).Val; 
04296:  MOVLW  0D
04298:  MOVLB  9
0429A:  MOVWF  xA5
0429C:  MOVLB  0
0429E:  CALL   157A
042A2:  MOVFF  01,987
....................  
....................    // Calculate the difference between the pointers, taking care to account 
....................    // for buffer wrapping conditions 
....................    if ( WritePT.Val > ReadPT.Val ) 
042A6:  MOVLB  9
042A8:  MOVF   x87,W
042AA:  SUBWF  x89,W
042AC:  BNC   42DA
042AE:  BNZ   42B6
042B0:  MOVF   x88,W
042B2:  SUBWF  x86,W
042B4:  BC    42DA
....................    { 
....................       return (RXSTOP - RXSTART) - (WritePT.Val - ReadPT.Val); 
042B6:  MOVF   x86,W
042B8:  SUBWF  x88,W
042BA:  MOVWF  00
042BC:  MOVF   x87,W
042BE:  SUBWFB x89,W
042C0:  MOVWF  03
042C2:  MOVF   00,W
042C4:  XORLW  FF
042C6:  ADDLW  F8
042C8:  MOVWF  00
042CA:  MOVLW  1B
042CC:  SUBFWB 03,F
042CE:  MOVFF  00,01
042D2:  MOVFF  03,02
042D6:  BRA    4310
....................    } 
042D8:  BRA    4310
....................    else if ( WritePT.Val == ReadPT.Val ) 
042DA:  MOVF   x86,W
042DC:  SUBWF  x88,W
042DE:  BNZ   42F2
042E0:  MOVF   x87,W
042E2:  SUBWF  x89,W
042E4:  BNZ   42F2
....................    { 
....................       return RXSIZE - 1; 
042E6:  MOVLW  F7
042E8:  MOVWF  01
042EA:  MOVLW  1B
042EC:  MOVWF  02
042EE:  BRA    4310
....................    } 
042F0:  BRA    4310
....................    else 
....................     { 
....................       return ReadPT.Val - WritePT.Val - 1; 
042F2:  MOVF   x88,W
042F4:  SUBWF  x86,W
042F6:  MOVWF  x8A
042F8:  MOVF   x89,W
042FA:  SUBWFB x87,W
042FC:  MOVWF  x8B
042FE:  MOVLW  01
04300:  SUBWF  x8A,W
04302:  MOVWF  00
04304:  MOVLW  00
04306:  SUBWFB x8B,W
04308:  MOVWF  03
0430A:  MOVFF  00,01
0430E:  MOVWF  02
....................    } 
04310:  MOVLB  0
04312:  GOTO   4594 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           *remote: Location to store the Source MAC address of the 
....................  *                      received frame. 
....................  *               *type: Location of a BYTE to store the constant 
....................  *                     MAC_UNKNOWN, ETHER_IP, or ETHER_ARP, representing 
....................  *                     the contents of the Ethernet type field. 
....................  * 
....................  * Output:          TRUE: If a packet was waiting in the RX buffer.  The 
....................  *                    remote, and type values are updated. 
....................  *               FALSE: If a packet was not pending.  remote and type are 
....................  *                     not changed. 
....................  * 
....................  * Side Effects:    Last packet is discarded if MACDiscardRx() hasn't already 
....................  *               been called. 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BOOL MACGetHeader(MAC_ADDR *remote, BYTE* type) 
.................... { 
....................    ENC_PREAMBLE header; 
....................  
....................    // Test if at least one packet has been received and is waiting 
....................    BankSel(EPKTCNT); 
*
02CF6:  MOVLW  01
02CF8:  MOVLB  9
02CFA:  MOVWF  xA9
02CFC:  MOVLW  19
02CFE:  MOVWF  xA8
02D00:  MOVLB  0
02D02:  CALL   1612
....................    if(ReadETHReg((BYTE)EPKTCNT).Val == 0) 
02D06:  MOVLW  19
02D08:  MOVLB  9
02D0A:  MOVWF  xA5
02D0C:  MOVLB  0
02D0E:  CALL   157A
02D12:  MOVFF  01,917
02D16:  MOVLB  9
02D18:  MOVF   x17,F
02D1A:  BNZ   2D22
....................       return FALSE; 
02D1C:  MOVLW  00
02D1E:  MOVWF  01
02D20:  BRA    2E3A
....................  
....................    // Make absolutely certain that any previous packet was discarded 
....................    if(WasDiscarded == FALSE) 
02D22:  MOVLB  3
02D24:  BTFSC  x93.0
02D26:  BRA    2D36
....................    { 
....................       MACDiscardRx(); 
02D28:  MOVLB  0
02D2A:  RCALL  2C06
....................       return FALSE; 
02D2C:  MOVLW  00
02D2E:  MOVWF  01
02D30:  MOVLB  9
02D32:  BRA    2E3A
02D34:  MOVLB  3
....................    } 
....................  
....................    // Save the location of this packet 
....................    CurrentPacketLocation.Val = NextPacketLocation.Val; 
02D36:  MOVFF  390,392
02D3A:  MOVFF  38F,391
....................  
....................    // Set the SPI read pointer to the beginning of the next unprocessed packet 
....................    BankSel(ERDPTL); 
02D3E:  MOVLB  9
02D40:  CLRF   xA9
02D42:  CLRF   xA8
02D44:  MOVLB  0
02D46:  CALL   1612
....................    WriteReg(ERDPTL, NextPacketLocation.v[0]); 
02D4A:  MOVLB  9
02D4C:  CLRF   xAB
02D4E:  MOVFF  38F,9AC
02D52:  MOVLB  0
02D54:  CALL   15B8
....................    WriteReg(ERDPTH, NextPacketLocation.v[1]); 
02D58:  MOVLW  01
02D5A:  MOVLB  9
02D5C:  MOVWF  xAB
02D5E:  MOVFF  390,9AC
02D62:  MOVLB  0
02D64:  CALL   15B8
....................  
....................    // Obtain the MAC header from the Ethernet buffer 
....................    MACGetArray((BYTE*)&header, sizeof(header)); 
02D68:  MOVLW  09
02D6A:  MOVLB  9
02D6C:  MOVWF  x18
02D6E:  MOVLW  03
02D70:  MOVWF  x17
02D72:  MOVFF  918,995
02D76:  MOVWF  x94
02D78:  CLRF   x97
02D7A:  MOVLW  14
02D7C:  MOVWF  x96
02D7E:  MOVLB  0
02D80:  RCALL  2C7C
....................  
....................    // The EtherType field, like most items transmitted on the Ethernet medium 
....................    // are in big endian. 
....................     header.Type.Val = swaps(header.Type.Val); 
02D82:  MOVFF  916,9A6
02D86:  MOVFF  915,9A5
02D8A:  RCALL  2CE0
02D8C:  MOVFF  02,916
02D90:  MOVFF  01,915
....................  
....................    // Validate the data returned from the ENC28J60.  Random data corruption, 
....................    // such as if a single SPI bit error occurs while communicating or a 
....................    // momentary power glitch could cause this to occur in rare circumstances. 
....................    if(header.NextPacketPointer > RXSTOP || ((BYTE_VAL*)(&header.NextPacketPointer))->bits.b0 || 
....................       header.StatusVector.bits.Zero || 
....................       header.StatusVector.bits.CRCError || 
....................       header.StatusVector.bits.ByteCount > 1518 || 
....................       !header.StatusVector.bits.ReceiveOk) 
02D94:  MOVLB  9
02D96:  MOVF   x04,W
02D98:  SUBLW  1A
02D9A:  BC    2DA6
02D9C:  XORLW  FF
02D9E:  BNZ   2DD2
02DA0:  MOVF   x03,W
02DA2:  SUBLW  F7
02DA4:  BNC   2DD2
02DA6:  MOVLW  09
02DA8:  MOVWF  x18
02DAA:  MOVLW  03
02DAC:  MOVWF  FE9
02DAE:  MOVFF  918,FEA
02DB2:  BTFSC  FEF.0
02DB4:  BRA    2DD2
02DB6:  BTFSC  x08.7
02DB8:  BRA    2DD2
02DBA:  BTFSC  x07.4
02DBC:  BRA    2DD2
02DBE:  MOVF   x06,W
02DC0:  SUBLW  04
02DC2:  BC    2DCE
02DC4:  XORLW  FF
02DC6:  BNZ   2DD2
02DC8:  MOVF   x05,W
02DCA:  SUBLW  EE
02DCC:  BNC   2DD2
02DCE:  BTFSC  x07.7
02DD0:  BRA    2DD4
....................    { 
....................       //Reset(); 
....................       reset_cpu(); 
02DD2:  RESET
....................    } 
....................  
....................    // Save the location where the hardware will write the next packet to 
....................    NextPacketLocation.Val = header.NextPacketPointer; 
02DD4:  MOVFF  904,390
02DD8:  MOVFF  903,38F
....................  
....................    // Return the Ethernet frame's Source MAC address field to the caller 
....................    // This parameter is useful for replying to requests without requiring an 
....................    // ARP cycle. 
....................     memcpy((void*)remote->v, (void*)header.SourceMACAddr.v, sizeof(*remote)); 
02DDC:  MOVLB  9
02DDE:  MOVFF  900,03
02DE2:  MOVFF  8FF,917
02DE6:  MOVFF  900,918
02DEA:  MOVFF  900,FEA
02DEE:  MOVFF  8FF,FE9
02DF2:  MOVLW  09
02DF4:  MOVWF  FE2
02DF6:  MOVLW  0F
02DF8:  MOVWF  FE1
02DFA:  MOVLW  06
02DFC:  MOVWF  01
02DFE:  MOVFF  FE6,FEE
02E02:  DECFSZ 01,F
02E04:  BRA    2DFE
....................  
....................    // Return a simplified version of the EtherType field to the caller 
....................     *type = MAC_UNKNOWN; 
02E06:  MOVFF  902,03
02E0A:  MOVF   x01,W
02E0C:  MOVWF  FE9
02E0E:  MOVFF  03,FEA
02E12:  SETF   FEF
....................     if( (header.Type.v[1] == 0x08u) && 
....................        ((header.Type.v[0] == ETHER_IP) || (header.Type.v[0] == ETHER_ARP)) ) 
02E14:  MOVF   x16,W
02E16:  SUBLW  08
02E18:  BNZ   2E30
02E1A:  MOVF   x15,F
02E1C:  BZ    2E24
02E1E:  MOVF   x15,W
02E20:  SUBLW  06
02E22:  BNZ   2E30
....................     { 
....................        *type = header.Type.v[0]; 
02E24:  MOVFF  901,FE9
02E28:  MOVFF  902,FEA
02E2C:  MOVFF  915,FEF
....................     } 
....................  
....................     // Mark this packet as discardable 
....................     WasDiscarded = FALSE; 
02E30:  MOVLB  3
02E32:  BCF    x93.0
....................    return TRUE; 
02E34:  MOVLW  01
02E36:  MOVWF  01
02E38:  MOVLB  9
02E3A:  MOVLB  0
02E3C:  GOTO   5ADA (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void    MACPutHeader(MAC_ADDR *remote, 
....................  *                                    BYTE type, 
....................  *                                   WORD dataLen) 
....................  * 
....................  * PreCondition:    MACIsTxReady() must return TRUE. 
....................  * 
....................  * Input:           *remote: Pointer to memory which contains the destination 
....................  *                       MAC address (6 bytes) 
....................  *               type: The constant ETHER_ARP or ETHER_IP, defining which 
....................  *                    value to write into the Ethernet header's type field. 
....................  *               dataLen: Length of the Ethernet data payload 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Because of the dataLen parameter, it is probably 
....................  *               advantagous to call this function immediately before 
....................  *               transmitting a packet rather than initially when the 
....................  *               packet is first created.  The order in which the packet 
....................  *               is constructed (header first or data first) is not 
....................  *               important. 
....................  *****************************************************************************/ 
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen) 
.................... { 
....................  
....................    BankSel(EWRPTL); 
*
0314E:  MOVLB  9
03150:  CLRF   xA9
03152:  MOVLW  02
03154:  MOVWF  xA8
03156:  MOVLB  0
03158:  CALL   1612
....................  
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(EWRPTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TxBuffers[CurrentTxBuffer].StartAddress.Val; 
....................    TxBuffers[CurrentTxBuffer].EndAddress.Val = dataLen; 
.................... #else 
....................    // Set the SPI write pointer to the beginning of the transmit buffer 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
0315C:  MOVLW  02
0315E:  MOVLB  9
03160:  MOVWF  xAB
03162:  MOVLW  F8
03164:  MOVWF  xAC
03166:  MOVLB  0
03168:  CALL   15B8
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
0316C:  MOVLW  03
0316E:  MOVLB  9
03170:  MOVWF  xAB
03172:  MOVLW  1B
03174:  MOVWF  xAC
03176:  MOVLB  0
03178:  CALL   15B8
....................  
....................    // Calculate where to put the TXND pointer 
....................     dataLen += (WORD)sizeof(ETHER_HEADER) + TXSTART; 
0317C:  MOVLW  06
0317E:  MOVLB  9
03180:  ADDWF  xA6,F
03182:  MOVLW  1C
03184:  ADDWFC xA7,F
....................  
....................    // Write the TXND pointer into the registers, given the dataLen given 
....................    WriteReg(ETXNDL, ((WORD_VAL*)&dataLen)->v[0]); 
03186:  MOVLW  09
03188:  MOVWF  xA9
0318A:  MOVLW  A6
0318C:  MOVWF  xA8
0318E:  MOVWF  FE9
03190:  MOVFF  9A9,FEA
03194:  MOVFF  FEF,9AA
03198:  MOVLW  06
0319A:  MOVWF  xAB
0319C:  MOVFF  9AA,9AC
031A0:  MOVLB  0
031A2:  CALL   15B8
....................    WriteReg(ETXNDH, ((WORD_VAL*)&dataLen)->v[1]); 
031A6:  MOVLW  09
031A8:  MOVLB  9
031AA:  MOVWF  xA9
031AC:  MOVLW  A6
031AE:  MOVWF  xA8
031B0:  MOVLW  01
031B2:  ADDWF  xA8,W
031B4:  MOVWF  FE9
031B6:  MOVLW  00
031B8:  ADDWFC xA9,W
031BA:  MOVWF  FEA
031BC:  MOVFF  FEF,9AA
031C0:  MOVLW  07
031C2:  MOVWF  xAB
031C4:  MOVFF  9AA,9AC
031C8:  MOVLB  0
031CA:  CALL   15B8
.................... #endif 
....................  
....................  
....................    // Set the per-packet control byte and write the Ethernet destination 
....................    // address 
....................    MACPut(0x00);   // Use default control configuration 
031CE:  MOVLB  9
031D0:  CLRF   xA9
031D2:  MOVLB  0
031D4:  RCALL  30E2
....................     MACPutArray((BYTE*)remote, sizeof(*remote)); 
031D6:  MOVFF  9A4,9AB
031DA:  MOVFF  9A3,9AA
031DE:  MOVLB  9
031E0:  CLRF   xAD
031E2:  MOVLW  06
031E4:  MOVWF  xAC
031E6:  MOVLB  0
031E8:  RCALL  3100
....................  
....................    // Write our MAC address in the Ethernet source field 
....................    MACPutArray((BYTE*)&AppConfig.MyMACAddr, sizeof(AppConfig.MyMACAddr)); 
031EA:  MOVLW  03
031EC:  MOVLB  9
031EE:  MOVWF  xA9
031F0:  MOVLW  57
031F2:  MOVWF  xA8
031F4:  MOVFF  9A9,9AB
031F8:  MOVWF  xAA
031FA:  CLRF   xAD
031FC:  MOVLW  06
031FE:  MOVWF  xAC
03200:  MOVLB  0
03202:  RCALL  3100
....................  
....................    // Write the appropriate Ethernet Type WORD for the protocol being used 
....................     MACPut(0x08); 
03204:  MOVLW  08
03206:  MOVLB  9
03208:  MOVWF  xA9
0320A:  MOVLB  0
0320C:  RCALL  30E2
....................     MACPut((type == MAC_IP) ? ETHER_IP : ETHER_ARP); 
0320E:  MOVLB  9
03210:  MOVF   xA5,F
03212:  BNZ   3218
03214:  MOVLW  00
03216:  BRA    321A
03218:  MOVLW  06
0321A:  MOVWF  xA8
0321C:  MOVWF  xA9
0321E:  MOVLB  0
03220:  RCALL  30E2
03222:  RETURN 0
.................... } 
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACFlush(void) 
....................  * 
....................  * PreCondition:    A packet has been created by calling MACPut() and 
....................  *               MACPutHeader(). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACFlush causes the current TX packet to be sent out on 
....................  *               the Ethernet medium.  The hardware MAC will take control 
....................  *               and handle CRC generation, collision retransmission and 
....................  *               other details. 
....................  * 
....................  * Note:         After transmission completes (MACIsTxReady() returns TRUE), 
....................  *               the packet can be modified and transmitted again by calling 
....................  *               MACFlush() again.  Until MACPutHeader() or MACPut() is 
....................  *               called (in the TX data area), the data in the TX buffer 
....................  *               will not be corrupted. 
....................  *****************************************************************************/ 
.................... void MACFlush(void) 
.................... { 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    // Set the packet start and end address pointers 
....................    BankSel(ETXSTL); 
....................    WriteReg(ETXSTL, TxBuffers[CurrentTxBuffer].StartAddress.v[0]); 
....................    WriteReg(ETXSTH, TxBuffers[CurrentTxBuffer].StartAddress.v[1]); 
....................    WriteReg(ETXNDL, TxBuffers[CurrentTxBuffer].EndAddress.v[0]); 
....................    WriteReg(ETXNDH, TxBuffers[CurrentTxBuffer].EndAddress.v[1]); 
....................    LastTXedBuffer = CurrentTxBuffer; 
....................    TxBuffers[CurrentTxBuffer].Flags.bTransmitted = TRUE; 
.................... #endif 
....................  
....................    // Reset transmit logic if a TX Error has previously occured 
....................    // This is a silicon errata workaround 
....................    if(ReadETHReg(EIR).EIRbits.TXERIF) 
03224:  MOVLW  1C
03226:  MOVLB  9
03228:  MOVWF  xA5
0322A:  MOVLB  0
0322C:  CALL   157A
03230:  MOVFF  01,992
03234:  MOVLW  00
03236:  MOVLB  9
03238:  BTFSC  01.1
0323A:  MOVLW  01
0323C:  XORLW  00
0323E:  BZ    3260
....................    { 
....................       BFSReg(ECON1, ECON1_TXRST); 
03240:  MOVLW  1F
03242:  MOVWF  xAD
03244:  MOVLW  80
03246:  MOVWF  xAE
03248:  MOVLB  0
0324A:  CALL   15F4
....................       BFCReg(ECON1, ECON1_TXRST); 
0324E:  MOVLW  1F
03250:  MOVLB  9
03252:  MOVWF  xAA
03254:  MOVLW  80
03256:  MOVWF  xAB
03258:  MOVLB  0
0325A:  CALL   15D6
0325E:  MOVLB  9
....................    } 
....................    BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
03260:  MOVLW  1C
03262:  MOVWF  xAA
03264:  MOVLW  0A
03266:  MOVWF  xAB
03268:  MOVLB  0
0326A:  CALL   15D6
....................  
....................    // Start the transmission 
....................    // After transmission completes (MACIsTxReady() returns TRUE), the packet 
....................    // can be modified and transmitted again by calling MACFlush() again. 
....................    // Until MACPutHeader() is called, the data in the TX buffer will not be 
....................    // corrupted. 
....................    BFSReg(ECON1, ECON1_TXRTS); 
0326E:  MOVLW  1F
03270:  MOVLB  9
03272:  MOVWF  xAD
03274:  MOVLW  08
03276:  MOVWF  xAE
03278:  MOVLB  0
0327A:  CALL   15F4
....................  
....................    // Revision B5 silicon errata workaround 
....................    if(ENCRevID == 0x05) 
0327E:  MOVLB  3
03280:  MOVF   x94,W
03282:  SUBLW  05
03284:  BTFSS  FD8.2
03286:  BRA    3450
....................    { 
....................       while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
03288:  MOVLW  1C
0328A:  MOVLB  9
0328C:  MOVWF  xA5
0328E:  MOVLB  0
03290:  CALL   157A
03294:  MOVFF  01,992
03298:  MOVLB  9
0329A:  MOVF   01,W
0329C:  ANDLW  0A
0329E:  BTFSS  FD8.2
032A0:  BRA    32A6
032A2:  MOVLB  3
032A4:  BRA    3288
....................       if(ReadETHReg(EIR).EIRbits.TXERIF) 
032A6:  MOVLW  1C
032A8:  MOVWF  xA5
032AA:  MOVLB  0
032AC:  CALL   157A
032B0:  MOVFF  01,992
032B4:  MOVLW  00
032B6:  MOVLB  9
032B8:  BTFSC  01.1
032BA:  MOVLW  01
032BC:  XORLW  00
032BE:  BTFSC  FD8.2
032C0:  BRA    344E
....................       { 
....................          WORD_VAL ReadPtrSave; 
....................          WORD_VAL TXEnd; 
....................          TXSTATUS TXStatus; 
....................          BYTE i; 
....................  
....................          // Cancel the previous transmission if it has become stuck set 
....................          BFCReg(ECON1, ECON1_TXRTS); 
032C2:  MOVLW  1F
032C4:  MOVWF  xAA
032C6:  MOVLW  08
032C8:  MOVWF  xAB
032CA:  MOVLB  0
032CC:  CALL   15D6
....................  
....................          // Save the current read pointer (controlled by application) 
....................          BankSel(ERDPTL); 
032D0:  MOVLB  9
032D2:  CLRF   xA9
032D4:  CLRF   xA8
032D6:  MOVLB  0
032D8:  CALL   1612
....................          ReadPtrSave.v[0] = ReadETHReg(ERDPTL).Val; 
032DC:  MOVLB  9
032DE:  CLRF   xA5
032E0:  MOVLB  0
032E2:  CALL   157A
032E6:  MOVFF  01,986
....................          ReadPtrSave.v[1] = ReadETHReg(ERDPTH).Val; 
032EA:  MOVLW  01
032EC:  MOVLB  9
032EE:  MOVWF  xA5
032F0:  MOVLB  0
032F2:  CALL   157A
032F6:  MOVFF  01,987
....................  
....................          // Get the location of the transmit status vector 
....................          TXEnd.v[0] = ReadETHReg(ETXNDL).Val; 
032FA:  MOVLW  06
032FC:  MOVLB  9
032FE:  MOVWF  xA5
03300:  MOVLB  0
03302:  CALL   157A
03306:  MOVFF  01,988
....................          TXEnd.v[1] = ReadETHReg(ETXNDH).Val; 
0330A:  MOVLW  07
0330C:  MOVLB  9
0330E:  MOVWF  xA5
03310:  MOVLB  0
03312:  CALL   157A
03316:  MOVFF  01,989
....................          TXEnd.Val++; 
0331A:  MOVLB  9
0331C:  INCF   x88,F
0331E:  BTFSC  FD8.2
03320:  INCF   x89,F
....................  
....................          // Read the transmit status vector 
....................          WriteReg(ERDPTL, TXEnd.v[0]); 
03322:  CLRF   xAB
03324:  MOVFF  988,9AC
03328:  MOVLB  0
0332A:  CALL   15B8
....................          WriteReg(ERDPTH, TXEnd.v[1]); 
0332E:  MOVLW  01
03330:  MOVLB  9
03332:  MOVWF  xAB
03334:  MOVFF  989,9AC
03338:  MOVLB  0
0333A:  CALL   15B8
....................          MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
0333E:  MOVLW  09
03340:  MOVLB  9
03342:  MOVWF  x93
03344:  MOVLW  8A
03346:  MOVWF  x92
03348:  MOVFF  993,995
0334C:  MOVWF  x94
0334E:  CLRF   x97
03350:  MOVLW  07
03352:  MOVWF  x96
03354:  MOVLB  0
03356:  RCALL  2C7C
....................  
....................          // Implement retransmission if a late collision occured (this can 
....................          // happen on B5 when certain link pulses arrive at the same time 
....................          // as the transmission) 
....................          for(i = 0; i < 16; i++) 
03358:  MOVLB  9
0335A:  CLRF   x91
0335C:  MOVF   x91,W
0335E:  SUBLW  0F
03360:  BNC   3430
....................          { 
....................             if(ReadETHReg(EIR).EIRbits.TXERIF && TXStatus.bits.LateCollision) 
03362:  MOVLW  1C
03364:  MOVWF  xA5
03366:  MOVLB  0
03368:  CALL   157A
0336C:  MOVFF  01,992
03370:  MOVLW  00
03372:  MOVLB  9
03374:  BTFSC  01.1
03376:  MOVLW  01
03378:  XORLW  00
0337A:  BZ    3426
0337C:  BTFSS  x8D.5
0337E:  BRA    3426
....................             { 
....................                // Reset the TX logic 
....................                BFSReg(ECON1, ECON1_TXRST); 
03380:  MOVLW  1F
03382:  MOVWF  xAD
03384:  MOVLW  80
03386:  MOVWF  xAE
03388:  MOVLB  0
0338A:  CALL   15F4
....................                BFCReg(ECON1, ECON1_TXRST); 
0338E:  MOVLW  1F
03390:  MOVLB  9
03392:  MOVWF  xAA
03394:  MOVLW  80
03396:  MOVWF  xAB
03398:  MOVLB  0
0339A:  CALL   15D6
....................                BFCReg(EIR, EIR_TXERIF | EIR_TXIF); 
0339E:  MOVLW  1C
033A0:  MOVLB  9
033A2:  MOVWF  xAA
033A4:  MOVLW  0A
033A6:  MOVWF  xAB
033A8:  MOVLB  0
033AA:  CALL   15D6
....................  
....................                // Transmit the packet again 
....................                BFSReg(ECON1, ECON1_TXRTS); 
033AE:  MOVLW  1F
033B0:  MOVLB  9
033B2:  MOVWF  xAD
033B4:  MOVLW  08
033B6:  MOVWF  xAE
033B8:  MOVLB  0
033BA:  CALL   15F4
....................                while(!(ReadETHReg(EIR).Val & (EIR_TXERIF | EIR_TXIF))); 
033BE:  MOVLW  1C
033C0:  MOVLB  9
033C2:  MOVWF  xA5
033C4:  MOVLB  0
033C6:  CALL   157A
033CA:  MOVFF  01,992
033CE:  MOVLB  9
033D0:  MOVF   01,W
033D2:  ANDLW  0A
033D4:  BTFSS  FD8.2
033D6:  BRA    33DC
033D8:  MOVLB  0
033DA:  BRA    33BE
....................  
....................                // Cancel the previous transmission if it has become stuck set 
....................                BFCReg(ECON1, ECON1_TXRTS); 
033DC:  MOVLW  1F
033DE:  MOVWF  xAA
033E0:  MOVLW  08
033E2:  MOVWF  xAB
033E4:  MOVLB  0
033E6:  CALL   15D6
....................  
....................                // Read transmit status vector 
....................                WriteReg(ERDPTL, TXEnd.v[0]); 
033EA:  MOVLB  9
033EC:  CLRF   xAB
033EE:  MOVFF  988,9AC
033F2:  MOVLB  0
033F4:  CALL   15B8
....................                WriteReg(ERDPTH, TXEnd.v[1]); 
033F8:  MOVLW  01
033FA:  MOVLB  9
033FC:  MOVWF  xAB
033FE:  MOVFF  989,9AC
03402:  MOVLB  0
03404:  CALL   15B8
....................                MACGetArray((BYTE*)&TXStatus, sizeof(TXStatus)); 
03408:  MOVLW  09
0340A:  MOVLB  9
0340C:  MOVWF  x93
0340E:  MOVLW  8A
03410:  MOVWF  x92
03412:  MOVFF  993,995
03416:  MOVWF  x94
03418:  CLRF   x97
0341A:  MOVLW  07
0341C:  MOVWF  x96
0341E:  MOVLB  0
03420:  RCALL  2C7C
....................             } 
03422:  BRA    342A
03424:  MOVLB  9
....................             else 
....................             { 
....................                break; 
03426:  BRA    3430
03428:  MOVLB  0
....................             } 
0342A:  MOVLB  9
0342C:  INCF   x91,F
0342E:  BRA    335C
....................          } 
....................  
....................          // Restore the current read pointer 
....................          WriteReg(ERDPTL, ReadPtrSave.v[0]); 
03430:  CLRF   xAB
03432:  MOVFF  986,9AC
03436:  MOVLB  0
03438:  CALL   15B8
....................          WriteReg(ERDPTH, ReadPtrSave.v[1]); 
0343C:  MOVLW  01
0343E:  MOVLB  9
03440:  MOVWF  xAB
03442:  MOVFF  987,9AC
03446:  MOVLB  0
03448:  CALL   15B8
0344C:  MOVLB  9
0344E:  MOVLB  3
....................       } 
....................    } 
03450:  MOVLB  0
03452:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetRxBuffer(WORD offset) 
....................  * 
....................  * PreCondition:    A packet has been obtained by calling MACGetHeader() and 
....................  *               getting a TRUE result. 
....................  * 
....................  * Input:           offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         RXSTOP must be statically defined as being > RXSTART for 
....................  *               this function to work correctly.  In other words, do not 
....................  *               define an RX buffer which spans the 0x1FFF->0x0000 memory 
....................  *               boundary. 
....................  *****************************************************************************/ 
.................... void MACSetRxBuffer(WORD offset) 
.................... { 
....................    WORD_VAL ReadPT; 
....................  
....................    // Determine the address of the beginning of the entire packet 
....................    // and adjust the address to the desired location 
....................    ReadPT.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
0378C:  MOVLW  14
0378E:  MOVLB  3
03790:  ADDWF  x91,W
03792:  MOVLB  9
03794:  MOVWF  x35
03796:  MOVLW  00
03798:  MOVLB  3
0379A:  ADDWFC x92,W
0379C:  MOVLB  9
0379E:  MOVWF  x36
037A0:  MOVF   x31,W
037A2:  ADDWF  x35,W
037A4:  MOVWF  x33
037A6:  MOVF   x32,W
037A8:  ADDWFC x36,W
037AA:  MOVWF  x34
....................  
....................    // Since the receive buffer is circular, adjust if a wraparound is needed 
....................    if ( ReadPT.Val > RXSTOP ) 
037AC:  MOVF   x34,W
037AE:  SUBLW  1A
037B0:  BC    37C4
037B2:  XORLW  FF
037B4:  BNZ   37BC
037B6:  MOVF   x33,W
037B8:  SUBLW  F7
037BA:  BC    37C4
....................       ReadPT.Val -= RXSIZE; 
037BC:  MOVLW  F8
037BE:  SUBWF  x33,F
037C0:  MOVLW  1B
037C2:  SUBWFB x34,F
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(ERDPTL); 
037C4:  CLRF   xA9
037C6:  CLRF   xA8
037C8:  MOVLB  0
037CA:  CALL   1612
....................    WriteReg(ERDPTL, ReadPT.v[0]); 
037CE:  MOVLB  9
037D0:  CLRF   xAB
037D2:  MOVFF  933,9AC
037D6:  MOVLB  0
037D8:  CALL   15B8
....................    WriteReg(ERDPTH, ReadPT.v[1]); 
037DC:  MOVLW  01
037DE:  MOVLB  9
037E0:  MOVWF  xAB
037E2:  MOVFF  934,9AC
037E6:  MOVLB  0
037E8:  CALL   15B8
....................    WriteReg(EWRPTL, ReadPT.v[0]); 
037EC:  MOVLW  02
037EE:  MOVLB  9
037F0:  MOVWF  xAB
037F2:  MOVFF  933,9AC
037F6:  MOVLB  0
037F8:  CALL   15B8
....................    WriteReg(EWRPTH, ReadPT.v[1]); 
037FC:  MOVLW  03
037FE:  MOVLB  9
03800:  MOVWF  xAB
03802:  MOVFF  934,9AC
03806:  MOVLB  0
03808:  CALL   15B8
0380C:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetTxBuffer(BUFFER buffer, WORD offset) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           buffer: BYTE specifying which transmit buffer to seek 
....................  *                     within.  If MAC_TX_BUFFER_COUNT <= 1, this 
....................  *                     parameter is not used. 
....................  *               offset: WORD specifying how many bytes beyond the Ethernet 
....................  *                     header's type field to relocate the SPI read and 
....................  *                     write pointers. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SPI read and write pointers are updated.  All calls to 
....................  *               MACGet(), MACPut(), MACGetArray(), and MACPutArray(), 
....................  *               and various other functions will use these new values. 
....................  * 
....................  * Note:         None 
....................  *****************************************************************************/ 
.................... void MACSetTxBuffer(BUFFER buffer, WORD offset) 
.................... { 
....................     CurrentTxBuffer = buffer; 
*
03034:  MOVFF  99F,38A
....................  
....................    // Calculate the proper address.  Since the TX memory area is not circular, 
....................    // no wrapparound checks are necessary. +1 adjustment is needed because of 
....................    // the per packet control byte which preceeds the packet in the TX memory 
....................    // area. 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    offset += TxBuffers[buffer].StartAddress.Val + 1 + sizeof(ETHER_HEADER); 
.................... #else 
....................    offset += TXSTART + 1 + sizeof(ETHER_HEADER); 
03038:  MOVLW  07
0303A:  MOVLB  9
0303C:  ADDWF  xA0,F
0303E:  MOVLW  1C
03040:  ADDWFC xA1,F
.................... #endif 
....................  
....................    // Set the SPI read and write pointers to the new calculated value 
....................    BankSel(EWRPTL); 
03042:  CLRF   xA9
03044:  MOVLW  02
03046:  MOVWF  xA8
03048:  MOVLB  0
0304A:  CALL   1612
....................    WriteReg(ERDPTL, ((WORD_VAL*)&offset)->v[0]); 
0304E:  MOVLW  09
03050:  MOVLB  9
03052:  MOVWF  xA3
03054:  MOVLW  A0
03056:  MOVWF  xA2
03058:  MOVWF  FE9
0305A:  MOVFF  9A3,FEA
0305E:  MOVFF  FEF,9A4
03062:  CLRF   xAB
03064:  MOVFF  9A4,9AC
03068:  MOVLB  0
0306A:  CALL   15B8
....................    WriteReg(ERDPTH, ((WORD_VAL*)&offset)->v[1]); 
0306E:  MOVLW  09
03070:  MOVLB  9
03072:  MOVWF  xA3
03074:  MOVLW  A0
03076:  MOVWF  xA2
03078:  MOVLW  01
0307A:  ADDWF  xA2,W
0307C:  MOVWF  FE9
0307E:  MOVLW  00
03080:  ADDWFC xA3,W
03082:  MOVWF  FEA
03084:  MOVFF  FEF,9A4
03088:  MOVLW  01
0308A:  MOVWF  xAB
0308C:  MOVFF  9A4,9AC
03090:  MOVLB  0
03092:  CALL   15B8
....................    WriteReg(EWRPTL, ((WORD_VAL*)&offset)->v[0]); 
03096:  MOVLW  09
03098:  MOVLB  9
0309A:  MOVWF  xA3
0309C:  MOVLW  A0
0309E:  MOVWF  xA2
030A0:  MOVWF  FE9
030A2:  MOVFF  9A3,FEA
030A6:  MOVFF  FEF,9A4
030AA:  MOVLW  02
030AC:  MOVWF  xAB
030AE:  MOVFF  9A4,9AC
030B2:  MOVLB  0
030B4:  CALL   15B8
....................    WriteReg(EWRPTH, ((WORD_VAL*)&offset)->v[1]); 
030B8:  MOVLW  09
030BA:  MOVLB  9
030BC:  MOVWF  xA3
030BE:  MOVLW  A0
030C0:  MOVWF  xA2
030C2:  MOVLW  01
030C4:  ADDWF  xA2,W
030C6:  MOVWF  FE9
030C8:  MOVLW  00
030CA:  ADDWFC xA3,W
030CC:  MOVWF  FEA
030CE:  MOVFF  FEF,9A4
030D2:  MOVLW  03
030D4:  MOVWF  xAB
030D6:  MOVFF  9A4,9AC
030DA:  MOVLB  0
030DC:  CALL   15B8
030E0:  RETURN 0
.................... } 
....................  
....................  
.................... #if defined(MCHP_MAC) 
.................... // MACCalcRxChecksum() and MACCalcTxChecksum() use the DMA module to calculate 
.................... // checksums.  These two functions have been tested. 
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcRxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcRxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Add the offset requested by firmware plus the Ethernet header 
....................    temp.Val = CurrentPacketLocation.Val + sizeof(ENC_PREAMBLE) + offset; 
*
0367E:  MOVLW  14
03680:  MOVLB  3
03682:  ADDWF  x91,W
03684:  MOVLB  9
03686:  MOVWF  x5E
03688:  MOVLW  00
0368A:  MOVLB  3
0368C:  ADDWFC x92,W
0368E:  MOVLB  9
03690:  MOVWF  x5F
03692:  MOVF   x58,W
03694:  ADDWF  x5E,W
03696:  MOVWF  x5C
03698:  MOVF   x59,W
0369A:  ADDWFC x5F,W
0369C:  MOVWF  x5D
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
0369E:  MOVF   x5D,W
036A0:  SUBLW  1A
036A2:  BC    36B6
036A4:  XORLW  FF
036A6:  BNZ   36AE
036A8:  MOVF   x5C,W
036AA:  SUBLW  F7
036AC:  BC    36B6
....................    { 
....................       temp.Val -= RXSIZE; 
036AE:  MOVLW  F8
036B0:  SUBWF  x5C,F
036B2:  MOVLW  1B
036B4:  SUBWFB x5D,F
....................    } 
....................  
....................    // Program the start address of the DMA 
....................    BankSel(EDMASTL); 
036B6:  CLRF   xA9
036B8:  MOVLW  10
036BA:  MOVWF  xA8
036BC:  MOVLB  0
036BE:  CALL   1612
....................    WriteReg(EDMASTL, temp.v[0]); 
036C2:  MOVLW  10
036C4:  MOVLB  9
036C6:  MOVWF  xAB
036C8:  MOVFF  95C,9AC
036CC:  MOVLB  0
036CE:  CALL   15B8
....................    WriteReg(EDMASTH, temp.v[1]); 
036D2:  MOVLW  11
036D4:  MOVLB  9
036D6:  MOVWF  xAB
036D8:  MOVFF  95D,9AC
036DC:  MOVLB  0
036DE:  CALL   15B8
....................  
....................    // Calculate the end address, given the start address and len 
....................    temp.Val += len-1; 
036E2:  MOVLW  01
036E4:  MOVLB  9
036E6:  SUBWF  x5A,W
036E8:  MOVWF  00
036EA:  MOVLW  00
036EC:  SUBWFB x5B,W
036EE:  MOVWF  03
036F0:  MOVF   00,W
036F2:  ADDWF  x5C,F
036F4:  MOVF   03,W
036F6:  ADDWFC x5D,F
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
036F8:  MOVF   x5D,W
036FA:  SUBLW  1A
036FC:  BC    3710
036FE:  XORLW  FF
03700:  BNZ   3708
03702:  MOVF   x5C,W
03704:  SUBLW  F7
03706:  BC    3710
....................    { 
....................       temp.Val -= RXSIZE; 
03708:  MOVLW  F8
0370A:  SUBWF  x5C,F
0370C:  MOVLW  1B
0370E:  SUBWFB x5D,F
....................    } 
....................  
....................    // Program the end address of the DMA 
....................    WriteReg(EDMANDL, temp.v[0]); 
03710:  MOVLW  12
03712:  MOVWF  xAB
03714:  MOVFF  95C,9AC
03718:  MOVLB  0
0371A:  CALL   15B8
....................    WriteReg(EDMANDH, temp.v[1]); 
0371E:  MOVLW  13
03720:  MOVLB  9
03722:  MOVWF  xAB
03724:  MOVFF  95D,9AC
03728:  MOVLB  0
0372A:  CALL   15B8
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
0372E:  MOVLW  1F
03730:  MOVLB  9
03732:  MOVWF  xAD
03734:  MOVLW  30
03736:  MOVWF  xAE
03738:  MOVLB  0
0373A:  CALL   15F4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
0373E:  MOVLW  1F
03740:  MOVLB  9
03742:  MOVWF  xA5
03744:  MOVLB  0
03746:  CALL   157A
0374A:  MOVFF  01,95E
0374E:  MOVLW  00
03750:  MOVLB  9
03752:  BTFSC  01.5
03754:  MOVLW  01
03756:  XORLW  00
03758:  BTFSC  FD8.2
0375A:  BRA    3760
0375C:  MOVLB  0
0375E:  BRA    373E
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
03760:  MOVLW  16
03762:  MOVWF  xA5
03764:  MOVLB  0
03766:  CALL   157A
0376A:  MOVFF  01,95D
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
0376E:  MOVLW  17
03770:  MOVLB  9
03772:  MOVWF  xA5
03774:  MOVLB  0
03776:  CALL   157A
0377A:  MOVFF  01,95C
....................    return temp.Val; 
0377E:  MOVLB  9
03780:  MOVFF  95C,01
03784:  MOVFF  95D,02
03788:  MOVLB  0
0378A:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACCalcTxChecksum(WORD offset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           offset   - Number of bytes beyond the beginning of the 
....................  *                     Ethernet data (first byte after the type field) 
....................  *                     where the checksum should begin 
....................  *               len      - Total number of bytes to include in the checksum 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself using the hardware DMA module 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACCalcTxChecksum(WORD offset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Program the start address of the DMA, after adjusting for the Ethernet 
....................    // header 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................    temp.Val = TxBuffers[CurrentTxBuffer].StartAddress.Val + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
.................... #else 
....................    temp.Val = TXSTART + sizeof(ETHER_HEADER) 
....................             + offset + 1;   // +1 needed to account for per packet control byte 
*
04316:  MOVLW  06
04318:  MOVLB  9
0431A:  ADDWF  x9F,W
0431C:  MOVWF  xA5
0431E:  MOVLW  1C
04320:  ADDWFC xA0,W
04322:  MOVWF  xA6
04324:  MOVLW  01
04326:  ADDWF  xA5,W
04328:  MOVWF  xA3
0432A:  MOVLW  00
0432C:  ADDWFC xA6,W
0432E:  MOVWF  xA4
.................... #endif 
....................    BankSel(EDMASTL); 
04330:  CLRF   xA9
04332:  MOVLW  10
04334:  MOVWF  xA8
04336:  MOVLB  0
04338:  CALL   1612
....................    WriteReg(EDMASTL, temp.v[0]); 
0433C:  MOVLW  10
0433E:  MOVLB  9
04340:  MOVWF  xAB
04342:  MOVFF  9A3,9AC
04346:  MOVLB  0
04348:  CALL   15B8
....................    WriteReg(EDMASTH, temp.v[1]); 
0434C:  MOVLW  11
0434E:  MOVLB  9
04350:  MOVWF  xAB
04352:  MOVFF  9A4,9AC
04356:  MOVLB  0
04358:  CALL   15B8
....................  
....................    // Program the end address of the DMA. 
....................    temp.Val += len-1; 
0435C:  MOVLW  01
0435E:  MOVLB  9
04360:  SUBWF  xA1,W
04362:  MOVWF  00
04364:  MOVLW  00
04366:  SUBWFB xA2,W
04368:  MOVWF  03
0436A:  MOVF   00,W
0436C:  ADDWF  xA3,F
0436E:  MOVF   03,W
04370:  ADDWFC xA4,F
....................    WriteReg(EDMANDL, temp.v[0]); 
04372:  MOVLW  12
04374:  MOVWF  xAB
04376:  MOVFF  9A3,9AC
0437A:  MOVLB  0
0437C:  CALL   15B8
....................    WriteReg(EDMANDH, temp.v[1]); 
04380:  MOVLW  13
04382:  MOVLB  9
04384:  MOVWF  xAB
04386:  MOVFF  9A4,9AC
0438A:  MOVLB  0
0438C:  CALL   15B8
....................  
....................    // Do the checksum calculation 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
04390:  MOVLW  1F
04392:  MOVLB  9
04394:  MOVWF  xAD
04396:  MOVLW  30
04398:  MOVWF  xAE
0439A:  MOVLB  0
0439C:  CALL   15F4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
043A0:  MOVLW  1F
043A2:  MOVLB  9
043A4:  MOVWF  xA5
043A6:  MOVLB  0
043A8:  CALL   157A
043AC:  MOVFF  01,9A5
043B0:  MOVLW  00
043B2:  MOVLB  9
043B4:  BTFSC  01.5
043B6:  MOVLW  01
043B8:  XORLW  00
043BA:  BTFSC  FD8.2
043BC:  BRA    43C2
043BE:  MOVLB  0
043C0:  BRA    43A0
....................  
....................    // Swap endianness and return 
....................    temp.v[1] = ReadETHReg(EDMACSL).Val; 
043C2:  MOVLW  16
043C4:  MOVWF  xA5
043C6:  MOVLB  0
043C8:  CALL   157A
043CC:  MOVFF  01,9A4
....................    temp.v[0] = ReadETHReg(EDMACSH).Val; 
043D0:  MOVLW  17
043D2:  MOVLB  9
043D4:  MOVWF  xA5
043D6:  MOVLB  0
043D8:  CALL   157A
043DC:  MOVFF  01,9A3
....................    return temp.Val; 
043E0:  MOVLB  9
043E2:  MOVFF  9A3,01
043E6:  MOVFF  9A4,02
043EA:  MOVLB  0
043EC:  RETURN 0
.................... } 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD CalcIPBufferChecksum(WORD len) 
....................  * 
....................  * PreCondition:    Read buffer pointer set to starting of checksum data 
....................  * 
....................  * Input:           len: Total number of bytes to calculate the checksum over. 
....................  *                   The first byte included in the checksum is the byte 
....................  *                   pointed to by ERDPT, which is updated by calls to 
....................  *                   MACGet(), MACSetRxBuffer(), MACSetTxBuffer(), etc. 
....................  * 
....................  * Output:          16-bit checksum as defined by rfc 793. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        This function performs a checksum calculation in the MAC 
....................  *                  buffer itself.  The ENC28J60 has a hardware DMA module 
....................  *               which can calculate the checksum faster than software, so 
....................  *               this function replaces the CaclIPBufferChecksum() function 
....................  *               defined in the helpers.c file.  Through the use of 
....................  *               preprocessor defines, this replacement is automatic. 
....................  * 
....................  * Note:            This function works either in the RX buffer area or the TX 
....................  *               buffer area.  No validation is done on the len parameter. 
....................  *****************************************************************************/ 
.................... WORD CalcIPBufferChecksum(WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    // Take care of special cases which the DMA cannot be used for 
....................    if(len == 0u) 
*
03AF8:  MOVLB  9
03AFA:  MOVF   x86,F
03AFC:  BNZ   3B0C
03AFE:  MOVF   x87,F
03B00:  BNZ   3B0C
....................    { 
....................       return 0xFFFF; 
03B02:  MOVLW  FF
03B04:  MOVWF  01
03B06:  MOVWF  02
03B08:  BRA    3C4C
....................    } 
03B0A:  BRA    3B3A
....................    else if(len == 1u) 
03B0C:  DECFSZ x86,W
03B0E:  BRA    3B3A
03B10:  MOVF   x87,F
03B12:  BNZ   3B3A
....................    { 
....................       return ~(((WORD)MACGet())<<8); 
03B14:  MOVLB  0
03B16:  RCALL  3ACC
03B18:  MOVLB  9
03B1A:  CLRF   x8B
03B1C:  MOVFF  01,98A
03B20:  MOVFF  01,03
03B24:  MOVLW  00
03B26:  CLRF   00
03B28:  DECF   00,F
03B2A:  XORWF  00,F
03B2C:  MOVLW  FF
03B2E:  XORWF  03,F
03B30:  MOVFF  00,01
03B34:  MOVFF  03,02
03B38:  BRA    3C4C
....................    } 
....................  
....................  
....................    // Set the DMA starting address to the SPI read pointer value 
....................    BankSel(ERDPTL); 
03B3A:  CLRF   xA9
03B3C:  CLRF   xA8
03B3E:  MOVLB  0
03B40:  CALL   1612
....................    temp.v[0] = ReadETHReg(ERDPTL).Val; 
03B44:  MOVLB  9
03B46:  CLRF   xA5
03B48:  MOVLB  0
03B4A:  CALL   157A
03B4E:  MOVFF  01,988
....................    temp.v[1] = ReadETHReg(ERDPTH).Val; 
03B52:  MOVLW  01
03B54:  MOVLB  9
03B56:  MOVWF  xA5
03B58:  MOVLB  0
03B5A:  CALL   157A
03B5E:  MOVFF  01,989
....................    WriteReg(EDMASTL, temp.v[0]); 
03B62:  MOVLW  10
03B64:  MOVLB  9
03B66:  MOVWF  xAB
03B68:  MOVFF  988,9AC
03B6C:  MOVLB  0
03B6E:  CALL   15B8
....................    WriteReg(EDMASTH, temp.v[1]); 
03B72:  MOVLW  11
03B74:  MOVLB  9
03B76:  MOVWF  xAB
03B78:  MOVFF  989,9AC
03B7C:  MOVLB  0
03B7E:  CALL   15B8
....................  
....................    // See if we are calculating a checksum within the RX buffer (where 
....................    // wrapping rules apply) or TX/unused area (where wrapping rules are 
....................    // not applied) 
.................... #if RXSTART == 0 
....................    if(temp.Val <= RXSTOP) 
03B82:  MOVLB  9
03B84:  MOVF   x89,W
03B86:  SUBLW  1B
03B88:  BNC   3BC0
03B8A:  BNZ   3B92
03B8C:  MOVF   x88,W
03B8E:  SUBLW  F7
03B90:  BNC   3BC0
.................... #else 
....................    if(temp.Val >= RXSTART && temp.Val <= RXSTOP) 
.................... #endif 
....................    { 
....................       // Calculate the DMA ending address given the starting address and len 
....................       // parameter.  The DMA will follow the receive buffer wrapping boundary. 
....................       temp.Val += len-1; 
03B92:  MOVLW  01
03B94:  SUBWF  x86,W
03B96:  MOVWF  00
03B98:  MOVLW  00
03B9A:  SUBWFB x87,W
03B9C:  MOVWF  03
03B9E:  MOVF   00,W
03BA0:  ADDWF  x88,F
03BA2:  MOVF   03,W
03BA4:  ADDWFC x89,F
....................       if(temp.Val > RXSTOP) 
03BA6:  MOVF   x89,W
03BA8:  SUBLW  1A
03BAA:  BC    3BBE
03BAC:  XORLW  FF
03BAE:  BNZ   3BB6
03BB0:  MOVF   x88,W
03BB2:  SUBLW  F7
03BB4:  BC    3BBE
....................       { 
....................          temp.Val -= RXSIZE; 
03BB6:  MOVLW  F8
03BB8:  SUBWF  x88,F
03BBA:  MOVLW  1B
03BBC:  SUBWFB x89,F
....................       } 
....................    } 
03BBE:  BRA    3BD4
....................    else 
....................    { 
....................       temp.Val += len-1; 
03BC0:  MOVLW  01
03BC2:  SUBWF  x86,W
03BC4:  MOVWF  00
03BC6:  MOVLW  00
03BC8:  SUBWFB x87,W
03BCA:  MOVWF  03
03BCC:  MOVF   00,W
03BCE:  ADDWF  x88,F
03BD0:  MOVF   03,W
03BD2:  ADDWFC x89,F
....................    } 
....................  
....................    // Write the DMA end address 
....................    WriteReg(EDMANDL, temp.v[0]); 
03BD4:  MOVLW  12
03BD6:  MOVWF  xAB
03BD8:  MOVFF  988,9AC
03BDC:  MOVLB  0
03BDE:  CALL   15B8
....................    WriteReg(EDMANDH, temp.v[1]); 
03BE2:  MOVLW  13
03BE4:  MOVLB  9
03BE6:  MOVWF  xAB
03BE8:  MOVFF  989,9AC
03BEC:  MOVLB  0
03BEE:  CALL   15B8
....................  
....................    // Begin the DMA checksum calculation and wait until it is finished 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
03BF2:  MOVLW  1F
03BF4:  MOVLB  9
03BF6:  MOVWF  xAD
03BF8:  MOVLW  30
03BFA:  MOVWF  xAE
03BFC:  MOVLB  0
03BFE:  CALL   15F4
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
03C02:  MOVLW  1F
03C04:  MOVLB  9
03C06:  MOVWF  xA5
03C08:  MOVLB  0
03C0A:  CALL   157A
03C0E:  MOVFF  01,98A
03C12:  MOVLW  00
03C14:  MOVLB  9
03C16:  BTFSC  01.5
03C18:  MOVLW  01
03C1A:  XORLW  00
03C1C:  BTFSC  FD8.2
03C1E:  BRA    3C24
03C20:  MOVLB  0
03C22:  BRA    3C02
....................  
....................    // Return the resulting good stuff 
....................    temp.v[0] = ReadETHReg(EDMACSL).Val; 
03C24:  MOVLW  16
03C26:  MOVWF  xA5
03C28:  MOVLB  0
03C2A:  CALL   157A
03C2E:  MOVFF  01,988
....................    temp.v[1] = ReadETHReg(EDMACSH).Val; 
03C32:  MOVLW  17
03C34:  MOVLB  9
03C36:  MOVWF  xA5
03C38:  MOVLB  0
03C3A:  CALL   157A
03C3E:  MOVFF  01,989
....................    return temp.Val; 
03C42:  MOVLB  9
03C44:  MOVFF  988,01
03C48:  MOVFF  989,02
03C4C:  MOVLB  0
03C4E:  RETURN 0
.................... } 
.................... #endif   // End of MCHP_MAC specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           RxOffset: Offset in the RX buffer (0=first byte of 
....................  *                        destination MAC address) to copy from. 
....................  *               TxOffset: Offset in the TX buffer (0=first byte of 
....................  *                       destination MAC address) to copy to. 
....................  *               len:     Number of bytes to copy 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        If the TX logic is transmitting a packet (ECON1.TXRTS is 
....................  *               set), the hardware will wait until it is finished.  Then, 
....................  *               the DMA module will copy the data from the receive buffer 
....................  *               to the transmit buffer. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... // Remove this line if your application needs to use this 
.................... // function.  This code has NOT been tested. 
.................... #if 0 
.................... void MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len) 
.................... { 
....................    WORD_VAL temp; 
....................  
....................    temp.Val = CurrentPacketLocation.Val + RxOffset + sizeof(ENC_PREAMBLE); 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    BankSel(EDMASTL); 
....................    WriteReg(EDMASTL, temp.v[0]); 
....................    WriteReg(EDMASTH, temp.v[1]); 
....................  
....................    temp.Val += len-1; 
....................    if ( temp.Val > RXSTOP )      // Adjust value if a wrap is needed 
....................       temp.Val -= RXSIZE; 
....................  
....................    WriteReg(EDMANDL, temp.v[0]); 
....................    WriteReg(EDMANDH, temp.v[1]); 
....................  
....................    TxOffset += TXSTART+1; 
....................    WriteReg(EDMADSTL, ((WORD_VAL*)&TxOffset)->v[0]); 
....................    WriteReg(EDMADSTH, ((WORD_VAL*)&TxOffset)->v[1]); 
....................  
....................    // Do the DMA Copy.  The DMA module will wait for TXRTS to become clear 
....................    // before starting the copy. 
....................    BFCReg(ECON1, ECON1_CSUMEN); 
....................    BFSReg(ECON1, ECON1_DMAST); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
.................... } 
.................... #endif 
....................  
....................  
.................... #if defined(MAC_FILTER_BROADCASTS) 
.................... // NOTE: This code has NOT been tested.  See StackTsk.h's explanation 
.................... // of MAC_FILTER_BROADCASTS. 
.................... /****************************************************************************** 
....................  * Function:        void MACSetPMFilter(BYTE *Pattern, 
....................  *                              BYTE *PatternMask, 
....................  *                              WORD PatternOffset) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                MACIsTxReady() must return TRUE 
....................  * 
....................  * Input:           *Pattern: Pointer to an intial pattern to compare against 
....................  *               *PatternMask: Pointer to an 8 byte pattern mask which 
....................  *                          defines which bytes of the pattern are 
....................  *                          important.  At least one bit must be set. 
....................  *               PatternOffset: Offset from the beginning of the Ethernet 
....................  *                           frame (1st byte of destination address), to 
....................  *                           begin comparing with the given pattern. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Contents of the TX buffer space are overwritten 
....................  * 
....................  * Overview:        MACSetPMFilter sets the hardware receive filters for: 
....................  *               CRC AND (Unicast OR Pattern Match).  As a result, only a 
....................  *               subset of the broadcast packets which are normally 
....................  *               received will be received. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACSetPMFilter(BYTE *Pattern, 
....................                BYTE *PatternMask, 
....................                WORD PatternOffset) 
.................... { 
....................    WORD_VAL i; 
....................    BYTE *MaskPtr; 
....................    BYTE UnmaskedPatternLen; 
....................  
....................    // Set the SPI write pointer and DMA startting address to the beginning of 
....................    // the transmit buffer 
....................    BankSel(EWRPTL); 
....................    WriteReg(EWRPTL, LOW(TXSTART)); 
....................    WriteReg(EWRPTH, HIGH(TXSTART)); 
....................    WriteReg(EDMASTL, LOW(TXSTART)); 
....................    WriteReg(EDMASTH, HIGH(TXSTART)); 
....................  
....................    // Fill the transmit buffer with the pattern to match against.  Only the 
....................    // bytes which have a mask bit of 1 are written into the buffer and will 
....................    // subsequently be used for checksum computation. 
....................    MaskPtr = PatternMask; 
....................    for(i.Val = 0x0100; i.v[0] < 64; i.v[0]++) 
....................    { 
....................       if( *MaskPtr & i.v[1] ) 
....................       { 
....................          MACPut(*Pattern); 
....................          UnmaskedPatternLen++; 
....................       } 
....................       Pattern++; 
....................  
....................       i.v[1] <<= 1; 
....................       if( i.v[1] == 0u ) 
....................       { 
....................          i.v[1] = 0x01; 
....................          MaskPtr++; 
....................       } 
....................    } 
....................  
....................    // Calculate and set the DMA end address 
....................    i.Val = TXSTART + (WORD)UnmaskedPatternLen - 1; 
....................    WriteReg(EDMANDL, i.v[0]); 
....................    WriteReg(EDMANDH, i.v[1]); 
....................  
....................    // Calculate the checksum on the given pattern using the DMA module 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Make certain that the PM filter isn't enabled while it is 
....................    // being reconfigured. 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................  
....................    // Get the calculated DMA checksum and store it in the PM 
....................    // checksum registers 
....................    i.v[0] == ReadETHReg(EDMACSL).Val; 
....................    i.v[1] == ReadETHReg(EDMACSH).Val; 
....................    WriteReg(EPMCSL, i.v[0]); 
....................    WriteReg(EPMCSH, i.v[0]); 
....................  
....................    // Set the Pattern Match offset and 8 byte mask 
....................    WriteReg(EPMOL, ((WORD_VAL*)&PatternOffset)->v[0]); 
....................    WriteReg(EPMOH, ((WORD_VAL*)&PatternOffset)->v[1]); 
....................    for(i.Val = EPMM0; i.Val <= EPMM7 ; i.Val++) 
....................    { 
....................       WriteReg(i.Val, *PatternMask++); 
....................    } 
....................  
....................    // Begin using the new Pattern Match filter instead of the 
....................    // broadcast filter 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_PMEN); 
.................... }//end MACSetPMFilter 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACDisablePMFilter(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACDisablePMFilter disables the Pattern Match receive 
....................  *               filter (if enabled) and returns to the default filter 
....................  *               configuration of: CRC AND (Unicast OR Broadcast). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACDisablePMFilter(void) 
.................... { 
....................    BankSel(ERXFCON); 
....................    WriteReg(ERXFCON, ERXFCON_UCEN | ERXFCON_CRCEN | ERXFCON_BCEN); 
....................    return; 
.................... }//end MACDisablePMFilter 
.................... #endif // end of MAC_FILTER_BROADCASTS specific code 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE MACGet() 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Byte read from the ENC28J60's RAM 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACGet returns the byte pointed to by ERDPT and 
....................  *               increments ERDPT so MACGet() can be called again.  The 
....................  *               increment will follow the receive buffer wrapping boundary. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE MACGet() 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return SSPBUF; 
.................... */ 
....................    char c; 
....................  
....................    SPISelectEthernet(); 
*
03ACC:  BCF    F94.1
03ACE:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
03AD0:  MOVLW  3A
03AD2:  MOVLB  9
03AD4:  MOVWF  xB0
03AD6:  MOVLB  0
03AD8:  CALL   1540
....................    c=ENCSPIXfer(0); 
03ADC:  MOVLB  9
03ADE:  CLRF   xB0
03AE0:  MOVLB  0
03AE2:  CALL   1540
03AE6:  MOVFF  01,98A
....................    SPIUnselectEthernet(); 
03AEA:  BCF    F94.1
03AEC:  BSF    F8B.1
....................    return(c); 
03AEE:  MOVLB  9
03AF0:  MOVFF  98A,01
03AF4:  MOVLB  0
03AF6:  RETURN 0
.................... }//end MACGet 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WORD MACGetArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                ERDPT must point to the place to read from. 
....................  * 
....................  * Input:           *val: Pointer to storage location 
....................  *               len:  Number of bytes to read from the data buffer. 
....................  * 
....................  * Output:          Byte(s) of data read from the data buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Burst reads several sequential bytes from the data buffer 
....................  *               and places them into local memory.  With SPI burst support, 
....................  *               it performs much faster than multiple MACGet() calls. 
....................  *               ERDPT is incremented after each byte, following the same 
....................  *               rules as MACGet(). 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... WORD MACGetArray(BYTE *val, WORD len) 
*
02C7C:  MOVLB  9
02C7E:  CLRF   x99
02C80:  CLRF   x98
.................... { 
.................... /* 
....................    int16 i; 
....................  
....................    // Start the burst operation 
....................    SPISelectEthernet(); 
....................    SSPBUF = RBM;         // Send the Read Buffer Memory opcode. 
....................    i = 0; 
....................    val--; 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Read the data 
....................    while(i<len) 
....................    { 
....................       SSPBUF = 0;         // Send a dummy byte to receive a byte 
....................       i++; 
....................       val++; 
....................       while(!PIR1_SSPIF);   // Wait until byte is received. 
....................       PIR1_SSPIF = 0; 
....................       *val = SSPBUF; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
....................  
....................    return i; 
.................... */ 
....................  
....................    int16 i=0; 
....................  
....................    SPISelectEthernet(); 
02C82:  BCF    F94.1
02C84:  BCF    F8B.1
....................    ENCSPIXfer(RBM); 
02C86:  MOVLW  3A
02C88:  MOVWF  xB0
02C8A:  MOVLB  0
02C8C:  CALL   1540
....................    while(i<len) 
02C90:  MOVLB  9
02C92:  MOVF   x99,W
02C94:  SUBWF  x97,W
02C96:  BNC   2CD0
02C98:  BNZ   2CA0
02C9A:  MOVF   x96,W
02C9C:  SUBWF  x98,W
02C9E:  BC    2CD0
....................    { 
....................       *val=ENCSPIXfer(0); 
02CA0:  MOVFF  995,03
02CA4:  MOVFF  994,99A
02CA8:  MOVFF  995,99B
02CAC:  CLRF   xB0
02CAE:  MOVLB  0
02CB0:  CALL   1540
02CB4:  MOVFF  99B,FEA
02CB8:  MOVFF  99A,FE9
02CBC:  MOVFF  01,FEF
....................       val++; 
02CC0:  MOVLB  9
02CC2:  INCF   x94,F
02CC4:  BTFSC  FD8.2
02CC6:  INCF   x95,F
....................       i++; 
02CC8:  INCF   x98,F
02CCA:  BTFSC  FD8.2
02CCC:  INCF   x99,F
02CCE:  BRA    2C92
....................    } 
....................    SPIUnselectEthernet(); 
02CD0:  BCF    F94.1
02CD2:  BSF    F8B.1
....................  
....................    return(i); 
02CD4:  MOVFF  998,01
02CD8:  MOVFF  999,02
02CDC:  MOVLB  0
02CDE:  RETURN 0
.................... }//end MACGetArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPut(BYTE val) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           Byte to write into the ENC28J60 buffer memory 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPut outputs the Write Buffer Memory opcode/constant 
....................  *               (8 bits) and data to write (8 bits) over the SPI. 
....................  *               EWRPT is incremented after the write. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPut(BYTE val) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the opcode and constant. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = val;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until byte is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
030E2:  BCF    F94.1
030E4:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
030E6:  MOVLW  7A
030E8:  MOVLB  9
030EA:  MOVWF  xB0
030EC:  MOVLB  0
030EE:  CALL   1540
....................    ENCSPIXfer(val); 
030F2:  MOVFF  9A9,9B0
030F6:  CALL   1540
....................    SPIUnselectEthernet(); 
030FA:  BCF    F94.1
030FC:  BSF    F8B.1
030FE:  RETURN 0
.................... }//end MACPut 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPutArray(BYTE *val, WORD len) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                EWRPT must point to the location to begin writing. 
....................  * 
....................  * Input:           *val: Pointer to source of bytes to copy. 
....................  *               len:  Number of bytes to write to the data buffer. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPutArray writes several sequential bytes to the 
....................  *               ENC28J60 RAM.  It performs faster than multiple MACPut() 
....................  *               calls.  EWRPT is incremented by len. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void MACPutArray(BYTE *val, WORD len) 
.................... { 
.................... /* 
....................    // Select the chip and send the proper opcode 
....................    SPISelectEthernet(); 
....................    SSPBUF = WBM;         // Send the Write Buffer Memory opcode 
....................    while(!PIR1_SSPIF);      // Wait until opcode/constant is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    // Send the data 
....................    while(len) 
....................    { 
....................       SSPBUF = *val;      // Start sending the byte 
....................       val++;            // Increment after writing to SSPBUF to increase speed 
....................       len--;            // Decrement after writing to SSPBUF to increase speed 
....................       while(!PIR1_SSPIF);   // Wait until byte is transmitted 
....................       PIR1_SSPIF = 0; 
....................    }; 
....................  
....................    // Terminate the burst operation 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
03100:  BCF    F94.1
03102:  BCF    F8B.1
....................    ENCSPIXfer(WBM); 
03104:  MOVLW  7A
03106:  MOVLB  9
03108:  MOVWF  xB0
0310A:  MOVLB  0
0310C:  CALL   1540
....................    while(len--) 
03110:  MOVLB  9
03112:  MOVFF  9AD,03
03116:  MOVF   xAC,W
03118:  BTFSC  FD8.2
0311A:  DECF   xAD,F
0311C:  DECF   xAC,F
0311E:  IORWF  03,W
03120:  BZ    3146
....................    { 
....................       ENCSPIXfer(*val); 
03122:  MOVFF  9AB,03
03126:  MOVFF  9AA,FE9
0312A:  MOVFF  9AB,FEA
0312E:  MOVFF  FEF,9AE
03132:  MOVFF  9AE,9B0
03136:  MOVLB  0
03138:  CALL   1540
....................       val++; 
0313C:  MOVLB  9
0313E:  INCF   xAA,F
03140:  BTFSC  FD8.2
03142:  INCF   xAB,F
03144:  BRA    3112
....................    } 
....................    SPIUnselectEthernet(); 
03146:  BCF    F94.1
03148:  BSF    F8B.1
0314A:  MOVLB  0
0314C:  RETURN 0
.................... }//end MACPutArray 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static void SendSystemReset(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        SendSystemReset sends the System Reset SPI command to 
....................  *               the Ethernet controller.  It resets all register contents 
....................  *               (except for ECOCON) and returns the device to the power 
....................  *               on default state. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void SendSystemReset(void) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = SR; 
....................    while(!PIR1_SSPIF);      // Wait until the command is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
015A4:  BCF    F94.1
015A6:  BCF    F8B.1
....................    ENCSPIXfer(SR); 
015A8:  MOVLB  9
015AA:  SETF   xB0
015AC:  MOVLB  0
015AE:  RCALL  1540
....................    SPIUnselectEthernet(); 
015B0:  BCF    F94.1
015B2:  BSF    F8B.1
015B4:  GOTO   1872 (RETURN)
.................... }//end SendSystemReset 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadETHReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the ETH control register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's ETH register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadETHReg sends the 8 bit RCR opcode/Address byte over 
....................  *               the SPI and then retrives the register contents in the 
....................  *               next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access MAC/MII or PHY 
....................  *               registers.  Use ReadMACReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadETHReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    // Select the chip and send the Read Control Register opcode/address 
....................    SPISelectEthernet(); 
....................    SSPBUF = RCR | Address; 
....................  
....................    while(!PIR1_SSPIF);      // Wait until the opcode/address is transmitted 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = 0;            // Send a dummy byte to receive the register 
....................                      //   contents 
....................    while(!PIR1_SSPIF);      // Wait until the register is received 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
....................    */ 
....................  
....................    SPISelectEthernet(); 
*
0157A:  BCF    F94.1
0157C:  BCF    F8B.1
....................    ENCSPIXfer(RCR | Address); 
0157E:  MOVFF  9A5,9A7
01582:  MOVFF  9A5,9B0
01586:  MOVLB  0
01588:  RCALL  1540
....................    c=ENCSPIXfer(0); 
0158A:  MOVLB  9
0158C:  CLRF   xB0
0158E:  MOVLB  0
01590:  RCALL  1540
01592:  MOVFF  01,9A6
....................    SPIUnselectEthernet(); 
01596:  BCF    F94.1
01598:  BSF    F8B.1
....................    return(c); 
0159A:  MOVLB  9
0159C:  MOVFF  9A6,01
015A0:  MOVLB  0
015A2:  RETURN 0
.................... }//end ReadETHReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        REG ReadMACReg(BYTE Address) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                to read from. 
....................  * 
....................  * Input:           5 bit address of the MAC or MII register to read from. 
....................  *                 The top 3 bits must be 0. 
....................  * 
....................  * Output:          Byte read from the Ethernet controller's MAC/MII register. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        ReadMACReg sends the 8 bit RCR opcode/Address byte as well 
....................  *               as a dummy byte over the SPI and then retrives the 
....................  *               register contents in the last 8 SPI clocks. 
....................  * 
....................  * Note:            This routine cannot be used to access ETH or PHY 
....................  *               registers.  Use ReadETHReg() or ReadPHYReg() for that 
....................  *               purpose. 
....................  *****************************************************************************/ 
.................... static REG ReadMACReg(BYTE Address) 
.................... { 
....................    char c; 
.................... /* 
....................    SPISelectEthernet(); 
....................  
....................    SSPBUF = RCR | Address;   // Send the Read Control Register opcode and 
....................                      //   address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send a dummy byte 
....................    while(!PIR1_SSPIF);      // Wait for the dummy byte to be transmitted 
....................    PIR1_SSPIF = 0; 
....................  
....................    SSPBUF = 0;            // Send another dummy byte to receive the register 
....................                      //   contents. 
....................    while(!PIR1_SSPIF);      // Wait until register is received. 
....................    PIR1_SSPIF = 0; 
....................  
....................    SPIUnselectEthernet(); 
....................  
....................    return *((REG*)&SSPBUF); 
.................... */ 
....................    SPISelectEthernet(); 
*
01648:  BCF    F94.1
0164A:  BCF    F8B.1
....................  
....................    ENCSPIXfer(RCR | Address); 
0164C:  MOVFF  903,905
01650:  MOVFF  903,9B0
01654:  MOVLB  0
01656:  RCALL  1540
....................    ENCSPIXfer(0); 
01658:  MOVLB  9
0165A:  CLRF   xB0
0165C:  MOVLB  0
0165E:  RCALL  1540
....................    c=ENCSPIXfer(0); 
01660:  MOVLB  9
01662:  CLRF   xB0
01664:  MOVLB  0
01666:  RCALL  1540
01668:  MOVFF  01,904
....................  
....................    SPIUnselectEthernet(); 
0166C:  BCF    F94.1
0166E:  BSF    F8B.1
....................  
....................    return(c); 
01670:  MOVLB  9
01672:  MOVFF  904,01
01676:  MOVLB  0
01678:  RETURN 0
.................... }//end ReadMACReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        ReadPHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to read from. 
....................  * 
....................  * Output:          16 bits of data read from the PHY register. 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 2 
....................  * 
....................  * Overview:        ReadPHYReg performs an MII read operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... PHYREG ReadPHYReg(BYTE Register) 
.................... { 
....................    PHYREG Result; 
....................  
....................    // Set the right address and start the register read operation 
....................    BankSel(MIREGADR); 
*
0170A:  MOVLW  02
0170C:  MOVLB  9
0170E:  MOVWF  xA9
01710:  MOVLW  14
01712:  MOVWF  xA8
01714:  MOVLB  0
01716:  RCALL  1612
....................    WriteReg(MIREGADR, Register); 
01718:  MOVLW  14
0171A:  MOVLB  9
0171C:  MOVWF  xAB
0171E:  MOVFF  8FE,9AC
01722:  MOVLB  0
01724:  RCALL  15B8
....................    WriteReg(MICMD, MICMD_MIIRD); 
01726:  MOVLW  12
01728:  MOVLB  9
0172A:  MOVWF  xAB
0172C:  MOVLW  01
0172E:  MOVWF  xAC
01730:  MOVLB  0
01732:  RCALL  15B8
....................  
....................    // Loop to wait until the PHY register has been read through the MII 
....................    // This requires 10.24us 
....................    BankSel(MISTAT); 
01734:  MOVLW  03
01736:  MOVLB  9
01738:  MOVWF  xA9
0173A:  MOVLW  0A
0173C:  MOVWF  xA8
0173E:  MOVLB  0
01740:  RCALL  1612
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
01742:  MOVLW  0A
01744:  MOVLB  9
01746:  MOVWF  x03
01748:  MOVLB  0
0174A:  RCALL  1648
0174C:  MOVFF  01,901
01750:  MOVLW  00
01752:  MOVLB  9
01754:  BTFSC  01.0
01756:  MOVLW  01
01758:  XORLW  00
0175A:  BTFSC  FD8.2
0175C:  BRA    1762
0175E:  MOVLB  0
01760:  BRA    1742
....................  
....................    // Stop reading 
....................    BankSel(MIREGADR); 
01762:  MOVLW  02
01764:  MOVWF  xA9
01766:  MOVLW  14
01768:  MOVWF  xA8
0176A:  MOVLB  0
0176C:  RCALL  1612
....................    WriteReg(MICMD, 0x00); 
0176E:  MOVLW  12
01770:  MOVLB  9
01772:  MOVWF  xAB
01774:  CLRF   xAC
01776:  MOVLB  0
01778:  RCALL  15B8
....................  
....................    // Obtain results and return 
....................    Result.VAL.v[0] = ReadMACReg(MIRDL).Val; 
0177A:  MOVLW  18
0177C:  MOVLB  9
0177E:  MOVWF  x03
01780:  MOVLB  0
01782:  RCALL  1648
01784:  MOVFF  01,8FF
....................    Result.VAL.v[1] = ReadMACReg(MIRDH).Val; 
01788:  MOVLW  19
0178A:  MOVLB  9
0178C:  MOVWF  x03
0178E:  MOVLB  0
01790:  RCALL  1648
01792:  MOVFF  01,900
....................    return Result; 
01796:  MOVFF  8FF,01
0179A:  MOVLB  9
0179C:  MOVFF  900,02
017A0:  MOVLB  0
017A2:  RETURN 0
.................... }//end ReadPHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void WriteReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the ETH, MAC, or MII register to modify. 
....................  *                 The top 3 bits must be 0. 
....................  *               Byte to be written into the register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        WriteReg sends the 8 bit WCR opcode/Address byte over the 
....................  *               SPI and then sends the data to write in the next 8 SPI 
....................  *               clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the BFCReg() and 
....................  *               BFSReg() functions.  It is seperate to maximize speed. 
....................  *               Unlike the ReadETHReg/ReadMACReg functions, WriteReg() 
....................  *               can write to any ETH or MAC register.  Writing to PHY 
....................  *               registers must be accomplished with WritePHYReg(). 
....................  *****************************************************************************/ 
.................... static void WriteReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = WCR | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
*
015B8:  BCF    F94.1
015BA:  BCF    F8B.1
....................    ENCSPIXfer(WCR | Address); 
015BC:  MOVLB  9
015BE:  MOVF   xAB,W
015C0:  IORLW  40
015C2:  MOVWF  xAD
015C4:  MOVWF  xB0
015C6:  MOVLB  0
015C8:  RCALL  1540
....................    ENCSPIXfer(Data); 
015CA:  MOVFF  9AC,9B0
015CE:  RCALL  1540
....................    SPIUnselectEthernet(); 
015D0:  BCF    F94.1
015D2:  BSF    F8B.1
015D4:  RETURN 0
.................... }//end WriteReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFCReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *                 to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Clear operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFCReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFSReg() functions.  It is separate to maximize speed. 
....................  *               BFCReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFCReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFC | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
015D6:  BCF    F94.1
015D8:  BCF    F8B.1
....................    ENCSPIXfer(BFC | Address); 
015DA:  MOVLB  9
015DC:  MOVF   xAA,W
015DE:  IORLW  A0
015E0:  MOVWF  xAC
015E2:  MOVWF  xB0
015E4:  MOVLB  0
015E6:  RCALL  1540
....................    ENCSPIXfer(Data); 
015E8:  MOVFF  9AB,9B0
015EC:  RCALL  1540
....................    SPIUnselectEthernet(); 
015EE:  BCF    F94.1
015F0:  BSF    F8B.1
015F2:  RETURN 0
.................... }//end BFCReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void BFSReg(BYTE Address, BYTE Data) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  *                Bank select bits must be set corresponding to the register 
....................  *               to modify. 
....................  * 
....................  * Input:           5 bit address of the register to modify.  The top 3 bits 
....................  *                 must be 0. 
....................  *               Byte to be used with the Bit Field Set operation. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BFSReg sends the 8 bit BFC opcode/Address byte over the 
....................  *               SPI and then sends the data in the next 8 SPI clocks. 
....................  * 
....................  * Note:            This routine is almost identical to the WriteReg() and 
....................  *               BFCReg() functions.  It is separate to maximize speed. 
....................  *               BFSReg() must only be used on ETH registers. 
....................  *****************************************************************************/ 
.................... static void BFSReg(BYTE Address, BYTE Data) 
.................... { 
.................... /* 
....................    SPISelectEthernet(); 
....................    SSPBUF = BFS | Address;   // Send the opcode and address. 
....................    while(!PIR1_SSPIF);      // Wait until opcode/address is transmitted. 
....................    PIR1_SSPIF = 0; 
....................    SSPBUF = Data;         // Send the byte to be writen. 
....................    while(!PIR1_SSPIF);      // Wait until register is written. 
....................    PIR1_SSPIF = 0; 
....................    SPIUnselectEthernet(); 
.................... */ 
....................    SPISelectEthernet(); 
015F4:  BCF    F94.1
015F6:  BCF    F8B.1
....................    ENCSPIXfer(BFS | Address); 
015F8:  MOVLB  9
015FA:  MOVF   xAD,W
015FC:  IORLW  80
015FE:  MOVWF  xAF
01600:  MOVWF  xB0
01602:  MOVLB  0
01604:  RCALL  1540
....................    ENCSPIXfer(Data); 
01606:  MOVFF  9AE,9B0
0160A:  RCALL  1540
....................    SPIUnselectEthernet(); 
0160C:  BCF    F94.1
0160E:  BSF    F8B.1
01610:  RETURN 0
.................... }//end BFSReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        WritePHYReg 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Address of the PHY register to write to. 
....................  *               16 bits of data to write to PHY register. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Alters bank bits to point to Bank 3 
....................  * 
....................  * Overview:        WritePHYReg performs an MII write operation.  While in 
....................  *               progress, it simply polls the MII BUSY bit wasting time. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... void WritePHYReg(BYTE Register, WORD Data) 
.................... { 
....................    // Write the register address 
....................    BankSel(MIREGADR); 
*
0167A:  MOVLW  02
0167C:  MOVLB  9
0167E:  MOVWF  xA9
01680:  MOVLW  14
01682:  MOVWF  xA8
01684:  MOVLB  0
01686:  RCALL  1612
....................    WriteReg(MIREGADR, Register); 
01688:  MOVLW  14
0168A:  MOVLB  9
0168C:  MOVWF  xAB
0168E:  MOVFF  8FE,9AC
01692:  MOVLB  0
01694:  RCALL  15B8
....................  
....................    // Write the data 
....................    // Order is important: write low byte first, high byte last 
....................    WriteReg(MIWRL, ((WORD_VAL*)&Data)->v[0]); 
01696:  MOVLW  08
01698:  MOVLB  9
0169A:  MOVWF  x02
0169C:  SETF   x01
0169E:  MOVFF  901,FE9
016A2:  MOVWF  FEA
016A4:  MOVFF  FEF,903
016A8:  MOVLW  16
016AA:  MOVWF  xAB
016AC:  MOVFF  903,9AC
016B0:  MOVLB  0
016B2:  RCALL  15B8
....................    WriteReg(MIWRH, ((WORD_VAL*)&Data)->v[1]); 
016B4:  MOVLW  08
016B6:  MOVLB  9
016B8:  MOVWF  x02
016BA:  SETF   x01
016BC:  MOVLW  01
016BE:  ADDWF  x01,W
016C0:  MOVWF  FE9
016C2:  MOVLW  00
016C4:  ADDWFC x02,W
016C6:  MOVWF  FEA
016C8:  MOVFF  FEF,903
016CC:  MOVLW  17
016CE:  MOVWF  xAB
016D0:  MOVFF  903,9AC
016D4:  MOVLB  0
016D6:  RCALL  15B8
....................  
....................    // Wait until the PHY register has been written 
....................    BankSel(MISTAT); 
016D8:  MOVLW  03
016DA:  MOVLB  9
016DC:  MOVWF  xA9
016DE:  MOVLW  0A
016E0:  MOVWF  xA8
016E2:  MOVLB  0
016E4:  RCALL  1612
....................    while(ReadMACReg(MISTAT).MISTATbits.BUSY); 
016E6:  MOVLW  0A
016E8:  MOVLB  9
016EA:  MOVWF  x03
016EC:  MOVLB  0
016EE:  RCALL  1648
016F0:  MOVFF  01,901
016F4:  MOVLW  00
016F6:  MOVLB  9
016F8:  BTFSC  01.0
016FA:  MOVLW  01
016FC:  XORLW  00
016FE:  BTFSC  FD8.2
01700:  BRA    1706
01702:  MOVLB  0
01704:  BRA    16E6
01706:  MOVLB  0
01708:  RETURN 0
.................... }//end WritePHYReg 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BankSel 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Register address with the high byte containing the 2 bank 
....................  *                 select 2 bits. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        BankSel takes the high byte of a register address and 
....................  *               changes the bank select bits in ETHCON1 to match. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... static void BankSel(WORD Register) 
.................... { 
....................    BFCReg(ECON1, ECON1_BSEL1 | ECON1_BSEL0); 
*
01612:  MOVLW  1F
01614:  MOVLB  9
01616:  MOVWF  xAA
01618:  MOVLW  03
0161A:  MOVWF  xAB
0161C:  MOVLB  0
0161E:  RCALL  15D6
....................    BFSReg(ECON1, ((WORD_VAL*)&Register)->v[1]); 
01620:  MOVLW  09
01622:  MOVLB  9
01624:  MOVWF  xAB
01626:  MOVLW  A8
01628:  MOVWF  xAA
0162A:  MOVLW  01
0162C:  ADDWF  xAA,W
0162E:  MOVWF  FE9
01630:  MOVLW  00
01632:  ADDWFC xAB,W
01634:  MOVWF  FEA
01636:  MOVFF  FEF,9AC
0163A:  MOVLW  1F
0163C:  MOVWF  xAD
0163E:  MOVFF  9AC,9AE
01642:  MOVLB  0
01644:  RCALL  15F4
01646:  RETURN 0
.................... }//end BankSel 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        static BOOL TestMemory(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if the memory tests have passed 
....................  *               FALSE if the BIST has detected a hardware fault 
....................  * 
....................  * Side Effects:    Alters the state of numerous control registers and all 
....................  *               RAM bytes. 
....................  * 
....................  * Overview:        The internal BIST and DMA modules are used to fill the 
....................  *               entire dual port memory and calculate a checksum of the 
....................  *               data stored within.  Address and Random fill modes are 
....................  *               used. 
....................  * 
....................  * Note:            For the Random Fill mode, the random number generator is 
....................  *               seeded by the contents of the TMR0L PIC SFR.  If the timer 
....................  *               is running, additional confidence that the memory is 
....................  *               working can be obtained by calling TestMemory multiple 
....................  *               times. 
....................  *****************************************************************************/ 
.................... #if defined(MAC_POWER_ON_TEST) 
.................... static BOOL TestMemory(void) 
.................... { 
....................    #define RANDOM_FILL      0b0000 
....................    #define ADDRESS_FILL   0b0100 
....................    #define PATTERN_SHIFT   0b1000 
....................  
....................    WORD_VAL DMAChecksum, BISTChecksum; 
....................  
....................  
....................    // Select Bank 0 and disable anything that could have been in progress 
....................    WriteReg(ECON1, 0x00); 
....................  
....................    // Set up necessary pointers for the DMA to calculate over the entire 
....................    // memory 
....................    WriteReg(EDMASTL, 0x00); 
....................    WriteReg(EDMASTH, 0x00); 
....................    WriteReg(EDMANDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(EDMANDH, HIGH(RAMSIZE-1u)); 
....................    WriteReg(ERXNDL, LOW(RAMSIZE-1u)); 
....................    WriteReg(ERXNDH, HIGH(RAMSIZE-1u)); 
....................  
....................    // Enable Test Mode and do an Address Fill 
....................    BankSel(EBSTCON); 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                    EBSTCON_BISTST | 
....................                    ADDRESS_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode before 
....................    // starting any DMA operations. 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................    // Compare the results 
....................    // 0xF807 should always be generated in Address fill mode 
....................    if( (DMAChecksum.Val != BISTChecksum.Val) || (DMAChecksum.Val != 0xF807) ) 
....................       return FALSE; 
....................  
....................    // Seed the random number generator and begin another Random Fill test 
....................    // with the DMA and BIST memory access ports swapped. 
.................... #ifdef __C30__ 
....................    WriteReg((BYTE)EBSTSD, TMR1); 
.................... #else 
....................    WriteReg((BYTE)EBSTSD, TMR0L); 
.................... #endif 
....................    WriteReg((BYTE)EBSTCON, EBSTCON_TME | 
....................                  EBSTCON_PSEL | 
....................                  EBSTCON_BISTST | 
....................                  RANDOM_FILL); 
....................  
....................  
....................    // Wait for the BIST to complete and disable test mode since 
....................    // we won't be needing it anymore 
....................    while(ReadETHReg((BYTE)EBSTCON).EBSTCONbits.BISTST); 
....................    BFCReg((BYTE)EBSTCON, EBSTCON_TME); 
....................  
....................  
....................    // Begin reading the memory and calculating a checksum over it 
....................    // Block until the checksum is generated 
....................    BFSReg(ECON1, ECON1_DMAST | ECON1_CSUMEN); 
....................    BankSel(EDMACSL); 
....................    while(ReadETHReg(ECON1).ECON1bits.DMAST); 
....................  
....................    // Obtain the resulting DMA checksum and the expected BIST checksum 
....................    DMAChecksum.v[0] = ReadETHReg(EDMACSL).Val; 
....................    DMAChecksum.v[1] = ReadETHReg(EDMACSH).Val; 
....................    BankSel(EBSTCSL); 
....................    BISTChecksum.v[0] = ReadETHReg((BYTE)EBSTCSL).Val; 
....................    BISTChecksum.v[1] = ReadETHReg((BYTE)EBSTCSH).Val; 
....................  
....................    return (DMAChecksum.Val == BISTChecksum.Val); 
.................... }//end TestMemory 
.................... #endif 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACSetDuplex(DUPLEX DuplexState) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           Member of DUPLEX enum: 
....................  *                  FULL: Set full duplex mode 
....................  *                  HALF: Set half duplex mode 
....................  *                  USE_PHY: Set the MAC to match the PHYDPLXMODE bit in 
....................  *                         PHYCON.  This is controlled by LEDB on RESET. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    Changes bank bits to Bank 2. 
....................  * 
....................  * Overview:        Disables RX, TX logic, sets MAC up for full duplex 
....................  *               operation, sets PHY up for full duplex operation, and 
....................  *               reenables RX logic.  The back-to-back inter-packet gap 
....................  *               register (MACBBIPG) is updated to maintain a 9.6us gap. 
....................  * 
....................  * Note:            If a packet is being transmitted or received while this 
....................  *               function is called, it will be aborted. 
....................  *****************************************************************************/ 
.................... void MACSetDuplex(DUPLEX DuplexState) 
.................... { 
....................    REG Register; 
....................    PHYREG PhyReg; 
....................  
....................    // Disable receive logic and abort any packets currently being transmitted 
....................    BFCReg(ECON1, ECON1_TXRTS | ECON1_RXEN); 
*
017A4:  MOVLW  1F
017A6:  MOVLB  9
017A8:  MOVWF  xAA
017AA:  MOVLW  0C
017AC:  MOVWF  xAB
017AE:  MOVLB  0
017B0:  RCALL  15D6
....................  
....................    // Set the PHY to the proper duplex mode 
....................    PhyReg = ReadPHYReg(PHCON1); 
017B2:  MOVLB  8
017B4:  CLRF   xFE
017B6:  MOVLB  0
017B8:  RCALL  170A
017BA:  MOVFF  02,8FD
017BE:  MOVFF  01,8FC
....................    if(DuplexState == USE_PHY) 
017C2:  MOVLB  8
017C4:  MOVF   xFA,W
017C6:  SUBLW  02
017C8:  BNZ   17D2
....................    { 
....................       DuplexState = PhyReg.PHCON1bits.PDPXMD; 
017CA:  CLRF   xFA
017CC:  BTFSC  xFD.0
017CE:  INCF   xFA,F
....................    } 
017D0:  BRA    17E8
....................    else 
....................    { 
....................       PhyReg.PHCON1bits.PDPXMD = DuplexState; 
017D2:  BCF    xFD.0
017D4:  BTFSC  xFA.0
017D6:  BSF    xFD.0
....................       WritePHYReg(PHCON1, PhyReg.Val); 
017D8:  CLRF   xFE
017DA:  MOVFF  8FD,900
017DE:  MOVFF  8FC,8FF
017E2:  MOVLB  0
017E4:  RCALL  167A
017E6:  MOVLB  8
....................    } 
....................  
....................    // Set the MAC to the proper duplex mode 
....................    BankSel(MACON3); 
017E8:  MOVLW  02
017EA:  MOVLB  9
017EC:  MOVWF  xA9
017EE:  MOVWF  xA8
017F0:  MOVLB  0
017F2:  RCALL  1612
....................    Register = ReadMACReg(MACON3); 
017F4:  MOVLW  02
017F6:  MOVLB  9
017F8:  MOVWF  x03
017FA:  MOVLB  0
017FC:  RCALL  1648
017FE:  MOVFF  01,8FB
....................    Register.MACON3bits.FULDPX = DuplexState; 
01802:  MOVLB  8
01804:  BCF    xFB.0
01806:  BTFSC  xFA.0
01808:  BSF    xFB.0
....................    WriteReg(MACON3, Register.Val); 
0180A:  MOVLW  02
0180C:  MOVLB  9
0180E:  MOVWF  xAB
01810:  MOVFF  8FB,9AC
01814:  MOVLB  0
01816:  RCALL  15B8
....................  
....................    // Set the back-to-back inter-packet gap time to IEEE specified 
....................    // requirements.  The meaning of the MABBIPG value changes with the duplex 
....................    // state, so it must be updated in this function. 
....................    // In full duplex, 0x15 represents 9.6us; 0x12 is 9.6us in half duplex 
....................    WriteReg(MABBIPG, DuplexState ? 0x15 : 0x12); 
01818:  MOVLB  8
0181A:  MOVF   xFA,F
0181C:  BZ    1822
0181E:  MOVLW  15
01820:  BRA    1824
01822:  MOVLW  12
01824:  MOVWF  xFE
01826:  MOVLW  04
01828:  MOVLB  9
0182A:  MOVWF  xAB
0182C:  MOVFF  8FE,9AC
01830:  MOVLB  0
01832:  RCALL  15B8
....................  
....................    // Reenable receive logic 
....................    BFSReg(ECON1, ECON1_RXEN); 
01834:  MOVLW  1F
01836:  MOVLB  9
01838:  MOVWF  xAD
0183A:  MOVLW  04
0183C:  MOVWF  xAE
0183E:  MOVLB  0
01840:  RCALL  15F4
01842:  GOTO   1A0E (RETURN)
.................... }//end MACSetDuplex 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerDown(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerDown puts the ENC28J60 in low power sleep mode. In 
....................  *               sleep mode, no packets can be transmitted or received. 
....................  *               All MAC and PHY registers should not be accessed. 
....................  * 
....................  * Note:            If a packet is being transmitted while this function is 
....................  *                called, this function will block until it is it complete. 
....................  *               If anything is being received, it will be completed. 
....................  *****************************************************************************/ 
.................... void MACPowerDown(void) 
.................... { 
....................    // Disable packet reception 
....................    BFCReg(ECON1, ECON1_RXEN); 
....................  
....................    // Make sure any last packet which was in-progress when RXEN was cleared 
....................    // is completed 
....................    while(ReadETHReg(ESTAT).ESTATbits.RXBUSY); 
....................  
....................    // If a packet is being transmitted, wait for it to finish 
....................    while(ReadETHReg(ECON1).ECON1bits.TXRTS); 
....................  
....................    // Enter sleep mode 
....................    BFSReg(ECON2, ECON2_PWRSV); 
.................... }//end MACPowerDown 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void MACPowerUp(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        MACPowerUp returns the ENC28J60 back to normal operation 
....................  *               after a previous call to MACPowerDown().  Calling this 
....................  *               function when already powered up will have no effect. 
....................  * 
....................  * Note:            The first packet transmitted may get lost at the RX end if 
....................  *               you don't wait for the link to go up first.  MACIsLinked() 
....................  *               can be called to determine if a link is established. 
....................  *****************************************************************************/ 
.................... void MACPowerUp(void) 
.................... { 
....................    // Leave power down mode 
....................    BFCReg(ECON2, ECON2_PWRSV); 
....................  
....................    // Wait for the 300us Oscillator Startup Timer (OST) to time out.  This 
....................    // delay is required for the PHY module to return to an operational state. 
....................    while(!ReadETHReg(ESTAT).ESTATbits.CLKRDY); 
....................  
....................    // Enable packet reception 
....................    BFSReg(ECON1, ECON1_RXEN); 
.................... }//end MACPowerUp 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        void SetCLKOUT(BYTE NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - 0x00: CLKOUT disabled (pin driven low) 
....................  *                        0x01: Divide by 1 (25 MHz) 
....................  *                        0x02: Divide by 2 (12.5 MHz) 
....................  *                        0x03: Divide by 3 (8.333333 MHz) 
....................  *                        0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                        0x05: Divide by 8 (3.125 MHz) 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the ECOCON register. 
....................  *               The CLKOUT pin will beginning outputting the new frequency 
....................  *               immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... void SetCLKOUT(BYTE NewConfig) 
.................... { 
....................    BankSel(ECOCON); 
....................    WriteReg(ECOCON, NewConfig); 
.................... }//end SetCLKOUT 
....................  
....................  
.................... /****************************************************************************** 
....................  * Function:        BYTE GetCLKOUT(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          BYTE - 0x00: CLKOUT disabled (pin driven low) 
....................  *                     0x01: Divide by 1 (25 MHz) 
....................  *                     0x02: Divide by 2 (12.5 MHz) 
....................  *                     0x03: Divide by 3 (8.333333 MHz) 
....................  *                     0x04: Divide by 4 (6.25 MHz, POR default) 
....................  *                     0x05: Divide by 8 (3.125 MHz) 
....................  *                     0x06: Reserved 
....................  *                     0x07: Reserved 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the ECOCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... BYTE GetCLKOUT(void) 
.................... { 
....................    BankSel(ECOCON); 
....................    return ReadETHReg(ECOCON).Val; 
.................... }//end GetCLKOUT 
....................  
....................    #elif STACK_USE_MCPINC 
....................     #include "tcpip/eth97j60.c" 
....................    #else 
....................     #include "tcpip/rtl8019AS.c" 
....................    #endif 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    #include "tcpip/modem.c" 
....................    #include "tcpip/ppp.c" 
....................    #include "tcpip/pppwrap.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SLIP 
....................    #include "tcpip/slip.c" 
.................... #ENDIF 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FAT 
....................    #include "fat/fat_pic.c" 
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.h" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.h" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.h" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.h" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.h" 
.................... #endif 
....................  
.................... /* 
.................... #if STACK_USE_MPFS 
....................    #include "tcpip/mpfs.h" 
.................... #endif 
.................... */ 
....................  
.................... #include "tcpip/ip.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  PIC IP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.C 
....................  * Dependencies:    string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Howard Schlunder		8/31/04	Beta Rev 0.9 (See version.log for detail) 
....................  * Howard Schlunder		1/5/06	Improved DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... // This is left shifted by 4.  Actual value is 0x04. 
.................... #define IPv4                (0x40u) 
.................... #define IP_VERSION          IPv4 
....................  
.................... #define debug_ip 
.................... //#define debug_ip  debug_printf 
....................  
.................... // IHL (Internet Header Length) is # of DWORDs in a header. 
.................... // Since, we do not support options, our IP header length will be 
.................... // minimum i.e. 20 bytes : IHL = 20 / 4 = 5. 
.................... #define IP_IHL              (0x05) 
....................  
.................... #define IP_SERVICE_NW_CTRL  (0x07) 
.................... #define IP_SERVICE_IN_CTRL  (0x06) 
.................... #define IP_SERVICE_ECP      (0x05) 
.................... #define IP_SERVICE_OVR      (0x04) 
.................... #define IP_SERVICE_FLASH    (0x03) 
.................... #define IP_SERVICE_IMM      (0x02) 
.................... #define IP_SERVICE_PRIOR    (0x01) 
.................... #define IP_SERVICE_ROUTINE  (0x00) 
....................  
.................... #define IP_SERVICE_N_DELAY  (0x00) 
.................... #define IP_SERCICE_L_DELAY  (0x08) 
.................... #define IP_SERVICE_N_THRPT  (0x00) 
.................... #define IP_SERVICE_H_THRPT  (0x10) 
.................... #define IP_SERVICE_N_RELIB  (0x00) 
.................... #define IP_SERVICE_H_RELIB  (0x20) 
....................  
.................... #define IP_SERVICE          (IP_SERVICE_ROUTINE | IP_SERVICE_N_DELAY) 
....................  
.................... #define MY_IP_TTL           (100)   // Time-To-Live in Seconds 
....................  
....................  
....................  
....................  
.................... static WORD _Identifier = 0; 
.................... static BYTE IPHeaderLen; 
....................  
.................... static void SwapIPHeader(IP_HEADER* h); 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len) 
.................... { 
....................     WORD_VAL    CalcChecksum; 
....................     IP_HEADER   header; 
....................  
.................... #if !defined(MCHP_MAC) 
....................     WORD_VAL    ReceivedChecksum; 
....................     WORD        checksums[2]; 
....................     BYTE        optionsLen; 
.................... #define MAX_OPTIONS_LEN     (40)            // As per RFC 791. 
....................     BYTE        options[MAX_OPTIONS_LEN]; 
.................... #endif 
....................  
....................     // Read IP header. 
....................     MACGetArray((BYTE*)&header, sizeof(header)); 
*
038EE:  MOVLW  09
038F0:  MOVLB  9
038F2:  MOVWF  x1E
038F4:  MOVWF  x1D
038F6:  MOVWF  x95
038F8:  MOVWF  x94
038FA:  CLRF   x97
038FC:  MOVLW  14
038FE:  MOVWF  x96
03900:  MOVLB  0
03902:  CALL   2C7C
....................  
....................     // Make sure that this is an IPv4 packet. 
....................     if ( (header.VersionIHL & 0xf0) != IP_VERSION ) 
03906:  MOVLB  9
03908:  MOVF   x09,W
0390A:  ANDLW  F0
0390C:  SUBLW  40
0390E:  BZ    3916
....................     	return FALSE; 
03910:  MOVLW  00
03912:  MOVWF  01
03914:  BRA    39D0
....................  
.................... 	IPHeaderLen = (header.VersionIHL & 0x0f) << 2; 
03916:  MOVF   x09,W
03918:  ANDLW  0F
0391A:  MOVWF  00
0391C:  RLCF   00,W
0391E:  MOVLB  3
03920:  MOVWF  x97
03922:  RLCF   x97,F
03924:  MOVLW  FC
03926:  ANDWF  x97,F
....................  
.................... #if defined(MCHP_MAC) 
.................... 	// Validate the IP header.  If it is correct, the checksum 
.................... 	// will come out to 0x0000 (because the header contains a 
.................... 	// precomputed checksum).  A corrupt header will have a 
.................... 	// nonzero checksum. 
.................... 	CalcChecksum.Val = MACCalcRxChecksum(0, IPHeaderLen); 
03928:  MOVLB  9
0392A:  CLRF   x59
0392C:  CLRF   x58
0392E:  CLRF   x5B
03930:  MOVFF  397,95A
03934:  MOVLB  0
03936:  RCALL  367E
03938:  MOVFF  02,908
0393C:  MOVFF  01,907
....................  
.................... 	// Seek to the end of the IP header 
.................... 	MACSetRxBuffer(IPHeaderLen); 
03940:  MOVLB  9
03942:  CLRF   x32
03944:  MOVFF  397,931
03948:  MOVLB  0
0394A:  RCALL  378C
....................  
....................     if(CalcChecksum.Val) 
0394C:  MOVLB  9
0394E:  MOVF   x07,W
03950:  IORWF  x08,W
03952:  BZ    395A
.................... #else 
....................  
....................     // Calculate options length in this header, if there is any. 
....................     // IHL is in terms of numbers of 32-bit DWORDs; i.e. actual 
....................     // length is 4 times IHL. 
....................     optionsLen = ((header.VersionIHL & 0x0f) << 2) - sizeof(header); 
....................  
....................     // If there is any option(s), read it so that we can include them 
....................     // in checksum calculation. 
....................     if ( optionsLen > MAX_OPTIONS_LEN ) 
....................         return FALSE; 
....................  
....................     if ( optionsLen > 0 ) 
....................         MACGetArray(options, optionsLen); 
....................  
....................     // Save header checksum; clear it and recalculate it ourselves. 
....................     ReceivedChecksum.Val = header.HeaderChecksum; 
....................     header.HeaderChecksum = 0; 
....................  
....................     // Calculate checksum of header including options bytes. 
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&header, sizeof(header)); 
....................  
....................     // Calculate Options checksum too, if they are present. 
....................     if ( optionsLen > 0 ) 
....................         checksums[1] = ~CalcIPChecksum((BYTE*)options, optionsLen); 
....................     else 
....................         checksums[1] = 0; 
....................  
....................     CalcChecksum.Val  = CalcIPChecksum((BYTE*)checksums, 
....................                                             2 * sizeof(WORD)); 
....................  
....................     // Make sure that checksum is correct 
....................     if ( ReceivedChecksum.Val != CalcChecksum.Val ) 
.................... #endif 
....................     { 
....................         // Bad packet. The function caller will be notified by means of the FALSE 
....................         // return value and it should discard the packet. 
....................         return FALSE; 
03954:  MOVLW  00
03956:  MOVWF  01
03958:  BRA    39D0
....................     } 
....................  
....................     // Network to host conversion. 
....................     SwapIPHeader(&header); 
0395A:  MOVLW  09
0395C:  MOVWF  xA0
0395E:  MOVWF  x9F
03960:  MOVLB  0
03962:  RCALL  380E
....................  
....................     // If caller is intrested, return destination IP address 
....................     // as seen in this IP header. 
....................     if ( localIP ) 
03964:  MOVLB  8
03966:  MOVF   xFF,W
03968:  MOVLB  9
0396A:  IORWF  x00,W
0396C:  BZ    3988
....................         localIP->Val    = header.DestAddress.Val; 
0396E:  MOVFF  8FF,FE9
03972:  MOVLB  9
03974:  MOVFF  900,FEA
03978:  MOVFF  919,FEF
0397C:  MOVFF  91A,FEC
03980:  MOVFF  91B,FEC
03984:  MOVFF  91C,FEC
....................  
....................     remote->IPAddr.Val  = header.SourceAddress.Val; 
03988:  MOVLW  06
0398A:  ADDWF  x01,W
0398C:  MOVWF  FE9
0398E:  MOVLW  00
03990:  ADDWFC x02,W
03992:  MOVWF  FEA
03994:  MOVFF  915,FEF
03998:  MOVFF  916,FEC
0399C:  MOVFF  917,FEC
039A0:  MOVFF  918,FEC
....................     *protocol           = header.Protocol; 
039A4:  MOVFF  903,FE9
039A8:  MOVFF  904,FEA
039AC:  MOVFF  912,FEF
.................... #if defined(MCHP_MAC) 
....................     *len 				= header.TotalLength - IPHeaderLen; 
039B0:  MOVFF  905,FE9
039B4:  MOVFF  906,FEA
039B8:  MOVLB  3
039BA:  MOVF   x97,W
039BC:  MOVLB  9
039BE:  SUBWF  x0B,W
039C0:  MOVWF  00
039C2:  MOVLW  00
039C4:  SUBWFB x0C,W
039C6:  MOVFF  00,FEF
039CA:  MOVWF  FEC
.................... #else 
....................     *len                = header.TotalLength - optionsLen - 
....................                             sizeof(header); 
.................... #endif 
....................  
....................     return TRUE; 
039CC:  MOVLW  01
039CE:  MOVWF  01
039D0:  MOVLB  0
039D2:  GOTO   5B46 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function: WORD IPPutHeader(NODE_INFO *remote, 
....................  *           				  BYTE protocol, 
....................  *                			  WORD len) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           *remote     - Destination node address 
....................  *                  protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          (WORD)0 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  ********************************************************************/ 
.................... WORD IPPutHeader(NODE_INFO *remote, 
....................                 BYTE protocol, 
....................                 WORD    len) 
.................... { 
....................     IP_HEADER   header; 
....................  
....................     IPHeaderLen = sizeof(IP_HEADER); 
*
043EE:  MOVLW  14
043F0:  MOVLB  3
043F2:  MOVWF  x97
....................  
....................     header.VersionIHL       = IP_VERSION | IP_IHL; 
043F4:  MOVLW  45
043F6:  MOVLB  9
043F8:  MOVWF  x8B
....................     header.TypeOfService    = IP_SERVICE; 
043FA:  CLRF   x8C
....................     header.TotalLength      = sizeof(header) + len; 
043FC:  MOVLW  14
043FE:  ADDWF  x89,W
04400:  MOVWF  x8D
04402:  MOVLW  00
04404:  ADDWFC x8A,W
04406:  MOVWF  x8E
....................     header.Identification   = ++_Identifier; 
04408:  MOVLB  3
0440A:  INCF   x95,F
0440C:  BTFSC  FD8.2
0440E:  INCF   x96,F
04410:  MOVFF  396,990
04414:  MOVFF  395,98F
....................     header.FragmentInfo     = 0; 
04418:  MOVLB  9
0441A:  CLRF   x92
0441C:  CLRF   x91
....................     header.TimeToLive       = MY_IP_TTL; 
0441E:  MOVLW  64
04420:  MOVWF  x93
....................     header.Protocol         = protocol; 
04422:  MOVFF  988,994
....................     header.HeaderChecksum   = 0; 
04426:  CLRF   x96
04428:  CLRF   x95
.................... 	header.SourceAddress = AppConfig.MyIPAddr; 
0442A:  MOVFF  356,99A
0442E:  MOVFF  355,999
04432:  MOVFF  354,998
04436:  MOVFF  353,997
....................  
....................     header.DestAddress.Val = remote->IPAddr.Val; 
0443A:  MOVLW  06
0443C:  ADDWF  x86,W
0443E:  MOVWF  FE9
04440:  MOVLW  00
04442:  ADDWFC x87,W
04444:  MOVWF  FEA
04446:  MOVFF  FEF,99B
0444A:  MOVFF  FEC,99C
0444E:  MOVFF  FEC,99D
04452:  MOVFF  FEC,99E
....................  
....................     SwapIPHeader(&header); 
04456:  MOVLW  09
04458:  MOVWF  xA0
0445A:  MOVLW  8B
0445C:  MOVWF  x9F
0445E:  MOVLB  0
04460:  CALL   380E
....................  
.................... #if !defined(MCHP_MAC) 
....................     header.HeaderChecksum   = CalcIPChecksum((BYTE*)&header, 
....................                                                 sizeof(header)); 
.................... #endif 
....................  
....................     MACPutHeader(&remote->MACAddr, MAC_IP, (sizeof(header)+len)); 
04464:  MOVLB  9
04466:  MOVFF  986,01
0446A:  MOVFF  987,03
0446E:  MOVFF  986,99F
04472:  MOVFF  987,9A0
04476:  MOVLW  14
04478:  ADDWF  x89,W
0447A:  MOVWF  xA1
0447C:  MOVLW  00
0447E:  ADDWFC x8A,W
04480:  MOVWF  xA2
04482:  MOVFF  987,9A4
04486:  MOVFF  986,9A3
0448A:  CLRF   xA5
0448C:  MOVWF  xA7
0448E:  MOVFF  9A1,9A6
04492:  MOVLB  0
04494:  CALL   314E
....................     MACPutArray((BYTE*)&header, sizeof(header)); 
04498:  MOVLW  09
0449A:  MOVLB  9
0449C:  MOVWF  xA0
0449E:  MOVLW  8B
044A0:  MOVWF  x9F
044A2:  MOVFF  9A0,9AB
044A6:  MOVWF  xAA
044A8:  CLRF   xAD
044AA:  MOVLW  14
044AC:  MOVWF  xAC
044AE:  MOVLB  0
044B0:  CALL   3100
....................  
.................... #if defined(MCHP_MAC) 
.................... 	header.HeaderChecksum = MACCalcTxChecksum(0, sizeof(header)); 
044B4:  MOVLB  9
044B6:  CLRF   xA0
044B8:  CLRF   x9F
044BA:  CLRF   xA2
044BC:  MOVLW  14
044BE:  MOVWF  xA1
044C0:  MOVLB  0
044C2:  RCALL  4316
044C4:  MOVFF  02,996
044C8:  MOVFF  01,995
.................... 	MACSetTxBuffer(CurrentTxBuffer, 10);	// 10 is the offset in header to the HeaderChecksum member 
044CC:  MOVFF  38A,99F
044D0:  MOVLB  9
044D2:  CLRF   xA1
044D4:  MOVLW  0A
044D6:  MOVWF  xA0
044D8:  MOVLB  0
044DA:  CALL   3034
.................... 	MACPutArray((BYTE*)&header.HeaderChecksum, 2); 
044DE:  MOVLW  09
044E0:  MOVLB  9
044E2:  MOVWF  xA0
044E4:  MOVLW  95
044E6:  MOVWF  x9F
044E8:  MOVFF  9A0,9AB
044EC:  MOVWF  xAA
044EE:  CLRF   xAD
044F0:  MOVLW  02
044F2:  MOVWF  xAC
044F4:  MOVLB  0
044F6:  CALL   3100
.................... 	MACSetTxBuffer(CurrentTxBuffer, sizeof(header));	// Seek back to the end of the packet 
044FA:  MOVFF  38A,99F
044FE:  MOVLB  9
04500:  CLRF   xA1
04502:  MOVLW  14
04504:  MOVWF  xA0
04506:  MOVLB  0
04508:  CALL   3034
.................... #endif 
....................  
....................     return 0x0; 
0450C:  MOVLW  00
0450E:  MOVWF  01
04510:  MOVWF  02
04512:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset) 
.................... { 
.................... 	MACSetRxBuffer(Offset+IPHeaderLen); 
*
03C50:  MOVLB  3
03C52:  MOVF   x97,W
03C54:  MOVLB  9
03C56:  ADDWF  x2D,W
03C58:  MOVWF  x2F
03C5A:  MOVLW  00
03C5C:  ADDWFC x2E,W
03C5E:  MOVWF  x30
03C60:  MOVWF  x32
03C62:  MOVFF  92F,931
03C66:  MOVLB  0
03C68:  RCALL  378C
03C6A:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... static void SwapIPHeader(IP_HEADER* h) 
.................... { 
....................     h->TotalLength      = swaps(h->TotalLength); 
*
0380E:  MOVLW  02
03810:  MOVLB  9
03812:  ADDWF  x9F,W
03814:  MOVWF  01
03816:  MOVLW  00
03818:  ADDWFC xA0,W
0381A:  MOVWF  03
0381C:  MOVFF  01,9A1
03820:  MOVWF  xA2
03822:  MOVLW  02
03824:  ADDWF  x9F,W
03826:  MOVWF  FE9
03828:  MOVLW  00
0382A:  ADDWFC xA0,W
0382C:  MOVWF  FEA
0382E:  MOVFF  FEC,9A4
03832:  MOVF   FED,F
03834:  MOVFF  FEF,9A3
03838:  MOVFF  9A4,9A6
0383C:  MOVFF  9A3,9A5
03840:  MOVLB  0
03842:  CALL   2CE0
03846:  MOVFF  9A2,FEA
0384A:  MOVFF  9A1,FE9
0384E:  MOVFF  02,FEC
03852:  MOVF   FED,F
03854:  MOVFF  01,FEF
....................     h->Identification   = swaps(h->Identification); 
03858:  MOVLW  04
0385A:  MOVLB  9
0385C:  ADDWF  x9F,W
0385E:  MOVWF  01
03860:  MOVLW  00
03862:  ADDWFC xA0,W
03864:  MOVWF  03
03866:  MOVFF  01,9A1
0386A:  MOVWF  xA2
0386C:  MOVLW  04
0386E:  ADDWF  x9F,W
03870:  MOVWF  FE9
03872:  MOVLW  00
03874:  ADDWFC xA0,W
03876:  MOVWF  FEA
03878:  MOVFF  FEC,9A4
0387C:  MOVF   FED,F
0387E:  MOVFF  FEF,9A3
03882:  MOVFF  9A4,9A6
03886:  MOVFF  9A3,9A5
0388A:  MOVLB  0
0388C:  CALL   2CE0
03890:  MOVFF  9A2,FEA
03894:  MOVFF  9A1,FE9
03898:  MOVFF  02,FEC
0389C:  MOVF   FED,F
0389E:  MOVFF  01,FEF
....................     h->HeaderChecksum   = swaps(h->HeaderChecksum); 
038A2:  MOVLW  0A
038A4:  MOVLB  9
038A6:  ADDWF  x9F,W
038A8:  MOVWF  01
038AA:  MOVLW  00
038AC:  ADDWFC xA0,W
038AE:  MOVWF  03
038B0:  MOVFF  01,9A1
038B4:  MOVWF  xA2
038B6:  MOVLW  0A
038B8:  ADDWF  x9F,W
038BA:  MOVWF  FE9
038BC:  MOVLW  00
038BE:  ADDWFC xA0,W
038C0:  MOVWF  FEA
038C2:  MOVFF  FEC,9A4
038C6:  MOVF   FED,F
038C8:  MOVFF  FEF,9A3
038CC:  MOVFF  9A4,9A6
038D0:  MOVFF  9A3,9A5
038D4:  MOVLB  0
038D6:  CALL   2CE0
038DA:  MOVFF  9A2,FEA
038DE:  MOVFF  9A1,FE9
038E2:  MOVFF  02,FEC
038E6:  MOVF   FED,F
038E8:  MOVFF  01,FEF
038EC:  RETURN 0
.................... } 
....................  
....................  
.................... #if STACK_USE_TCP 
....................    #include "tcpip/tcp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module for Microchip TCP/IP Stack 
....................  *               Based on RFC 793 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
.................... * FileName:        TCP.C 
.................... * Dependencies:    string.h 
.................... *                  StackTsk.h 
.................... *                  Helpers.h 
.................... *                  IP.h 
.................... *                  MAC.h 
.................... *                  ARP.h 
.................... *                  Tick.h 
.................... *                  TCP.h 
.................... * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
.................... * Complier:        CCS PCH 
.................... * Company:         Microchip Technology, Inc. 
.................... * 
.................... * Software License Agreement 
.................... * 
.................... * This software is owned by Microchip Technology Inc. ("Microchip") 
.................... * and is supplied to you for use exclusively as described in the 
.................... * associated software agreement.  This software is protected by 
.................... * software and other intellectual property laws.  Any use in 
.................... * violation of the software license may subject the user to criminal 
.................... * sanctions as well as civil liability.  Copyright 2006 Microchip 
.................... * Technology Inc.  All rights reserved. 
.................... * 
.................... * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
.................... * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
.................... * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
.................... * INFRINGEMENT.  Microchip shall in no event be liable for special, 
.................... * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     11/1/02 Fixed TCPTick() SYN Retry bug. 
....................  * Darren Rook (CCS)    06/28/04  Applied 2.20 fix (above) 
....................  * Darren Rook (CCS)    06/30/04 TCPTick() will not time out an establisehd socket if that socket is in server mode. 
....................  * Darren Rook (CCS)    07/02/04 A bug fix for change made on 06/28/04 
....................  * Darren Rook (CCS)    07/12/04 TCPConnect() will set StartTick to fix a bug with timeout 
....................  * Darren Rook (CCS)    07/12/04 TCPInit() attempts to make _NextPort a random number 
....................  * Darren Rook (CCS)    07/12/06 startTick spelled wrong (case) 
....................  * Nilesh Rajbharti     12/5/02   Modified TCPProcess() 
....................  *                              to include localIP as third param. 
....................  *                              This was done to allow this function 
....................  *                              to calculate checksum correctly. 
....................  * Roy Schofield      10/1/04   TCPConnect() startTick bug fix. 
....................  * Howard Schlunder      1/3/05   Fixed HandleTCPSeg() unexpected 
....................  *                         discard problem identified by Richard 
....................  *                         Shelquist. 
....................  * Howard Schlunder      1/16/06   Fixed an imporbable RX checksum bug 
....................  *                        when using a Microchip Ethernet controller) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    09/18/06 Added TCPPutAvailable() 
....................  * Howard Schlunder      5/10/06   Revised TCP state machine, add TCP_FIN_2 
....................  * Howard Schlunder      8/01/06 Adjusted response to ACK only in TCP_SYN_SENT state 
....................  * Howard Schlunder      8/03/06 Fixed checksum comparison check 
....................  *                        reported by DouglasPunch on Microchip Forum. 
....................  * Howard Schlunder      8/11/06 Fixed a resource leak causing MAC TX 
....................  *                        Buffers to be obtained but not 
....................  *                        released when many web requests were 
....................  *                        received concurrently. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.75 stack 
....................  * Darren Rook (CCS)   01/03/07 Fixed a bug in TCPPutArray() 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tcp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  TCP Module Defs for Microchip TCP/IP Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        TCP.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18, PIC24F, PIC24H, dsPIC30F, dsPIC33F 
....................  * Complier:        CCS PCH 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip")  
....................  * and is supplied to you for use exclusively as described in the  
....................  * associated software agreement.  This software is protected by  
....................  * software and other intellectual property laws.  Any use in  
....................  * violation of the software license may subject the user to criminal  
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL  
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED  
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND  
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special,  
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/8/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Nilesh Rajbharti     12/5/03 Modified TCPProcess() prototype. 
....................  *                              See TCP.c for more information. 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef TCP_H 
.................... #define TCP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/tick.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Tick Manager for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Tick.h 
....................  * Dependencies:    None 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     6/28/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * R. Shelquist (CCS)   09/24/04 TickGetDiff fixed so it isn't off by 1 if a<b 
....................  ********************************************************************/ 
....................  
.................... #ifndef TICK_H 
.................... #define TICK_H 
....................  
.................... typedef int16 TICKTYPE; 
....................  
.................... /* 
....................  * This value is used by TCP to implement timeout actions. 
....................  */ 
.................... #define TICKS_PER_SECOND               12 // 10 original value (MiE) 
....................  
.................... #if (TICKS_PER_SECOND < 10 || TICKS_PER_SECOND > 255) 
.................... #error Invalid TICKS_PER_SECONDS specified. 
.................... #endif 
....................  
.................... //16 is the prescalar 
.................... #define CYCLES_PER_TICKS_PER_SECOND getenv("CLOCK")/(4 * 16 * TICKS_PER_SECOND) 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND > 0xFFFF) 
....................  #error Reduce Clock Speed or Increase TICKS_PER_SECOND 
.................... #endif 
....................  
.................... #if (CYCLES_PER_TICKS_PER_SECOND <= 100) 
....................  #error Timer0 not accurate enough.  Raise Clock Speed or Reduce TICKS_PER_SECOND 
.................... #endif 
....................  
....................  
.................... #define TICK_COUNTER 0xFFFF-CYCLES_PER_TICKS_PER_SECOND 
....................  
.................... /* 
.................... #if (getenv("CLOCK")==20000000) 
....................    #define TICK_COUNTER 34250 
.................... #elif (getenv("CLOCK")==40000000) 
....................    #define TICK_COUNTER 3035 
.................... #elif (getenv("CLOCK")==19600000) 
....................    #define TICK_COUNTER 34910 
.................... #else 
....................  #error CALCULATE THIS CLOCK SPEED (INCREMENT TICKCOUNT EVERY 100MS).  SEE TickInit() 
.................... #endif 
.................... */ 
....................  
.................... #define TICK_SECOND  TICKS_PER_SECOND 
....................  
....................  
.................... #define TickGetDiff(a, b)       ((TICKTYPE)(a < b) ? (((TICKTYPE)0xffff - b) + a + 1) : (a - b)) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Tick manager is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initializes Timer0 as a tick counter. 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void TickInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TICK TickGet(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current second value is given 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TICKTYPE TickGet(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TickUpdate(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Internal Tick and Seconds count are updated. 
....................  * 
....................  * Note:            None 
....................  * 
....................  * CCS NOTE:        CCS has removed TickUpdate and replaced it with an interrupt. 
....................  *                  You do not have to call TickUpdate() at a regular interval. 
....................  ********************************************************************/ 
.................... //void TickUpdate(void); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... typedef BYTE TCP_SOCKET; 
.................... typedef WORD TCP_PORT; 
....................  
.................... #ifndef TCP_NO_WAIT_FOR_ACK 
....................    #define TCP_NO_WAIT_FOR_ACK   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * Maximum number of times a connection be retried before 
....................  * closing it down. 
....................  */ 
.................... #define MAX_RETRY_COUNTS    (3) 
....................  
.................... #define INVALID_SOCKET      (0xfe) 
.................... #define UNKNOWN_SOCKET      (0xff) 
....................  
.................... #define REMOTE_HOST(s)      (TCB[s].remote) 
....................  
.................... /* 
....................  * TCP States as defined by rfc793 
....................  */ 
.................... typedef enum _TCP_STATE 
.................... { 
....................     TCP_LISTEN = 0, 
....................     TCP_SYN_SENT, 
....................     TCP_SYN_RECEIVED, 
....................     TCP_ESTABLISHED, 
....................     TCP_FIN_WAIT_1, 
....................     TCP_FIN_WAIT_2, 
....................     TCP_CLOSING, 
....................     TCP_TIME_WAIT, 
....................    TCP_CLOSE_WAIT, 
....................     TCP_LAST_ACK, 
....................     TCP_CLOSED, 
.................... } TCP_STATE; 
....................  
.................... /* 
....................  * Socket info. 
....................  * Union is used to create anonymous structure members. 
....................  */ 
.................... typedef struct _SOCKET_INFO 
.................... { 
....................     TCP_STATE smState; 
....................  
....................     NODE_INFO remote; 
....................     TCP_PORT localPort; 
....................     TCP_PORT remotePort; 
....................  
....................     BUFFER TxBuffer; 
....................     WORD TxCount; 
....................     WORD RxCount; 
....................    WORD RemoteWindow; 
....................     
....................     DWORD SND_SEQ; 
....................     DWORD SND_ACK; 
....................  
....................     BYTE RetryCount; 
....................     TICKTYPE startTick; 
....................     TICKTYPE TimeOut; 
....................  
....................     struct 
....................     { 
....................         int1 bServer        : 1; 
....................         int1 bIsPutReady    : 1; 
....................         int1 bFirstRead     : 1; 
....................         int1 bIsGetReady    : 1; 
....................         int1 bIsTxInProgress : 1; 
....................         int1 bACKValid : 1; 
....................     } Flags; 
....................  
.................... } SOCKET_INFO; 
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TCP is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Initialize all socket info. 
....................  * 
....................  * Note:            This function is called only one during lifetime 
....................  *                  of the application. 
....................  ********************************************************************/ 
.................... void        TCPInit(void); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           port    - A TCP port to be opened. 
....................  * 
....................  * Output:          Given port is opened and returned on success 
....................  *                  INVALID_SOCKET if no more sockets left. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... TCP_SOCKET  TCPListen(TCP_PORT port); 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
....................  *                                      TCP_PORT remotePort) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           remote      - Remote node address info 
....................  *                  remotePort  - remote port to be connected. 
....................  * 
....................  * Output:          A new socket is created, connection request is 
....................  *                  sent and socket handle is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT port); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsConnected(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPDisconnect(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsPutReady(s) == TRUE 
....................  * 
....................  * Input:           s       - Socket to be disconnected. 
....................  * 
....................  * Output:          A disconnect request is sent for given socket. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPDisconnect(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL        TCPIsPutReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s       - socket to use 
....................  *                  byte    - a data byte to send 
....................  * 
....................  * Output:          TRUE if given byte was put in transmit buffer 
....................  *                  FALSE if transmit buffer is full. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPPut(TCP_SOCKET socket, BYTE data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPFlush(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket whose data is to be transmitted. 
....................  * 
....................  * Output:          All and any data associated with this socket 
....................  *                  is marked as ready for transmission. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPFlush(TCP_SOCKET socket); 
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPIsGetReady(TCP_SOCKET s); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPGet(TCP_SOCKET socket, int8 *data); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD        TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPDiscard(TCP_SOCKET socket); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPProcess(NODE_INFO* remote, 
....................  *                                  IP_ADDR *localIP, 
....................  *                                  WORD len) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCP segment is ready in MAC buffer 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  len         - Total length of TCP semgent. 
....................  * 
....................  * Output:          TRUE if this function has completed its task 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL        TCPProcess(NODE_INFO *remote, 
....................                        IP_ADDR *localIP, 
....................                        WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void TCPTick(void) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Each socket FSM is executed for any timeout 
....................  *                  situation. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void        TCPTick(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... #define debug_tcp(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
.................... //#define debug_tcp debug_printf 
....................  
.................... // Max TCP data length is MAC_TX_BUFFER_SIZE - sizeof(TCP_HEADER) - 
.................... // sizeof(IP_HEADER) - sizeof(ETHER_HEADER) 
.................... #define MAX_TCP_DATA_LEN    (MAC_TX_BUFFER_SIZE - 54) 
....................  
.................... // TCP Timeout value to begin with. 
.................... #define TCP_START_TIMEOUT_VAL   (TICKS_PER_SECOND * (TICKTYPE)3) 
....................  
.................... // TCP Flags defined in RFC 
.................... #define FIN     (0x01) 
.................... #define SYN     (0x02) 
.................... #define RST     (0x04) 
.................... #define PSH     (0x08) 
.................... #define ACK     (0x10) 
.................... #define URG     (0x20) 
....................  
....................  
.................... // TCP Header 
.................... typedef struct _TCP_HEADER 
.................... { 
....................     WORD    SourcePort; 
....................     WORD    DestPort; 
....................     DWORD   SeqNumber; 
....................     DWORD   AckNumber; 
....................  
....................     struct 
....................     { 
....................        BYTE Reserved3:4; 
....................        BYTE Val:4; 
....................     } DataOffset; 
....................  
....................  
....................     union 
....................     { 
....................         struct 
....................         { 
....................              int1 flagFIN    : 1; 
....................              int1 flagSYN    : 1; 
....................              int1 flagRST    : 1; 
....................              int1 flagPSH    : 1; 
....................              int1 flagACK    : 1; 
....................              int1 flagURG    : 1; 
....................              int1 Reserved2  : 2; 
....................         } bits; 
....................         BYTE b; 
....................     } Flags; 
....................  
....................     WORD    Window; 
....................     WORD    Checksum; 
....................     WORD    UrgentPointer; 
.................... } TCP_HEADER; 
....................  
....................  
.................... // TCP Options as defined by RFC 
.................... #define TCP_OPTIONS_END_OF_LIST     (0x00) 
.................... #define TCP_OPTIONS_NO_OP           (0x01) 
.................... #define TCP_OPTIONS_MAX_SEG_SIZE    (0x02) 
.................... typedef struct _TCP_OPTIONS 
.................... { 
....................     BYTE        Kind; 
....................     BYTE        Length; 
....................     WORD_VAL    MaxSegSize; 
.................... } TCP_OPTIONS; 
....................  
.................... #define SwapPseudoTCPHeader(h)  (h.TCPLength = swaps(h.TCPLength)) 
....................  
.................... // IP pseudo header as defined by RFC 793 
.................... typedef struct _PSEUDO_HEADER 
.................... { 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................     BYTE Zero; 
....................     BYTE Protocol; 
....................     WORD TCPLength; 
.................... } PSEUDO_HEADER; 
....................  
.................... #define LOCAL_PORT_START_NUMBER (1024) 
.................... #define LOCAL_PORT_END_NUMBER   (5000) 
....................  
.................... // Local temp port numbers. 
.................... static WORD _NextPort = LOCAL_PORT_START_NUMBER; 
....................  
.................... // The TCB array is very large.  With the C18 compiler, one must 
.................... // modify the linker script to make an array that spans more than 
.................... // one memory bank.  To do this, make the necessary changes to your 
.................... // processor's linker script (.lkr).  Here is an example showing 
.................... // gpr11 and 128 bytes of gpr12 being combined into one 384 byte 
.................... // block used exclusively by the TCB_MEM data section: 
.................... // ... 
.................... // //DATABANK   NAME=gpr11      START=0xB00          END=0xBFF 
.................... // //DATABANK   NAME=gpr12      START=0xC00          END=0xCFF 
.................... // DATABANK   NAME=gpr11b     START=0xB00          END=0xC7F           PROTECTED 
.................... // DATABANK   NAME=gpr12      START=0xC80          END=0xCFF 
.................... // ... 
.................... // SECTION    NAME=TCB_MEM    RAM=gpr11b 
.................... // ... 
.................... //#pragma udata TCB_MEM   //not needed in ccs 
.................... SOCKET_INFO TCB[MAX_SOCKETS]; 
.................... //   #pragma udata bla   // Return to any other RAM section   //not needed in ccs 
....................  
.................... static void    HandleTCPSeg(TCP_SOCKET s, 
....................                                NODE_INFO *remote, 
....................                                TCP_HEADER *h, 
....................                                WORD len); 
....................  
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                         TCP_PORT localPort, 
....................                         TCP_PORT remotePort, 
....................                         DWORD tseq, 
....................                         DWORD tack, 
....................                         BYTE flags, 
....................                         BUFFER buff, 
....................                         WORD len); 
....................  
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................                                     NODE_INFO *remote); 
.................... static void    SwapTCPHeader(TCP_HEADER* header); 
.................... static void CloseSocket(SOCKET_INFO* ps); 
....................  
.................... #define SendTCP(remote, localPort, remotePort, seq, ack, flags)     \ 
....................         TransmitTCP(remote, localPort, remotePort, seq, ack, flags, \ 
....................                     INVALID_BUFFER, 0) 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPInit(void) 
.................... * 
.................... * PreCondition:    None 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          TCP is initialized. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        Initialize all socket states 
.................... * 
.................... * Note:            This function is called only once during lifetime 
.................... *                  of the application. 
.................... ********************************************************************/ 
.................... int16 TCPInit_RandSeed; 
.................... void TCPInit(void) 
.................... { 
....................     TCP_SOCKET s; 
....................     SOCKET_INFO* ps; 
....................  
....................  
....................     // Initialize all sockets. 
....................     for ( s = 0; s < MAX_SOCKETS; s++ ) 
*
01B9A:  MOVLB  8
01B9C:  CLRF   xF9
01B9E:  MOVF   xF9,W
01BA0:  SUBLW  22
01BA2:  BNC   1C86
....................     { 
....................         ps = &TCB[s]; 
01BA4:  MOVLB  9
01BA6:  CLRF   x4B
01BA8:  MOVFF  8F9,94A
01BAC:  CLRF   x4D
01BAE:  MOVLW  24
01BB0:  MOVWF  x4C
01BB2:  MOVLB  0
01BB4:  RCALL  1A40
01BB6:  MOVFF  02,03
01BBA:  MOVF   01,W
01BBC:  ADDLW  9A
01BBE:  MOVWF  01
01BC0:  MOVLW  03
01BC2:  ADDWFC 03,F
01BC4:  MOVFF  01,8FA
01BC8:  MOVLB  8
01BCA:  MOVFF  03,8FB
....................  
....................         ps->smState             = TCP_CLOSED; 
01BCE:  MOVFF  8FA,FE9
01BD2:  MOVFF  8FB,FEA
01BD6:  MOVLW  0A
01BD8:  MOVWF  FEF
....................         ps->Flags.bServer       = FALSE; 
01BDA:  MOVLW  23
01BDC:  ADDWF  xFA,W
01BDE:  MOVWF  FE9
01BE0:  MOVLW  00
01BE2:  ADDWFC xFB,W
01BE4:  MOVWF  FEA
01BE6:  BCF    FEF.0
....................         ps->Flags.bIsPutReady   = TRUE; 
01BE8:  MOVLW  23
01BEA:  ADDWF  xFA,W
01BEC:  MOVWF  FE9
01BEE:  MOVLW  00
01BF0:  ADDWFC xFB,W
01BF2:  MOVWF  FEA
01BF4:  BSF    FEF.1
....................         ps->Flags.bFirstRead    = TRUE; 
01BF6:  MOVLW  23
01BF8:  ADDWF  xFA,W
01BFA:  MOVWF  FE9
01BFC:  MOVLW  00
01BFE:  ADDWFC xFB,W
01C00:  MOVWF  FEA
01C02:  BSF    FEF.2
....................         ps->Flags.bIsTxInProgress = FALSE; 
01C04:  MOVLW  23
01C06:  ADDWF  xFA,W
01C08:  MOVWF  FE9
01C0A:  MOVLW  00
01C0C:  ADDWFC xFB,W
01C0E:  MOVWF  FEA
01C10:  BCF    FEF.4
....................         ps->Flags.bIsGetReady   = FALSE; 
01C12:  MOVLW  23
01C14:  ADDWF  xFA,W
01C16:  MOVWF  FE9
01C18:  MOVLW  00
01C1A:  ADDWFC xFB,W
01C1C:  MOVWF  FEA
01C1E:  BCF    FEF.3
....................       if(ps->TxBuffer != INVALID_BUFFER) 
01C20:  MOVLW  0F
01C22:  ADDWF  xFA,W
01C24:  MOVWF  FE9
01C26:  MOVLW  00
01C28:  ADDWFC xFB,W
01C2A:  MOVWF  FEA
01C2C:  INCFSZ FEF,W
01C2E:  BRA    1C32
01C30:  BRA    1C5C
....................       { 
....................          MACDiscardTx(ps->TxBuffer); 
01C32:  MOVLW  0F
01C34:  ADDWF  xFA,W
01C36:  MOVWF  FE9
01C38:  MOVLW  00
01C3A:  ADDWFC xFB,W
01C3C:  MOVWF  FEA
01C3E:  MOVFF  FEF,8FC
01C42:  MOVFF  8FC,94D
01C46:  MOVLB  0
01C48:  CALL   0004
....................          ps->TxBuffer        = INVALID_BUFFER; 
01C4C:  MOVLW  0F
01C4E:  MOVLB  8
01C50:  ADDWF  xFA,W
01C52:  MOVWF  FE9
01C54:  MOVLW  00
01C56:  ADDWFC xFB,W
01C58:  MOVWF  FEA
01C5A:  SETF   FEF
....................       } 
....................         ps->TimeOut             = TCP_START_TIMEOUT_VAL; 
01C5C:  MOVLW  21
01C5E:  ADDWF  xFA,W
01C60:  MOVWF  FE9
01C62:  MOVLW  00
01C64:  ADDWFC xFB,W
01C66:  MOVWF  FEA
01C68:  CLRF   FEC
01C6A:  MOVF   FED,F
01C6C:  MOVLW  24
01C6E:  MOVWF  FEF
....................       ps->TxCount            = 0; 
01C70:  MOVLW  10
01C72:  ADDWF  xFA,W
01C74:  MOVWF  FE9
01C76:  MOVLW  00
01C78:  ADDWFC xFB,W
01C7A:  MOVWF  FEA
01C7C:  CLRF   FEC
01C7E:  MOVF   FED,F
01C80:  CLRF   FEF
....................    } 
....................  
....................     //_NextPort = LOCAL_PORT_START_NUMBER; 
....................     #if getenv("TIMER0") 
01C82:  INCF   xF9,F
01C84:  BRA    1B9E
....................     TCPInit_RandSeed+=get_timer0(); 
01C86:  MOVF   FD6,W
01C88:  ADDWF  x86,F
01C8A:  MOVF   FD7,W
01C8C:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER1") 
....................      TCPInit_RandSeed+=get_timer1(); 
01C8E:  MOVF   FCE,W
01C90:  ADDWF  x86,F
01C92:  MOVF   FCF,W
01C94:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER2") 
....................      TCPInit_RandSeed+=get_timer2(); 
01C96:  MOVF   FCC,W
01C98:  ADDWF  x86,F
01C9A:  MOVLW  00
01C9C:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER3") 
....................      TCPInit_RandSeed+=get_timer3(); 
01C9E:  MOVF   FB2,W
01CA0:  ADDWF  x86,F
01CA2:  MOVF   FB3,W
01CA4:  ADDWFC x87,F
....................     #endif 
....................     #if getenv("TIMER4") 
....................      TCPInit_RandSeed+=get_timer4(); 
....................     #endif 
....................     #if getenv("TIMER5") 
....................      TCPInit_RandSeed+=get_timer5(); 
....................     #endif 
....................     srand(TCPInit_RandSeed); 
01CA6:  CLRF   xFF
01CA8:  CLRF   xFE
01CAA:  MOVFF  887,8FD
01CAE:  MOVFF  886,8FC
01CB2:  MOVLB  0
01CB4:  BRA    1A62
....................     _NextPort=rand(); 
01CB6:  BRA    1B18
01CB8:  MOVFF  02,399
01CBC:  MOVFF  01,398
....................     _NextPort+=LOCAL_PORT_START_NUMBER; 
01CC0:  MOVLW  04
01CC2:  MOVLB  3
01CC4:  ADDWF  x99,F
....................     while (_NextPort >= LOCAL_PORT_END_NUMBER) {_NextPort-=LOCAL_PORT_END_NUMBER;} 
01CC6:  MOVF   x99,W
01CC8:  SUBLW  12
01CCA:  BC    1CE0
01CCC:  XORLW  FF
01CCE:  BNZ   1CD6
01CD0:  MOVF   x98,W
01CD2:  SUBLW  87
01CD4:  BC    1CE0
01CD6:  MOVLW  88
01CD8:  SUBWF  x98,F
01CDA:  MOVLW  13
01CDC:  SUBWFB x99,F
01CDE:  BRA    1CC6
....................     if (_NextPort < LOCAL_PORT_START_NUMBER) {_NextPort+=LOCAL_PORT_START_NUMBER;} 
01CE0:  MOVF   x99,W
01CE2:  SUBLW  03
01CE4:  BNC   1CEA
01CE6:  MOVLW  04
01CE8:  ADDWF  x99,F
01CEA:  MOVLB  0
01CEC:  GOTO   1CFE (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPListen(TCP_PORT port) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           port    - A TCP port to be opened. 
.................... * 
.................... * Output:          Given port is opened and returned on success 
.................... *                  INVALID_SOCKET if no more sockets left. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPListen(TCP_PORT port) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................  
....................    debug_tcp("\r\nTCP LISTEN PORT=%LU -> ", port); 
....................  
....................    for(s = 0; s < MAX_SOCKETS; s++) 
....................    { 
....................       ps = &TCB[s]; 
....................  
....................       if(ps->smState == TCP_CLOSED) 
....................       { 
....................          // We have a CLOSED socket. 
....................          // Initialize it with LISTENing state info. 
....................          ps->smState             = TCP_LISTEN; 
....................          ps->localPort           = port; 
....................          ps->remotePort          = 0; 
....................  
....................          // There is no remote node IP address info yet. 
....................          ps->remote.IPAddr.Val   = 0x00; 
....................  
....................          // If a socket is listened on, it is a SERVER. 
....................          ps->Flags.bServer       = TRUE; 
....................  
....................          ps->Flags.bIsGetReady   = FALSE; 
....................          if(ps->TxBuffer != INVALID_BUFFER) 
....................          { 
....................             MACDiscardTx(ps->TxBuffer); 
....................             ps->TxBuffer        = INVALID_BUFFER; 
....................          } 
....................          ps->Flags.bIsPutReady   = TRUE; 
....................  
....................          debug_tcp("SOCK=%U", s); 
....................  
....................          return s; 
....................       } 
....................    } 
....................  
....................    debug_tcp("FAIL"); 
....................  
....................    return INVALID_SOCKET; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        TCP_SOCKET TCPConnect(NODE_INFO* remote, 
.................... *                                      TCP_PORT remotePort) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           remote      - Remote node address info 
.................... *                  remotePort  - remote port to be connected. 
.................... * 
.................... * Output:          A new socket is created, connection request is 
.................... *                  sent and socket handle is returned. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... ********************************************************************/ 
.................... TCP_SOCKET TCPConnect(NODE_INFO *remote, TCP_PORT remotePort) 
.................... { 
....................    TCP_SOCKET s; 
....................    SOCKET_INFO* ps; 
....................    BOOL lbFound; 
....................  
....................  
....................    lbFound = FALSE; 
*
05D5E:  MOVLB  9
05D60:  BCF    x03.0
....................  
....................    debug_tcp("\r\nTCP CONNECT PORT=%LU -> ", remotePort); 
....................  
....................    // Find an available socket 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
05D62:  CLRF   x00
05D64:  MOVF   x00,W
05D66:  SUBLW  22
05D68:  BNC   5DAA
....................    { 
....................       ps = &TCB[s]; 
05D6A:  CLRF   x4B
05D6C:  MOVFF  900,94A
05D70:  CLRF   x4D
05D72:  MOVLW  24
05D74:  MOVWF  x4C
05D76:  MOVLB  0
05D78:  CALL   1A40
05D7C:  MOVFF  02,03
05D80:  MOVF   01,W
05D82:  ADDLW  9A
05D84:  MOVWF  01
05D86:  MOVLW  03
05D88:  ADDWFC 03,F
05D8A:  MOVFF  01,901
05D8E:  MOVLB  9
05D90:  MOVFF  03,902
....................       if(ps->smState == TCP_CLOSED) 
05D94:  MOVFF  901,FE9
05D98:  MOVFF  902,FEA
05D9C:  MOVF   FEF,W
05D9E:  SUBLW  0A
05DA0:  BNZ   5DA6
....................       { 
....................          lbFound = TRUE; 
05DA2:  BSF    x03.0
....................          break; 
05DA4:  BRA    5DAA
....................       } 
05DA6:  INCF   x00,F
05DA8:  BRA    5D64
....................    } 
....................  
....................    // If there is no socket available, return error. 
....................    if(!lbFound) 
05DAA:  BTFSC  x03.0
05DAC:  BRA    5DB4
....................       return INVALID_SOCKET; 
05DAE:  MOVLW  FE
05DB0:  MOVWF  01
05DB2:  BRA    5F84
....................  
....................    // Each new socket that is opened by this node, gets 
....................    // next sequential port number. 
....................    ps->localPort = ++_NextPort; 
05DB4:  MOVLW  0B
05DB6:  ADDWF  x01,W
05DB8:  MOVWF  FE9
05DBA:  MOVLW  00
05DBC:  ADDWFC x02,W
05DBE:  MOVWF  FEA
05DC0:  MOVLB  3
05DC2:  INCF   x98,F
05DC4:  BTFSC  FD8.2
05DC6:  INCF   x99,F
05DC8:  MOVFF  399,FEC
05DCC:  MOVF   FED,F
05DCE:  MOVFF  398,FEF
....................    if(_NextPort >= LOCAL_PORT_END_NUMBER) 
05DD2:  MOVF   x99,W
05DD4:  SUBLW  12
05DD6:  BC    5DE8
05DD8:  XORLW  FF
05DDA:  BNZ   5DE2
05DDC:  MOVF   x98,W
05DDE:  SUBLW  87
05DE0:  BC    5DE8
....................       _NextPort = LOCAL_PORT_START_NUMBER-1; 
05DE2:  MOVLW  03
05DE4:  MOVWF  x99
05DE6:  SETF   x98
....................  
....................    // This is a client socket. 
....................    ps->Flags.bServer = FALSE; 
05DE8:  MOVLW  23
05DEA:  MOVLB  9
05DEC:  ADDWF  x01,W
05DEE:  MOVWF  FE9
05DF0:  MOVLW  00
05DF2:  ADDWFC x02,W
05DF4:  MOVWF  FEA
05DF6:  BCF    FEF.0
....................  
....................    // This is the port, we are trying to connect to. 
....................    ps->remotePort = remotePort; 
05DF8:  MOVLW  0D
05DFA:  ADDWF  x01,W
05DFC:  MOVWF  FE9
05DFE:  MOVLW  00
05E00:  ADDWFC x02,W
05E02:  MOVWF  FEA
05E04:  MOVFF  8FF,FEC
05E08:  MOVF   FED,F
05E0A:  MOVFF  8FE,FEF
....................  
....................    // Each new socket that is opened by this node, will 
....................    // start with next the next seqeuence number (essentially random) 
....................    ps->SND_SEQ++; 
05E0E:  MOVLW  16
05E10:  ADDWF  x01,W
05E12:  MOVWF  FE9
05E14:  MOVLW  00
05E16:  ADDWFC x02,W
05E18:  MOVWF  FEA
05E1A:  MOVLW  01
05E1C:  ADDWF  FEE,F
05E1E:  MOVLW  00
05E20:  ADDWFC FEE,F
05E22:  ADDWFC FEE,F
05E24:  ADDWFC FED,F
....................    ps->SND_ACK = 0; 
05E26:  MOVLW  1A
05E28:  ADDWF  x01,W
05E2A:  MOVWF  FE9
05E2C:  MOVLW  00
05E2E:  ADDWFC x02,W
05E30:  MOVWF  FEA
05E32:  MOVF   FEE,F
05E34:  MOVF   FEE,F
05E36:  CLRF   FEC
05E38:  MOVF   FED,F
05E3A:  CLRF   FEF
05E3C:  MOVF   FED,F
05E3E:  CLRF   FEF
05E40:  MOVF   FED,F
05E42:  CLRF   FEF
....................  
....................    memcpy((BYTE*)&ps->remote, (void*)remote, sizeof(ps->remote)); 
05E44:  MOVLW  01
05E46:  ADDWF  x01,W
05E48:  MOVWF  01
05E4A:  MOVLW  00
05E4C:  ADDWFC x02,W
05E4E:  MOVWF  03
05E50:  MOVFF  01,904
05E54:  MOVWF  x05
05E56:  MOVWF  FEA
05E58:  MOVFF  01,FE9
05E5C:  MOVFF  8FD,FE2
05E60:  MOVFF  8FC,FE1
05E64:  MOVLW  0A
05E66:  MOVWF  01
05E68:  MOVFF  FE6,FEE
05E6C:  DECFSZ 01,F
05E6E:  BRA    5E68
....................  
....................    // Send SYN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       SYN); 
05E70:  MOVLW  01
05E72:  ADDWF  x01,W
05E74:  MOVWF  01
05E76:  MOVLW  00
05E78:  ADDWFC x02,W
05E7A:  MOVWF  03
05E7C:  MOVFF  01,904
05E80:  MOVWF  x05
05E82:  MOVLW  0B
05E84:  ADDWF  x01,W
05E86:  MOVWF  FE9
05E88:  MOVLW  00
05E8A:  ADDWFC x02,W
05E8C:  MOVWF  FEA
05E8E:  MOVFF  FEC,907
05E92:  MOVF   FED,F
05E94:  MOVFF  FEF,906
05E98:  MOVLW  0D
05E9A:  ADDWF  x01,W
05E9C:  MOVWF  FE9
05E9E:  MOVLW  00
05EA0:  ADDWFC x02,W
05EA2:  MOVWF  FEA
05EA4:  MOVFF  FEC,909
05EA8:  MOVF   FED,F
05EAA:  MOVFF  FEF,908
05EAE:  MOVLW  16
05EB0:  ADDWF  x01,W
05EB2:  MOVWF  FE9
05EB4:  MOVLW  00
05EB6:  ADDWFC x02,W
05EB8:  MOVWF  FEA
05EBA:  MOVFF  FEF,90A
05EBE:  MOVFF  FEC,90B
05EC2:  MOVFF  FEC,90C
05EC6:  MOVFF  FEC,90D
05ECA:  MOVLW  1A
05ECC:  ADDWF  x01,W
05ECE:  MOVWF  FE9
05ED0:  MOVLW  00
05ED2:  ADDWFC x02,W
05ED4:  MOVWF  FEA
05ED6:  MOVFF  FEF,90E
05EDA:  MOVFF  FEC,90F
05EDE:  MOVFF  FEC,910
05EE2:  MOVFF  FEC,911
05EE6:  MOVFF  03,94F
05EEA:  MOVFF  01,94E
05EEE:  MOVFF  907,951
05EF2:  MOVFF  906,950
05EF6:  MOVFF  909,953
05EFA:  MOVFF  908,952
05EFE:  MOVFF  90D,957
05F02:  MOVFF  90C,956
05F06:  MOVFF  90B,955
05F0A:  MOVFF  90A,954
05F0E:  MOVFF  911,95B
05F12:  MOVFF  910,95A
05F16:  MOVFF  90F,959
05F1A:  MOVFF  90E,958
05F1E:  MOVLW  02
05F20:  MOVWF  x5C
05F22:  SETF   x5D
05F24:  CLRF   x5F
05F26:  CLRF   x5E
05F28:  MOVLB  0
05F2A:  CALL   4514
....................  
....................    ps->smState = TCP_SYN_SENT; 
05F2E:  MOVLB  9
05F30:  MOVFF  901,FE9
05F34:  MOVFF  902,FEA
05F38:  MOVLW  01
05F3A:  MOVWF  FEF
....................    ps->SND_SEQ++; 
05F3C:  MOVLW  16
05F3E:  ADDWF  x01,W
05F40:  MOVWF  FE9
05F42:  MOVLW  00
05F44:  ADDWFC x02,W
05F46:  MOVWF  FEA
05F48:  MOVLW  01
05F4A:  ADDWF  FEE,F
05F4C:  MOVLW  00
05F4E:  ADDWFC FEE,F
05F50:  ADDWFC FEE,F
05F52:  ADDWFC FED,F
....................  
....................    // Allow TCPTick() to operate properly 
....................    ps->startTick = TickGet(); 
05F54:  MOVLW  1F
05F56:  ADDWF  x01,W
05F58:  MOVWF  01
05F5A:  MOVLW  00
05F5C:  ADDWFC x02,W
05F5E:  MOVWF  03
05F60:  MOVFF  01,904
05F64:  MOVWF  x05
05F66:  MOVLB  0
05F68:  CALL   40BA
05F6C:  MOVFF  905,FEA
05F70:  MOVFF  904,FE9
05F74:  MOVFF  02,FEC
05F78:  MOVF   FED,F
05F7A:  MOVFF  01,FEF
....................  
....................    debug_tcp("SOCK=%U", s); 
....................  
....................    return s; 
05F7E:  MOVLB  9
05F80:  MOVFF  900,01
05F84:  MOVLB  0
05F86:  GOTO   6AF2 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsConnected(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - Socket to be checked for connection. 
....................  * 
....................  * Output:          TRUE    if given socket is connected 
....................  *                  FALSE   if given socket is not connected. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            A socket is said to be connected if it is not 
....................  *                  in LISTEN and CLOSED mode.  Socket may be in 
....................  *                  SYN_RCVD or FIN_WAIT_1 and may contain socket 
....................  *                  data. 
....................  ********************************************************************/ 
.................... BOOL TCPIsConnected(TCP_SOCKET s) 
.................... { 
....................     return ( TCB[s].smState == TCP_ESTABLISHED ); 
05F8A:  MOVLB  9
05F8C:  CLRF   x4B
05F8E:  MOVFF  8FC,94A
05F92:  CLRF   x4D
05F94:  MOVLW  24
05F96:  MOVWF  x4C
05F98:  MOVLB  0
05F9A:  CALL   1A40
05F9E:  MOVFF  02,8FE
05FA2:  MOVFF  01,8FD
05FA6:  MOVLW  9A
05FA8:  MOVLB  8
05FAA:  ADDWF  01,W
05FAC:  MOVWF  FE9
05FAE:  MOVLW  03
05FB0:  ADDWFC 02,W
05FB2:  MOVWF  FEA
05FB4:  MOVF   FEF,W
05FB6:  SUBLW  03
05FB8:  BZ    5FBE
05FBA:  MOVLW  00
05FBC:  BRA    5FC0
05FBE:  MOVLW  01
05FC0:  MOVWF  01
05FC2:  MOVLB  0
05FC4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPDisconnect(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady(s) == TRUE 
.................... * 
.................... * Input:           s       - Socket to be disconnected. 
.................... * 
.................... * Output:          A disconnect request is sent for given socket. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPDisconnect(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
0671A:  MOVLB  9
0671C:  CLRF   x4B
0671E:  MOVFF  8FE,94A
06722:  CLRF   x4D
06724:  MOVLW  24
06726:  MOVWF  x4C
06728:  MOVLB  0
0672A:  CALL   1A40
0672E:  MOVFF  02,03
06732:  MOVF   01,W
06734:  ADDLW  9A
06736:  MOVWF  01
06738:  MOVLW  03
0673A:  ADDWFC 03,F
0673C:  MOVFF  01,8FF
06740:  MOVLB  8
06742:  MOVFF  03,900
....................  
....................    // If socket is not connected, may be it is already closed 
....................    // or in the process of closing.  Since we have called this 
....................    // explicitly, close it forcefully. 
....................    if(ps->smState != TCP_ESTABLISHED && ps->smState != TCP_SYN_RECEIVED) 
06746:  MOVFF  8FF,FE9
0674A:  MOVLB  9
0674C:  MOVFF  900,FEA
06750:  MOVF   FEF,W
06752:  SUBLW  03
06754:  BZ    6778
06756:  MOVFF  8FF,FE9
0675A:  MOVLB  9
0675C:  MOVFF  900,FEA
06760:  MOVF   FEF,W
06762:  SUBLW  02
06764:  BZ    6778
....................    { 
....................       CloseSocket(ps); 
06766:  MOVFF  900,94B
0676A:  MOVFF  8FF,94A
0676E:  MOVLB  0
06770:  CALL   40D4
....................       return; 
06774:  BRA    687E
06776:  MOVLB  9
....................    } 
....................  
....................    // Discard any outstanding data that is to be read. 
....................    TCPDiscard(s); 
06778:  MOVFF  8FE,903
0677C:  MOVLB  0
0677E:  BRA    66B8
....................  
....................    // Send FIN message. 
....................    SendTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       FIN | ACK); 
06780:  MOVLW  01
06782:  MOVLB  8
06784:  ADDWF  xFF,W
06786:  MOVWF  01
06788:  MOVLW  00
0678A:  MOVLB  9
0678C:  ADDWFC x00,W
0678E:  MOVWF  03
06790:  MOVFF  01,901
06794:  MOVWF  x02
06796:  MOVLW  0B
06798:  MOVLB  8
0679A:  ADDWF  xFF,W
0679C:  MOVWF  FE9
0679E:  MOVLW  00
067A0:  MOVLB  9
067A2:  ADDWFC x00,W
067A4:  MOVWF  FEA
067A6:  MOVFF  FEC,904
067AA:  MOVF   FED,F
067AC:  MOVFF  FEF,903
067B0:  MOVLW  0D
067B2:  MOVLB  8
067B4:  ADDWF  xFF,W
067B6:  MOVWF  FE9
067B8:  MOVLW  00
067BA:  MOVLB  9
067BC:  ADDWFC x00,W
067BE:  MOVWF  FEA
067C0:  MOVFF  FEC,906
067C4:  MOVF   FED,F
067C6:  MOVFF  FEF,905
067CA:  MOVLW  16
067CC:  MOVLB  8
067CE:  ADDWF  xFF,W
067D0:  MOVWF  FE9
067D2:  MOVLW  00
067D4:  MOVLB  9
067D6:  ADDWFC x00,W
067D8:  MOVWF  FEA
067DA:  MOVFF  FEF,907
067DE:  MOVFF  FEC,908
067E2:  MOVFF  FEC,909
067E6:  MOVFF  FEC,90A
067EA:  MOVLW  1A
067EC:  MOVLB  8
067EE:  ADDWF  xFF,W
067F0:  MOVWF  FE9
067F2:  MOVLW  00
067F4:  MOVLB  9
067F6:  ADDWFC x00,W
067F8:  MOVWF  FEA
067FA:  MOVFF  FEF,90B
067FE:  MOVFF  FEC,90C
06802:  MOVFF  FEC,90D
06806:  MOVFF  FEC,90E
0680A:  MOVFF  03,94F
0680E:  MOVFF  01,94E
06812:  MOVFF  904,951
06816:  MOVFF  903,950
0681A:  MOVFF  906,953
0681E:  MOVFF  905,952
06822:  MOVFF  90A,957
06826:  MOVFF  909,956
0682A:  MOVFF  908,955
0682E:  MOVFF  907,954
06832:  MOVFF  90E,95B
06836:  MOVFF  90D,95A
0683A:  MOVFF  90C,959
0683E:  MOVFF  90B,958
06842:  MOVLW  11
06844:  MOVWF  x5C
06846:  SETF   x5D
06848:  CLRF   x5F
0684A:  CLRF   x5E
0684C:  MOVLB  0
0684E:  CALL   4514
....................    //DebugPrint("."); 
....................  
....................    ps->SND_SEQ++; 
06852:  MOVLW  16
06854:  MOVLB  8
06856:  ADDWF  xFF,W
06858:  MOVWF  FE9
0685A:  MOVLW  00
0685C:  MOVLB  9
0685E:  ADDWFC x00,W
06860:  MOVWF  FEA
06862:  MOVLW  01
06864:  ADDWF  FEE,F
06866:  MOVLW  00
06868:  ADDWFC FEE,F
0686A:  ADDWFC FEE,F
0686C:  ADDWFC FED,F
....................  
....................    ps->smState = TCP_FIN_WAIT_1; 
0686E:  MOVFF  8FF,FE9
06872:  MOVLB  9
06874:  MOVFF  900,FEA
06878:  MOVLW  04
0687A:  MOVWF  FEF
0687C:  MOVLB  0
....................  
....................    return; 
0687E:  RETURN 0
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPFlush(TCP_SOCKET s) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           s       - Socket whose data is to be transmitted. 
.................... * 
.................... * Output:          All and any data associated with this socket 
.................... *                  is marked as ready for transmission. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPFlush(TCP_SOCKET s) 
.................... { 
....................    SOCKET_INFO *ps; 
....................  
....................    ps = &TCB[s]; 
*
06300:  MOVLB  9
06302:  CLRF   x4B
06304:  MOVFF  909,94A
06308:  CLRF   x4D
0630A:  MOVLW  24
0630C:  MOVWF  x4C
0630E:  MOVLB  0
06310:  CALL   1A40
06314:  MOVFF  02,03
06318:  MOVF   01,W
0631A:  ADDLW  9A
0631C:  MOVWF  01
0631E:  MOVLW  03
06320:  ADDWFC 03,F
06322:  MOVFF  01,90A
06326:  MOVLB  9
06328:  MOVFF  03,90B
....................  
....................    // Make sure that there is TxBuffer assigned to this socket. 
....................    if ( ps->TxBuffer == INVALID_BUFFER ) 
0632C:  MOVLW  0F
0632E:  ADDWF  x0A,W
06330:  MOVWF  FE9
06332:  MOVLW  00
06334:  ADDWFC x0B,W
06336:  MOVWF  FEA
06338:  INCFSZ FEF,W
0633A:  BRA    6342
....................       return FALSE; 
0633C:  MOVLW  00
0633E:  MOVWF  01
06340:  BRA    64D8
....................  
....................    if ( ps->Flags.bIsPutReady == FALSE ) 
06342:  MOVLW  23
06344:  ADDWF  x0A,W
06346:  MOVWF  FE9
06348:  MOVLW  00
0634A:  ADDWFC x0B,W
0634C:  MOVWF  FEA
0634E:  MOVFF  FEF,00
06352:  RRCF   00,W
06354:  ANDLW  01
06356:  BNZ   635E
....................       return FALSE; 
06358:  MOVLW  00
0635A:  MOVWF  01
0635C:  BRA    64D8
....................  
....................    TransmitTCP(&ps->remote, 
....................       ps->localPort, 
....................       ps->remotePort, 
....................       ps->SND_SEQ, 
....................       ps->SND_ACK, 
....................       ACK + PSH,      // Use PSH to make sure the end application receives the data right away 
....................       ps->TxBuffer, 
....................       ps->TxCount); 
0635E:  MOVLW  01
06360:  ADDWF  x0A,W
06362:  MOVWF  01
06364:  MOVLW  00
06366:  ADDWFC x0B,W
06368:  MOVWF  03
0636A:  MOVFF  01,90C
0636E:  MOVWF  x0D
06370:  MOVLW  0B
06372:  ADDWF  x0A,W
06374:  MOVWF  FE9
06376:  MOVLW  00
06378:  ADDWFC x0B,W
0637A:  MOVWF  FEA
0637C:  MOVFF  FEC,90F
06380:  MOVF   FED,F
06382:  MOVFF  FEF,90E
06386:  MOVLW  0D
06388:  ADDWF  x0A,W
0638A:  MOVWF  FE9
0638C:  MOVLW  00
0638E:  ADDWFC x0B,W
06390:  MOVWF  FEA
06392:  MOVFF  FEC,911
06396:  MOVF   FED,F
06398:  MOVFF  FEF,910
0639C:  MOVLW  16
0639E:  ADDWF  x0A,W
063A0:  MOVWF  FE9
063A2:  MOVLW  00
063A4:  ADDWFC x0B,W
063A6:  MOVWF  FEA
063A8:  MOVFF  FEF,912
063AC:  MOVFF  FEC,913
063B0:  MOVFF  FEC,914
063B4:  MOVFF  FEC,915
063B8:  MOVLW  1A
063BA:  ADDWF  x0A,W
063BC:  MOVWF  FE9
063BE:  MOVLW  00
063C0:  ADDWFC x0B,W
063C2:  MOVWF  FEA
063C4:  MOVFF  FEF,916
063C8:  MOVFF  FEC,917
063CC:  MOVFF  FEC,918
063D0:  MOVFF  FEC,919
063D4:  MOVLW  0F
063D6:  ADDWF  x0A,W
063D8:  MOVWF  FE9
063DA:  MOVLW  00
063DC:  ADDWFC x0B,W
063DE:  MOVWF  FEA
063E0:  MOVFF  FEF,91A
063E4:  MOVLW  10
063E6:  ADDWF  x0A,W
063E8:  MOVWF  FE9
063EA:  MOVLW  00
063EC:  ADDWFC x0B,W
063EE:  MOVWF  FEA
063F0:  MOVFF  FEC,91C
063F4:  MOVF   FED,F
063F6:  MOVFF  FEF,91B
063FA:  MOVFF  03,94F
063FE:  MOVFF  01,94E
06402:  MOVFF  90F,951
06406:  MOVFF  90E,950
0640A:  MOVFF  911,953
0640E:  MOVFF  910,952
06412:  MOVFF  915,957
06416:  MOVFF  914,956
0641A:  MOVFF  913,955
0641E:  MOVFF  912,954
06422:  MOVFF  919,95B
06426:  MOVFF  918,95A
0642A:  MOVFF  917,959
0642E:  MOVFF  916,958
06432:  MOVLW  18
06434:  MOVWF  x5C
06436:  MOVFF  91A,95D
0643A:  MOVFF  91C,95F
0643E:  MOVFF  91B,95E
06442:  MOVLB  0
06444:  CALL   4514
....................  
....................    ps->SND_SEQ += (DWORD)ps->TxCount; 
06448:  MOVLW  16
0644A:  MOVLB  9
0644C:  ADDWF  x0A,W
0644E:  MOVWF  01
06450:  MOVLW  00
06452:  ADDWFC x0B,W
06454:  MOVWF  03
06456:  MOVFF  01,90C
0645A:  MOVWF  x0D
0645C:  MOVWF  FEA
0645E:  MOVFF  01,FE9
06462:  MOVFF  FEF,90E
06466:  MOVFF  FEC,90F
0646A:  MOVFF  FEC,910
0646E:  MOVFF  FEC,911
06472:  MOVLW  10
06474:  ADDWF  x0A,W
06476:  MOVWF  FE9
06478:  MOVLW  00
0647A:  ADDWFC x0B,W
0647C:  MOVWF  FEA
0647E:  MOVFF  FEC,03
06482:  MOVF   FED,F
06484:  MOVFF  FEF,00
06488:  MOVFF  03,01
0648C:  CLRF   02
0648E:  CLRF   03
06490:  MOVF   x0E,W
06492:  ADDWF  00,F
06494:  MOVF   x0F,W
06496:  ADDWFC 01,F
06498:  MOVF   x10,W
0649A:  ADDWFC 02,F
0649C:  MOVF   x11,W
0649E:  ADDWFC 03,F
064A0:  MOVFF  90D,FEA
064A4:  MOVFF  90C,FE9
064A8:  MOVFF  00,FEF
064AC:  MOVFF  01,FEC
064B0:  MOVFF  02,FEC
064B4:  MOVFF  03,FEC
....................    ps->Flags.bIsPutReady       = FALSE; 
064B8:  MOVLW  23
064BA:  ADDWF  x0A,W
064BC:  MOVWF  FE9
064BE:  MOVLW  00
064C0:  ADDWFC x0B,W
064C2:  MOVWF  FEA
064C4:  BCF    FEF.1
....................    ps->Flags.bIsTxInProgress   = FALSE; 
064C6:  MOVLW  23
064C8:  ADDWF  x0A,W
064CA:  MOVWF  FE9
064CC:  MOVLW  00
064CE:  ADDWFC x0B,W
064D0:  MOVWF  FEA
064D2:  BCF    FEF.4
....................  
.................... #if TCP_NO_WAIT_FOR_ACK 
....................    if(ps->TxBuffer != INVALID_BUFFER) 
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
....................       ps->TxBuffer        = INVALID_BUFFER; 
....................    } 
....................    ps->Flags.bIsPutReady       = TRUE; 
.................... #endif 
....................  
....................    return TRUE; 
064D4:  MOVLW  01
064D6:  MOVWF  01
064D8:  MOVLB  0
064DA:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsPutReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' is free to transmit 
....................  *                  FALSE if socket 's' is not free to transmit. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            Each socket maintains only transmit buffer. 
....................  *                  Hence until a data packet is acknowledeged by 
....................  *                  remote node, socket will not be ready for 
....................  *                  next transmission. 
....................  *                  All control transmission such as Connect, 
....................  *                  Disconnect do not consume/reserve any transmit 
....................  *                  buffer. 
....................  ********************************************************************/ 
.................... BOOL TCPIsPutReady(TCP_SOCKET s) 
.................... { 
....................    if(TCB[s].RemoteWindow == 0) 
*
060F4:  MOVLB  9
060F6:  CLRF   x4B
060F8:  MOVFF  90E,94A
060FC:  CLRF   x4D
060FE:  MOVLW  24
06100:  MOVWF  x4C
06102:  MOVLB  0
06104:  CALL   1A40
06108:  MOVFF  01,90F
0610C:  MOVLW  14
0610E:  MOVLB  9
06110:  ADDWF  01,W
06112:  MOVWF  01
06114:  MOVLW  00
06116:  ADDWFC 02,W
06118:  MOVWF  03
0611A:  MOVF   01,W
0611C:  ADDLW  9A
0611E:  MOVWF  FE9
06120:  MOVLW  03
06122:  ADDWFC 03,W
06124:  MOVWF  FEA
06126:  MOVFF  FEC,910
0612A:  MOVF   FED,F
0612C:  MOVFF  FEF,90F
06130:  MOVF   x0F,F
06132:  BNZ   613E
06134:  MOVF   x10,F
06136:  BNZ   613E
....................       return FALSE; 
06138:  MOVLW  00
0613A:  MOVWF  01
0613C:  BRA    61BE
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
0613E:  CLRF   x4B
06140:  MOVFF  90E,94A
06144:  CLRF   x4D
06146:  MOVLW  24
06148:  MOVWF  x4C
0614A:  MOVLB  0
0614C:  CALL   1A40
06150:  MOVFF  02,910
06154:  MOVFF  01,90F
06158:  MOVLW  0F
0615A:  MOVLB  9
0615C:  ADDWF  01,W
0615E:  MOVWF  01
06160:  MOVLW  00
06162:  ADDWFC 02,W
06164:  MOVWF  03
06166:  MOVF   01,W
06168:  ADDLW  9A
0616A:  MOVWF  FE9
0616C:  MOVLW  03
0616E:  ADDWFC 03,W
06170:  MOVWF  FEA
06172:  INCFSZ FEF,W
06174:  BRA    6186
....................       return IPIsTxReady(FALSE); 
06176:  CLRF   x86
06178:  MOVLB  0
0617A:  CALL   41D6
0617E:  MOVF   01,W
06180:  MOVLB  9
06182:  BRA    61BE
06184:  BRA    61BE
....................    else 
....................       return TCB[s].Flags.bIsPutReady; 
06186:  CLRF   x4B
06188:  MOVFF  90E,94A
0618C:  CLRF   x4D
0618E:  MOVLW  24
06190:  MOVWF  x4C
06192:  MOVLB  0
06194:  CALL   1A40
06198:  MOVFF  02,910
0619C:  MOVFF  01,90F
061A0:  MOVLW  23
061A2:  MOVLB  9
061A4:  ADDWF  x0F,F
061A6:  MOVLW  00
061A8:  ADDWFC x10,F
061AA:  MOVLW  9A
061AC:  ADDWF  x0F,W
061AE:  MOVWF  FE9
061B0:  MOVLW  03
061B2:  ADDWFC x10,W
061B4:  MOVWF  FEA
061B6:  MOVLW  00
061B8:  BTFSC  FEF.1
061BA:  MOVLW  01
061BC:  MOVWF  01
061BE:  MOVLB  0
061C0:  RETURN 0
.................... } 
....................  
....................  
.................... int16 TCPPutAvailable(TCP_SOCKET s) 
.................... { 
....................    int16 txCount, txAvail; 
....................  
....................    if (!TCPIsPutReady(s)) 
061C2:  MOVFF  909,90E
061C6:  RCALL  60F4
061C8:  MOVF   01,F
061CA:  BNZ   61D4
....................       return(0); 
061CC:  MOVLW  00
061CE:  MOVWF  01
061D0:  MOVWF  02
061D2:  BRA    62FA
....................  
....................    if ( TCB[s].TxBuffer == INVALID_BUFFER ) 
061D4:  MOVLB  9
061D6:  CLRF   x4B
061D8:  MOVFF  909,94A
061DC:  CLRF   x4D
061DE:  MOVLW  24
061E0:  MOVWF  x4C
061E2:  MOVLB  0
061E4:  CALL   1A40
061E8:  MOVFF  02,90F
061EC:  MOVFF  01,90E
061F0:  MOVLW  0F
061F2:  MOVLB  9
061F4:  ADDWF  01,W
061F6:  MOVWF  01
061F8:  MOVLW  00
061FA:  ADDWFC 02,W
061FC:  MOVWF  03
061FE:  MOVF   01,W
06200:  ADDLW  9A
06202:  MOVWF  FE9
06204:  MOVLW  03
06206:  ADDWFC 03,W
06208:  MOVWF  FEA
0620A:  INCFSZ FEF,W
0620C:  BRA    6214
....................       txCount = 0; 
0620E:  CLRF   x0B
06210:  CLRF   x0A
06212:  BRA    624E
....................    else 
....................       txCount = TCB[s].TxCount; 
06214:  CLRF   x4B
06216:  MOVFF  909,94A
0621A:  CLRF   x4D
0621C:  MOVLW  24
0621E:  MOVWF  x4C
06220:  MOVLB  0
06222:  CALL   1A40
06226:  MOVFF  01,90E
0622A:  MOVLW  10
0622C:  MOVLB  9
0622E:  ADDWF  01,W
06230:  MOVWF  01
06232:  MOVLW  00
06234:  ADDWFC 02,W
06236:  MOVWF  03
06238:  MOVF   01,W
0623A:  ADDLW  9A
0623C:  MOVWF  FE9
0623E:  MOVLW  03
06240:  ADDWFC 03,W
06242:  MOVWF  FEA
06244:  MOVFF  FEC,90B
06248:  MOVF   FED,F
0624A:  MOVFF  FEF,90A
....................  
....................    txAvail = MAX_TCP_DATA_LEN - txCount; 
0624E:  MOVLW  CA
06250:  BSF    FD8.0
06252:  SUBFWB x0A,W
06254:  MOVWF  x0C
06256:  MOVLW  03
06258:  SUBFWB x0B,W
0625A:  MOVWF  x0D
....................  
....................    txAvail = txAvail > TCB[s].RemoteWindow ? TCB[s].RemoteWindow : txAvail; 
0625C:  CLRF   x4B
0625E:  MOVFF  909,94A
06262:  CLRF   x4D
06264:  MOVLW  24
06266:  MOVWF  x4C
06268:  MOVLB  0
0626A:  CALL   1A40
0626E:  MOVFF  02,90F
06272:  MOVFF  01,90E
06276:  MOVLW  14
06278:  MOVLB  9
0627A:  ADDWF  01,W
0627C:  MOVWF  01
0627E:  MOVLW  00
06280:  ADDWFC 02,W
06282:  MOVWF  03
06284:  MOVF   01,W
06286:  ADDLW  9A
06288:  MOVWF  FE9
0628A:  MOVLW  03
0628C:  ADDWFC 03,W
0628E:  MOVWF  FEA
06290:  MOVFF  FEC,03
06294:  MOVF   FED,F
06296:  MOVFF  FEF,01
0629A:  MOVF   03,W
0629C:  SUBWF  x0D,W
0629E:  BNC   62E6
062A0:  BNZ   62A8
062A2:  MOVF   x0C,W
062A4:  SUBWF  01,W
062A6:  BC    62E6
062A8:  CLRF   x4B
062AA:  MOVFF  909,94A
062AE:  CLRF   x4D
062B0:  MOVLW  24
062B2:  MOVWF  x4C
062B4:  MOVLB  0
062B6:  CALL   1A40
062BA:  MOVFF  02,90F
062BE:  MOVFF  01,90E
062C2:  MOVLW  14
062C4:  MOVLB  9
062C6:  ADDWF  01,W
062C8:  MOVWF  01
062CA:  MOVLW  00
062CC:  ADDWFC 02,W
062CE:  MOVWF  03
062D0:  MOVF   01,W
062D2:  ADDLW  9A
062D4:  MOVWF  FE9
062D6:  MOVLW  03
062D8:  ADDWFC 03,W
062DA:  MOVWF  FEA
062DC:  MOVFF  FEC,03
062E0:  MOVF   FED,F
062E2:  MOVF   FEF,W
062E4:  BRA    62EC
062E6:  MOVFF  90D,03
062EA:  MOVF   x0C,W
062EC:  MOVWF  x0C
062EE:  MOVFF  03,90D
....................  
....................    return(txAvail); 
062F2:  MOVFF  90C,01
062F6:  MOVFF  90D,02
062FA:  MOVLB  0
062FC:  GOTO   65BA (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer -OR- we ran out of space in the remote node's 
....................  *                  window.  In either case you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPPutArray(TCP_SOCKET s, BYTE *ptr, WORD len) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD n; 
....................  
....................    ps = &TCB[s]; 
*
064DC:  MOVLB  9
064DE:  CLRF   x4B
064E0:  MOVFF  8FE,94A
064E4:  CLRF   x4D
064E6:  MOVLW  24
064E8:  MOVWF  x4C
064EA:  MOVLB  0
064EC:  CALL   1A40
064F0:  MOVFF  02,03
064F4:  MOVF   01,W
064F6:  ADDLW  9A
064F8:  MOVWF  01
064FA:  MOVLW  03
064FC:  ADDWFC 03,F
064FE:  MOVFF  01,903
06502:  MOVLB  9
06504:  MOVFF  03,904
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
06508:  MOVLW  14
0650A:  ADDWF  x03,W
0650C:  MOVWF  FE9
0650E:  MOVLW  00
06510:  ADDWFC x04,W
06512:  MOVWF  FEA
06514:  MOVFF  FEC,908
06518:  MOVF   FED,F
0651A:  MOVFF  FEF,907
0651E:  MOVF   x07,F
06520:  BNZ   652E
06522:  MOVF   x08,F
06524:  BNZ   652E
....................       return 0; 
06526:  MOVLW  00
06528:  MOVWF  01
0652A:  MOVWF  02
0652C:  BRA    66B2
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
0652E:  MOVLW  0F
06530:  ADDWF  x03,W
06532:  MOVWF  FE9
06534:  MOVLW  00
06536:  ADDWFC x04,W
06538:  MOVWF  FEA
0653A:  INCFSZ FEF,W
0653C:  BRA    65B2
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
0653E:  MOVLW  0F
06540:  ADDWF  x03,W
06542:  MOVWF  01
06544:  MOVLW  00
06546:  ADDWFC x04,W
06548:  MOVWF  03
0654A:  MOVFF  01,907
0654E:  MOVWF  x08
06550:  CLRF   x86
06552:  MOVLB  0
06554:  CALL   300C
06558:  MOVFF  908,FEA
0655C:  MOVFF  907,FE9
06560:  MOVFF  01,FEF
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
06564:  MOVLW  0F
06566:  MOVLB  9
06568:  ADDWF  x03,W
0656A:  MOVWF  FE9
0656C:  MOVLW  00
0656E:  ADDWFC x04,W
06570:  MOVWF  FEA
06572:  INCFSZ FEF,W
06574:  BRA    657E
....................          return 0; 
06576:  MOVLW  00
06578:  MOVWF  01
0657A:  MOVWF  02
0657C:  BRA    66B2
....................  
....................       ps->TxCount = 0; 
0657E:  MOVLW  10
06580:  ADDWF  x03,W
06582:  MOVWF  FE9
06584:  MOVLW  00
06586:  ADDWFC x04,W
06588:  MOVWF  FEA
0658A:  CLRF   FEC
0658C:  MOVF   FED,F
0658E:  CLRF   FEF
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
06590:  MOVLW  0F
06592:  ADDWF  x03,W
06594:  MOVWF  FE9
06596:  MOVLW  00
06598:  ADDWFC x04,W
0659A:  MOVWF  FEA
0659C:  MOVFF  FEF,907
065A0:  MOVFF  907,99F
065A4:  CLRF   xA1
065A6:  MOVLW  28
065A8:  MOVWF  xA0
065AA:  MOVLB  0
065AC:  CALL   3034
065B0:  MOVLB  9
....................    } 
....................  
....................    n = TCPPutAvailable(s); 
065B2:  MOVFF  8FE,909
065B6:  MOVLB  0
065B8:  BRA    61C2
065BA:  MOVFF  02,906
065BE:  MOVFF  01,905
....................     
....................    len = n < len ? n : len; 
065C2:  MOVLB  9
065C4:  MOVF   x06,W
065C6:  SUBWF  x02,W
065C8:  BNC   65DA
065CA:  BNZ   65D2
065CC:  MOVF   x01,W
065CE:  SUBWF  x05,W
065D0:  BC    65DA
065D2:  MOVFF  906,03
065D6:  MOVF   x05,W
065D8:  BRA    65E0
065DA:  MOVFF  902,03
065DE:  MOVF   x01,W
065E0:  MOVWF  x01
065E2:  MOVFF  03,902
....................    n = len; 
065E6:  MOVFF  902,906
065EA:  MOVFF  901,905
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
065EE:  MOVLW  23
065F0:  ADDWF  x03,W
065F2:  MOVWF  FE9
065F4:  MOVLW  00
065F6:  ADDWFC x04,W
065F8:  MOVWF  FEA
065FA:  BSF    FEF.4
....................  
....................    while (n--) 
065FC:  MOVFF  906,03
06600:  MOVF   x05,W
06602:  BTFSC  FD8.2
06604:  DECF   x06,F
06606:  DECF   x05,F
06608:  IORWF  03,W
0660A:  BZ    667A
....................    { 
....................       MACPut(*ptr++); 
0660C:  MOVFF  900,03
06610:  MOVLB  8
06612:  MOVF   xFF,W
06614:  INCF   xFF,F
06616:  BTFSS  FD8.2
06618:  BRA    6620
0661A:  MOVLB  9
0661C:  INCF   x00,F
0661E:  MOVLB  8
06620:  MOVWF  FE9
06622:  MOVFF  03,FEA
06626:  MOVFF  FEF,907
0662A:  MOVFF  907,9A9
0662E:  MOVLB  0
06630:  CALL   30E2
....................       ps->RemoteWindow -= 1; 
06634:  MOVLW  14
06636:  MOVLB  9
06638:  ADDWF  x03,W
0663A:  MOVWF  FE9
0663C:  MOVLW  00
0663E:  ADDWFC x04,W
06640:  MOVWF  FEA
06642:  MOVLW  01
06644:  SUBWF  FEF,W
06646:  MOVWF  00
06648:  MOVLW  00
0664A:  SUBWFB FEC,W
0664C:  MOVWF  03
0664E:  MOVF   00,W
06650:  MOVF   FED,F
06652:  MOVWF  FEF
06654:  MOVFF  03,FEC
....................       ps->TxCount += 1; 
06658:  MOVLW  10
0665A:  ADDWF  x03,W
0665C:  MOVWF  FE9
0665E:  MOVLW  00
06660:  ADDWFC x04,W
06662:  MOVWF  FEA
06664:  MOVLW  01
06666:  ADDWF  FEF,W
06668:  MOVWF  01
0666A:  MOVLW  00
0666C:  ADDWFC FEC,W
0666E:  MOVWF  03
06670:  MOVF   FED,F
06672:  MOVFF  01,FEF
06676:  MOVWF  FEC
06678:  BRA    65FC
....................    } 
....................  
....................    if(ps->TxCount >= MAX_TCP_DATA_LEN) 
0667A:  MOVLW  10
0667C:  ADDWF  x03,W
0667E:  MOVWF  FE9
06680:  MOVLW  00
06682:  ADDWFC x04,W
06684:  MOVWF  FEA
06686:  MOVFF  FEC,908
0668A:  MOVF   FED,F
0668C:  MOVFF  FEF,907
06690:  MOVF   x08,W
06692:  SUBLW  02
06694:  BC    66AA
06696:  XORLW  FF
06698:  BNZ   66A0
0669A:  MOVF   x07,W
0669C:  SUBLW  C9
0669E:  BC    66AA
....................       TCPFlush(s); 
066A0:  MOVFF  8FE,909
066A4:  MOVLB  0
066A6:  RCALL  6300
066A8:  MOVLB  9
....................  
....................    return(len); 
066AA:  MOVFF  901,01
066AE:  MOVFF  902,02
066B2:  MOVLB  0
066B4:  GOTO   6950 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPPut(TCP_SOCKET s, BYTE *ptr, WORD len) 
....................  * 
....................  * PreCondition:    TCPIsPutReady() == TRUE 
....................  * 
....................  * Input:           s      - socket to use 
....................  *                  ptr    - Block of data to send over TCP 
....................  *                  len    - number of bytes to send over TCP 
....................  * 
....................  * Output:          Total number of bytes written to TCP.  If this value 
....................  *                  is not equal len that means we ran out of space in the 
....................  *                  TX buffer and you will have to continue later. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPPut(TCP_SOCKET s, BYTE byte) 
.................... { 
....................    SOCKET_INFO* ps; 
....................    WORD tempCount; 
....................  
....................    ps = &TCB[s]; 
....................  
....................    // Make sure that the remote node is able to accept our data 
....................    if(ps->RemoteWindow == 0) 
....................       return FALSE; 
....................  
....................    if(ps->TxBuffer == INVALID_BUFFER) 
....................    { 
....................       ps->TxBuffer = MACGetTxBuffer(FALSE); 
....................  
....................       // Check to make sure that we received a TX Buffer 
....................       if(ps->TxBuffer == INVALID_BUFFER) 
....................          return FALSE; 
....................  
....................       ps->TxCount = 0; 
....................  
....................       IPSetTxBuffer(ps->TxBuffer, sizeof(TCP_HEADER)); 
....................    } 
....................  
....................    ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................    MACPut(byte); 
....................    ps->RemoteWindow--; 
....................  
....................    tempCount = ps->TxCount; 
....................    tempCount++; 
....................    ps->TxCount = tempCount; 
....................    if(tempCount >= MAX_TCP_DATA_LEN) 
....................       TCPFlush(s); 
....................  
....................    return TRUE; 
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPDiscard(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket 
....................  * 
....................  * Output:          TRUE if socket received data was discarded 
....................  *                  FALSE if socket received data was already 
....................  *                          discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPDiscard(TCP_SOCKET s) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
066B8:  MOVLB  9
066BA:  CLRF   x4B
066BC:  MOVFF  903,94A
066C0:  CLRF   x4D
066C2:  MOVLW  24
066C4:  MOVWF  x4C
066C6:  MOVLB  0
066C8:  CALL   1A40
066CC:  MOVFF  02,03
066D0:  MOVF   01,W
066D2:  ADDLW  9A
066D4:  MOVWF  01
066D6:  MOVLW  03
066D8:  ADDWFC 03,F
066DA:  MOVFF  01,904
066DE:  MOVLB  9
066E0:  MOVFF  03,905
....................  
....................     // This socket must contain data for it to be discarded. 
....................     if ( !ps->Flags.bIsGetReady ) 
066E4:  MOVLW  23
066E6:  ADDWF  x04,W
066E8:  MOVWF  FE9
066EA:  MOVLW  00
066EC:  ADDWFC x05,W
066EE:  MOVWF  FEA
066F0:  BTFSC  FEF.3
066F2:  BRA    66FA
....................         return FALSE; 
066F4:  MOVLW  00
066F6:  MOVWF  01
066F8:  BRA    6714
....................  
....................     MACDiscardRx(); 
066FA:  MOVLB  0
066FC:  CALL   2C06
....................     ps->Flags.bIsGetReady = FALSE; 
06700:  MOVLW  23
06702:  MOVLB  9
06704:  ADDWF  x04,W
06706:  MOVWF  FE9
06708:  MOVLW  00
0670A:  ADDWFC x05,W
0670C:  MOVWF  FEA
0670E:  BCF    FEF.3
....................  
....................     return TRUE; 
06710:  MOVLW  01
06712:  MOVWF  01
06714:  MOVLB  0
06716:  GOTO   6780 (RETURN)
.................... } 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD TCPGetArray(TCP_SOCKET s, BYTE *buffer, 
....................  *                                      WORD count) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  buffer  - Buffer to hold received data. 
....................  *                  count   - Buffer length 
....................  * 
....................  * Output:          Number of bytes loaded into buffer. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... WORD TCPGetArray(TCP_SOCKET s, BYTE *buff, WORD count) 
.................... { 
....................     SOCKET_INFO *ps; 
....................  
....................     ps = &TCB[s]; 
....................  
....................     if ( ps->Flags.bIsGetReady ) 
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
....................         { 
....................          // Position read pointer to begining of TCP data 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
....................  
....................             ps->Flags.bFirstRead = FALSE; 
....................         } 
....................  
....................         ps->Flags.bIsTxInProgress = TRUE; 
....................  
....................         return MACGetArray(buff, count); 
....................     } 
....................     else 
....................         return 0; 
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPGet(TCP_SOCKET s, BYTE *byte) 
....................  * 
....................  * PreCondition:    TCPInit() is already called     AND 
....................  *                  TCPIsGetReady(s) == TRUE 
....................  * 
....................  * Input:           s       - socket 
....................  *                  byte    - Pointer to a byte. 
....................  * 
....................  * Output:          TRUE if a byte was read. 
....................  *                  FALSE if byte was not read. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPGet(TCP_SOCKET s, BYTE *data) 
.................... { 
....................     SOCKET_INFO* ps; 
....................  
....................     ps = &TCB[s]; 
*
0600C:  MOVLB  9
0600E:  CLRF   x4B
06010:  MOVFF  8FE,94A
06014:  CLRF   x4D
06016:  MOVLW  24
06018:  MOVWF  x4C
0601A:  MOVLB  0
0601C:  CALL   1A40
06020:  MOVFF  02,03
06024:  MOVF   01,W
06026:  ADDLW  9A
06028:  MOVWF  01
0602A:  MOVLW  03
0602C:  ADDWFC 03,F
0602E:  MOVFF  01,901
06032:  MOVLB  9
06034:  MOVFF  03,902
....................  
....................     if ( ps->Flags.bIsGetReady ) 
06038:  MOVLW  23
0603A:  ADDWF  x01,W
0603C:  MOVWF  FE9
0603E:  MOVLW  00
06040:  ADDWFC x02,W
06042:  MOVWF  FEA
06044:  BTFSS  FEF.3
06046:  BRA    60EA
....................     { 
....................         if ( ps->Flags.bFirstRead ) 
06048:  MOVLW  23
0604A:  ADDWF  x01,W
0604C:  MOVWF  FE9
0604E:  MOVLW  00
06050:  ADDWFC x02,W
06052:  MOVWF  FEA
06054:  BTFSS  FEF.2
06056:  BRA    6074
....................         { 
....................             // Position read pointer to begining of correct 
....................             // buffer. 
....................             IPSetRxBuffer(sizeof(TCP_HEADER)); 
06058:  CLRF   x2E
0605A:  MOVLW  14
0605C:  MOVWF  x2D
0605E:  MOVLB  0
06060:  CALL   3C50
....................  
....................             ps->Flags.bFirstRead = FALSE; 
06064:  MOVLW  23
06066:  MOVLB  9
06068:  ADDWF  x01,W
0606A:  MOVWF  FE9
0606C:  MOVLW  00
0606E:  ADDWFC x02,W
06070:  MOVWF  FEA
06072:  BCF    FEF.2
....................         } 
....................  
....................         if ( ps->RxCount == 0 ) 
06074:  MOVLW  12
06076:  ADDWF  x01,W
06078:  MOVWF  FE9
0607A:  MOVLW  00
0607C:  ADDWFC x02,W
0607E:  MOVWF  FEA
06080:  MOVFF  FEC,904
06084:  MOVF   FED,F
06086:  MOVFF  FEF,903
0608A:  MOVF   x03,F
0608C:  BNZ   60AE
0608E:  MOVF   x04,F
06090:  BNZ   60AE
....................         { 
....................             MACDiscardRx(); 
06092:  MOVLB  0
06094:  CALL   2C06
....................             ps->Flags.bIsGetReady = FALSE; 
06098:  MOVLW  23
0609A:  MOVLB  9
0609C:  ADDWF  x01,W
0609E:  MOVWF  FE9
060A0:  MOVLW  00
060A2:  ADDWFC x02,W
060A4:  MOVWF  FEA
060A6:  BCF    FEF.3
....................             return FALSE; 
060A8:  MOVLW  00
060AA:  MOVWF  01
060AC:  BRA    60EE
....................         } 
....................  
....................          ps->RxCount--; 
060AE:  MOVLW  12
060B0:  ADDWF  x01,W
060B2:  MOVWF  FE9
060B4:  MOVLW  00
060B6:  ADDWFC x02,W
060B8:  MOVWF  FEA
060BA:  MOVLW  FF
060BC:  ADDWF  FEF,F
060BE:  BC    60C4
060C0:  MOVF   FEE,F
060C2:  DECF   FED,F
....................          *data = MACGet(); 
060C4:  MOVFF  900,03
060C8:  MOVFF  8FF,903
060CC:  MOVFF  900,904
060D0:  MOVLB  0
060D2:  CALL   3ACC
060D6:  MOVFF  904,FEA
060DA:  MOVFF  903,FE9
060DE:  MOVFF  01,FEF
....................         return TRUE; 
060E2:  MOVLW  01
060E4:  MOVWF  01
060E6:  MOVLB  9
060E8:  BRA    60EE
....................     } 
....................     return FALSE; 
060EA:  MOVLW  00
060EC:  MOVWF  01
060EE:  MOVLB  0
060F0:  GOTO   68AA (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL TCPIsGetReady(TCP_SOCKET s) 
....................  * 
....................  * PreCondition:    TCPInit() is already called. 
....................  * 
....................  * Input:           s       - socket to test 
....................  * 
....................  * Output:          TRUE if socket 's' contains any data. 
....................  *                  FALSE if socket 's' does not contain any data. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL TCPIsGetReady(TCP_SOCKET s) 
.................... { 
....................     /* 
....................      * A socket is said to be "Get" ready when it has already 
....................      * received some data.  Sometime, a socket may be closed, 
....................      * but it still may contain data.  Thus in order to ensure 
....................      * reuse of a socket, caller must make sure that it reads 
....................      * a socket, if is ready. 
....................      */ 
....................     return (TCB[s].Flags.bIsGetReady ); 
*
05FC6:  MOVLB  9
05FC8:  CLRF   x4B
05FCA:  MOVFF  8FE,94A
05FCE:  CLRF   x4D
05FD0:  MOVLW  24
05FD2:  MOVWF  x4C
05FD4:  MOVLB  0
05FD6:  CALL   1A40
05FDA:  MOVFF  02,900
05FDE:  MOVFF  01,8FF
05FE2:  MOVLW  23
05FE4:  MOVLB  8
05FE6:  ADDWF  xFF,F
05FE8:  MOVLW  00
05FEA:  MOVLB  9
05FEC:  ADDWFC x00,F
05FEE:  MOVLW  9A
05FF0:  MOVLB  8
05FF2:  ADDWF  xFF,W
05FF4:  MOVWF  FE9
05FF6:  MOVLW  03
05FF8:  MOVLB  9
05FFA:  ADDWFC x00,W
05FFC:  MOVWF  FEA
05FFE:  MOVLW  00
06000:  BTFSC  FEF.3
06002:  MOVLW  01
06004:  MOVWF  01
06006:  MOVLB  0
06008:  GOTO   6888 (RETURN)
.................... } 
....................  
.................... //// internal functions ///// 
....................  
.................... void DebugTCPDisplayState(TCP_STATE st) 
.................... { 
....................    switch(st) 
....................    { 
....................       case TCP_LISTEN:        debug_tcp("LISTEN"); break; 
....................       case TCP_SYN_SENT:      debug_tcp("SYN_SENT"); break; 
....................       case TCP_SYN_RECEIVED:  debug_tcp("SYN_RECVD"); break; 
....................       case TCP_ESTABLISHED:   debug_tcp("ESTABLISHED"); break; 
....................       case TCP_FIN_WAIT_1:    debug_tcp("FIN_WAIT_1"); break; 
....................       case TCP_FIN_WAIT_2:    debug_tcp("FIN_WAIT_2"); break; 
....................       case TCP_CLOSING:       debug_tcp("CLOSING"); break; 
....................       case TCP_TIME_WAIT:     debug_tcp("TIME_WAIT"); break; 
....................       case TCP_CLOSE_WAIT:    debug_tcp("CLOSE_WAIT"); break; 
....................       case TCP_LAST_ACK:      debug_tcp("LAST_ACK"); break; 
....................       case TCP_CLOSED:        debug_tcp("CLOSED"); break; 
....................       default:                debug_tcp("UNKNOWN %U",st); break; 
....................    } 
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        void TCPTick(void) 
.................... * 
.................... * PreCondition:    TCPInit() is already called. 
.................... * 
.................... * Input:           None 
.................... * 
.................... * Output:          Each socket FSM is executed for any timeout 
.................... *                  situation. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... void TCPTick(void) 
.................... { 
....................    TCP_SOCKET s; 
....................    TICKTYPE diffTicks; 
....................    TICKTYPE tick; 
....................    SOCKET_INFO* ps; 
....................    DWORD seq; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................  
....................    flags = 0x00; 
*
055F0:  MOVLB  9
055F2:  CLRF   x0A
....................    // Periodically all "not closed" sockets must perform timed operations 
....................    for(s = 0; s < MAX_SOCKETS; s++) 
055F4:  MOVLB  8
055F6:  CLRF   xFF
055F8:  MOVF   xFF,W
055FA:  SUBLW  22
055FC:  BTFSS  FD8.0
055FE:  BRA    5A76
....................    { 
....................       ps = &TCB[s]; 
05600:  MOVLB  9
05602:  CLRF   x4B
05604:  MOVFF  8FF,94A
05608:  CLRF   x4D
0560A:  MOVLW  24
0560C:  MOVWF  x4C
0560E:  MOVLB  0
05610:  CALL   1A40
05614:  MOVFF  02,03
05618:  MOVF   01,W
0561A:  ADDLW  9A
0561C:  MOVWF  01
0561E:  MOVLW  03
05620:  ADDWFC 03,F
05622:  MOVFF  01,904
05626:  MOVLB  9
05628:  MOVFF  03,905
....................  
....................       //debugLastState = TCB[s].smState; 
....................  
....................       if ( ps->Flags.bIsGetReady || ps->Flags.bIsTxInProgress ) 
0562C:  MOVLW  23
0562E:  ADDWF  x04,W
05630:  MOVWF  FE9
05632:  MOVLW  00
05634:  ADDWFC x05,W
05636:  MOVWF  FEA
05638:  BTFSC  FEF.3
0563A:  BRA    564C
0563C:  MOVLW  23
0563E:  ADDWF  x04,W
05640:  MOVWF  FE9
05642:  MOVLW  00
05644:  ADDWFC x05,W
05646:  MOVWF  FEA
05648:  BTFSS  FEF.4
0564A:  BRA    564E
....................          continue; 
0564C:  BRA    5A70
....................  
....................  
....................       // Closed or Passively Listening socket do not care 
....................       // about timeout conditions. 
....................       if ( (ps->smState == TCP_CLOSED) || 
....................          (ps->smState == TCP_LISTEN && 
....................          ps->Flags.bServer == TRUE) ) 
0564E:  MOVFF  904,FE9
05652:  MOVFF  905,FEA
05656:  MOVF   FEF,W
05658:  SUBLW  0A
0565A:  BZ    567C
0565C:  MOVFF  904,FE9
05660:  MOVFF  905,FEA
05664:  MOVF   FEF,F
05666:  BNZ   567E
05668:  MOVLW  23
0566A:  ADDWF  x04,W
0566C:  MOVWF  FE9
0566E:  MOVLW  00
05670:  ADDWFC x05,W
05672:  MOVWF  FEA
05674:  MOVF   FEF,W
05676:  ANDLW  01
05678:  SUBLW  01
0567A:  BNZ   567E
....................          continue; 
0567C:  BRA    5A70
....................  
....................       //TODO: review this 
....................       //DSR ADD 063004 
....................         //i do this because if i am a server, i don't want to timeout. 
....................       if ( (ps->smState == TCP_ESTABLISHED) && (ps->Flags.bServer == TRUE) ) 
0567E:  MOVFF  904,FE9
05682:  MOVFF  905,FEA
05686:  MOVF   FEF,W
05688:  SUBLW  03
0568A:  BNZ   56A2
0568C:  MOVLW  23
0568E:  ADDWF  x04,W
05690:  MOVWF  FE9
05692:  MOVLW  00
05694:  ADDWFC x05,W
05696:  MOVWF  FEA
05698:  MOVF   FEF,W
0569A:  ANDLW  01
0569C:  SUBLW  01
0569E:  BNZ   56A2
....................          continue; 
056A0:  BRA    5A70
....................  
....................  
....................       tick = TickGet(); 
056A2:  MOVLB  0
056A4:  CALL   40BA
056A8:  MOVFF  02,903
056AC:  MOVFF  01,902
....................  
....................       // Calculate timeout value for this socket. 
....................       diffTicks = TickGetDiff(tick, ps->startTick); 
056B0:  MOVLW  1F
056B2:  MOVLB  9
056B4:  ADDWF  x04,W
056B6:  MOVWF  FE9
056B8:  MOVLW  00
056BA:  ADDWFC x05,W
056BC:  MOVWF  FEA
056BE:  MOVFF  FEC,03
056C2:  MOVF   FED,F
056C4:  MOVFF  FEF,01
056C8:  MOVF   x03,W
056CA:  SUBWF  03,W
056CC:  BNC   56D6
056CE:  BNZ   56DA
056D0:  MOVF   01,W
056D2:  SUBWF  x02,W
056D4:  BNC   56DA
056D6:  MOVLW  00
056D8:  BRA    56DC
056DA:  MOVLW  01
056DC:  CLRF   03
056DE:  IORWF  03,W
056E0:  BZ    5718
056E2:  MOVLW  1F
056E4:  ADDWF  x04,W
056E6:  MOVWF  FE9
056E8:  MOVLW  00
056EA:  ADDWFC x05,W
056EC:  MOVWF  FEA
056EE:  MOVFF  FEC,03
056F2:  MOVF   FED,F
056F4:  MOVF   FEF,W
056F6:  SUBLW  FF
056F8:  MOVWF  x0B
056FA:  MOVLW  FF
056FC:  SUBFWB 03,W
056FE:  MOVWF  x0C
05700:  MOVF   x02,W
05702:  ADDWF  x0B,F
05704:  MOVF   x03,W
05706:  ADDWFC x0C,F
05708:  MOVLW  01
0570A:  ADDWF  x0B,W
0570C:  MOVWF  01
0570E:  MOVLW  00
05710:  ADDWFC x0C,W
05712:  MOVWF  03
05714:  MOVF   01,W
05716:  BRA    5738
05718:  MOVLW  1F
0571A:  ADDWF  x04,W
0571C:  MOVWF  FE9
0571E:  MOVLW  00
05720:  ADDWFC x05,W
05722:  MOVWF  FEA
05724:  MOVFF  FEC,03
05728:  MOVF   FED,F
0572A:  MOVF   FEF,W
0572C:  SUBWF  x02,W
0572E:  MOVWF  00
05730:  MOVF   03,W
05732:  SUBWFB x03,W
05734:  MOVWF  03
05736:  MOVF   00,W
05738:  MOVWF  x00
0573A:  MOVFF  03,901
....................  
....................       // If timeout has not occured, do not do anything. 
....................       if(diffTicks <= ps->TimeOut) 
0573E:  MOVLW  21
05740:  ADDWF  x04,W
05742:  MOVWF  FE9
05744:  MOVLW  00
05746:  ADDWFC x05,W
05748:  MOVWF  FEA
0574A:  MOVFF  FEC,03
0574E:  MOVF   FED,F
05750:  MOVFF  FEF,01
05754:  MOVF   x01,W
05756:  SUBWF  03,W
05758:  BNC   5764
0575A:  BNZ   5762
0575C:  MOVF   x00,W
0575E:  SUBWF  01,W
05760:  BNC   5764
....................          continue; 
05762:  BRA    5A70
....................  
....................       // Most states require retransmission, so check for transmitter 
....................       // availability right here - common for all. 
....................       if(!IPIsTxReady(TRUE)) 
05764:  MOVLW  01
05766:  MOVWF  x86
05768:  MOVLB  0
0576A:  CALL   41D6
0576E:  MOVF   01,F
05770:  BNZ   5774
....................          return; 
05772:  BRA    5A76
....................  
....................       // Restart timeout reference. 
....................       ps->startTick = TickGet(); 
05774:  MOVLW  1F
05776:  MOVLB  9
05778:  ADDWF  x04,W
0577A:  MOVWF  01
0577C:  MOVLW  00
0577E:  ADDWFC x05,W
05780:  MOVWF  03
05782:  MOVFF  01,90B
05786:  MOVWF  x0C
05788:  MOVLB  0
0578A:  CALL   40BA
0578E:  MOVFF  90C,FEA
05792:  MOVFF  90B,FE9
05796:  MOVFF  02,FEC
0579A:  MOVF   FED,F
0579C:  MOVFF  01,FEF
....................  
....................       // Update timeout value if there is need to wait longer. 
....................       ps->TimeOut <<= 1; 
057A0:  MOVLW  21
057A2:  MOVLB  9
057A4:  ADDWF  x04,W
057A6:  MOVWF  FE9
057A8:  MOVLW  00
057AA:  ADDWFC x05,W
057AC:  MOVWF  FEA
057AE:  BCF    FD8.0
057B0:  RLCF   FEF,W
057B2:  MOVWF  02
057B4:  RLCF   FEC,W
057B6:  MOVWF  03
057B8:  MOVF   02,W
057BA:  MOVF   FED,F
057BC:  MOVWF  FEF
057BE:  MOVFF  03,FEC
....................  
....................       // This will be one more attempt. 
....................       ps->RetryCount++; 
057C2:  MOVLW  1E
057C4:  ADDWF  x04,W
057C6:  MOVWF  FE9
057C8:  MOVLW  00
057CA:  ADDWFC x05,W
057CC:  MOVWF  FEA
057CE:  INCF   FEF,F
....................  
....................       // A timeout has occured.  Respond to this timeout condition 
....................       // depending on what state this socket is in. 
....................       switch(ps->smState) 
057D0:  MOVFF  904,FE9
057D4:  MOVFF  905,FEA
057D8:  MOVLW  01
057DA:  SUBWF  FEF,W
057DC:  ADDLW  F7
057DE:  BTFSC  FD8.0
057E0:  BRA    5970
057E2:  ADDLW  09
057E4:  MOVLB  0
057E6:  GOTO   5A7C
....................       { 
....................       case TCP_SYN_SENT: 
....................          // Keep sending SYN until we hear from remote node. 
....................          // This may be for infinite time, in that case 
....................          // caller must detect it and do something. 
....................          // Bug Fix: 11/1/02 
....................          flags = SYN; 
057EA:  MOVLW  02
057EC:  MOVLB  9
057EE:  MOVWF  x0A
....................          break; 
057F0:  BRA    5970
....................  
....................       case TCP_SYN_RECEIVED: 
....................          // We must receive ACK before timeout expires. 
....................          // If not, resend SYN+ACK. 
....................          // Abort, if maximum attempts counts are reached. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
057F2:  MOVLW  1E
057F4:  MOVLB  9
057F6:  ADDWF  x04,W
057F8:  MOVWF  FE9
057FA:  MOVLW  00
057FC:  ADDWFC x05,W
057FE:  MOVWF  FEA
05800:  MOVF   FEF,W
05802:  SUBLW  03
05804:  BNC   580C
....................          { 
....................             flags = SYN | ACK; 
05806:  MOVLW  12
05808:  MOVWF  x0A
....................          } 
0580A:  BRA    5838
....................          else 
....................          { 
....................             if(ps->Flags.bServer) 
0580C:  MOVLW  23
0580E:  ADDWF  x04,W
05810:  MOVWF  FE9
05812:  MOVLW  00
05814:  ADDWFC x05,W
05816:  MOVWF  FEA
05818:  BTFSS  FEF.0
0581A:  BRA    5828
....................             { 
....................                ps->smState = TCP_LISTEN; 
0581C:  MOVFF  904,FE9
05820:  MOVFF  905,FEA
05824:  CLRF   FEF
....................             } 
05826:  BRA    5838
....................             else 
....................             { 
....................                flags = SYN; 
05828:  MOVLW  02
0582A:  MOVWF  x0A
....................                ps->smState = TCP_SYN_SENT; 
0582C:  MOVFF  904,FE9
05830:  MOVFF  905,FEA
05834:  MOVLW  01
05836:  MOVWF  FEF
....................             } 
....................          } 
....................          break; 
05838:  BRA    5970
....................  
....................       case TCP_ESTABLISHED: 
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          // Don't let this connection idle for very long time. 
....................          // If we did not receive or send any message before timeout 
....................          // expires, close this connection. 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
0583A:  MOVLW  1E
0583C:  MOVLB  9
0583E:  ADDWF  x04,W
05840:  MOVWF  FE9
05842:  MOVLW  00
05844:  ADDWFC x05,W
05846:  MOVWF  FEA
05848:  MOVF   FEF,W
0584A:  SUBLW  03
0584C:  BNC   5890
....................          { 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
0584E:  MOVLW  0F
05850:  ADDWF  x04,W
05852:  MOVWF  FE9
05854:  MOVLW  00
05856:  ADDWFC x05,W
05858:  MOVWF  FEA
0585A:  INCFSZ FEF,W
0585C:  BRA    5860
0585E:  BRA    5886
....................             { 
....................                MACSetTxBuffer(ps->TxBuffer, 0); 
05860:  MOVLW  0F
05862:  ADDWF  x04,W
05864:  MOVWF  FE9
05866:  MOVLW  00
05868:  ADDWFC x05,W
0586A:  MOVWF  FEA
0586C:  MOVFF  FEF,90B
05870:  MOVFF  90B,99F
05874:  CLRF   xA1
05876:  CLRF   xA0
05878:  MOVLB  0
0587A:  CALL   3034
....................                MACFlush(); 
0587E:  CALL   3224
....................             } 
05882:  BRA    588C
05884:  MOVLB  9
....................             else 
....................                flags = ACK; 
05886:  MOVLW  10
05888:  MOVWF  x0A
0588A:  MOVLB  0
....................          } 
0588C:  BRA    58DE
0588E:  MOVLB  9
....................          else 
....................          { 
....................             // Forget about previous transmission. 
....................             if(ps->TxBuffer != INVALID_BUFFER) 
05890:  MOVLW  0F
05892:  ADDWF  x04,W
05894:  MOVWF  FE9
05896:  MOVLW  00
05898:  ADDWFC x05,W
0589A:  MOVWF  FEA
0589C:  INCFSZ FEF,W
0589E:  BRA    58A2
058A0:  BRA    58CC
....................             { 
....................                MACDiscardTx(ps->TxBuffer); 
058A2:  MOVLW  0F
058A4:  ADDWF  x04,W
058A6:  MOVWF  FE9
058A8:  MOVLW  00
058AA:  ADDWFC x05,W
058AC:  MOVWF  FEA
058AE:  MOVFF  FEF,90B
058B2:  MOVFF  90B,94D
058B6:  MOVLB  0
058B8:  CALL   0004
....................                ps->TxBuffer = INVALID_BUFFER; 
058BC:  MOVLW  0F
058BE:  MOVLB  9
058C0:  ADDWF  x04,W
058C2:  MOVWF  FE9
058C4:  MOVLW  00
058C6:  ADDWFC x05,W
058C8:  MOVWF  FEA
058CA:  SETF   FEF
....................             } 
....................  
.................... #endif 
....................             // Request closure. 
....................             flags = FIN | ACK; 
058CC:  MOVLW  11
058CE:  MOVWF  x0A
....................             //DebugPrint("!"); 
....................  
....................             ps->smState = TCP_FIN_WAIT_1; 
058D0:  MOVFF  904,FE9
058D4:  MOVFF  905,FEA
058D8:  MOVLW  04
058DA:  MOVWF  FEF
058DC:  MOVLB  0
.................... #if !TCP_NO_WAIT_FOR_ACK 
....................          } 
.................... #endif 
....................          break; 
058DE:  MOVLB  9
058E0:  BRA    5970
....................  
....................       case TCP_FIN_WAIT_1: 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
058E2:  MOVLW  1E
058E4:  MOVLB  9
058E6:  ADDWF  x04,W
058E8:  MOVWF  FE9
058EA:  MOVLW  00
058EC:  ADDWFC x05,W
058EE:  MOVWF  FEA
058F0:  MOVF   FEF,W
058F2:  SUBLW  03
058F4:  BNC   58FC
....................          { 
....................                // Send another FIN 
....................                flags = FIN; 
058F6:  MOVLW  01
058F8:  MOVWF  x0A
....................          } 
058FA:  BRA    590C
....................          else 
....................          { 
....................             // Close on our own, we can't seem to communicate 
....................             // with the remote node anymore 
....................             CloseSocket(ps); 
058FC:  MOVFF  905,94B
05900:  MOVFF  904,94A
05904:  MOVLB  0
05906:  CALL   40D4
0590A:  MOVLB  9
....................          } 
....................          break; 
0590C:  BRA    5970
....................  
....................       case TCP_FIN_WAIT_2: 
....................       case TCP_CLOSING: 
....................          // Close on our own, we can't seem to communicate 
....................          // with the remote node anymore 
....................          CloseSocket(ps); 
0590E:  MOVFF  905,94B
05912:  MOVFF  904,94A
05916:  CALL   40D4
....................          break; 
0591A:  MOVLB  9
0591C:  BRA    5970
....................  
....................       case TCP_TIME_WAIT: 
....................          // Wait around for a while (2MSL) and then goto closed state 
....................          CloseSocket(ps); 
0591E:  MOVFF  905,94B
05922:  MOVFF  904,94A
05926:  CALL   40D4
....................          break; 
0592A:  MOVLB  9
0592C:  BRA    5970
....................  
....................       case TCP_CLOSE_WAIT: 
....................          flags = FIN; 
0592E:  MOVLW  01
05930:  MOVLB  9
05932:  MOVWF  x0A
....................          ps->smState = TCP_LAST_ACK; 
05934:  MOVFF  904,FE9
05938:  MOVFF  905,FEA
0593C:  MOVLW  09
0593E:  MOVWF  FEF
....................          break; 
05940:  BRA    5970
....................  
....................       case TCP_LAST_ACK: 
....................          // Send some more FINs or close anyway 
....................          if(ps->RetryCount <= MAX_RETRY_COUNTS) 
05942:  MOVLW  1E
05944:  MOVLB  9
05946:  ADDWF  x04,W
05948:  MOVWF  FE9
0594A:  MOVLW  00
0594C:  ADDWFC x05,W
0594E:  MOVWF  FEA
05950:  MOVF   FEF,W
05952:  SUBLW  03
05954:  BNC   595C
....................             flags = FIN; 
05956:  MOVLW  01
05958:  MOVWF  x0A
0595A:  BRA    596C
....................          else 
....................             CloseSocket(ps); 
0595C:  MOVFF  905,94B
05960:  MOVFF  904,94A
05964:  MOVLB  0
05966:  CALL   40D4
0596A:  MOVLB  9
....................          break; 
0596C:  BRA    5970
0596E:  MOVLB  9
....................       } 
....................  
....................  
....................       if(flags) 
05970:  MOVF   x0A,F
05972:  BTFSC  FD8.2
05974:  BRA    5A70
....................       { 
....................          if(flags & ACK) 
05976:  BTFSS  x0A.4
05978:  BRA    5998
....................             seq = ps->SND_SEQ; 
0597A:  MOVLW  16
0597C:  ADDWF  x04,W
0597E:  MOVWF  FE9
05980:  MOVLW  00
05982:  ADDWFC x05,W
05984:  MOVWF  FEA
05986:  MOVFF  FEF,906
0598A:  MOVFF  FEC,907
0598E:  MOVFF  FEC,908
05992:  MOVFF  FEC,909
05996:  BRA    59CC
....................          else 
....................          { 
....................             //seq = ps->SND_SEQ++;  //currently buggy in CCS 
....................             seq = ps->SND_SEQ; 
05998:  MOVLW  16
0599A:  ADDWF  x04,W
0599C:  MOVWF  FE9
0599E:  MOVLW  00
059A0:  ADDWFC x05,W
059A2:  MOVWF  FEA
059A4:  MOVFF  FEF,906
059A8:  MOVFF  FEC,907
059AC:  MOVFF  FEC,908
059B0:  MOVFF  FEC,909
....................             ps->SND_SEQ++; 
059B4:  MOVLW  16
059B6:  ADDWF  x04,W
059B8:  MOVWF  FE9
059BA:  MOVLW  00
059BC:  ADDWFC x05,W
059BE:  MOVWF  FEA
059C0:  MOVLW  01
059C2:  ADDWF  FEE,F
059C4:  MOVLW  00
059C6:  ADDWFC FEE,F
059C8:  ADDWFC FEE,F
059CA:  ADDWFC FED,F
....................          } 
....................  
....................          SendTCP(&ps->remote, 
....................             ps->localPort, 
....................             ps->remotePort, 
....................             seq, 
....................             ps->SND_ACK, 
....................             flags); 
059CC:  MOVLW  01
059CE:  ADDWF  x04,W
059D0:  MOVWF  01
059D2:  MOVLW  00
059D4:  ADDWFC x05,W
059D6:  MOVWF  03
059D8:  MOVFF  01,90B
059DC:  MOVWF  x0C
059DE:  MOVLW  0B
059E0:  ADDWF  x04,W
059E2:  MOVWF  FE9
059E4:  MOVLW  00
059E6:  ADDWFC x05,W
059E8:  MOVWF  FEA
059EA:  MOVFF  FEC,90E
059EE:  MOVF   FED,F
059F0:  MOVFF  FEF,90D
059F4:  MOVLW  0D
059F6:  ADDWF  x04,W
059F8:  MOVWF  FE9
059FA:  MOVLW  00
059FC:  ADDWFC x05,W
059FE:  MOVWF  FEA
05A00:  MOVFF  FEC,910
05A04:  MOVF   FED,F
05A06:  MOVFF  FEF,90F
05A0A:  MOVLW  1A
05A0C:  ADDWF  x04,W
05A0E:  MOVWF  FE9
05A10:  MOVLW  00
05A12:  ADDWFC x05,W
05A14:  MOVWF  FEA
05A16:  MOVFF  FEF,911
05A1A:  MOVFF  FEC,912
05A1E:  MOVFF  FEC,913
05A22:  MOVFF  FEC,914
05A26:  MOVFF  03,94F
05A2A:  MOVFF  01,94E
05A2E:  MOVFF  90E,951
05A32:  MOVFF  90D,950
05A36:  MOVFF  910,953
05A3A:  MOVFF  90F,952
05A3E:  MOVFF  909,957
05A42:  MOVFF  908,956
05A46:  MOVFF  907,955
05A4A:  MOVFF  906,954
05A4E:  MOVFF  914,95B
05A52:  MOVFF  913,95A
05A56:  MOVFF  912,959
05A5A:  MOVFF  911,958
05A5E:  MOVFF  90A,95C
05A62:  SETF   x5D
05A64:  CLRF   x5F
05A66:  CLRF   x5E
05A68:  MOVLB  0
05A6A:  CALL   4514
05A6E:  MOVLB  9
....................       } 
05A70:  MOVLB  8
05A72:  INCF   xFF,F
05A74:  BRA    55F8
05A76:  MOVLB  0
....................  
....................       /*if (debugLastState != ps->smState) 
....................       { 
....................          debug_tcp("\r\nTCP TICK %u - ", s); 
....................          DebugTCPDisplayState(debugLastState); 
....................          debug_tcp(" -> "); 
....................          DebugTCPDisplayState(ps->smState); 
....................       }*/ 
....................    } 
05A78:  GOTO   5C68 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        BOOL TCPProcess(NODE_INFO* remote, 
.................... *                                  IP_ADDR *localIP, 
.................... *                                  WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCP segment is ready in MAC buffer 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  len         - Total length of TCP semgent. 
.................... * 
.................... * Output:          TRUE if this function has completed its task 
.................... *                  FALSE otherwise 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... BOOL TCPProcess(NODE_INFO *remote, IP_ADDR *localIP, WORD len) 
.................... { 
....................    TCP_HEADER      TCPHeader; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................    TCP_SOCKET      socket; 
....................    WORD_VAL        checksum1; 
....................    WORD_VAL        checksum2; 
....................    BYTE            optionsSize; 
....................    
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress      = remote->IPAddr; 
*
05176:  MOVLW  06
05178:  MOVLB  8
0517A:  ADDWF  xFF,W
0517C:  MOVWF  FE9
0517E:  MOVLW  00
05180:  MOVLB  9
05182:  ADDWFC x00,W
05184:  MOVWF  FEA
05186:  MOVFF  FEF,00
0518A:  MOVFF  FEC,01
0518E:  MOVFF  FEC,02
05192:  MOVFF  FEC,03
05196:  MOVFF  00,919
0519A:  MOVFF  01,91A
0519E:  MOVFF  02,91B
051A2:  MOVFF  03,91C
....................    pseudoHeader.DestAddress        = *localIP; 
051A6:  MOVFF  901,FE9
051AA:  MOVFF  902,FEA
051AE:  MOVFF  FEF,00
051B2:  MOVFF  FEC,01
051B6:  MOVFF  FEC,02
051BA:  MOVFF  FEC,03
051BE:  MOVFF  00,91D
051C2:  MOVFF  01,91E
051C6:  MOVFF  02,91F
051CA:  MOVFF  03,920
....................    pseudoHeader.Zero               = 0x0; 
051CE:  CLRF   x21
....................    pseudoHeader.Protocol           = IP_PROT_TCP; 
051D0:  MOVLW  06
051D2:  MOVWF  x22
....................    pseudoHeader.TCPLength          = len; 
051D4:  MOVFF  904,924
051D8:  MOVFF  903,923
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
051DC:  MOVFF  924,9A6
051E0:  MOVFF  923,9A5
051E4:  MOVLB  0
051E6:  CALL   2CE0
051EA:  MOVFF  02,924
051EE:  MOVFF  01,923
....................  
....................    checksum1.Val = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
051F2:  MOVLW  09
051F4:  MOVLB  9
051F6:  MOVWF  x2C
051F8:  MOVLW  19
051FA:  MOVWF  x2B
051FC:  MOVFF  92C,989
05200:  MOVWF  x88
05202:  CLRF   x8B
05204:  MOVLW  0C
05206:  MOVWF  x8A
05208:  MOVLB  0
0520A:  CALL   39D6
0520E:  MOVFF  01,926
05212:  MOVLB  9
05214:  COMF   x26,F
05216:  MOVFF  02,927
0521A:  COMF   x27,F
....................  
....................  
....................    // Now calculate TCP packet checksum in NIC RAM - should match 
....................    // pesudo header checksum 
....................    checksum2.Val = CalcIPBufferChecksum(len); 
0521C:  MOVFF  904,987
05220:  MOVFF  903,986
05224:  MOVLB  0
05226:  CALL   3AF8
0522A:  MOVFF  02,929
0522E:  MOVFF  01,928
....................  
....................    // Compare checksums.  Note that the endianness is different. 
....................    if(checksum1.v[0] != checksum2.v[1] || checksum1.v[1] != checksum2.v[0]) 
05232:  MOVLB  9
05234:  MOVF   x29,W
05236:  SUBWF  x26,W
05238:  BNZ   5240
0523A:  MOVF   x28,W
0523C:  SUBWF  x27,W
0523E:  BZ    524E
....................    { 
....................       MACDiscardRx(); 
05240:  MOVLB  0
05242:  CALL   2C06
....................       return TRUE; 
05246:  MOVLW  01
05248:  MOVWF  01
0524A:  BRA    5322
0524C:  MOVLB  9
....................    } 
....................  
....................    // Retrieve TCP header. 
....................    IPSetRxBuffer(0); 
0524E:  CLRF   x2E
05250:  CLRF   x2D
05252:  MOVLB  0
05254:  CALL   3C50
....................    MACGetArray((BYTE*)&TCPHeader, sizeof(TCPHeader)); 
05258:  MOVLW  09
0525A:  MOVLB  9
0525C:  MOVWF  x2C
0525E:  MOVLW  05
05260:  MOVWF  x2B
05262:  MOVFF  92C,995
05266:  MOVWF  x94
05268:  CLRF   x97
0526A:  MOVLW  14
0526C:  MOVWF  x96
0526E:  MOVLB  0
05270:  CALL   2C7C
....................    SwapTCPHeader(&TCPHeader); 
05274:  MOVLW  09
05276:  MOVLB  9
05278:  MOVWF  x87
0527A:  MOVLW  05
0527C:  MOVWF  x86
0527E:  MOVLB  0
05280:  CALL   3C8E
....................  
....................  
....................    // Skip over options and retrieve all data bytes. 
....................    optionsSize = (BYTE)((TCPHeader.DataOffset.Val << 2)- 
....................       sizeof(TCPHeader)); 
05284:  MOVLB  9
05286:  SWAPF  x11,W
05288:  ANDLW  0F
0528A:  MOVWF  00
0528C:  RLCF   00,F
0528E:  RLCF   00,F
05290:  MOVLW  FC
05292:  ANDWF  00,F
05294:  MOVF   00,W
05296:  ADDLW  EC
05298:  MOVWF  x2A
....................    len = len - optionsSize - sizeof(TCPHeader); 
0529A:  MOVF   x2A,W
0529C:  SUBWF  x03,W
0529E:  MOVWF  x2B
052A0:  MOVLW  00
052A2:  SUBWFB x04,W
052A4:  MOVWF  x2C
052A6:  MOVLW  14
052A8:  SUBWF  x2B,W
052AA:  MOVWF  x03
052AC:  MOVLW  00
052AE:  SUBWFB x2C,W
052B0:  MOVWF  x04
....................  
....................    // Position packet read pointer to start of data area. 
....................    IPSetRxBuffer((TCPHeader.DataOffset.Val << 2)); 
052B2:  SWAPF  x11,W
052B4:  ANDLW  0F
052B6:  MOVWF  00
052B8:  RLCF   00,W
052BA:  MOVWF  x2B
052BC:  RLCF   x2B,F
052BE:  MOVLW  FC
052C0:  ANDWF  x2B,F
052C2:  CLRF   x2E
052C4:  MOVFF  92B,92D
052C8:  MOVLB  0
052CA:  CALL   3C50
....................  
....................    // Find matching socket. 
....................    socket =FindMatching_TCP_Socket(&TCPHeader, remote); 
052CE:  MOVLW  09
052D0:  MOVLB  9
052D2:  MOVWF  x2D
052D4:  MOVLW  05
052D6:  MOVWF  x2C
052D8:  MOVFF  900,92F
052DC:  MOVFF  8FF,92E
052E0:  MOVLB  0
052E2:  GOTO   3EB4
052E6:  MOVFF  01,925
....................    if(socket != INVALID_SOCKET) 
052EA:  MOVLB  9
052EC:  MOVF   x25,W
052EE:  SUBLW  FE
052F0:  BZ    5318
....................    { 
....................       HandleTCPSeg(socket, remote, &TCPHeader, len); 
052F2:  MOVFF  925,92C
052F6:  MOVFF  900,92E
052FA:  MOVFF  8FF,92D
052FE:  MOVLW  09
05300:  MOVWF  x30
05302:  MOVLW  05
05304:  MOVWF  x2F
05306:  MOVFF  904,932
0530A:  MOVFF  903,931
0530E:  MOVLB  0
05310:  GOTO   4748
....................    } 
05314:  BRA    531E
05316:  MOVLB  9
....................    else 
....................    { 
....................       // If this is an unknown socket, or we don't have any 
....................       // listening sockets available, discard it we can't 
....................       // process it right now 
....................       MACDiscardRx(); 
05318:  MOVLB  0
0531A:  CALL   2C06
....................  
.................... //      // Send a RESET to the remote node is it knows that we 
.................... //      // are not available 
.................... //      TCPHeader.AckNumber += len; 
.................... //      if( TCPHeader.Flags.bits.flagSYN || 
.................... //         TCPHeader.Flags.bits.flagFIN ) 
.................... //         TCPHeader.AckNumber++; 
.................... // 
.................... //      SendTCP(remote, 
.................... //         TCPHeader.DestPort, 
.................... //         TCPHeader.SourcePort, 
.................... //         TCPHeader.AckNumber, 
.................... //         TCPHeader.SeqNumber, 
.................... //         RST); 
....................    } 
....................  
....................    return TRUE; 
0531E:  MOVLW  01
05320:  MOVWF  01
05322:  GOTO   5BA2 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
.................... * Function:        static void TransmitTCP(NODE_INFO* remote 
.................... *                                          TCP_PORT localPort, 
.................... *                                          TCP_PORT remotePort, 
.................... *                                          DWORD seq, 
.................... *                                          DWORD ack, 
.................... *                                          BYTE flags, 
.................... *                                          BUFFER buffer, 
.................... *                                          WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPIsPutReady() == TRUE 
.................... * 
.................... * Input:           remote      - Remote node info 
.................... *                  localPort   - Source port number 
.................... *                  remotePort  - Destination port number 
.................... *                  seq         - Segment sequence number 
.................... *                  ack         - Segment acknowledge number 
.................... *                  flags       - Segment flags 
.................... *                  buffer      - Buffer to which this segment 
.................... *                                is to be transmitted 
.................... *                  len         - Total data length for this segment. 
.................... * 
.................... * Output:          A TCP segment is assembled and put to transmit. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void TransmitTCP(NODE_INFO *remote, 
....................                   TCP_PORT localPort, 
....................                   TCP_PORT remotePort, 
....................                   DWORD tseq, 
....................                   DWORD tack, 
....................                   BYTE flags, 
....................                   BUFFER buff, 
....................                   WORD len) 
.................... { 
....................    WORD_VAL        checkSum; 
....................    TCP_HEADER      header; 
....................    TCP_OPTIONS     options; 
....................    PSEUDO_HEADER   pseudoHeader; 
....................  
....................    debug_tcp("\r\n\nTCP OUT => LP:%LX RP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X", 
....................       localPort, 
....................       remotePort, 
....................       tseq, 
....................       tack, 
....................       len, 
....................       flags 
....................    ); 
....................  
....................    //  Make sure that this Tx buffer isn't currently being transmitted 
....................    while( !IPIsTxReady(TRUE) );   //TODO: This may need to be conditionally false 
*
04514:  MOVLW  01
04516:  MOVLB  9
04518:  MOVWF  x86
0451A:  MOVLB  0
0451C:  RCALL  41D6
0451E:  MOVF   01,F
04520:  BZ    4514
....................  
....................    // Obtain an AutoFree buffer if this packet is a control packet 
....................    // only (contains no application data in an already allocated 
....................    // buffer) 
....................    if(buff == INVALID_BUFFER) 
04522:  MOVLB  9
04524:  INCFSZ x5D,W
04526:  BRA    4538
....................       buff = MACGetTxBuffer(TRUE); 
04528:  MOVLW  01
0452A:  MOVWF  x86
0452C:  MOVLB  0
0452E:  CALL   300C
04532:  MOVFF  01,95D
04536:  MOVLB  9
....................  
....................    if(buff == INVALID_BUFFER) 
04538:  INCFSZ x5D,W
0453A:  BRA    453E
....................       return; 
0453C:  BRA    4744
....................  
....................    IPSetTxBuffer(buff, 0); 
0453E:  MOVFF  95D,99F
04542:  CLRF   xA1
04544:  MOVLW  14
04546:  MOVWF  xA0
04548:  MOVLB  0
0454A:  CALL   3034
....................  
....................    header.SourcePort           = localPort; 
0454E:  MOVFF  951,963
04552:  MOVFF  950,962
....................    header.DestPort             = remotePort; 
04556:  MOVFF  953,965
0455A:  MOVFF  952,964
....................    header.SeqNumber            = tseq; 
0455E:  MOVFF  957,969
04562:  MOVFF  956,968
04566:  MOVFF  955,967
0456A:  MOVFF  954,966
....................    header.AckNumber            = tack; 
0456E:  MOVFF  95B,96D
04572:  MOVFF  95A,96C
04576:  MOVFF  959,96B
0457A:  MOVFF  958,96A
....................    header.Flags.bits.Reserved2 = 0; 
0457E:  MOVLW  3F
04580:  MOVLB  9
04582:  ANDWF  x6F,W
04584:  MOVWF  x6F
....................    header.DataOffset.Reserved3 = 0; 
04586:  MOVLW  F0
04588:  ANDWF  x6E,W
0458A:  MOVWF  x6E
....................    header.Flags.b              = flags; 
0458C:  MOVFF  95C,96F
....................    // Receive window = MAC Free buffer size - TCP header (20) - IP header (20) 
....................    //                  - ETHERNET header (14 if using NIC) . 
....................    header.Window               = MACGetFreeRxSize(); 
04590:  MOVLB  0
04592:  BRA    41FE
04594:  MOVFF  02,971
04598:  MOVFF  01,970
.................... #if STACK_USE_SLIP 
....................    /* 
....................    * Limit one segment at a time from remote host. 
....................    * This limit increases overall throughput as remote host does not 
....................    * flood us with packets and later retry with significant delay. 
....................    */ 
....................    if ( header.Window >= MAC_RX_BUFFER_SIZE ) 
....................       header.Window = MAC_RX_BUFFER_SIZE; 
....................  
....................    else if ( header.Window > 54 ) 
....................    { 
....................       header.Window -= 54; 
....................    } 
....................    else 
....................       header.Window = 0; 
.................... #else 
....................    if ( header.Window > 40 ) 
0459C:  MOVLB  9
0459E:  MOVF   x71,F
045A0:  BNZ   45A8
045A2:  MOVF   x70,W
045A4:  SUBLW  28
045A6:  BC    45B2
....................    { 
....................       header.Window -= 40; 
045A8:  MOVLW  28
045AA:  SUBWF  x70,F
045AC:  MOVLW  00
045AE:  SUBWFB x71,F
....................    } 
045B0:  BRA    45B6
....................    else 
....................       header.Window = 0; 
045B2:  CLRF   x71
045B4:  CLRF   x70
.................... #endif 
....................  
....................    header.Checksum             = 0; 
045B6:  CLRF   x73
045B8:  CLRF   x72
....................    header.UrgentPointer        = 0; 
045BA:  CLRF   x75
045BC:  CLRF   x74
....................  
....................    SwapTCPHeader(&header); 
045BE:  MOVLW  09
045C0:  MOVWF  x87
045C2:  MOVLW  62
045C4:  MOVWF  x86
045C6:  MOVLB  0
045C8:  CALL   3C8E
....................  
....................    len += sizeof(header); 
045CC:  MOVLW  14
045CE:  MOVLB  9
045D0:  ADDWF  x5E,F
045D2:  MOVLW  00
045D4:  ADDWFC x5F,F
....................  
....................    if ( flags & SYN ) 
045D6:  BTFSS  x5C.1
045D8:  BRA    45F8
....................    { 
....................       len += sizeof(options); 
045DA:  MOVLW  04
045DC:  ADDWF  x5E,F
045DE:  MOVLW  00
045E0:  ADDWFC x5F,F
....................       options.Kind = TCP_OPTIONS_MAX_SEG_SIZE; 
045E2:  MOVLW  02
045E4:  MOVWF  x76
....................       options.Length = 0x04; 
045E6:  MOVLW  04
045E8:  MOVWF  x77
....................  
....................       // Load MSS in already swapped order. 
....................       options.MaxSegSize.v[0]  = (MAC_RX_BUFFER_SIZE >> 8); // 0x05; 
045EA:  MOVWF  x78
....................       options.MaxSegSize.v[1]  = (MAC_RX_BUFFER_SIZE & 0xff); // 0xb4; 
045EC:  CLRF   x79
....................  
....................       header.DataOffset.Val   = (sizeof(header) + sizeof(options)) >> 2; 
045EE:  MOVLW  0F
045F0:  ANDWF  x6E,W
045F2:  IORLW  60
045F4:  MOVWF  x6E
....................    } 
045F6:  BRA    4600
....................    else 
....................       header.DataOffset.Val   = sizeof(header) >> 2; 
045F8:  MOVLW  0F
045FA:  ANDWF  x6E,W
045FC:  IORLW  50
045FE:  MOVWF  x6E
....................  
....................  
....................    // Calculate IP pseudoheader checksum. 
....................    pseudoHeader.SourceAddress   = AppConfig.MyIPAddr; 
04600:  MOVFF  356,97D
04604:  MOVFF  355,97C
04608:  MOVFF  354,97B
0460C:  MOVFF  353,97A
....................    pseudoHeader.DestAddress    = remote->IPAddr; 
04610:  MOVLW  06
04612:  ADDWF  x4E,W
04614:  MOVWF  FE9
04616:  MOVLW  00
04618:  ADDWFC x4F,W
0461A:  MOVWF  FEA
0461C:  MOVFF  FEF,00
04620:  MOVFF  FEC,01
04624:  MOVFF  FEC,02
04628:  MOVFF  FEC,03
0462C:  MOVFF  00,97E
04630:  MOVFF  01,97F
04634:  MOVFF  02,980
04638:  MOVFF  03,981
....................    pseudoHeader.Zero           = 0x0; 
0463C:  CLRF   x82
....................    pseudoHeader.Protocol       = IP_PROT_TCP; 
0463E:  MOVLW  06
04640:  MOVWF  x83
....................    pseudoHeader.TCPLength      = len; 
04642:  MOVFF  95F,985
04646:  MOVFF  95E,984
....................  
....................    SwapPseudoTCPHeader(pseudoHeader); 
0464A:  MOVFF  985,9A6
0464E:  MOVFF  984,9A5
04652:  MOVLB  0
04654:  CALL   2CE0
04658:  MOVFF  02,985
0465C:  MOVFF  01,984
....................  
....................    header.Checksum = ~CalcIPChecksum((BYTE*)&pseudoHeader, 
....................       sizeof(pseudoHeader)); 
04660:  MOVLW  09
04662:  MOVLB  9
04664:  MOVWF  x87
04666:  MOVLW  7A
04668:  MOVWF  x86
0466A:  MOVFF  987,989
0466E:  MOVWF  x88
04670:  CLRF   x8B
04672:  MOVLW  0C
04674:  MOVWF  x8A
04676:  MOVLB  0
04678:  CALL   39D6
0467C:  MOVFF  01,972
04680:  MOVLB  9
04682:  COMF   x72,F
04684:  MOVFF  02,973
04688:  COMF   x73,F
....................    checkSum.Val = header.Checksum; 
0468A:  MOVFF  973,961
0468E:  MOVFF  972,960
....................  
....................    // Write IP header. 
....................    IPPutHeader(remote, IP_PROT_TCP, len); 
04692:  MOVFF  94F,987
04696:  MOVFF  94E,986
0469A:  MOVLW  06
0469C:  MOVWF  x88
0469E:  MOVFF  95F,98A
046A2:  MOVFF  95E,989
046A6:  MOVLB  0
046A8:  RCALL  43EE
....................    IPPutArray((BYTE*)&header, sizeof(header)); 
046AA:  MOVLW  09
046AC:  MOVLB  9
046AE:  MOVWF  x87
046B0:  MOVLW  62
046B2:  MOVWF  x86
046B4:  MOVFF  987,9AB
046B8:  MOVWF  xAA
046BA:  CLRF   xAD
046BC:  MOVLW  14
046BE:  MOVWF  xAC
046C0:  MOVLB  0
046C2:  CALL   3100
....................  
....................    if ( flags & SYN ) 
046C6:  MOVLB  9
046C8:  BTFSS  x5C.1
046CA:  BRA    46E8
....................       IPPutArray((BYTE*)&options, sizeof(options)); 
046CC:  MOVLW  09
046CE:  MOVWF  x87
046D0:  MOVLW  76
046D2:  MOVWF  x86
046D4:  MOVFF  987,9AB
046D8:  MOVWF  xAA
046DA:  CLRF   xAD
046DC:  MOVLW  04
046DE:  MOVWF  xAC
046E0:  MOVLB  0
046E2:  CALL   3100
046E6:  MOVLB  9
....................  
....................    IPSetTxBuffer(buff, 0); 
046E8:  MOVFF  95D,99F
046EC:  CLRF   xA1
046EE:  MOVLW  14
046F0:  MOVWF  xA0
046F2:  MOVLB  0
046F4:  CALL   3034
....................  
....................    checkSum.Val = CalcIPBufferChecksum(len); 
046F8:  MOVFF  95F,987
046FC:  MOVFF  95E,986
04700:  CALL   3AF8
04704:  MOVFF  02,961
04708:  MOVFF  01,960
....................  
....................    // Update the checksum. 
....................    IPSetTxBuffer(buff, 16); 
0470C:  MOVFF  95D,99F
04710:  MOVLB  9
04712:  CLRF   xA1
04714:  MOVLW  24
04716:  MOVWF  xA0
04718:  MOVLB  0
0471A:  CALL   3034
....................    MACPut(checkSum.v[1]); 
0471E:  MOVFF  961,9A9
04722:  CALL   30E2
....................    MACPut(checkSum.v[0]); 
04726:  MOVFF  960,9A9
0472A:  CALL   30E2
....................    MACSetTxBuffer(buff, 0); 
0472E:  MOVFF  95D,99F
04732:  MOVLB  9
04734:  CLRF   xA1
04736:  CLRF   xA0
04738:  MOVLB  0
0473A:  CALL   3034
....................  
....................    MACFlush(); 
0473E:  CALL   3224
04742:  MOVLB  9
....................  
.................... #if !TCP_NO_WAIT_FOR_ACK /*&& !defined(DEBUG)*/ 
....................    // If we send the packet again, the remote node might think that we timed 
....................    // out and retransmitted.  It could thus immediately send back an ACK and 
....................    // dramatically improve throuput. 
....................    //while(!IPIsTxReady(TRUE)); 
....................    //MACFlush(); 
.................... #endif 
04744:  MOVLB  0
04746:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, 
....................  *                                      NODE_INFO* remote) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           h           - TCP Header to be matched against. 
....................  *                  remote      - Node who sent this header. 
....................  * 
....................  * Output:          A socket that matches with given header and remote 
....................  *                  node is searched. 
....................  *                  If such socket is found, its index is returned 
....................  *                  else INVALID_SOCKET is returned. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static TCP_SOCKET FindMatching_TCP_Socket(TCP_HEADER *h, NODE_INFO *remote) 
.................... { 
....................    SOCKET_INFO *ps; 
....................    TCP_SOCKET s; 
....................    TCP_SOCKET partialMatch; 
....................  
....................    partialMatch = INVALID_SOCKET; 
*
03EB4:  MOVLW  FE
03EB6:  MOVLB  9
03EB8:  MOVWF  x33
....................  
....................    for ( s = 0; s < MAX_SOCKETS; s++ ) 
03EBA:  CLRF   x32
03EBC:  MOVF   x32,W
03EBE:  SUBLW  22
03EC0:  BTFSS  FD8.0
03EC2:  BRA    3FCA
....................    { 
....................       ps = &TCB[s]; 
03EC4:  CLRF   x4B
03EC6:  MOVFF  932,94A
03ECA:  CLRF   x4D
03ECC:  MOVLW  24
03ECE:  MOVWF  x4C
03ED0:  MOVLB  0
03ED2:  CALL   1A40
03ED6:  MOVFF  02,03
03EDA:  MOVF   01,W
03EDC:  ADDLW  9A
03EDE:  MOVWF  01
03EE0:  MOVLW  03
03EE2:  ADDWFC 03,F
03EE4:  MOVFF  01,930
03EE8:  MOVLB  9
03EEA:  MOVFF  03,931
....................  
....................       if ( ps->smState != TCP_CLOSED ) 
03EEE:  MOVFF  930,FE9
03EF2:  MOVFF  931,FEA
03EF6:  MOVF   FEF,W
03EF8:  SUBLW  0A
03EFA:  BZ    3FC6
....................       { 
....................          if ( ps->localPort == h->DestPort ) 
03EFC:  MOVLW  0B
03EFE:  ADDWF  x30,W
03F00:  MOVWF  FE9
03F02:  MOVLW  00
03F04:  ADDWFC x31,W
03F06:  MOVWF  FEA
03F08:  MOVFF  FEC,935
03F0C:  MOVF   FED,F
03F0E:  MOVFF  FEF,934
03F12:  MOVLW  02
03F14:  ADDWF  x2C,W
03F16:  MOVWF  FE9
03F18:  MOVLW  00
03F1A:  ADDWFC x2D,W
03F1C:  MOVWF  FEA
03F1E:  MOVFF  FEC,03
03F22:  MOVF   FED,F
03F24:  MOVF   FEF,W
03F26:  SUBWF  x34,W
03F28:  BNZ   3FC6
03F2A:  MOVF   03,W
03F2C:  SUBWF  x35,W
03F2E:  BNZ   3FC6
....................          { 
....................             if ( ps->smState == TCP_LISTEN ) 
03F30:  MOVFF  930,FE9
03F34:  MOVFF  931,FEA
03F38:  MOVF   FEF,F
03F3A:  BNZ   3F40
....................                partialMatch = s; 
03F3C:  MOVFF  932,933
....................  
....................             if ( ps->remotePort == h->SourcePort && 
....................                ps->remote.IPAddr.Val == remote->IPAddr.Val ) 
03F40:  MOVLW  0D
03F42:  ADDWF  x30,W
03F44:  MOVWF  FE9
03F46:  MOVLW  00
03F48:  ADDWFC x31,W
03F4A:  MOVWF  FEA
03F4C:  MOVFF  FEC,935
03F50:  MOVF   FED,F
03F52:  MOVFF  FEF,934
03F56:  MOVFF  92C,FE9
03F5A:  MOVFF  92D,FEA
03F5E:  MOVFF  FEC,03
03F62:  MOVF   FED,F
03F64:  MOVF   FEF,W
03F66:  SUBWF  x34,W
03F68:  BNZ   3FC6
03F6A:  MOVF   03,W
03F6C:  SUBWF  x35,W
03F6E:  BNZ   3FC6
03F70:  MOVLW  07
03F72:  ADDWF  x30,W
03F74:  MOVWF  FE9
03F76:  MOVLW  00
03F78:  ADDWFC x31,W
03F7A:  MOVWF  FEA
03F7C:  MOVFF  FEF,934
03F80:  MOVFF  FEC,935
03F84:  MOVFF  FEC,936
03F88:  MOVFF  FEC,937
03F8C:  MOVLW  06
03F8E:  ADDWF  x2E,W
03F90:  MOVWF  FE9
03F92:  MOVLW  00
03F94:  ADDWFC x2F,W
03F96:  MOVWF  FEA
03F98:  MOVFF  FEF,00
03F9C:  MOVFF  FEC,01
03FA0:  MOVFF  FEC,02
03FA4:  MOVFF  FEC,03
03FA8:  MOVF   00,W
03FAA:  SUBWF  x34,W
03FAC:  BNZ   3FC6
03FAE:  MOVF   01,W
03FB0:  SUBWF  x35,W
03FB2:  BNZ   3FC6
03FB4:  MOVF   02,W
03FB6:  SUBWF  x36,W
03FB8:  BNZ   3FC6
03FBA:  MOVF   03,W
03FBC:  SUBWF  x37,W
03FBE:  BNZ   3FC6
....................             { 
....................                return s; 
03FC0:  MOVFF  932,01
03FC4:  BRA    40B4
....................             } 
....................          } 
....................       } 
03FC6:  INCF   x32,F
03FC8:  BRA    3EBC
....................    } 
....................  
....................    // We are not listening on this port 
....................    if(partialMatch == INVALID_SOCKET) 
03FCA:  MOVF   x33,W
03FCC:  SUBLW  FE
03FCE:  BNZ   3FD6
....................       return INVALID_SOCKET; 
03FD0:  MOVLW  FE
03FD2:  MOVWF  01
03FD4:  BRA    40B4
....................  
....................    // Copy the remote node IP/MAC address and source TCP port 
....................    // number into our TCB and return this socket to the caller 
....................    ps = &TCB[partialMatch]; 
03FD6:  CLRF   x4B
03FD8:  MOVFF  933,94A
03FDC:  CLRF   x4D
03FDE:  MOVLW  24
03FE0:  MOVWF  x4C
03FE2:  MOVLB  0
03FE4:  CALL   1A40
03FE8:  MOVFF  02,03
03FEC:  MOVF   01,W
03FEE:  ADDLW  9A
03FF0:  MOVWF  01
03FF2:  MOVLW  03
03FF4:  ADDWFC 03,F
03FF6:  MOVFF  01,930
03FFA:  MOVLB  9
03FFC:  MOVFF  03,931
....................    memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
04000:  MOVLW  01
04002:  ADDWF  x30,W
04004:  MOVWF  01
04006:  MOVLW  00
04008:  ADDWFC x31,W
0400A:  MOVWF  03
0400C:  MOVFF  01,934
04010:  MOVWF  x35
04012:  MOVWF  FEA
04014:  MOVFF  01,FE9
04018:  MOVFF  92F,FE2
0401C:  MOVFF  92E,FE1
04020:  MOVLW  0A
04022:  MOVWF  01
04024:  MOVFF  FE6,FEE
04028:  DECFSZ 01,F
0402A:  BRA    4024
....................    ps->remotePort          = h->SourcePort; 
0402C:  MOVLW  0D
0402E:  ADDWF  x30,W
04030:  MOVWF  01
04032:  MOVLW  00
04034:  ADDWFC x31,W
04036:  MOVFF  92C,FE9
0403A:  MOVFF  92D,FEA
0403E:  MOVFF  FEC,03
04042:  MOVF   FED,F
04044:  MOVFF  FEF,936
04048:  MOVWF  FEA
0404A:  MOVFF  01,FE9
0404E:  MOVFF  03,FEC
04052:  MOVF   FED,F
04054:  MOVFF  936,FEF
....................    ps->Flags.bIsGetReady   = FALSE; 
04058:  MOVLW  23
0405A:  ADDWF  x30,W
0405C:  MOVWF  FE9
0405E:  MOVLW  00
04060:  ADDWFC x31,W
04062:  MOVWF  FEA
04064:  BCF    FEF.3
....................    if(ps->TxBuffer != INVALID_BUFFER) 
04066:  MOVLW  0F
04068:  ADDWF  x30,W
0406A:  MOVWF  FE9
0406C:  MOVLW  00
0406E:  ADDWFC x31,W
04070:  MOVWF  FEA
04072:  INCFSZ FEF,W
04074:  BRA    4078
04076:  BRA    40A2
....................    { 
....................       MACDiscardTx(ps->TxBuffer); 
04078:  MOVLW  0F
0407A:  ADDWF  x30,W
0407C:  MOVWF  FE9
0407E:  MOVLW  00
04080:  ADDWFC x31,W
04082:  MOVWF  FEA
04084:  MOVFF  FEF,934
04088:  MOVFF  934,94D
0408C:  MOVLB  0
0408E:  CALL   0004
....................       ps->TxBuffer        = INVALID_BUFFER; 
04092:  MOVLW  0F
04094:  MOVLB  9
04096:  ADDWF  x30,W
04098:  MOVWF  FE9
0409A:  MOVLW  00
0409C:  ADDWFC x31,W
0409E:  MOVWF  FEA
040A0:  SETF   FEF
....................    } 
....................    ps->Flags.bIsPutReady   = TRUE; 
040A2:  MOVLW  23
040A4:  ADDWF  x30,W
040A6:  MOVWF  FE9
040A8:  MOVLW  00
040AA:  ADDWFC x31,W
040AC:  MOVWF  FEA
040AE:  BSF    FEF.1
....................  
....................    return partialMatch; 
040B0:  MOVFF  933,01
040B4:  MOVLB  0
040B6:  GOTO   52E6 (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapTCPHeader(TCP_HEADER* header) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           header      - TCP Header to be swapped. 
....................  * 
....................  * Output:          Given header is swapped. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapTCPHeader(TCP_HEADER* header) 
.................... { 
....................     header->SourcePort      = swaps(header->SourcePort); 
*
03C8E:  MOVLB  9
03C90:  MOVFF  986,01
03C94:  MOVFF  987,03
03C98:  MOVFF  986,988
03C9C:  MOVFF  987,989
03CA0:  MOVFF  986,FE9
03CA4:  MOVFF  987,FEA
03CA8:  MOVFF  FEC,98B
03CAC:  MOVF   FED,F
03CAE:  MOVFF  FEF,98A
03CB2:  MOVFF  98B,9A6
03CB6:  MOVFF  98A,9A5
03CBA:  MOVLB  0
03CBC:  CALL   2CE0
03CC0:  MOVFF  989,FEA
03CC4:  MOVFF  988,FE9
03CC8:  MOVFF  02,FEC
03CCC:  MOVF   FED,F
03CCE:  MOVFF  01,FEF
....................     header->DestPort        = swaps(header->DestPort); 
03CD2:  MOVLW  02
03CD4:  MOVLB  9
03CD6:  ADDWF  x86,W
03CD8:  MOVWF  01
03CDA:  MOVLW  00
03CDC:  ADDWFC x87,W
03CDE:  MOVWF  03
03CE0:  MOVFF  01,988
03CE4:  MOVWF  x89
03CE6:  MOVLW  02
03CE8:  ADDWF  x86,W
03CEA:  MOVWF  FE9
03CEC:  MOVLW  00
03CEE:  ADDWFC x87,W
03CF0:  MOVWF  FEA
03CF2:  MOVFF  FEC,98B
03CF6:  MOVF   FED,F
03CF8:  MOVFF  FEF,98A
03CFC:  MOVFF  98B,9A6
03D00:  MOVFF  98A,9A5
03D04:  MOVLB  0
03D06:  CALL   2CE0
03D0A:  MOVFF  989,FEA
03D0E:  MOVFF  988,FE9
03D12:  MOVFF  02,FEC
03D16:  MOVF   FED,F
03D18:  MOVFF  01,FEF
....................     header->SeqNumber       = swapl(header->SeqNumber); 
03D1C:  MOVLW  04
03D1E:  MOVLB  9
03D20:  ADDWF  x86,W
03D22:  MOVWF  01
03D24:  MOVLW  00
03D26:  ADDWFC x87,W
03D28:  MOVWF  03
03D2A:  MOVFF  01,988
03D2E:  MOVWF  x89
03D30:  MOVLW  04
03D32:  ADDWF  x86,W
03D34:  MOVWF  FE9
03D36:  MOVLW  00
03D38:  ADDWFC x87,W
03D3A:  MOVWF  FEA
03D3C:  MOVFF  FEF,98A
03D40:  MOVFF  FEC,98B
03D44:  MOVFF  FEC,98C
03D48:  MOVFF  FEC,98D
03D4C:  MOVFF  98D,991
03D50:  MOVFF  98C,990
03D54:  MOVFF  98B,98F
03D58:  MOVFF  98A,98E
03D5C:  MOVLB  0
03D5E:  RCALL  3C6C
03D60:  MOVFF  989,FEA
03D64:  MOVFF  988,FE9
03D68:  MOVFF  00,FEF
03D6C:  MOVFF  01,FEC
03D70:  MOVFF  02,FEC
03D74:  MOVFF  03,FEC
....................     header->AckNumber       = swapl(header->AckNumber); 
03D78:  MOVLW  08
03D7A:  MOVLB  9
03D7C:  ADDWF  x86,W
03D7E:  MOVWF  01
03D80:  MOVLW  00
03D82:  ADDWFC x87,W
03D84:  MOVWF  03
03D86:  MOVFF  01,988
03D8A:  MOVWF  x89
03D8C:  MOVLW  08
03D8E:  ADDWF  x86,W
03D90:  MOVWF  FE9
03D92:  MOVLW  00
03D94:  ADDWFC x87,W
03D96:  MOVWF  FEA
03D98:  MOVFF  FEF,98A
03D9C:  MOVFF  FEC,98B
03DA0:  MOVFF  FEC,98C
03DA4:  MOVFF  FEC,98D
03DA8:  MOVFF  98D,991
03DAC:  MOVFF  98C,990
03DB0:  MOVFF  98B,98F
03DB4:  MOVFF  98A,98E
03DB8:  MOVLB  0
03DBA:  RCALL  3C6C
03DBC:  MOVFF  989,FEA
03DC0:  MOVFF  988,FE9
03DC4:  MOVFF  00,FEF
03DC8:  MOVFF  01,FEC
03DCC:  MOVFF  02,FEC
03DD0:  MOVFF  03,FEC
....................     header->Window          = swaps(header->Window); 
03DD4:  MOVLW  0E
03DD6:  MOVLB  9
03DD8:  ADDWF  x86,W
03DDA:  MOVWF  01
03DDC:  MOVLW  00
03DDE:  ADDWFC x87,W
03DE0:  MOVWF  03
03DE2:  MOVFF  01,988
03DE6:  MOVWF  x89
03DE8:  MOVLW  0E
03DEA:  ADDWF  x86,W
03DEC:  MOVWF  FE9
03DEE:  MOVLW  00
03DF0:  ADDWFC x87,W
03DF2:  MOVWF  FEA
03DF4:  MOVFF  FEC,98B
03DF8:  MOVF   FED,F
03DFA:  MOVFF  FEF,98A
03DFE:  MOVFF  98B,9A6
03E02:  MOVFF  98A,9A5
03E06:  MOVLB  0
03E08:  CALL   2CE0
03E0C:  MOVFF  989,FEA
03E10:  MOVFF  988,FE9
03E14:  MOVFF  02,FEC
03E18:  MOVF   FED,F
03E1A:  MOVFF  01,FEF
....................     header->Checksum        = swaps(header->Checksum); 
03E1E:  MOVLW  10
03E20:  MOVLB  9
03E22:  ADDWF  x86,W
03E24:  MOVWF  01
03E26:  MOVLW  00
03E28:  ADDWFC x87,W
03E2A:  MOVWF  03
03E2C:  MOVFF  01,988
03E30:  MOVWF  x89
03E32:  MOVLW  10
03E34:  ADDWF  x86,W
03E36:  MOVWF  FE9
03E38:  MOVLW  00
03E3A:  ADDWFC x87,W
03E3C:  MOVWF  FEA
03E3E:  MOVFF  FEC,98B
03E42:  MOVF   FED,F
03E44:  MOVFF  FEF,98A
03E48:  MOVFF  98B,9A6
03E4C:  MOVFF  98A,9A5
03E50:  MOVLB  0
03E52:  CALL   2CE0
03E56:  MOVFF  989,FEA
03E5A:  MOVFF  988,FE9
03E5E:  MOVFF  02,FEC
03E62:  MOVF   FED,F
03E64:  MOVFF  01,FEF
....................     header->UrgentPointer   = swaps(header->UrgentPointer); 
03E68:  MOVLW  12
03E6A:  MOVLB  9
03E6C:  ADDWF  x86,W
03E6E:  MOVWF  01
03E70:  MOVLW  00
03E72:  ADDWFC x87,W
03E74:  MOVWF  03
03E76:  MOVFF  01,988
03E7A:  MOVWF  x89
03E7C:  MOVLW  12
03E7E:  ADDWF  x86,W
03E80:  MOVWF  FE9
03E82:  MOVLW  00
03E84:  ADDWFC x87,W
03E86:  MOVWF  FEA
03E88:  MOVFF  FEC,98B
03E8C:  MOVF   FED,F
03E8E:  MOVFF  FEF,98A
03E92:  MOVFF  98B,9A6
03E96:  MOVFF  98A,9A5
03E9A:  MOVLB  0
03E9C:  CALL   2CE0
03EA0:  MOVFF  989,FEA
03EA4:  MOVFF  988,FE9
03EA8:  MOVFF  02,FEC
03EAC:  MOVF   FED,F
03EAE:  MOVFF  01,FEF
03EB2:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void CloseSocket(SOCKET_INFO* ps) 
....................  * 
....................  * PreCondition:    TCPInit() is already called 
....................  * 
....................  * Input:           ps  - Pointer to a socket info that is to be 
....................  *                          closed. 
....................  * 
....................  * Output:          Given socket information is reset and any 
....................  *                  buffer held by this socket is discarded. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void CloseSocket(SOCKET_INFO* ps) 
.................... { 
....................    debug_tcp("\r\nTCP SOCKET CLOSED"); 
....................  
....................     if ( ps->TxBuffer != INVALID_BUFFER ) 
*
040D4:  MOVLW  0F
040D6:  MOVLB  9
040D8:  ADDWF  x4A,W
040DA:  MOVWF  FE9
040DC:  MOVLW  00
040DE:  ADDWFC x4B,W
040E0:  MOVWF  FEA
040E2:  INCFSZ FEF,W
040E4:  BRA    40E8
040E6:  BRA    4120
....................     { 
....................         MACDiscardTx(ps->TxBuffer); 
040E8:  MOVLW  0F
040EA:  ADDWF  x4A,W
040EC:  MOVWF  FE9
040EE:  MOVLW  00
040F0:  ADDWFC x4B,W
040F2:  MOVWF  FEA
040F4:  MOVFF  FEF,94C
040F8:  MOVFF  94C,94D
040FC:  MOVLB  0
040FE:  CALL   0004
....................         ps->TxBuffer            = INVALID_BUFFER; 
04102:  MOVLW  0F
04104:  MOVLB  9
04106:  ADDWF  x4A,W
04108:  MOVWF  FE9
0410A:  MOVLW  00
0410C:  ADDWFC x4B,W
0410E:  MOVWF  FEA
04110:  SETF   FEF
....................         ps->Flags.bIsPutReady   = TRUE; 
04112:  MOVLW  23
04114:  ADDWF  x4A,W
04116:  MOVWF  FE9
04118:  MOVLW  00
0411A:  ADDWFC x4B,W
0411C:  MOVWF  FEA
0411E:  BSF    FEF.1
....................     } 
....................  
....................     ps->remote.IPAddr.Val = 0x00; 
04120:  MOVLW  07
04122:  ADDWF  x4A,W
04124:  MOVWF  FE9
04126:  MOVLW  00
04128:  ADDWFC x4B,W
0412A:  MOVWF  FEA
0412C:  MOVF   FEE,F
0412E:  MOVF   FEE,F
04130:  CLRF   FEC
04132:  MOVF   FED,F
04134:  CLRF   FEF
04136:  MOVF   FED,F
04138:  CLRF   FEF
0413A:  MOVF   FED,F
0413C:  CLRF   FEF
....................     ps->remotePort = 0x00; 
0413E:  MOVLW  0D
04140:  ADDWF  x4A,W
04142:  MOVWF  FE9
04144:  MOVLW  00
04146:  ADDWFC x4B,W
04148:  MOVWF  FEA
0414A:  CLRF   FEC
0414C:  MOVF   FED,F
0414E:  CLRF   FEF
....................     if ( ps->Flags.bIsGetReady ) 
04150:  MOVLW  23
04152:  ADDWF  x4A,W
04154:  MOVWF  FE9
04156:  MOVLW  00
04158:  ADDWFC x4B,W
0415A:  MOVWF  FEA
0415C:  BTFSS  FEF.3
0415E:  BRA    4168
....................     { 
....................         MACDiscardRx(); 
04160:  MOVLB  0
04162:  CALL   2C06
04166:  MOVLB  9
....................     } 
....................     ps->Flags.bIsGetReady       = FALSE; 
04168:  MOVLW  23
0416A:  ADDWF  x4A,W
0416C:  MOVWF  FE9
0416E:  MOVLW  00
04170:  ADDWFC x4B,W
04172:  MOVWF  FEA
04174:  BCF    FEF.3
....................     ps->TimeOut                 = TCP_START_TIMEOUT_VAL; 
04176:  MOVLW  21
04178:  ADDWF  x4A,W
0417A:  MOVWF  FE9
0417C:  MOVLW  00
0417E:  ADDWFC x4B,W
04180:  MOVWF  FEA
04182:  CLRF   FEC
04184:  MOVF   FED,F
04186:  MOVLW  24
04188:  MOVWF  FEF
....................  
....................     ps->Flags.bIsTxInProgress   = FALSE; 
0418A:  MOVLW  23
0418C:  ADDWF  x4A,W
0418E:  MOVWF  FE9
04190:  MOVLW  00
04192:  ADDWFC x4B,W
04194:  MOVWF  FEA
04196:  BCF    FEF.4
....................  
....................     if ( ps->Flags.bServer ) 
04198:  MOVLW  23
0419A:  ADDWF  x4A,W
0419C:  MOVWF  FE9
0419E:  MOVLW  00
041A0:  ADDWFC x4B,W
041A2:  MOVWF  FEA
041A4:  BTFSS  FEF.0
041A6:  BRA    41B4
....................     { 
....................         ps->smState = TCP_LISTEN; 
041A8:  MOVFF  94A,FE9
041AC:  MOVFF  94B,FEA
041B0:  CLRF   FEF
....................     } 
041B2:  BRA    41C0
....................     else 
....................     { 
....................         ps->smState = TCP_CLOSED; 
041B4:  MOVFF  94A,FE9
041B8:  MOVFF  94B,FEA
041BC:  MOVLW  0A
041BE:  MOVWF  FEF
....................     } 
....................     //ps->smState = TCP_CLOSED; 
....................  
....................    ps->TxCount = 0; 
041C0:  MOVLW  10
041C2:  ADDWF  x4A,W
041C4:  MOVWF  FE9
041C6:  MOVLW  00
041C8:  ADDWFC x4B,W
041CA:  MOVWF  FEA
041CC:  CLRF   FEC
041CE:  MOVF   FED,F
041D0:  CLRF   FEF
....................  
....................     return; 
041D2:  MOVLB  0
041D4:  RETURN 0
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
.................... * Function:        static void HandleTCPSeg(TCP_SOCKET s, 
.................... *                                      NODE_INFO *remote, 
.................... *                                      TCP_HEADER* h, 
.................... *                                      WORD len) 
.................... * 
.................... * PreCondition:    TCPInit() is already called     AND 
.................... *                  TCPProcess() is the caller. 
.................... * 
.................... * Input:           s           - Socket that owns this segment 
.................... *                  remote      - Remote node info 
.................... *                  h           - TCP Header 
.................... *                  len         - Total buffer length. 
.................... * 
.................... * Output:          TCP FSM is executed on given socket with 
.................... *                  given TCP segment. 
.................... * 
.................... * Side Effects:    None 
.................... * 
.................... * Overview:        None 
.................... * 
.................... * Note:            None 
.................... ********************************************************************/ 
.................... static void HandleTCPSeg(TCP_SOCKET s, 
....................                    NODE_INFO *remote, 
....................                    TCP_HEADER *h, 
....................                    WORD len) 
.................... { 
....................    DWORD ack; 
....................    DWORD seq; 
....................    DWORD prevAck, prevSeq; 
....................    SOCKET_INFO *ps; 
....................    BYTE flags; 
....................    //BYTE debugLastState; 
....................    signed int32 temp; 
....................  
....................    ps = &TCB[s]; 
*
04748:  MOVLB  9
0474A:  CLRF   x4B
0474C:  MOVFF  92C,94A
04750:  CLRF   x4D
04752:  MOVLW  24
04754:  MOVWF  x4C
04756:  MOVLB  0
04758:  CALL   1A40
0475C:  MOVFF  02,03
04760:  MOVF   01,W
04762:  ADDLW  9A
04764:  MOVWF  01
04766:  MOVLW  03
04768:  ADDWFC 03,F
0476A:  MOVFF  01,943
0476E:  MOVLB  9
04770:  MOVFF  03,944
....................    //debugLastState = TCB[s].smState; 
....................  
....................    flags = 0x00; 
04774:  CLRF   x45
....................  
....................    // Clear timeout info 
....................    ps->RetryCount  = 0; 
04776:  MOVLW  1E
04778:  ADDWF  x43,W
0477A:  MOVWF  FE9
0477C:  MOVLW  00
0477E:  ADDWFC x44,W
04780:  MOVWF  FEA
04782:  CLRF   FEF
....................    ps->startTick   = TickGet(); 
04784:  MOVLW  1F
04786:  ADDWF  x43,W
04788:  MOVWF  01
0478A:  MOVLW  00
0478C:  ADDWFC x44,W
0478E:  MOVWF  03
04790:  MOVFF  01,94A
04794:  MOVWF  x4B
04796:  MOVLB  0
04798:  RCALL  40BA
0479A:  MOVFF  94B,FEA
0479E:  MOVFF  94A,FE9
047A2:  MOVFF  02,FEC
047A6:  MOVF   FED,F
047A8:  MOVFF  01,FEF
....................    ps->TimeOut = TCP_START_TIMEOUT_VAL; 
047AC:  MOVLW  21
047AE:  MOVLB  9
047B0:  ADDWF  x43,W
047B2:  MOVWF  FE9
047B4:  MOVLW  00
047B6:  ADDWFC x44,W
047B8:  MOVWF  FEA
047BA:  CLRF   FEC
047BC:  MOVF   FED,F
047BE:  MOVLW  24
047C0:  MOVWF  FEF
....................  
....................    debug_tcp("\r\nTCP IN <= SP:%LX DP:%LX SEQ:%LX ACK:%LX LEN:%LX FL:%X\r\n", 
....................       h->SourcePort, 
....................       h->DestPort, 
....................       h->SeqNumber, 
....................       h->AckNumber, 
....................       len, 
....................       h->Flags 
....................    ); 
....................  
....................  
....................    // Reset FSM, if RST is received. 
....................    if(h->Flags.bits.flagRST) 
047C2:  MOVLW  0D
047C4:  ADDWF  x2F,W
047C6:  MOVWF  FE9
047C8:  MOVLW  00
047CA:  ADDWFC x30,W
047CC:  MOVWF  FEA
047CE:  BTFSS  FEF.2
047D0:  BRA    480E
....................    { 
....................       MACDiscardRx(); 
047D2:  MOVLB  0
047D4:  CALL   2C06
....................       ps->smState = ps->Flags.bServer ? TCP_LISTEN : TCP_SYN_SENT; 
047D8:  MOVLB  9
047DA:  MOVFF  943,01
047DE:  MOVFF  944,03
047E2:  MOVFF  943,94A
047E6:  MOVFF  944,94B
047EA:  MOVLW  23
047EC:  ADDWF  x43,W
047EE:  MOVWF  FE9
047F0:  MOVLW  00
047F2:  ADDWFC x44,W
047F4:  MOVWF  FEA
047F6:  BTFSS  FEF.0
047F8:  BRA    47FE
047FA:  MOVLW  00
047FC:  BRA    4800
047FE:  MOVLW  01
04800:  MOVFF  94B,FEA
04804:  MOVFF  94A,FE9
04808:  MOVWF  FEF
....................       return; 
0480A:  GOTO   5170
....................    } 
....................  
....................    seq = ps->SND_SEQ; 
0480E:  MOVLW  16
04810:  ADDWF  x43,W
04812:  MOVWF  FE9
04814:  MOVLW  00
04816:  ADDWFC x44,W
04818:  MOVWF  FEA
0481A:  MOVFF  FEF,937
0481E:  MOVFF  FEC,938
04822:  MOVFF  FEC,939
04826:  MOVFF  FEC,93A
....................  
....................    temp = (signed int32)h->Window - ((signed int32)seq - (signed int32)h->AckNumber) - (signed int32)ps->TxCount; 
0482A:  MOVLW  0E
0482C:  ADDWF  x2F,W
0482E:  MOVWF  FE9
04830:  MOVLW  00
04832:  ADDWFC x30,W
04834:  MOVWF  FEA
04836:  MOVFF  FEC,03
0483A:  MOVF   FED,F
0483C:  MOVFF  FEF,94A
04840:  MOVFF  03,94B
04844:  CLRF   x4C
04846:  CLRF   x4D
04848:  MOVLW  08
0484A:  ADDWF  x2F,W
0484C:  MOVWF  FE9
0484E:  MOVLW  00
04850:  ADDWFC x30,W
04852:  MOVWF  FEA
04854:  MOVFF  FEF,00
04858:  MOVFF  FEC,01
0485C:  MOVFF  FEC,02
04860:  MOVFF  FEC,03
04864:  MOVF   00,W
04866:  SUBWF  x37,W
04868:  MOVWF  00
0486A:  MOVF   01,W
0486C:  SUBWFB x38,W
0486E:  MOVWF  01
04870:  MOVF   02,W
04872:  SUBWFB x39,W
04874:  MOVWF  02
04876:  MOVF   03,W
04878:  SUBWFB x3A,W
0487A:  MOVWF  03
0487C:  MOVF   00,W
0487E:  SUBWF  x4A,F
04880:  MOVF   01,W
04882:  SUBWFB x4B,F
04884:  MOVF   02,W
04886:  SUBWFB x4C,F
04888:  MOVF   03,W
0488A:  SUBWFB x4D,F
0488C:  MOVLW  10
0488E:  ADDWF  x43,W
04890:  MOVWF  FE9
04892:  MOVLW  00
04894:  ADDWFC x44,W
04896:  MOVWF  FEA
04898:  MOVFF  FEC,03
0489C:  MOVF   FED,F
0489E:  MOVFF  FEF,00
048A2:  MOVFF  03,01
048A6:  CLRF   02
048A8:  CLRF   03
048AA:  MOVF   00,W
048AC:  SUBWF  x4A,W
048AE:  MOVWF  x46
048B0:  MOVF   01,W
048B2:  SUBWFB x4B,W
048B4:  MOVWF  x47
048B6:  MOVF   02,W
048B8:  SUBWFB x4C,W
048BA:  MOVWF  x48
048BC:  MOVF   03,W
048BE:  SUBWFB x4D,W
048C0:  MOVWF  x49
....................    if(temp < 0) 
048C2:  BTFSS  x49.7
048C4:  BRA    48DA
....................    { 
....................       ps->RemoteWindow = 0; 
048C6:  MOVLW  14
048C8:  ADDWF  x43,W
048CA:  MOVWF  FE9
048CC:  MOVLW  00
048CE:  ADDWFC x44,W
048D0:  MOVWF  FEA
048D2:  CLRF   FEC
048D4:  MOVF   FED,F
048D6:  CLRF   FEF
....................       debug_tcp("\r\nRW1 => %LX, res=%LX W=%LX S=%LX A=%LX C=%LX\r\n", 
....................             ps->RemoteWindow, 
....................             temp, 
....................             h->Window, 
....................             seq, 
....................             h->AckNumber, 
....................             ps->TxCount 
....................          ); 
....................    } 
048D8:  BRA    48EE
....................    else 
....................    { 
....................       ps->RemoteWindow = ack; 
048DA:  MOVLW  14
048DC:  ADDWF  x43,W
048DE:  MOVWF  FE9
048E0:  MOVLW  00
048E2:  ADDWFC x44,W
048E4:  MOVWF  FEA
048E6:  MOVFF  933,FEF
048EA:  MOVFF  934,FEC
....................       debug_tcp("\r\nRW2 => %LX\r\n", ps->RemoteWindow); 
....................    } 
....................  
....................    // Handle TCP_SYN_SENT state 
....................    // The TCP_SYN_SENT state occurs when an application 
....................    // calls TCPConnect().  After an initial SYN is sent, 
....................    // we expect a SYN + ACK before establishing the 
....................    // connection. 
....................    if(ps->smState == TCP_SYN_SENT) 
048EE:  MOVFF  943,FE9
048F2:  MOVFF  944,FEA
048F6:  DECFSZ FEF,W
048F8:  BRA    4A64
....................    { 
....................       // Check if this is a SYN packet.  Unsynchronized, we cannot 
....................       // handle any other packet types. 
....................       if(!h->Flags.bits.flagSYN) 
048FA:  MOVLW  0D
048FC:  ADDWF  x2F,W
048FE:  MOVWF  FE9
04900:  MOVLW  00
04902:  ADDWFC x30,W
04904:  MOVWF  FEA
04906:  BTFSC  FEF.1
04908:  BRA    492E
....................       { 
....................          MACDiscardRx(); 
0490A:  MOVLB  0
0490C:  CALL   2C06
....................  
....................          // Send out a RESET if the remote node thinks a connection is already established 
....................           if(h->Flags.bits.flagACK) 
04910:  MOVLW  0D
04912:  MOVLB  9
04914:  ADDWF  x2F,W
04916:  MOVWF  FE9
04918:  MOVLW  00
0491A:  ADDWFC x30,W
0491C:  MOVWF  FEA
0491E:  BTFSS  FEF.4
04920:  BRA    492A
....................           { 
....................             flags = RST; 
04922:  MOVLW  04
04924:  MOVWF  x45
....................             goto SendTCPControlPacket; 
04926:  GOTO   50FA
....................            } 
....................  
....................          return; 
0492A:  GOTO   5170
....................       } 
....................  
....................       // We now have a sequence number for the remote node 
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
0492E:  MOVLW  1A
04930:  ADDWF  x43,W
04932:  MOVWF  01
04934:  MOVLW  00
04936:  ADDWFC x44,W
04938:  MOVFF  01,94A
0493C:  MOVWF  x4B
0493E:  MOVLW  04
04940:  ADDWF  x2F,W
04942:  MOVWF  FE9
04944:  MOVLW  00
04946:  ADDWFC x30,W
04948:  MOVWF  FEA
0494A:  MOVFF  FEF,94C
0494E:  MOVFF  FEC,94D
04952:  MOVFF  FEC,94E
04956:  MOVFF  FEC,94F
0495A:  MOVF   x31,W
0495C:  ADDWF  x4C,F
0495E:  MOVF   x32,W
04960:  ADDWFC x4D,F
04962:  MOVLW  00
04964:  ADDWFC x4E,F
04966:  ADDWFC x4F,F
04968:  MOVLW  01
0496A:  ADDWF  x4C,W
0496C:  MOVWF  00
0496E:  MOVLW  00
04970:  ADDWFC x4D,W
04972:  MOVWF  01
04974:  MOVLW  00
04976:  ADDWFC x4E,W
04978:  MOVWF  02
0497A:  MOVLW  00
0497C:  ADDWFC x4F,W
0497E:  MOVFF  94B,FEA
04982:  MOVFF  94A,FE9
04986:  MOVFF  00,FEF
0498A:  MOVFF  01,FEC
0498E:  MOVFF  02,FEC
04992:  MOVWF  FEC
....................       ack = ps->SND_ACK; 
04994:  MOVLW  1A
04996:  ADDWF  x43,W
04998:  MOVWF  FE9
0499A:  MOVLW  00
0499C:  ADDWFC x44,W
0499E:  MOVWF  FEA
049A0:  MOVFF  FEF,933
049A4:  MOVFF  FEC,934
049A8:  MOVFF  FEC,935
049AC:  MOVFF  FEC,936
....................  
....................       // If there is no ACK, we must go to TCP_SYN_RECEIVED.  With an ACK, 
....................       // we can establish the connection now. 
....................       if(!h->Flags.bits.flagACK) 
049B0:  MOVLW  0D
049B2:  ADDWF  x2F,W
049B4:  MOVWF  FE9
049B6:  MOVLW  00
049B8:  ADDWFC x30,W
049BA:  MOVWF  FEA
049BC:  BTFSC  FEF.4
049BE:  BRA    49DA
....................       { 
....................          ps->smState = TCP_SYN_RECEIVED; 
049C0:  MOVFF  943,FE9
049C4:  MOVFF  944,FEA
049C8:  MOVLW  02
049CA:  MOVWF  FEF
....................          MACDiscardRx(); 
049CC:  MOVLB  0
049CE:  CALL   2C06
....................          // Send out a SYN+ACK for simultaneous connection open 
....................          flags = SYN | ACK; 
049D2:  MOVLW  12
049D4:  MOVLB  9
049D6:  MOVWF  x45
....................          goto SendTCPControlPacket; 
049D8:  BRA    50FA
....................       } 
....................  
....................       // We received SYN+ACK, establish the connection now 
....................       ps->smState = TCP_ESTABLISHED; 
049DA:  MOVFF  943,FE9
049DE:  MOVFF  944,FEA
049E2:  MOVLW  03
049E4:  MOVWF  FEF
....................       // Send out an ACK 
....................       flags = ACK; 
049E6:  MOVLW  10
049E8:  MOVWF  x45
....................  
....................       ps->RemoteWindow = h->Window; 
049EA:  MOVLW  14
049EC:  ADDWF  x43,W
049EE:  MOVWF  01
049F0:  MOVLW  00
049F2:  ADDWFC x44,W
049F4:  MOVWF  03
049F6:  MOVWF  x4B
049F8:  MOVLW  0E
049FA:  ADDWF  x2F,W
049FC:  MOVWF  FE9
049FE:  MOVLW  00
04A00:  ADDWFC x30,W
04A02:  MOVWF  FEA
04A04:  MOVFF  FEC,03
04A08:  MOVF   FED,F
04A0A:  MOVFF  FEF,94C
04A0E:  MOVFF  94B,FEA
04A12:  MOVFF  01,FE9
04A16:  MOVFF  03,FEC
04A1A:  MOVF   FED,F
04A1C:  MOVFF  94C,FEF
....................       debug_tcp("\r\nRW3 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // Check for application data and make it 
....................       // available, if present 
....................       if(len) 
04A20:  MOVF   x31,W
04A22:  IORWF  x32,W
04A24:  BZ    4A5A
....................       { 
....................          ps->Flags.bIsGetReady   = TRUE; 
04A26:  MOVLW  23
04A28:  ADDWF  x43,W
04A2A:  MOVWF  FE9
04A2C:  MOVLW  00
04A2E:  ADDWFC x44,W
04A30:  MOVWF  FEA
04A32:  BSF    FEF.3
....................          ps->RxCount             = len; 
04A34:  MOVLW  12
04A36:  ADDWF  x43,W
04A38:  MOVWF  FE9
04A3A:  MOVLW  00
04A3C:  ADDWFC x44,W
04A3E:  MOVWF  FEA
04A40:  MOVFF  932,FEC
04A44:  MOVF   FED,F
04A46:  MOVFF  931,FEF
....................          ps->Flags.bFirstRead    = TRUE; 
04A4A:  MOVLW  23
04A4C:  ADDWF  x43,W
04A4E:  MOVWF  FE9
04A50:  MOVLW  00
04A52:  ADDWFC x44,W
04A54:  MOVWF  FEA
04A56:  BSF    FEF.2
....................       } 
04A58:  BRA    4A62
....................       else   // No application data in this packet 
....................       { 
....................          MACDiscardRx(); 
04A5A:  MOVLB  0
04A5C:  CALL   2C06
04A60:  MOVLB  9
....................       } 
....................       goto SendTCPControlPacket; 
04A62:  BRA    50FA
....................    } 
....................  
....................    // Handle TCP_LISTEN state 
....................    if(ps->smState == TCP_LISTEN ) 
04A64:  MOVFF  943,FE9
04A68:  MOVFF  944,FEA
04A6C:  MOVF   FEF,F
04A6E:  BTFSS  FD8.2
04A70:  BRA    4BE6
....................    { 
....................       MACDiscardRx(); 
04A72:  MOVLB  0
04A74:  CALL   2C06
....................  
....................       // Send a RST if this isn't a SYN packet 
....................       if(!h->Flags.bits.flagSYN) 
04A78:  MOVLW  0D
04A7A:  MOVLB  9
04A7C:  ADDWF  x2F,W
04A7E:  MOVWF  FE9
04A80:  MOVLW  00
04A82:  ADDWFC x30,W
04A84:  MOVWF  FEA
04A86:  BTFSC  FEF.1
04A88:  BRA    4A90
....................       { 
....................          flags = RST; 
04A8A:  MOVLW  04
04A8C:  MOVWF  x45
....................          goto SendTCPControlPacket; 
04A8E:  BRA    50FA
....................       } 
....................  
....................       ps->SND_ACK = h->SeqNumber + len + 1; 
04A90:  MOVLW  1A
04A92:  ADDWF  x43,W
04A94:  MOVWF  01
04A96:  MOVLW  00
04A98:  ADDWFC x44,W
04A9A:  MOVFF  01,94A
04A9E:  MOVWF  x4B
04AA0:  MOVLW  04
04AA2:  ADDWF  x2F,W
04AA4:  MOVWF  FE9
04AA6:  MOVLW  00
04AA8:  ADDWFC x30,W
04AAA:  MOVWF  FEA
04AAC:  MOVFF  FEF,94C
04AB0:  MOVFF  FEC,94D
04AB4:  MOVFF  FEC,94E
04AB8:  MOVFF  FEC,94F
04ABC:  MOVF   x31,W
04ABE:  ADDWF  x4C,F
04AC0:  MOVF   x32,W
04AC2:  ADDWFC x4D,F
04AC4:  MOVLW  00
04AC6:  ADDWFC x4E,F
04AC8:  ADDWFC x4F,F
04ACA:  MOVLW  01
04ACC:  ADDWF  x4C,W
04ACE:  MOVWF  00
04AD0:  MOVLW  00
04AD2:  ADDWFC x4D,W
04AD4:  MOVWF  01
04AD6:  MOVLW  00
04AD8:  ADDWFC x4E,W
04ADA:  MOVWF  02
04ADC:  MOVLW  00
04ADE:  ADDWFC x4F,W
04AE0:  MOVFF  94B,FEA
04AE4:  MOVFF  94A,FE9
04AE8:  MOVFF  00,FEF
04AEC:  MOVFF  01,FEC
04AF0:  MOVFF  02,FEC
04AF4:  MOVWF  FEC
....................       ps->RemoteWindow = h->Window; 
04AF6:  MOVLW  14
04AF8:  ADDWF  x43,W
04AFA:  MOVWF  01
04AFC:  MOVLW  00
04AFE:  ADDWFC x44,W
04B00:  MOVWF  03
04B02:  MOVWF  x4B
04B04:  MOVLW  0E
04B06:  ADDWF  x2F,W
04B08:  MOVWF  FE9
04B0A:  MOVLW  00
04B0C:  ADDWFC x30,W
04B0E:  MOVWF  FEA
04B10:  MOVFF  FEC,03
04B14:  MOVF   FED,F
04B16:  MOVFF  FEF,94C
04B1A:  MOVFF  94B,FEA
04B1E:  MOVFF  01,FE9
04B22:  MOVFF  03,FEC
04B26:  MOVF   FED,F
04B28:  MOVFF  94C,FEF
....................       debug_tcp("\r\nRW4 => %LX\r\n", ps->RemoteWindow); 
....................  
....................       // This socket has received connection request (SYN). 
....................       // Remember calling node, assign next segment seq. number 
....................       // for this potential connection. 
....................       memcpy((void*)&ps->remote, (void*)remote, sizeof(*remote)); 
04B2C:  MOVLW  01
04B2E:  ADDWF  x43,W
04B30:  MOVWF  01
04B32:  MOVLW  00
04B34:  ADDWFC x44,W
04B36:  MOVWF  03
04B38:  MOVFF  01,94A
04B3C:  MOVWF  x4B
04B3E:  MOVWF  FEA
04B40:  MOVFF  01,FE9
04B44:  MOVFF  92E,FE2
04B48:  MOVFF  92D,FE1
04B4C:  MOVLW  0A
04B4E:  MOVWF  01
04B50:  MOVFF  FE6,FEE
04B54:  DECFSZ 01,F
04B56:  BRA    4B50
....................       ps->remotePort = h->SourcePort; 
04B58:  MOVLW  0D
04B5A:  ADDWF  x43,W
04B5C:  MOVWF  01
04B5E:  MOVLW  00
04B60:  ADDWFC x44,W
04B62:  MOVFF  92F,FE9
04B66:  MOVFF  930,FEA
04B6A:  MOVFF  FEC,03
04B6E:  MOVF   FED,F
04B70:  MOVFF  FEF,94C
04B74:  MOVWF  FEA
04B76:  MOVFF  01,FE9
04B7A:  MOVFF  03,FEC
04B7E:  MOVF   FED,F
04B80:  MOVFF  94C,FEF
....................  
....................       // Grant connection request. 
....................       ps->smState = TCP_SYN_RECEIVED; 
04B84:  MOVFF  943,FE9
04B88:  MOVFF  944,FEA
04B8C:  MOVLW  02
04B8E:  MOVWF  FEF
....................       //seq = ps->SND_SEQ++;  //currently buggy in ccs 
....................       seq = ps->SND_SEQ; 
04B90:  MOVLW  16
04B92:  ADDWF  x43,W
04B94:  MOVWF  FE9
04B96:  MOVLW  00
04B98:  ADDWFC x44,W
04B9A:  MOVWF  FEA
04B9C:  MOVFF  FEF,937
04BA0:  MOVFF  FEC,938
04BA4:  MOVFF  FEC,939
04BA8:  MOVFF  FEC,93A
....................       ps->SND_SEQ++; 
04BAC:  MOVLW  16
04BAE:  ADDWF  x43,W
04BB0:  MOVWF  FE9
04BB2:  MOVLW  00
04BB4:  ADDWFC x44,W
04BB6:  MOVWF  FEA
04BB8:  MOVLW  01
04BBA:  ADDWF  FEE,F
04BBC:  MOVLW  00
04BBE:  ADDWFC FEE,F
04BC0:  ADDWFC FEE,F
04BC2:  ADDWFC FED,F
....................       ack =  ps->SND_ACK; 
04BC4:  MOVLW  1A
04BC6:  ADDWF  x43,W
04BC8:  MOVWF  FE9
04BCA:  MOVLW  00
04BCC:  ADDWFC x44,W
04BCE:  MOVWF  FEA
04BD0:  MOVFF  FEF,933
04BD4:  MOVFF  FEC,934
04BD8:  MOVFF  FEC,935
04BDC:  MOVFF  FEC,936
....................       flags = SYN | ACK; 
04BE0:  MOVLW  12
04BE2:  MOVWF  x45
....................       goto SendTCPControlPacket; 
04BE4:  BRA    50FA
....................    } 
....................  
....................  
....................    // Remember current seq and ack for our connection so that if 
....................    // we have to silently discard this packet, we can go back to 
....................    // previous ack and seq numbers. 
....................    prevAck = ps->SND_ACK; 
04BE6:  MOVLW  1A
04BE8:  ADDWF  x43,W
04BEA:  MOVWF  FE9
04BEC:  MOVLW  00
04BEE:  ADDWFC x44,W
04BF0:  MOVWF  FEA
04BF2:  MOVFF  FEF,93B
04BF6:  MOVFF  FEC,93C
04BFA:  MOVFF  FEC,93D
04BFE:  MOVFF  FEC,93E
....................    prevSeq = ps->SND_SEQ; 
04C02:  MOVLW  16
04C04:  ADDWF  x43,W
04C06:  MOVWF  FE9
04C08:  MOVLW  00
04C0A:  ADDWFC x44,W
04C0C:  MOVWF  FEA
04C0E:  MOVFF  FEF,93F
04C12:  MOVFF  FEC,940
04C16:  MOVFF  FEC,941
04C1A:  MOVFF  FEC,942
....................  
....................    ack = h->SeqNumber; 
04C1E:  MOVLW  04
04C20:  ADDWF  x2F,W
04C22:  MOVWF  FE9
04C24:  MOVLW  00
04C26:  ADDWFC x30,W
04C28:  MOVWF  FEA
04C2A:  MOVFF  FEF,933
04C2E:  MOVFF  FEC,934
04C32:  MOVFF  FEC,935
04C36:  MOVFF  FEC,936
....................    ack += (DWORD)len; 
04C3A:  CLRF   02
04C3C:  CLRF   03
04C3E:  MOVF   x31,W
04C40:  ADDWF  x33,F
04C42:  MOVF   x32,W
04C44:  ADDWFC x34,F
04C46:  MOVF   02,W
04C48:  ADDWFC x35,F
04C4A:  MOVF   03,W
04C4C:  ADDWFC x36,F
....................    seq = ps->SND_SEQ; 
04C4E:  MOVLW  16
04C50:  ADDWF  x43,W
04C52:  MOVWF  FE9
04C54:  MOVLW  00
04C56:  ADDWFC x44,W
04C58:  MOVWF  FEA
04C5A:  MOVFF  FEF,937
04C5E:  MOVFF  FEC,938
04C62:  MOVFF  FEC,939
04C66:  MOVFF  FEC,93A
....................  
....................    // State is something other than TCP_LISTEN, handle it. 
....................    { 
....................       // Check to see if the incomming sequence number is what 
....................       // we expect (last transmitted ACK value).  Throw this packet 
....................       // away if it is wrong. 
....................       if(h->SeqNumber == prevAck) 
04C6A:  MOVLW  04
04C6C:  ADDWF  x2F,W
04C6E:  MOVWF  FE9
04C70:  MOVLW  00
04C72:  ADDWFC x30,W
04C74:  MOVWF  FEA
04C76:  MOVFF  FEF,94A
04C7A:  MOVFF  FEC,94B
04C7E:  MOVFF  FEC,94C
04C82:  MOVFF  FEC,94D
04C86:  MOVF   x3B,W
04C88:  SUBWF  x4A,W
04C8A:  BTFSS  FD8.2
04C8C:  BRA    50DE
04C8E:  MOVF   x3C,W
04C90:  SUBWF  x4B,W
04C92:  BTFSS  FD8.2
04C94:  BRA    50DE
04C96:  MOVF   x3D,W
04C98:  SUBWF  x4C,W
04C9A:  BTFSS  FD8.2
04C9C:  BRA    50DE
04C9E:  MOVF   x3E,W
04CA0:  SUBWF  x4D,W
04CA2:  BTFSS  FD8.2
04CA4:  BRA    50DE
....................       { 
....................          // After receiving a SYNchronization request, we expect an 
....................          // ACK to our transmitted SYN 
....................          if(ps->smState == TCP_SYN_RECEIVED) 
04CA6:  MOVFF  943,FE9
04CAA:  MOVFF  944,FEA
04CAE:  MOVF   FEF,W
04CB0:  SUBLW  02
04CB2:  BNZ   4D3A
....................          { 
....................             if(h->Flags.bits.flagACK) 
04CB4:  MOVLW  0D
04CB6:  ADDWF  x2F,W
04CB8:  MOVWF  FE9
04CBA:  MOVLW  00
04CBC:  ADDWFC x30,W
04CBE:  MOVWF  FEA
04CC0:  BTFSS  FEF.4
04CC2:  BRA    4D30
....................             { 
....................                // ACK received as expected, this connection is 
....................                // now established 
....................                ps->SND_ACK = ack; 
04CC4:  MOVLW  1A
04CC6:  ADDWF  x43,W
04CC8:  MOVWF  FE9
04CCA:  MOVLW  00
04CCC:  ADDWFC x44,W
04CCE:  MOVWF  FEA
04CD0:  MOVFF  933,FEF
04CD4:  MOVFF  934,FEC
04CD8:  MOVFF  935,FEC
04CDC:  MOVFF  936,FEC
....................                ps->smState = TCP_ESTABLISHED; 
04CE0:  MOVFF  943,FE9
04CE4:  MOVFF  944,FEA
04CE8:  MOVLW  03
04CEA:  MOVWF  FEF
....................  
....................                // Check if this first packet has application data 
....................                // in it.  Make it available if so. 
....................                if(len) 
04CEC:  MOVF   x31,W
04CEE:  IORWF  x32,W
04CF0:  BZ    4D26
....................                { 
....................                   ps->Flags.bIsGetReady   = TRUE; 
04CF2:  MOVLW  23
04CF4:  ADDWF  x43,W
04CF6:  MOVWF  FE9
04CF8:  MOVLW  00
04CFA:  ADDWFC x44,W
04CFC:  MOVWF  FEA
04CFE:  BSF    FEF.3
....................                   ps->RxCount             = len; 
04D00:  MOVLW  12
04D02:  ADDWF  x43,W
04D04:  MOVWF  FE9
04D06:  MOVLW  00
04D08:  ADDWFC x44,W
04D0A:  MOVWF  FEA
04D0C:  MOVFF  932,FEC
04D10:  MOVF   FED,F
04D12:  MOVFF  931,FEF
....................                   ps->Flags.bFirstRead    = TRUE; 
04D16:  MOVLW  23
04D18:  ADDWF  x43,W
04D1A:  MOVWF  FE9
04D1C:  MOVLW  00
04D1E:  ADDWFC x44,W
04D20:  MOVWF  FEA
04D22:  BSF    FEF.2
....................                } 
04D24:  BRA    4D2E
....................                else 
....................                   MACDiscardRx(); 
04D26:  MOVLB  0
04D28:  CALL   2C06
04D2C:  MOVLB  9
....................             } 
04D2E:  BRA    4D38
....................             else   // No ACK to our SYN 
....................             { 
....................                MACDiscardRx(); 
04D30:  MOVLB  0
04D32:  CALL   2C06
04D36:  MOVLB  9
....................             } 
....................          } 
04D38:  BRA    50DC
....................          // Connection is established, closing, or otherwise 
....................          else 
....................          { 
....................  
....................             // Save the seq+len value of the packet for our future 
....................             // ACK transmission, and so out of sequence packets 
....................             // can be detected in the future. 
....................             ps->SND_ACK = ack; 
04D3A:  MOVLW  1A
04D3C:  ADDWF  x43,W
04D3E:  MOVWF  FE9
04D40:  MOVLW  00
04D42:  ADDWFC x44,W
04D44:  MOVWF  FEA
04D46:  MOVFF  933,FEF
04D4A:  MOVFF  934,FEC
04D4E:  MOVFF  935,FEC
04D52:  MOVFF  936,FEC
....................  
....................             // Handle packets received while connection established. 
....................             if(ps->smState == TCP_ESTABLISHED) 
04D56:  MOVFF  943,FE9
04D5A:  MOVFF  944,FEA
04D5E:  MOVF   FEF,W
04D60:  SUBLW  03
04D62:  BTFSS  FD8.2
04D64:  BRA    4F0E
....................             { 
....................                // If this packet has the ACK set, mark all 
....................                // previous TX packets as no longer needed for 
....................                // possible retransmission. 
....................                // TODO: Make this more sophisticated so that partial ACKs due to fragmentation are handled correctly.  i.e. Keep a real output stream buffer with slidable window capability. 
....................                if(h->Flags.bits.flagACK && !ps->Flags.bIsPutReady) 
04D66:  MOVLW  0D
04D68:  ADDWF  x2F,W
04D6A:  MOVWF  FE9
04D6C:  MOVLW  00
04D6E:  ADDWFC x30,W
04D70:  MOVWF  FEA
04D72:  BTFSS  FEF.4
04D74:  BRA    4DD0
04D76:  MOVLW  23
04D78:  ADDWF  x43,W
04D7A:  MOVWF  FE9
04D7C:  MOVLW  00
04D7E:  ADDWFC x44,W
04D80:  MOVWF  FEA
04D82:  BTFSC  FEF.1
04D84:  BRA    4DD0
....................                { 
....................                   if(ps->TxBuffer != INVALID_BUFFER) 
04D86:  MOVLW  0F
04D88:  ADDWF  x43,W
04D8A:  MOVWF  FE9
04D8C:  MOVLW  00
04D8E:  ADDWFC x44,W
04D90:  MOVWF  FEA
04D92:  INCFSZ FEF,W
04D94:  BRA    4D98
04D96:  BRA    4DD0
....................                   { 
....................                      MACDiscardTx(ps->TxBuffer); 
04D98:  MOVLW  0F
04D9A:  ADDWF  x43,W
04D9C:  MOVWF  FE9
04D9E:  MOVLW  00
04DA0:  ADDWFC x44,W
04DA2:  MOVWF  FEA
04DA4:  MOVFF  FEF,94A
04DA8:  MOVFF  94A,94D
04DAC:  MOVLB  0
04DAE:  CALL   0004
....................                      ps->TxBuffer            = INVALID_BUFFER; 
04DB2:  MOVLW  0F
04DB4:  MOVLB  9
04DB6:  ADDWF  x43,W
04DB8:  MOVWF  FE9
04DBA:  MOVLW  00
04DBC:  ADDWFC x44,W
04DBE:  MOVWF  FEA
04DC0:  SETF   FEF
....................                      ps->Flags.bIsPutReady   = TRUE; 
04DC2:  MOVLW  23
04DC4:  ADDWF  x43,W
04DC6:  MOVWF  FE9
04DC8:  MOVLW  00
04DCA:  ADDWFC x44,W
04DCC:  MOVWF  FEA
04DCE:  BSF    FEF.1
....................                   } 
....................                } 
....................  
....................                // Check if the remote node is closing the connection 
....................                if(h->Flags.bits.flagFIN) 
04DD0:  MOVLW  0D
04DD2:  ADDWF  x2F,W
04DD4:  MOVWF  FE9
04DD6:  MOVLW  00
04DD8:  ADDWFC x30,W
04DDA:  MOVWF  FEA
04DDC:  BTFSS  FEF.0
04DDE:  BRA    4E76
....................                { 
....................                   //DebugPrint("|"); 
....................                   flags = FIN | ACK; 
04DE0:  MOVLW  11
04DE2:  MOVWF  x45
....................                   //seq = ps->SND_SEQ++; //currently buggy in CCS 
....................                   seq = ps->SND_SEQ; 
04DE4:  MOVLW  16
04DE6:  ADDWF  x43,W
04DE8:  MOVWF  FE9
04DEA:  MOVLW  00
04DEC:  ADDWFC x44,W
04DEE:  MOVWF  FEA
04DF0:  MOVFF  FEF,937
04DF4:  MOVFF  FEC,938
04DF8:  MOVFF  FEC,939
04DFC:  MOVFF  FEC,93A
....................                   ps->SND_SEQ++; 
04E00:  MOVLW  16
04E02:  ADDWF  x43,W
04E04:  MOVWF  FE9
04E06:  MOVLW  00
04E08:  ADDWFC x44,W
04E0A:  MOVWF  FEA
04E0C:  MOVLW  01
04E0E:  ADDWF  FEE,F
04E10:  MOVLW  00
04E12:  ADDWFC FEE,F
04E14:  ADDWFC FEE,F
04E16:  ADDWFC FED,F
....................                   //ack = ++ps->SND_ACK;   /////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
04E18:  MOVLW  1A
04E1A:  ADDWF  x43,W
04E1C:  MOVWF  FE9
04E1E:  MOVLW  00
04E20:  ADDWFC x44,W
04E22:  MOVWF  FEA
04E24:  MOVLW  01
04E26:  ADDWF  FEF,W
04E28:  MOVWF  00
04E2A:  MOVLW  00
04E2C:  ADDWFC FEC,W
04E2E:  MOVWF  01
04E30:  MOVLW  00
04E32:  ADDWFC FEC,W
04E34:  MOVWF  02
04E36:  MOVLW  00
04E38:  ADDWFC FEC,W
04E3A:  MOVF   FED,F
04E3C:  MOVF   FED,F
04E3E:  MOVF   FED,F
04E40:  MOVFF  00,FEF
04E44:  MOVFF  01,FEC
04E48:  MOVFF  02,FEC
04E4C:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
04E4E:  MOVLW  1A
04E50:  ADDWF  x43,W
04E52:  MOVWF  FE9
04E54:  MOVLW  00
04E56:  ADDWFC x44,W
04E58:  MOVWF  FEA
04E5A:  MOVFF  FEF,933
04E5E:  MOVFF  FEC,934
04E62:  MOVFF  FEC,935
04E66:  MOVFF  FEC,936
....................                   ps->smState = TCP_LAST_ACK; 
04E6A:  MOVFF  943,FE9
04E6E:  MOVFF  944,FEA
04E72:  MOVLW  09
04E74:  MOVWF  FEF
....................                } 
....................  
....................                // Check if there is any application data in 
....................                // this packet. 
....................                if(len) 
04E76:  MOVF   x31,W
04E78:  IORWF  x32,W
04E7A:  BZ    4F04
....................                { 
....................                   // There is data.  Make it available if we 
....................                   // don't already have data available. 
....................                   if(!ps->Flags.bIsGetReady) 
04E7C:  MOVLW  23
04E7E:  ADDWF  x43,W
04E80:  MOVWF  FE9
04E82:  MOVLW  00
04E84:  ADDWFC x44,W
04E86:  MOVWF  FEA
04E88:  BTFSC  FEF.3
04E8A:  BRA    4EC2
....................                   { 
....................                      ps->Flags.bIsGetReady   = TRUE; 
04E8C:  MOVLW  23
04E8E:  ADDWF  x43,W
04E90:  MOVWF  FE9
04E92:  MOVLW  00
04E94:  ADDWFC x44,W
04E96:  MOVWF  FEA
04E98:  BSF    FEF.3
....................                      ps->RxCount             = len; 
04E9A:  MOVLW  12
04E9C:  ADDWF  x43,W
04E9E:  MOVWF  FE9
04EA0:  MOVLW  00
04EA2:  ADDWFC x44,W
04EA4:  MOVWF  FEA
04EA6:  MOVFF  932,FEC
04EAA:  MOVF   FED,F
04EAC:  MOVFF  931,FEF
....................                      ps->Flags.bFirstRead    = TRUE; 
04EB0:  MOVLW  23
04EB2:  ADDWF  x43,W
04EB4:  MOVWF  FE9
04EB6:  MOVLW  00
04EB8:  ADDWFC x44,W
04EBA:  MOVWF  FEA
04EBC:  BSF    FEF.2
....................  
....................                      // 4/1/02 
....................                      flags |= ACK; 
04EBE:  BSF    x45.4
....................                   } 
04EC0:  BRA    4F02
....................                   // There is data, but we cannot handle it at this time. 
....................                   else 
....................                   { 
....................                      //DebugPrint("D"); 
....................                      // Since we cannot accept this packet, 
....................                      // restore to previous seq and ack. 
....................                      // and do not send anything back. 
....................                      // Host has to resend this packet when 
....................                      // we are ready. 
....................                      ps->SND_SEQ = prevSeq; 
04EC2:  MOVLW  16
04EC4:  ADDWF  x43,W
04EC6:  MOVWF  FE9
04EC8:  MOVLW  00
04ECA:  ADDWFC x44,W
04ECC:  MOVWF  FEA
04ECE:  MOVFF  93F,FEF
04ED2:  MOVFF  940,FEC
04ED6:  MOVFF  941,FEC
04EDA:  MOVFF  942,FEC
....................                      ps->SND_ACK = prevAck; 
04EDE:  MOVLW  1A
04EE0:  ADDWF  x43,W
04EE2:  MOVWF  FE9
04EE4:  MOVLW  00
04EE6:  ADDWFC x44,W
04EE8:  MOVWF  FEA
04EEA:  MOVFF  93B,FEF
04EEE:  MOVFF  93C,FEC
04EF2:  MOVFF  93D,FEC
04EF6:  MOVFF  93E,FEC
....................  
....................                      MACDiscardRx(); 
04EFA:  MOVLB  0
04EFC:  CALL   2C06
04F00:  MOVLB  9
....................                   } 
....................                } 
04F02:  BRA    4F0C
....................                // There is no data in this packet, and thus it 
....................                // can be thrown away. 
....................                else 
....................                { 
....................                   MACDiscardRx(); 
04F04:  MOVLB  0
04F06:  CALL   2C06
04F0A:  MOVLB  9
....................                } 
....................             } 
04F0C:  BRA    50DC
....................             // Connection is not established; check if we've sent 
....................             // a FIN and expect our last ACK 
....................             else if(ps->smState == TCP_LAST_ACK) 
04F0E:  MOVFF  943,FE9
04F12:  MOVFF  944,FEA
04F16:  MOVF   FEF,W
04F18:  SUBLW  09
04F1A:  BNZ   4F46
....................             { 
....................                MACDiscardRx(); 
04F1C:  MOVLB  0
04F1E:  CALL   2C06
....................  
....................                if(h->Flags.bits.flagACK) 
04F22:  MOVLW  0D
04F24:  MOVLB  9
04F26:  ADDWF  x2F,W
04F28:  MOVWF  FE9
04F2A:  MOVLW  00
04F2C:  ADDWFC x30,W
04F2E:  MOVWF  FEA
04F30:  BTFSS  FEF.4
04F32:  BRA    4F44
....................                { 
....................                   CloseSocket(ps); 
04F34:  MOVFF  944,94B
04F38:  MOVFF  943,94A
04F3C:  MOVLB  0
04F3E:  CALL   40D4
04F42:  MOVLB  9
....................                } 
....................             } 
04F44:  BRA    50DC
....................             else if(ps->smState == TCP_FIN_WAIT_1) 
04F46:  MOVFF  943,FE9
04F4A:  MOVFF  944,FEA
04F4E:  MOVF   FEF,W
04F50:  SUBLW  04
04F52:  BNZ   5018
....................             { 
....................                MACDiscardRx(); 
04F54:  MOVLB  0
04F56:  CALL   2C06
....................  
....................                if(h->Flags.bits.flagFIN) 
04F5A:  MOVLW  0D
04F5C:  MOVLB  9
04F5E:  ADDWF  x2F,W
04F60:  MOVWF  FE9
04F62:  MOVLW  00
04F64:  ADDWFC x30,W
04F66:  MOVWF  FEA
04F68:  BTFSS  FEF.0
04F6A:  BRA    4FF6
....................                { 
....................                   flags = ACK; 
04F6C:  MOVLW  10
04F6E:  MOVWF  x45
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
04F70:  MOVLW  1A
04F72:  ADDWF  x43,W
04F74:  MOVWF  FE9
04F76:  MOVLW  00
04F78:  ADDWFC x44,W
04F7A:  MOVWF  FEA
04F7C:  MOVLW  01
04F7E:  ADDWF  FEF,W
04F80:  MOVWF  00
04F82:  MOVLW  00
04F84:  ADDWFC FEC,W
04F86:  MOVWF  01
04F88:  MOVLW  00
04F8A:  ADDWFC FEC,W
04F8C:  MOVWF  02
04F8E:  MOVLW  00
04F90:  ADDWFC FEC,W
04F92:  MOVF   FED,F
04F94:  MOVF   FED,F
04F96:  MOVF   FED,F
04F98:  MOVFF  00,FEF
04F9C:  MOVFF  01,FEC
04FA0:  MOVFF  02,FEC
04FA4:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
04FA6:  MOVLW  1A
04FA8:  ADDWF  x43,W
04FAA:  MOVWF  FE9
04FAC:  MOVLW  00
04FAE:  ADDWFC x44,W
04FB0:  MOVWF  FEA
04FB2:  MOVFF  FEF,933
04FB6:  MOVFF  FEC,934
04FBA:  MOVFF  FEC,935
04FBE:  MOVFF  FEC,936
....................                   if(h->Flags.bits.flagACK) 
04FC2:  MOVLW  0D
04FC4:  ADDWF  x2F,W
04FC6:  MOVWF  FE9
04FC8:  MOVLW  00
04FCA:  ADDWFC x30,W
04FCC:  MOVWF  FEA
04FCE:  BTFSS  FEF.4
04FD0:  BRA    4FE4
....................                   { 
....................                      CloseSocket(ps); 
04FD2:  MOVFF  944,94B
04FD6:  MOVFF  943,94A
04FDA:  MOVLB  0
04FDC:  CALL   40D4
....................                   } 
04FE0:  BRA    4FF2
04FE2:  MOVLB  9
....................                   else 
....................                   { 
....................                      ps->smState = TCP_CLOSING; 
04FE4:  MOVFF  943,FE9
04FE8:  MOVFF  944,FEA
04FEC:  MOVLW  06
04FEE:  MOVWF  FEF
04FF0:  MOVLB  0
....................                   } 
....................                } 
04FF2:  BRA    5014
04FF4:  MOVLB  9
....................                else if(h->Flags.bits.flagACK) 
04FF6:  MOVLW  0D
04FF8:  ADDWF  x2F,W
04FFA:  MOVWF  FE9
04FFC:  MOVLW  00
04FFE:  ADDWFC x30,W
05000:  MOVWF  FEA
05002:  BTFSS  FEF.4
05004:  BRA    5012
....................                { 
....................                   ps->smState = TCP_FIN_WAIT_2; 
05006:  MOVFF  943,FE9
0500A:  MOVFF  944,FEA
0500E:  MOVLW  05
05010:  MOVWF  FEF
05012:  MOVLB  0
....................                } 
....................             } 
05014:  BRA    50DA
05016:  MOVLB  9
....................             else if(ps->smState == TCP_FIN_WAIT_2) 
05018:  MOVFF  943,FE9
0501C:  MOVFF  944,FEA
05020:  MOVF   FEF,W
05022:  SUBLW  05
05024:  BNZ   50A6
....................             { 
....................                MACDiscardRx(); 
05026:  MOVLB  0
05028:  CALL   2C06
....................  
....................                if(h->Flags.bits.flagFIN) 
0502C:  MOVLW  0D
0502E:  MOVLB  9
05030:  ADDWF  x2F,W
05032:  MOVWF  FE9
05034:  MOVLW  00
05036:  ADDWFC x30,W
05038:  MOVWF  FEA
0503A:  BTFSS  FEF.0
0503C:  BRA    50A4
....................                { 
....................                   flags = ACK; 
0503E:  MOVLW  10
05040:  MOVWF  x45
....................                   //ack = ++ps->SND_ACK;   ////TODO HUGE BUG HERE? 
....................               ps->SND_ACK += 1; 
05042:  MOVLW  1A
05044:  ADDWF  x43,W
05046:  MOVWF  FE9
05048:  MOVLW  00
0504A:  ADDWFC x44,W
0504C:  MOVWF  FEA
0504E:  MOVLW  01
05050:  ADDWF  FEF,W
05052:  MOVWF  00
05054:  MOVLW  00
05056:  ADDWFC FEC,W
05058:  MOVWF  01
0505A:  MOVLW  00
0505C:  ADDWFC FEC,W
0505E:  MOVWF  02
05060:  MOVLW  00
05062:  ADDWFC FEC,W
05064:  MOVF   FED,F
05066:  MOVF   FED,F
05068:  MOVF   FED,F
0506A:  MOVFF  00,FEF
0506E:  MOVFF  01,FEC
05072:  MOVFF  02,FEC
05076:  MOVWF  FEC
....................               ack = ps->SND_ACK; 
05078:  MOVLW  1A
0507A:  ADDWF  x43,W
0507C:  MOVWF  FE9
0507E:  MOVLW  00
05080:  ADDWFC x44,W
05082:  MOVWF  FEA
05084:  MOVFF  FEF,933
05088:  MOVFF  FEC,934
0508C:  MOVFF  FEC,935
05090:  MOVFF  FEC,936
....................                   CloseSocket(ps); 
05094:  MOVFF  944,94B
05098:  MOVFF  943,94A
0509C:  MOVLB  0
0509E:  CALL   40D4
050A2:  MOVLB  9
....................                } 
....................             } 
050A4:  BRA    50DC
....................             else if ( ps->smState == TCP_CLOSING ) 
050A6:  MOVFF  943,FE9
050AA:  MOVFF  944,FEA
050AE:  MOVF   FEF,W
050B0:  SUBLW  06
050B2:  BNZ   50DC
....................             { 
....................                MACDiscardRx(); 
050B4:  MOVLB  0
050B6:  CALL   2C06
....................  
....................                if ( h->Flags.bits.flagACK ) 
050BA:  MOVLW  0D
050BC:  MOVLB  9
050BE:  ADDWF  x2F,W
050C0:  MOVWF  FE9
050C2:  MOVLW  00
050C4:  ADDWFC x30,W
050C6:  MOVWF  FEA
050C8:  BTFSS  FEF.4
050CA:  BRA    50DC
....................                { 
....................                   CloseSocket(ps); 
050CC:  MOVFF  944,94B
050D0:  MOVFF  943,94A
050D4:  MOVLB  0
050D6:  CALL   40D4
050DA:  MOVLB  9
....................                } 
....................             } 
....................          } 
....................       } 
050DC:  BRA    50FA
....................       // This packet's sequence number does not match what we were 
....................       // expecting (the last value we ACKed).  Throw this packet 
....................       // away.  This may happen if packets are delivered out of order. 
....................       // Not enough memory is available on our PIC or Ethernet 
....................       // controller to implement a robust stream reconstruction 
....................       // buffer.  As a result, the remote node will just have to 
....................       // retransmit its packets starting with the proper sequence number. 
....................       else 
....................       { 
....................          MACDiscardRx(); 
050DE:  MOVLB  0
050E0:  CALL   2C06
....................  
....................          // Send a new ACK out in case if the previous one was lost 
....................          // (ACKs aren't ACKed).  This is required to prevent an 
....................          // unlikely but possible situation which would cause the 
....................          // connection to time out if the ACK was lost and the 
....................          // remote node keeps sending us older data than we are 
....................          // expecting. 
....................          flags = ACK; 
050E4:  MOVLW  10
050E6:  MOVLB  9
050E8:  MOVWF  x45
....................          ack = prevAck; 
050EA:  MOVFF  93E,936
050EE:  MOVFF  93D,935
050F2:  MOVFF  93C,934
050F6:  MOVFF  93B,933
....................       } 
....................    } 
....................  
.................... SendTCPControlPacket: 
....................    if(flags) 
050FA:  MOVF   x45,F
050FC:  BZ    5170
....................    { 
....................       SendTCP(remote, 
....................          h->DestPort, 
....................          h->SourcePort, 
....................          seq, 
....................          ack, 
....................          flags); 
050FE:  MOVLW  02
05100:  ADDWF  x2F,W
05102:  MOVWF  FE9
05104:  MOVLW  00
05106:  ADDWFC x30,W
05108:  MOVWF  FEA
0510A:  MOVFF  FEC,94B
0510E:  MOVF   FED,F
05110:  MOVFF  FEF,94A
05114:  MOVFF  92F,FE9
05118:  MOVFF  930,FEA
0511C:  MOVFF  FEC,94D
05120:  MOVF   FED,F
05122:  MOVFF  FEF,94C
05126:  MOVFF  92E,94F
0512A:  MOVFF  92D,94E
0512E:  MOVFF  94B,951
05132:  MOVFF  94A,950
05136:  MOVFF  94D,953
0513A:  MOVFF  94C,952
0513E:  MOVFF  93A,957
05142:  MOVFF  939,956
05146:  MOVFF  938,955
0514A:  MOVFF  937,954
0514E:  MOVFF  936,95B
05152:  MOVFF  935,95A
05156:  MOVFF  934,959
0515A:  MOVFF  933,958
0515E:  MOVFF  945,95C
05162:  SETF   x5D
05164:  CLRF   x5F
05166:  CLRF   x5E
05168:  MOVLB  0
0516A:  CALL   4514
0516E:  MOVLB  9
....................    } 
05170:  MOVLB  0
05172:  GOTO   5314 (RETURN)
....................  
....................    /*if (debugLastState != ps->smState) 
....................    { 
....................       debug_tcp("\r\nHANDLE TCP SEG %U - ", s); 
....................       DebugTCPDisplayState(debugLastState); 
....................       debug_tcp(" -> "); 
....................       DebugTCPDisplayState(ps->smState); 
....................    }*/ 
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_ICMP 
....................    #include "tcpip/icmp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.C 
....................  * Dependencies:    ICMP.h 
....................  *                  string.h 
....................  *                  StackTsk.h 
....................  *                  Helpers.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/30/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/29/04 SwapICMPPacket() no longer static 
....................  * Howard Schlunder      9/9/04   Added ENC28J60 DMA checksum support 
....................  * Howard Schlunder      1/5/06   Increased DMA checksum efficiency 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/icmp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ICMP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ICMP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  IP.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    07/13/06 Increased MAX_ICMP_DATA to 64 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ICMP_H 
.................... #define ICMP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... // Windows ping uses 32 bytes, while MAC uses 56 bytes. 
.................... //#define MAX_ICMP_DATA       (32) 
.................... #define MAX_ICMP_DATA       (64) 
....................  
.................... #define MAX_ICMP_DATA_LEN   (MAX_ICMP_DATA) 
....................  
....................  
.................... typedef enum _ICMP_CODE 
.................... { 
....................     ICMP_ECHO_REPLY = 0, 
....................     ICMP_ECHO_REQUEST = 8 
.................... } ICMP_CODE, ICMP_REQUESTS; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPIsTxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is ready 
....................  *                  FALSE if transmit buffer is not ready 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define ICMPIsTxReady()     MACIsTxReady(TRUE) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/ip.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  IP Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        IP.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack  
....................  ********************************************************************/ 
....................  
.................... #ifndef IP_H 
.................... #define IP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
....................  
.................... #define IP_PROT_ICMP    (1) 
.................... #define IP_PROT_TCP     (6) 
.................... #define IP_PROT_UDP     (17) 
....................  
....................  
.................... /* 
....................  * IP packet header definition 
....................  */ 
.................... typedef struct _IP_HEADER 
.................... { 
....................     BYTE    VersionIHL; 
....................     BYTE    TypeOfService; 
....................     WORD    TotalLength; 
....................     WORD    Identification; 
....................     WORD    FragmentInfo; 
....................     BYTE    TimeToLive; 
....................     BYTE    Protocol; 
....................     WORD    HeaderChecksum; 
....................     IP_ADDR SourceAddress; 
....................     IP_ADDR DestAddress; 
....................  
.................... } IP_HEADER; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPIsTxReady(BOOL HighPriority) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if transmit buffer is empty 
....................  *                  FALSE if transmit buffer is not empty 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPIsTxReady(HighPriority)       MACIsTxReady(HighPriority) 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPSetTxBuffer(a, b) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           a       - Buffer identifier 
....................  *                  b       - Offset 
....................  * 
....................  * Output:          Next Read/Write access to transmit buffer 'a' 
....................  *                  set to offset 'b' 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPSetTxBuffer(a, b) MACSetTxBuffer(a, b+sizeof(IP_HEADER)) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        WORD IPPutHeader(   IP_ADDR *Dest, 
....................  *                                      BYTE    Protocol, 
....................  *                                      WORD    Identifier, 
....................  *                                      WORD    DataLen) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           Src         - Destination node address 
....................  *                  Protocol    - Current packet protocol 
....................  *                  Identifier  - Current packet identifier 
....................  *                  DataLen     - Current packet data length 
....................  * 
....................  * Output:          Handle to current packet - For use by 
....................  *                  IPSendByte() function. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be transmitted at any 
....................  *                  time. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... WORD    IPPutHeader(NODE_INFO *remote, 
....................                     BYTE protocol, 
....................                     WORD len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPPutArray(a, b) 
....................  * 
....................  * PreCondition:    IPIsTxReady() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied to IP data area. 
....................  * 
....................  ********************************************************************/ 
.................... #define IPPutArray(a, b)    MACPutArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL IPGetHeader( IP_ADDR    *localIP, 
....................  *                                    NODE_INFO  *remote, 
....................  *                                    BYTE        *Protocol, 
....................  *                                    WORD        *len) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           localIP     - Local node IP Address as received 
....................  *                                in current IP header. 
....................  *                                If this information is not required 
....................  *                                caller may pass NULL value. 
....................  *                  remote      - Remote node info 
....................  *                  Protocol    - Current packet protocol 
....................  *                  len         - Current packet data length 
....................  * 
....................  * Output:          TRUE, if valid packet was received 
....................  *                  FALSE otherwise 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Only one IP message can be received. 
....................  *                  Caller may not transmit and receive a message 
....................  *                  at the same time. 
....................  * 
....................  ********************************************************************/ 
.................... BOOL IPGetHeader(IP_ADDR *localIP, 
....................                  NODE_INFO *remote, 
....................                  BYTE *protocol, 
....................                  WORD *len); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPDiscard() 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Current packet is discarded and buffer is 
....................  *                  freed-up 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... #define IPDiscard()         MACDiscard() 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           IPGetArray(a, b) 
....................  * 
....................  * PreCondition:    MACGetHeader() == TRUE 
....................  * 
....................  * Input:           a       - Data buffer 
....................  *                  b       - Buffer length 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            Data is copied from IP data to given buffer 
....................  * 
....................  ********************************************************************/ 
.................... #define IPGetArray(a, b)    MACGetArray(a, b) 
....................  
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        IPSetRxBuffer(WORD Offset) 
....................  * 
....................  * PreCondition:    IPHeaderLen must have been intialized by 
....................  *					IPGetHeader() or IPPutHeader() 
....................  * 
....................  * Input:           Offset from beginning of IP data field 
....................  * 
....................  * Output:          Next Read/Write access to receive buffer is 
....................  *                  set to Offset 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            None 
....................  * 
....................  ********************************************************************/ 
.................... void IPSetRxBuffer(WORD Offset); 
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... //#define debug_icmp 
.................... //#define debug_icmp   debug_printf 
.................... #define debug_icmp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... //#define MAX_ICMP_DATA       32 //moved to icmp.h 
....................  
.................... /* 
....................  * ICMP packet definition 
....................  */ 
.................... typedef struct _ICMP_PACKET 
.................... { 
....................     BYTE    Type; 
....................     BYTE    Code; 
....................     WORD    Checksum; 
....................     WORD    Identifier; 
....................     WORD    SequenceNumber; 
....................     BYTE    Data[MAX_ICMP_DATA]; 
.................... } ICMP_PACKET; 
.................... #define ICMP_HEADER_SIZE    (sizeof(ICMP_PACKET) - MAX_ICMP_DATA) 
....................  
.................... static void SwapICMPPacket(ICMP_PACKET* p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ICMPGet(ICMP_CODE *code, 
....................  *                              BYTE *data, 
....................  *                              BYTE *len, 
....................  *                              WORD *id, 
....................  *                              WORD *seq) 
....................  * 
....................  * PreCondition:    MAC buffer contains ICMP type packet. 
....................  * 
....................  * Input:           code    - Buffer to hold ICMP code value 
....................  *                  data    - Buffer to hold ICMP data 
....................  *                  len     - Buffer to hold ICMP data length 
....................  *                  id      - Buffer to hold ICMP id 
....................  *                  seq     - Buffer to hold ICMP seq 
....................  * 
....................  * Output:          TRUE if valid ICMP packet was received 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ICMPGet(ICMP_CODE *code, 
....................              BYTE *data, 
....................              BYTE *len, 
....................              WORD *id, 
....................              WORD *seq) 
.................... { 
....................     ICMP_PACKET packet; 
....................     WORD CalcChecksum; 
....................     WORD ReceivedChecksum; 
.................... #if !defined(MCHP_MAC) 
....................     WORD checksums[2]; 
.................... #endif 
....................  
....................     debug_icmp(debug_putc, "\r\nICMP GET "); 
....................  
....................     // Obtain the ICMP Header 
....................     MACGetArray((BYTE*)&packet, ICMP_HEADER_SIZE); 
*
05406:  MOVLW  09
05408:  MOVLB  9
0540A:  MOVWF  x58
0540C:  MOVLW  0B
0540E:  MOVWF  x57
05410:  MOVFF  958,995
05414:  MOVWF  x94
05416:  CLRF   x97
05418:  MOVLW  08
0541A:  MOVWF  x96
0541C:  MOVLB  0
0541E:  CALL   2C7C
....................  
....................  
.................... #if defined(MCHP_MAC) 
....................    // Calculate the checksum using the Microchip MAC's DMA module 
....................    // The checksum data includes the precomputed checksum in the 
....................    // header, so a valid packet will always have a checksum of 
....................    // 0x0000 if the packet is not disturbed. 
....................    ReceivedChecksum = 0x0000; 
05422:  MOVLB  9
05424:  CLRF   x56
05426:  CLRF   x55
....................    CalcChecksum = MACCalcRxChecksum(0+sizeof(IP_HEADER), *len); 
05428:  MOVFF  906,03
0542C:  MOVFF  905,FE9
05430:  MOVFF  906,FEA
05434:  MOVFF  FEF,957
05438:  CLRF   x59
0543A:  MOVLW  14
0543C:  MOVWF  x58
0543E:  CLRF   x5B
05440:  MOVFF  957,95A
05444:  MOVLB  0
05446:  CALL   367E
0544A:  MOVFF  02,954
0544E:  MOVFF  01,953
.................... #endif 
....................  
....................    // Obtain the ICMP data payload 
....................     *len -= ICMP_HEADER_SIZE; 
05452:  MOVLB  9
05454:  MOVFF  905,FE9
05458:  MOVFF  906,FEA
0545C:  MOVLW  08
0545E:  SUBWF  FEF,W
05460:  MOVWF  FEF
....................     MACGetArray(data, *len); 
05462:  MOVFF  906,03
05466:  MOVFF  905,FE9
0546A:  MOVFF  906,FEA
0546E:  MOVFF  FEF,957
05472:  MOVFF  904,995
05476:  MOVFF  903,994
0547A:  CLRF   x97
0547C:  MOVFF  957,996
05480:  MOVLB  0
05482:  CALL   2C7C
....................  
....................  
.................... #if !defined(MCHP_MAC) 
....................    // Calculte the checksum in local memory without hardware help 
....................     ReceivedChecksum = packet.Checksum; 
....................     packet.Checksum = 0; 
....................  
....................     checksums[0] = ~CalcIPChecksum((BYTE*)&packet, ICMP_HEADER_SIZE); 
....................     checksums[1] = ~CalcIPChecksum(data, *len); 
....................  
....................     CalcChecksum = CalcIPChecksum((BYTE*)checksums, 2 * sizeof(WORD)); 
.................... #endif 
....................  
....................     SwapICMPPacket(&packet); 
05486:  MOVLW  09
05488:  MOVLB  9
0548A:  MOVWF  x58
0548C:  MOVLW  0B
0548E:  MOVWF  x57
05490:  MOVLB  0
05492:  RCALL  5326
....................  
....................     *code = packet.Type; 
05494:  MOVLB  9
05496:  MOVFF  901,FE9
0549A:  MOVFF  902,FEA
0549E:  MOVFF  90B,FEF
....................     *id = packet.Identifier; 
054A2:  MOVFF  907,FE9
054A6:  MOVFF  908,FEA
054AA:  MOVFF  910,FEC
054AE:  MOVF   FED,F
054B0:  MOVFF  90F,FEF
....................     *seq = packet.SequenceNumber; 
054B4:  MOVFF  909,FE9
054B8:  MOVFF  90A,FEA
054BC:  MOVFF  912,FEC
054C0:  MOVF   FED,F
054C2:  MOVFF  911,FEF
....................  
....................     debug_icmp(debug_putc, "%U", CalcChecksum == ReceivedChecksum); 
....................  
....................     return ( CalcChecksum == ReceivedChecksum ); 
054C6:  MOVF   x55,W
054C8:  SUBWF  x53,W
054CA:  BNZ   54D2
054CC:  MOVF   x56,W
054CE:  SUBWF  x54,W
054D0:  BZ    54D6
054D2:  MOVLW  00
054D4:  BRA    54D8
054D6:  MOVLW  01
054D8:  MOVWF  01
054DA:  MOVLB  0
054DC:  GOTO   5BF8 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ICMPPut(NODE_INFO *remote, 
....................  *                               ICMP_CODE code, 
....................  *                               BYTE *data, 
....................  *                               BYTE len, 
....................  *                               WORD id, 
....................  *                               WORD seq) 
....................  * 
....................  * PreCondition:    ICMPIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote      - Remote node info 
....................  *                  code        - ICMP_ECHO_REPLY or ICMP_ECHO_REQUEST 
....................  *                  data        - Data bytes 
....................  *                  len         - Number of bytes to send 
....................  *                  id          - ICMP identifier 
....................  *                  seq         - ICMP sequence number 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            A ICMP packet is created and put on MAC. 
....................  * 
....................  ********************************************************************/ 
.................... void ICMPPut(NODE_INFO *remote, 
....................              ICMP_CODE code, 
....................              BYTE *data, 
....................              BYTE len, 
....................              WORD id, 
....................              WORD seq) 
.................... { 
....................     ICMP_PACKET   packet; 
....................     WORD ICMPLen; 
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
054E0:  MOVLW  01
054E2:  MOVLB  9
054E4:  MOVWF  x86
054E6:  MOVLB  0
054E8:  CALL   300C
054EC:  MOVFF  01,953
....................  
....................    // Abort if there is no where in the Ethernet controller to 
....................    // store this packet. 
....................    if(MyTxBuffer == INVALID_BUFFER) 
054F0:  MOVLB  9
054F2:  INCFSZ x53,W
054F4:  BRA    54F8
....................       return; 
054F6:  BRA    55EA
....................  
....................    IPSetTxBuffer(MyTxBuffer, 0); 
054F8:  MOVFF  953,99F
054FC:  CLRF   xA1
054FE:  MOVLW  14
05500:  MOVWF  xA0
05502:  MOVLB  0
05504:  CALL   3034
....................  
....................  
....................    ICMPLen = ICMP_HEADER_SIZE + (WORD)len; 
05508:  CLRF   03
0550A:  MOVLB  9
0550C:  MOVF   x04,W
0550E:  ADDLW  08
05510:  MOVWF  x51
05512:  MOVLW  00
05514:  ADDWFC 03,W
05516:  MOVWF  x52
....................  
....................     packet.Code             = 0; 
05518:  CLRF   x0A
....................     packet.Type             = code; 
0551A:  MOVFF  901,909
....................     packet.Checksum         = 0; 
0551E:  CLRF   x0C
05520:  CLRF   x0B
....................     packet.Identifier       = id; 
05522:  MOVFF  906,90E
05526:  MOVFF  905,90D
....................     packet.SequenceNumber   = seq; 
0552A:  MOVFF  908,910
0552E:  MOVFF  907,90F
....................  
....................     memcpy((void*)packet.Data, (void*)data, len); 
05532:  MOVLW  09
05534:  MOVWF  FEA
05536:  MOVLW  11
05538:  MOVWF  FE9
0553A:  MOVFF  903,FE2
0553E:  MOVFF  902,FE1
05542:  MOVF   x04,W
05544:  MOVWF  01
05546:  BZ    5550
05548:  MOVFF  FE6,FEE
0554C:  DECFSZ 01,F
0554E:  BRA    5548
....................  
....................     SwapICMPPacket(&packet); 
05550:  MOVLW  09
05552:  MOVWF  x58
05554:  MOVWF  x57
05556:  MOVLB  0
05558:  RCALL  5326
....................  
.................... #if !defined(MCHP_MAC) 
....................     packet.Checksum         = CalcIPChecksum((BYTE*)&packet, 
....................                                     ICMPLen); 
.................... #endif 
....................  
....................     IPPutHeader(remote, 
....................                 IP_PROT_ICMP, 
....................                 (WORD)(ICMP_HEADER_SIZE + len)); 
0555A:  MOVLW  08
0555C:  MOVLB  9
0555E:  ADDWF  x04,W
05560:  CLRF   x55
05562:  MOVWF  x54
05564:  MOVFF  900,987
05568:  MOVFF  8FF,986
0556C:  MOVLW  01
0556E:  MOVWF  x88
05570:  MOVFF  955,98A
05574:  MOVFF  954,989
05578:  MOVLB  0
0557A:  CALL   43EE
....................  
....................     IPPutArray((BYTE*)&packet, ICMPLen); 
0557E:  MOVLW  09
05580:  MOVLB  9
05582:  MOVWF  x55
05584:  MOVWF  x54
05586:  MOVWF  xAB
05588:  MOVWF  xAA
0558A:  MOVFF  952,9AD
0558E:  MOVFF  951,9AC
05592:  MOVLB  0
05594:  CALL   3100
....................  
.................... #if defined(MCHP_MAC) 
....................     // Calculate and write the ICMP checksum using the Microchip MAC's DMA 
....................    packet.Checksum = MACCalcTxChecksum(sizeof(IP_HEADER), ICMPLen); 
05598:  MOVLB  9
0559A:  CLRF   xA0
0559C:  MOVLW  14
0559E:  MOVWF  x9F
055A0:  MOVFF  952,9A2
055A4:  MOVFF  951,9A1
055A8:  MOVLB  0
055AA:  CALL   4316
055AE:  MOVFF  02,90C
055B2:  MOVFF  01,90B
....................    IPSetTxBuffer(MyTxBuffer, 2); 
055B6:  MOVFF  953,99F
055BA:  MOVLB  9
055BC:  CLRF   xA1
055BE:  MOVLW  16
055C0:  MOVWF  xA0
055C2:  MOVLB  0
055C4:  CALL   3034
....................    MACPutArray((BYTE*)&packet.Checksum, 2); 
055C8:  MOVLW  09
055CA:  MOVLB  9
055CC:  MOVWF  x55
055CE:  MOVLW  0B
055D0:  MOVWF  x54
055D2:  MOVFF  955,9AB
055D6:  MOVWF  xAA
055D8:  CLRF   xAD
055DA:  MOVLW  02
055DC:  MOVWF  xAC
055DE:  MOVLB  0
055E0:  CALL   3100
.................... #endif 
....................  
....................  
....................     MACFlush(); 
055E4:  CALL   3224
055E8:  MOVLB  9
055EA:  MOVLB  0
055EC:  GOTO   5C54 (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void SwapICMPPacket(ICMP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p - ICMP packet header 
....................  * 
....................  * Output:          ICMP packet is swapped 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void SwapICMPPacket(ICMP_PACKET* p) 
.................... { 
....................     p->Identifier           = swaps(p->Identifier); 
*
05326:  MOVLW  04
05328:  MOVLB  9
0532A:  ADDWF  x57,W
0532C:  MOVWF  01
0532E:  MOVLW  00
05330:  ADDWFC x58,W
05332:  MOVWF  03
05334:  MOVFF  01,959
05338:  MOVWF  x5A
0533A:  MOVLW  04
0533C:  ADDWF  x57,W
0533E:  MOVWF  FE9
05340:  MOVLW  00
05342:  ADDWFC x58,W
05344:  MOVWF  FEA
05346:  MOVFF  FEC,95C
0534A:  MOVF   FED,F
0534C:  MOVFF  FEF,95B
05350:  MOVFF  95C,9A6
05354:  MOVFF  95B,9A5
05358:  MOVLB  0
0535A:  CALL   2CE0
0535E:  MOVFF  95A,FEA
05362:  MOVFF  959,FE9
05366:  MOVFF  02,FEC
0536A:  MOVF   FED,F
0536C:  MOVFF  01,FEF
....................     p->SequenceNumber       = swaps(p->SequenceNumber); 
05370:  MOVLW  06
05372:  MOVLB  9
05374:  ADDWF  x57,W
05376:  MOVWF  01
05378:  MOVLW  00
0537A:  ADDWFC x58,W
0537C:  MOVWF  03
0537E:  MOVFF  01,959
05382:  MOVWF  x5A
05384:  MOVLW  06
05386:  ADDWF  x57,W
05388:  MOVWF  FE9
0538A:  MOVLW  00
0538C:  ADDWFC x58,W
0538E:  MOVWF  FEA
05390:  MOVFF  FEC,95C
05394:  MOVF   FED,F
05396:  MOVFF  FEF,95B
0539A:  MOVFF  95C,9A6
0539E:  MOVFF  95B,9A5
053A2:  MOVLB  0
053A4:  CALL   2CE0
053A8:  MOVFF  95A,FEA
053AC:  MOVFF  959,FE9
053B0:  MOVFF  02,FEC
053B4:  MOVF   FED,F
053B6:  MOVFF  01,FEF
....................     p->Checksum             = swaps(p->Checksum); 
053BA:  MOVLW  02
053BC:  MOVLB  9
053BE:  ADDWF  x57,W
053C0:  MOVWF  01
053C2:  MOVLW  00
053C4:  ADDWFC x58,W
053C6:  MOVWF  03
053C8:  MOVFF  01,959
053CC:  MOVWF  x5A
053CE:  MOVLW  02
053D0:  ADDWF  x57,W
053D2:  MOVWF  FE9
053D4:  MOVLW  00
053D6:  ADDWFC x58,W
053D8:  MOVWF  FEA
053DA:  MOVFF  FEC,95C
053DE:  MOVF   FED,F
053E0:  MOVFF  FEF,95B
053E4:  MOVFF  95C,9A6
053E8:  MOVFF  95B,9A5
053EC:  MOVLB  0
053EE:  CALL   2CE0
053F2:  MOVFF  95A,FEA
053F6:  MOVFF  959,FE9
053FA:  MOVFF  02,FEC
053FE:  MOVF   FED,F
05400:  MOVFF  01,FEF
05404:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................    #include "tcpip/udp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    #include "tcpip/dhcp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    #include "tcpip/telnet2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................    #include "tcpip/arptsk.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.c 
....................  * Dependencies:    compiler.h 
....................  *                  string.h 
....................  *                  ARP.h 
....................  *                  ARPTsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    06/11/04 A macdiscardrx() added to arpprocess() to handle times when an eth packet with arp has padding bytes at the end 
....................  * Darren Rook (CCS)    06/28/04 ArpInit clears cache like in 2.20 
....................  * Darren Rook (CCS)    06/29/04 smArp, Cache no longer static 
....................  * Darren Rook (CCS)    07/12/06 MACDiscardRx spelled wrong (case) 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  *                               I am assuming STACK_CLIENT_MODE is TRUE for ARP. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/arptsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Server Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARPTsk.h 
....................  * Dependencies:    StackTsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/20/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes]. 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef ARP_TSK_H 
.................... #define ARP_TSK_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  * 
....................  * Note: 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr); 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
.................... #define debug_arptask 
.................... //#define debug_arptask   debug_printf 
....................  
.................... /* 
....................  * ARP Task FSM States 
....................  */ 
.................... typedef enum _ARP_STATE 
.................... { 
....................     SM_ARP_IDLE, 
....................     SM_ARP_REPLY 
.................... } ARP_STATE; 
....................  
....................  
.................... /* 
....................  * This ARP task caches one ARP response. 
....................  */ 
.................... static ARP_STATE smARP; 
....................  
.................... static NODE_INFO Cache; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP Cache is initialized. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... void ARPInit(void) 
.................... { 
....................     smARP = SM_ARP_IDLE; 
*
01A20:  MOVLB  3
01A22:  BCF    x93.1
....................  
....................     Cache.MACAddr.v[0] = 0xff; 
01A24:  MOVLB  8
01A26:  SETF   x88
....................     Cache.MACAddr.v[1] = 0xff; 
01A28:  SETF   x89
....................     Cache.MACAddr.v[2] = 0xff; 
01A2A:  SETF   x8A
....................     Cache.MACAddr.v[3] = 0xff; 
01A2C:  SETF   x8B
....................     Cache.MACAddr.v[4] = 0xff; 
01A2E:  SETF   x8C
....................     Cache.MACAddr.v[5] = 0xff; 
01A30:  SETF   x8D
....................  
....................     Cache.IPAddr.Val = 0x0; 
01A32:  CLRF   x91
01A34:  CLRF   x90
01A36:  CLRF   x8F
01A38:  CLRF   x8E
01A3A:  MOVLB  0
01A3C:  GOTO   1CFC (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPProcess(void) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          ARP FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPProcess(void) 
.................... { 
....................     NODE_INFO remoteNode; 
....................     BYTE opCode; 
....................  
....................     switch(smARP) 
*
035E8:  MOVLW  00
035EA:  MOVLB  3
035EC:  BTFSC  x93.1
035EE:  MOVLW  01
035F0:  XORLW  00
035F2:  MOVLB  0
035F4:  BZ    35F8
035F6:  BRA    3652
....................     { 
....................     case SM_ARP_IDLE: 
....................         if ( !ARPGet(&remoteNode, &opCode) ) 
035F8:  MOVLW  08
035FA:  MOVLB  9
035FC:  MOVWF  x0B
035FE:  SETF   x0A
03600:  MOVLW  09
03602:  MOVWF  x0D
03604:  MOVWF  x0C
03606:  MOVLB  0
03608:  BRA    2F14
0360A:  MOVF   01,F
0360C:  BNZ   3610
....................             break; 
0360E:  BRA    3676
....................  
....................          //dsr add 071204 
....................          //dsr fix 071206 
....................          MACDiscardRx(); 
03610:  CALL   2C06
....................  
....................         if ( opCode == ARP_REPLY ) 
03614:  MOVLB  9
03616:  MOVF   x09,F
03618:  BNZ   364C
....................         { 
.................... 			Cache.MACAddr = remoteNode.MACAddr; 
0361A:  MOVLW  08
0361C:  MOVWF  FEA
0361E:  MOVLW  88
03620:  MOVWF  FE9
03622:  MOVLW  08
03624:  MOVWF  FE2
03626:  SETF   FE1
03628:  MOVLW  06
0362A:  MOVWF  01
0362C:  MOVFF  FE6,FEE
03630:  DECFSZ 01,F
03632:  BRA    362C
....................             Cache.IPAddr.Val = remoteNode.IPAddr.Val; 
03634:  MOVFF  908,891
03638:  MOVFF  907,890
0363C:  MOVFF  906,88F
03640:  MOVFF  905,88E
....................             break; 
03644:  MOVLB  0
03646:  BRA    3676
....................         } 
03648:  BRA    3652
0364A:  MOVLB  9
....................         else 
....................             smARP = SM_ARP_REPLY; 
0364C:  MOVLB  3
0364E:  BSF    x93.1
03650:  MOVLB  0
....................  
....................     default: 
.................... 		if(ARPPut(&remoteNode, ARP_REPLY)) 
03652:  MOVLW  08
03654:  MOVLB  9
03656:  MOVWF  x0B
03658:  SETF   x0A
0365A:  CLRF   x0C
0365C:  MOVLB  0
0365E:  RCALL  3454
03660:  MOVF   01,F
03662:  BZ    366C
.................... 		{ 
.................... 			smARP = SM_ARP_IDLE; 
03664:  MOVLB  3
03666:  BCF    x93.1
.................... 		} 
03668:  BRA    3674
0366A:  MOVLB  0
....................         else 
....................             return FALSE; 
0366C:  MOVLW  00
0366E:  MOVWF  01
03670:  BRA    367A
03672:  MOVLB  3
....................         break; 
03674:  MOVLB  0
....................  
....................     } 
....................     return TRUE; 
03676:  MOVLW  01
03678:  MOVWF  01
0367A:  GOTO   5B0C (RETURN)
.................... } 
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPResolve(IP_ADDR* IPAddr) 
....................  * 
....................  * PreCondition:    MACIsTxReady(TRUE) returns TRUE 
....................  * 
....................  * Input:           IPAddr  - IP Address to be resolved. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        An ARP request is sent. 
....................  ********************************************************************/ 
.................... void ARPResolve(IP_ADDR *IPAddr) 
.................... { 
....................     NODE_INFO remoteNode; 
....................  
....................     remoteNode.IPAddr = *IPAddr; 
*
05C92:  MOVLB  8
05C94:  MOVFF  8FC,FE9
05C98:  MOVFF  8FD,FEA
05C9C:  MOVFF  FEF,00
05CA0:  MOVFF  FEC,01
05CA4:  MOVFF  FEC,02
05CA8:  MOVFF  FEC,03
05CAC:  MOVFF  00,904
05CB0:  MOVFF  01,905
05CB4:  MOVFF  02,906
05CB8:  MOVFF  03,907
....................  
....................     ARPPut(&remoteNode, ARP_REQUEST); 
05CBC:  MOVLW  08
05CBE:  MOVLB  9
05CC0:  MOVWF  x0B
05CC2:  MOVLW  FE
05CC4:  MOVWF  x0A
05CC6:  MOVLW  01
05CC8:  MOVWF  x0C
05CCA:  MOVLB  0
05CCC:  CALL   3454
05CD0:  GOTO   6A20 (RETURN)
.................... } 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPIsResolved(IP_ADDR* IPAddr, 
....................  *                                      MAC_ADDR *MACAddr) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           IPAddr      - IPAddress to be resolved. 
....................  *                  MACAddr     - Buffer to hold corresponding 
....................  *                                MAC Address. 
....................  * 
....................  * Output:          TRUE if given IP Address has been resolved. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  ********************************************************************/ 
.................... BOOL ARPIsResolved(IP_ADDR *IPAddr, MAC_ADDR *MACAddr) 
.................... { 
....................     if(Cache.IPAddr.Val == IPAddr->Val || Cache.IPAddr.Val == AppConfig.MyGateway.Val) 
05CD4:  MOVLB  8
05CD6:  MOVFF  8FC,FE9
05CDA:  MOVFF  8FD,FEA
05CDE:  MOVFF  FEF,00
05CE2:  MOVFF  FEC,01
05CE6:  MOVFF  FEC,02
05CEA:  MOVFF  FEC,03
05CEE:  MOVF   00,W
05CF0:  SUBWF  x8E,W
05CF2:  BNZ   5D06
05CF4:  MOVF   01,W
05CF6:  SUBWF  x8F,W
05CF8:  BNZ   5D06
05CFA:  MOVF   02,W
05CFC:  SUBWF  x90,W
05CFE:  BNZ   5D06
05D00:  MOVF   03,W
05D02:  SUBWF  x91,W
05D04:  BZ    5D2E
05D06:  MOVLB  3
05D08:  MOVF   x61,W
05D0A:  MOVLB  8
05D0C:  SUBWF  x8E,W
05D0E:  BNZ   5D54
05D10:  MOVLB  3
05D12:  MOVF   x62,W
05D14:  MOVLB  8
05D16:  SUBWF  x8F,W
05D18:  BNZ   5D54
05D1A:  MOVLB  3
05D1C:  MOVF   x63,W
05D1E:  MOVLB  8
05D20:  SUBWF  x90,W
05D22:  BNZ   5D54
05D24:  MOVLB  3
05D26:  MOVF   x64,W
05D28:  MOVLB  8
05D2A:  SUBWF  x91,W
05D2C:  BNZ   5D54
....................     { 
....................         *MACAddr = Cache.MACAddr; 
05D2E:  MOVFF  8FF,03
05D32:  MOVFF  8FE,FE9
05D36:  MOVFF  8FF,FEA
05D3A:  MOVLW  08
05D3C:  MOVWF  FE2
05D3E:  MOVLW  88
05D40:  MOVWF  FE1
05D42:  MOVLW  06
05D44:  MOVWF  01
05D46:  MOVFF  FE6,FEE
05D4A:  DECFSZ 01,F
05D4C:  BRA    5D46
....................         return TRUE; 
05D4E:  MOVLW  01
05D50:  MOVWF  01
05D52:  BRA    5D58
....................     } 
....................     return FALSE; 
05D54:  MOVLW  00
05D56:  MOVWF  01
05D58:  MOVLB  0
05D5A:  GOTO   6A4C (RETURN)
.................... } 
....................  
....................  
....................  
....................    #include "tcpip/arp.c" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.c 
....................  * Dependencies:    string.h 
....................  *                  stacktsk.h 
....................  *                  helpers.h 
....................  *                  arp.h 
....................  *                  mac.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack 
....................  ********************************************************************/ 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #include "tcpip/stacktsk.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Microchip TCP/IP Stack Definations for PIC18 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        StackTsk.h 
....................  * Dependencies:    compiler.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     8/10/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    04/08/05 Added http.c and http.h. 
....................  * Darren Rook (CCS)    09/01/06 Removed APP_CONFIG.Flags.bIsDHCPEnabled 
....................  * Nilesh Rajbharti     8/7/03  Rev 2.21 - TFTP Client addition 
....................  * Howard Schlunder      9/30/04   Added MCHP_MAC, MAC_POWER_ON_TEST, 
....................                          EEPROM_BUFFER_SIZE, USE_LCD 
....................  * Howard Schlunder      8/09/06   Removed MCHP_MAC, added STACK_USE_NBNS, 
....................  *                        STACK_USE_DNS, and STACK_USE_GENERIC_TCP_EXAMPLE 
....................  * Darren Rook (CCS)    10/25/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
.................... #ifndef STACK_TSK_H 
.................... #define STACK_TSK_H 
....................  
.................... #case 
....................  
.................... #ifndef OUTPUT_DRIVE_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_DRIVE_MACRO(x) bit_clear(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
.................... #ifndef OUTPUT_FLOAT_MACRO 
....................  #if defined(__PCH__) 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+18),x%8) 
....................  #else 
....................    #define OUTPUT_FLOAT_MACRO(x) bit_set(*(x/8+0x80),x%8) 
....................  #endif 
.................... #endif 
....................  
....................  
.................... #include "tcpip/pic18.h" 
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  If a Microchip controller is used and a self memory test 
....................  * should be done when the MACInit() function is called, 
....................  * uncomment this define.  The test requires ~512 bytes of 
....................  * program memory. 
....................  */ 
.................... //#define MAC_POWER_ON_TEST 
....................  
....................  
.................... /* 
....................  * This value is specific to the Microchip Ethernet controllers. 
....................  * If a different Ethernet controller is used, this define is not 
....................  * used.  Ideally, when MAC_FILTER_BROADCASTS is defined, all 
....................  * broadcast packets that are received would be discarded by the 
....................  * hardware, except for ARP requests for our IP address.  This could 
....................  * be accomplished by filtering all broadcasts, but allowing the ARPs 
....................  * using the patter match filter.  The code for this feature has been 
....................  * partially implemented, but it is not complete nor tested, so this 
....................  * option should remain unused in this stack version. 
....................  */ 
.................... //#define MAC_FILTER_BROADCASTS 
....................  
.................... /* 
....................  * Number of bytes to be reserved before MPFS storage is to start. 
....................  * 
....................  * These bytes host application configurations such as IP Address, 
....................  * MAC Address, and any other required variables. 
....................  * 
....................  * After making any change to this variable, MPFS.exe must be 
....................  * executed with correct block size. 
....................  * See MPFS.exe help message by executing MPFS /? 
....................  */ 
.................... #ifndef MPFS_START_POSITION 
.................... #define MPFS_START_POSITION   548 
.................... #endif 
....................  
.................... #define END_OF_MPFS_POINTER             (MPFS_START_POSITION) 
.................... #define MPFS_RESERVE_BLOCK              (END_OF_MPFS_POINTER+4) 
....................  
.................... /* 
....................  * Modules to include in this project 
....................  * For demo purpose only, each sample project defines one or more 
....................  * of following defines in compiler command-line options. (See 
....................  * each MPLAB Project Node Properties under "Project->Edit Project" menu. 
....................  * In real applcation, user may want to define them here. 
....................  */ 
.................... #ifndef STACK_USE_MAC 
....................    #define  STACK_USE_MAC  TRUE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPENC 
....................    #define STACK_USE_MCPENC FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MCPINC 
....................    #define STACK_USE_MCPINC FALSE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPENC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
.................... //using MCPENC chip requires MAC 
.................... #if STACK_USE_MCPINC 
....................    #undef STACK_USE_MAC 
....................    #define STACK_USE_MAC TRUE 
.................... #endif 
....................  
....................  
.................... #ifndef STACK_USE_PPP 
....................    #define STACK_USE_PPP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SLIP 
....................    #define STACK_USE_SLIP FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_SLIP + STACK_USE_PPP + STACK_USE_MAC)>1 
....................    #error ONLY SPECIFY ONE MAC DRIVER (SLIP, PPP or ETHERNET) 
.................... #endif 
....................  
.................... #if !(STACK_USE_SLIP || STACK_USE_PPP || STACK_USE_MAC) 
....................    #error PLEASE SPECIFY A MAC DRIVER 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DNS 
....................    #define STACK_USE_DNS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_UDP 
....................    #define STACK_USE_UDP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ICMP 
....................    #define STACK_USE_ICMP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ARP 
....................    #define   STACK_USE_ARP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TELNET 
....................    #define   STACK_USE_TELNET   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP 
....................    #define  STACK_USE_HTTP FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SMTP 
....................    #define STACK_USE_SMTP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_SNMP 
....................    #define STACK_USE_SNMP  FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_ANNOUNCE 
....................    #define STACK_USE_ANNOUNCE FALSE 
.................... #endif 
....................  
.................... #if (STACK_USE_ARP && STACK_USE_PPP) 
....................  #ERROR CANNOT USE ARP WITH PPP 
.................... #ENDIF 
....................  
.................... #ifndef   STACK_USE_TCP 
....................    #define   STACK_USE_TCP   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_IP_GLEANING 
....................    #define STACK_USE_IP_GLEANING   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_MPFS 
....................    #define STACK_USE_MPFS   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_HTTP2 
....................    #define STACK_USE_HTTP2   FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FAT 
....................    #define STACK_USE_FAT     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_FTP 
....................    #define STACK_USE_FTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TFTP 
....................    #define STACK_USE_TFTP     FALSE 
.................... #endif 
....................  
.................... #ifndef STACK_USE_TEMP 
....................    #define STACK_USE_TEMP     FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When SLIP is used, DHCP is not supported. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................    #undef STACK_USE_DHCP 
....................    #define STACK_USE_DHCP   FALSE 
.................... #endif 
....................  
.................... /* 
....................  * When DHCP is enabled, UDP must also be enabled. 
....................  */ 
.................... #if STACK_USE_DHCP 
....................     #if defined(STACK_USE_UDP) 
....................        #undef STACK_USE_UDP 
....................     #endif 
....................     #define STACK_USE_UDP TRUE 
.................... #endif 
....................  
.................... /* 
....................  * When IP Gleaning is enabled, ICMP must also be enabled. 
....................  */ 
.................... #if STACK_USE_IP_GLEANING 
....................     #if defined(STACK_USE_ICMP) 
....................        #undef STACK_USE_ICMP 
....................     #endif 
....................         #define STACK_USE_ICMP   TRUE 
.................... #endif 
....................  
.................... /* 
....................  * This value is for performance enhancing features specific to 
....................  * Microchip Ethernet controllers.  If a non-Microchip Ethernet 
....................  * controller is used, this define must be commented out.  When 
....................  * defined, checksum computations will be offloaded to the hardware. 
....................  */ 
.................... #if STACK_USE_MCPENC || STACK_USE_MCPINC 
....................  #define MCHP_MAC 
.................... #endif 
....................  
....................  
.................... /* 
....................  * DHCP requires unfragmented packet size of at least 328 bytes, 
....................  * and while in SLIP mode, our maximum packet size is less than 
....................  * 255.  Hence disallow DHCP module while SLIP is in use. 
....................  * If required, one can use DHCP while SLIP is in use by modifying 
....................  * C18 linker scipt file such that C18 compiler can allocate 
....................  * a static array larger than 255 bytes. 
....................  * Due to very specific application that would require this, 
....................  * sample stack does not provide such facility.  Interested users 
....................  * must do this on their own. 
....................  */ 
.................... #if STACK_USE_SLIP 
....................     #if STACK_USE_DHCP 
....................         #error DHCP cannot be used when SLIP is enabled. 
....................     #endif 
.................... #endif 
....................  
.................... #include "tcpip/hardware.h" 
....................  
.................... #define MY_MAC_BYTE1                    AppConfig.MyMACAddr.v[0] 
.................... #define MY_MAC_BYTE2                    AppConfig.MyMACAddr.v[1] 
.................... #define MY_MAC_BYTE3                    AppConfig.MyMACAddr.v[2] 
.................... #define MY_MAC_BYTE4                    AppConfig.MyMACAddr.v[3] 
.................... #define MY_MAC_BYTE5                    AppConfig.MyMACAddr.v[4] 
.................... #define MY_MAC_BYTE6                    AppConfig.MyMACAddr.v[5] 
....................  
.................... /* 
....................  * Subnet mask for this node. 
....................  * Must not be all zero's or else this node will never transmit 
....................  * anything !! 
....................  */ 
.................... #define MY_MASK_BYTE1                   AppConfig.MyMask.v[0] 
.................... #define MY_MASK_BYTE2                   AppConfig.MyMask.v[1] 
.................... #define MY_MASK_BYTE3                   AppConfig.MyMask.v[2] 
.................... #define MY_MASK_BYTE4                   AppConfig.MyMask.v[3] 
....................  
.................... /* 
....................  * Hardcoded IP address of this node 
....................  * My IP = 10.10.5.10 
....................  * 
....................  * Gateway = 10.10.5.10 
....................  */ 
....................  
.................... #define MY_IP                           AppConfig.MyIPAddr 
....................  
.................... #define MY_IP_BYTE1                     AppConfig.MyIPAddr.v[0] 
.................... #define MY_IP_BYTE2                     AppConfig.MyIPAddr.v[1] 
.................... #define MY_IP_BYTE3                     AppConfig.MyIPAddr.v[2] 
.................... #define MY_IP_BYTE4                     AppConfig.MyIPAddr.v[3] 
....................  
.................... /* 
....................  * Harcoded Gateway address for this node. 
....................  * This should be changed to match actual network environment. 
....................  */ 
.................... #define MY_GATE_BYTE1                   AppConfig.MyGateway.v[0] 
.................... #define MY_GATE_BYTE2                   AppConfig.MyGateway.v[1] 
.................... #define MY_GATE_BYTE3                   AppConfig.MyGateway.v[2] 
.................... #define MY_GATE_BYTE4                   AppConfig.MyGateway.v[3] 
....................  
.................... /* 
....................  * Harcoded DNS server for this node. 
....................  */ 
.................... #define MY_DNS_BYTE1                   AppConfig.PrimaryDNSServer.v[0] 
.................... #define MY_DNS_BYTE2                   AppConfig.PrimaryDNSServer.v[1] 
.................... #define MY_DNS_BYTE3                   AppConfig.PrimaryDNSServer.v[2] 
.................... #define MY_DNS_BYTE4                   AppConfig.PrimaryDNSServer.v[3] 
....................  
....................  
.................... #ifndef MAX_SOCKETS 
.................... #define MAX_SOCKETS                     35 
.................... #endif 
....................  
.................... #ifndef MAX_UDP_SOCKETS 
.................... #define MAX_UDP_SOCKETS                 2 
.................... #endif 
....................  
.................... #if (MAX_SOCKETS <= 0 || MAX_SOCKETS > 255) 
.................... #error Invalid MAX_SOCKETS value specified. 
.................... #endif 
....................  
.................... #if (MAX_UDP_SOCKETS <= 0 || MAX_UDP_SOCKETS > 255 )&&STACK_USE_UDP 
.................... #error Invlaid MAX_UDP_SOCKETS value specified 
.................... #endif 
....................  
....................  
....................  
.................... #if (MAC_TX_BUFFER_SIZE <= 0 || MAC_TX_BUFFER_SIZE > 1500 ) 
.................... #error Invalid MAC_TX_BUFFER_SIZE value specified. 
.................... #endif 
....................  
.................... #if ( (MAC_TX_BUFFER_SIZE * MAC_TX_BUFFER_COUNT) > (4* 1024) ) 
.................... #error Not enough room for Receive buffer. 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
....................     #if (MAX_UDP_SOCKETS < 1) 
....................         #error Set MAX_UDP_SOCKETS to at least one. 
....................     #endif 
.................... #endif 
....................  
.................... typedef int1 BOOL; 
....................  
.................... typedef BYTE BUFFER; 
....................  
.................... typedef int16 WORD; 
.................... typedef int32 DWORD; 
....................  
.................... typedef union _BYTE_VAL 
.................... { 
....................     BYTE Val; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................     } bits; 
.................... } BYTE_VAL; 
....................  
....................  
.................... typedef union _SWORD_VAL 
.................... { 
....................     int32 Val; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................         int8 USB; 
....................     } bytes; 
.................... } SWORD_VAL; 
....................  
....................  
.................... typedef union _WORD_VAL 
.................... { 
....................     int16 Val; 
....................     int8 v[2]; 
....................     struct 
....................     { 
....................         int8 LSB; 
....................         int8 MSB; 
....................     } bytes; 
.................... } WORD_VAL; 
....................  
.................... /* 
.................... typedef union _DWORD_VAL 
.................... { 
....................     int32 Val; 
....................     int8 v[4]; 
.................... } DWORD_VAL; 
.................... */ 
....................  
.................... typedef union _DWORD_VAL 
.................... { 
....................     DWORD Val; 
....................    WORD w[2]; 
....................     BYTE v[4]; 
....................     struct 
....................     { 
....................         WORD LW; 
....................         WORD HW; 
....................     } word; 
....................     struct 
....................     { 
....................         BYTE LB; 
....................         BYTE HB; 
....................         BYTE UB; 
....................         BYTE MB; 
....................     } byte; 
....................     struct 
....................     { 
....................         unsigned char b0:1; 
....................         unsigned char b1:1; 
....................         unsigned char b2:1; 
....................         unsigned char b3:1; 
....................         unsigned char b4:1; 
....................         unsigned char b5:1; 
....................         unsigned char b6:1; 
....................         unsigned char b7:1; 
....................         unsigned char b8:1; 
....................         unsigned char b9:1; 
....................         unsigned char b10:1; 
....................         unsigned char b11:1; 
....................         unsigned char b12:1; 
....................         unsigned char b13:1; 
....................         unsigned char b14:1; 
....................         unsigned char b15:1; 
....................         unsigned char b16:1; 
....................         unsigned char b17:1; 
....................         unsigned char b18:1; 
....................         unsigned char b19:1; 
....................         unsigned char b20:1; 
....................         unsigned char b21:1; 
....................         unsigned char b22:1; 
....................         unsigned char b23:1; 
....................         unsigned char b24:1; 
....................         unsigned char b25:1; 
....................         unsigned char b26:1; 
....................         unsigned char b27:1; 
....................         unsigned char b28:1; 
....................         unsigned char b29:1; 
....................         unsigned char b30:1; 
....................         unsigned char b31:1; 
....................     } bits; 
.................... } DWORD_VAL; 
....................  
....................  
.................... #define LOWER_LSB(a)    (a).v[0] 
.................... #define LOWER_MSB(a)   (a).v[1] 
.................... #define UPPER_LSB(a)    (a).v[2] 
.................... #define UPPER_MSB(a)    (a).v[3] 
....................  
.................... typedef struct _MAC_ADDR 
.................... { 
....................     BYTE v[6]; 
.................... } MAC_ADDR; 
....................  
.................... typedef union _IP_ADDR 
.................... { 
....................     BYTE        v[4]; 
....................     DWORD       Val; 
.................... } IP_ADDR; 
....................  
....................  
.................... typedef struct _NODE_INFO 
.................... { 
....................     MAC_ADDR    MACAddr; 
....................     IP_ADDR     IPAddr; 
.................... } NODE_INFO; 
....................  
.................... typedef struct _APP_CONFIG 
.................... { 
....................     IP_ADDR     MyIPAddr; 
....................     MAC_ADDR    MyMACAddr; 
....................     IP_ADDR     MyMask; 
....................     IP_ADDR     MyGateway; 
....................    IP_ADDR      PrimaryDNSServer; 
....................     struct 
....................     { 
....................         unsigned char bIsDHCPEnabled : 1; 
....................         unsigned char bInConfigMode : 1; 
....................     } Flags; 
....................     WORD_VAL    SerialNumber; 
....................     IP_ADDR     SMTPServerAddr;     // Not used. 
....................     IP_ADDR     TFTPServerAddr;     // Not used. 
....................    BYTE      NetBIOSName[16]; 
.................... } APP_CONFIG; 
....................  
.................... /*typedef union _STACK_FLAGS 
.................... { 
....................     struct 
....................     { 
....................         int1 bInConfigMode : 1; 
....................     } bits; 
....................     int8 Val; 
.................... } STACK_FLAGS;*/ 
....................  
.................... APP_CONFIG AppConfig; 
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     #define StackIsInConfigMode()   (stackFlags.bits.bInConfigMode) 
.................... #else 
....................     #define StackIsInConfigMode()   FALSE 
.................... #endif 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componentns are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines be used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically called 
....................  *                  to make sure that timely response. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void); 
....................  
....................  
.................... #endif 
....................  
.................... #include "tcpip/helpers.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  Helper Function Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        Helpers.h 
....................  * Dependencies:    stacktsk.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/17/01  Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    05/24/04 swaps() and swapl() optimized 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchip's V3.75 stack 
....................  ********************************************************************/ 
....................  
.................... #ifndef HELPERS_H 
.................... #define HELPERS_H 
....................  
.................... #include "tcpip/stacktsk.h" 
....................  
.................... #if defined(__C30__) || defined(HI_TECH_C) 
.................... void 	itoa(unsigned int Value, char* Buffer); 
.................... char *strupr(char *s); 
.................... #endif 
....................  
.................... BYTE 	ReadStringUART(BYTE *Dest, BYTE BufferLen); 
.................... BYTE	hexatob(WORD_VAL AsciiChars); 
.................... BYTE	btohexa_high(BYTE b); 
.................... BYTE	btohexa_low(BYTE b); 
....................  
.................... WORD    swaps(WORD_VAL v); 
.................... DWORD   swapl(DWORD_VAL v); 
....................  
.................... WORD    CalcIPChecksum(BYTE *buffer, WORD len); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... #endif 
....................  
.................... #include "tcpip/arp.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  ARP Module Defs for Microchip TCP/IP Stack 
....................  *                 (Modified to work with CCS PCH, by CCS) 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        ARP.h 
....................  * Dependencies:    Stacktsk.h 
....................  *                  MAC.h 
....................  * Processor:       PIC18 
....................  * Complier:        CCS PCH 3.181 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * The software supplied herewith by Microchip Technology Incorporated 
....................  * (the Company) for its PICmicro® Microcontroller is intended and 
....................  * supplied to you, the Companys customer, for use solely and 
....................  * exclusively on Microchip PICmicro Microcontroller products. The 
....................  * software is owned by the Company and/or its supplier, and is 
....................  * protected under applicable copyright laws. All rights are reserved. 
....................  * Any use in violation of the foregoing restrictions may subject the 
....................  * user to criminal sanctions under applicable laws, as well as to 
....................  * civil liability for the breach of the terms and conditions of this 
....................  * license. 
....................  * 
....................  * THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES, 
....................  * WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED 
....................  * TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A 
....................  * PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT, 
....................  * IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR 
....................  * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER. 
....................  * 
....................  * Author               Date     Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     5/1/01   Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     2/9/02   Cleanup 
....................  * Nilesh Rajbharti     5/22/02  Rev 2.0 (See version.log for detail) 
....................  * Darren Rook (CCS)    01/09/04 Initial CCS Public Release 
....................  * Darren Rook (CCS)    07/13/06 In synch with Microchip's V3.02 stack [no changes] 
....................  * Darren Rook (CCS)    10/24/06 In synch with Microchips's V3.75 stack  
....................  ********************************************************************/ 
.................... #ifndef ARP_H 
.................... #define ARP_H 
....................  
.................... #include "tcpip/stacktsk.h" 
.................... #include "tcpip/mac.h" 
....................  
.................... /* 
....................  * Following codes are must be used with ARPGet/Put functions. 
....................  */ 
.................... #define ARP_REPLY       (0x00) 
.................... #define ARP_REQUEST     (0x01) 
.................... #define ARP_UNKNOWN     (0x02) 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL    ARPGet(NODE_INFO *remote, BYTE *opCode); 
....................  
....................  
.................... /********************************************************************* 
....................  * Macro:           ARPIsRxReady() 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          TRUE if ARP receive buffer is full. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... #define ARPIsTxReady()      MACIsTxReady(TRUE) 
....................  
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    MACIsTxReady() == TRUE 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode); 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #include "tcpip/mac.h" 
.................... /********************************************************************* 
....................  * 
....................  *                  MAC Module Defs for Microchip Stack 
....................  * 
....................  ********************************************************************* 
....................  * FileName:        MAC.h 
....................  * Dependencies:    StackTsk.h 
....................  * Processor:       PIC18C 
....................  * Complier:        MCC18 v1.00.50 or higher 
....................  *                  HITECH PICC-18 V8.10PL1 or higher 
....................  * Company:         Microchip Technology, Inc. 
....................  * 
....................  * Software License Agreement 
....................  * 
....................  * This software is owned by Microchip Technology Inc. ("Microchip") 
....................  * and is supplied to you for use exclusively as described in the 
....................  * associated software agreement.  This software is protected by 
....................  * software and other intellectual property laws.  Any use in 
....................  * violation of the software license may subject the user to criminal 
....................  * sanctions as well as civil liability.  Copyright 2006 Microchip 
....................  * Technology Inc.  All rights reserved. 
....................  * 
....................  * This software is provided "AS IS."  MICROCHIP DISCLAIMS ALL 
....................  * WARRANTIES, EXPRESS, IMPLIED, STATUTORY OR OTHERWISE, NOT LIMITED 
....................  * TO MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND 
....................  * INFRINGEMENT.  Microchip shall in no event be liable for special, 
....................  * incidental, or consequential damages. 
....................  * 
....................  * Author               Date        Comment 
....................  *~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 
....................  * Nilesh Rajbharti     4/27/01     Original        (Rev 1.0) 
....................  * Nilesh Rajbharti     11/27/01    Added SLIP 
....................  * Nilesh Rajbharti     2/9/02      Cleanup 
....................  * Nilesh Rajbharti     5/22/02     Rev 2.0 (See version.log for detail) 
....................  * Howard Schlunder     6/28/04     Added ENC28J60 specific features 
....................  * Howard Schlunder      11/29/04   Added Get/SetLEDConfig macros 
....................  * Darren Rook          7/11/06  CCS Port 
....................  ********************************************************************/ 
....................  
.................... #ifndef MAC_H 
.................... #define MAC_H 
....................  
.................... #include "tcpip/StackTsk.h" 
....................  
.................... #define MAC_IP      (0u) 
.................... #define MAC_ARP     (0x6u) 
.................... #define MAC_UNKNOWN (0x0ffu) 
....................  
.................... #define INVALID_BUFFER  (0xffu) 
....................  
.................... /* 
....................  * Microchip Ethernet controller specific MAC items 
....................  */ 
.................... #if STACK_USE_MCPENC 
.................... #include "tcpip/ENC28J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC 
.................... #include "tcpip/ETH97J60.h" 
.................... #endif 
....................  
.................... #if STACK_USE_MCPINC || STACK_USE_MCPENC 
....................  
.................... // Duplex configuration options 
.................... typedef enum _DUPLEX { 
....................    HALF = 0, 
....................    FULL = 1, 
....................    USE_PHY = 2 
.................... } DUPLEX; 
....................  
.................... typedef enum _CLK_CONFIG { 
....................    Divide1, 
....................    Divide2, 
....................    Divide3, 
....................    Divide4, 
....................    Divide8 
.................... } CLK_CONFIG; 
.................... void   MACSetDuplex(DUPLEX DuplexState); 
.................... WORD    CalcIPBufferChecksum(WORD len); 
....................  
.................... void   MACPowerDown(void); 
.................... void    MACPowerUp(void); 
.................... WORD   MACCalcRxChecksum(WORD offset, WORD len); 
.................... WORD   MACCalcTxChecksum(WORD offset, WORD len); 
.................... void   MACCopyRxToTx(WORD RxOffset, WORD TxOffset, WORD len); 
.................... void   WritePHYReg(BYTE Register, WORD Data); 
.................... PHYREG   ReadPHYReg(BYTE Register); 
.................... void   SetRXHashTableEntry(MAC_ADDR DestMACAddr); 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           void SetLEDConfig(WORD NewConfig) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           NewConfig - xxx0: Pulse stretching disabled 
....................  *                        xxx2: Pulse stretch to 40ms (default) 
....................  *                        xxx6: Pulse stretch to 73ms 
....................  *                        xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                        xx1x: LEDB - TX 
....................  *                        xx2x: LEDB - RX (default) 
....................  *                        xx3x: LEDB - collisions 
....................  *                        xx4x: LEDB - link 
....................  *                        xx5x: LEDB - duplex 
....................  *                        xx7x: LEDB - TX and RX 
....................  *                        xx8x: LEDB - on 
....................  *                        xx9x: LEDB - off 
....................  *                        xxAx: LEDB - blink fast 
....................  *                        xxBx: LEDB - blink slow 
....................  *                        xxCx: LEDB - link and RX 
....................  *                        xxDx: LEDB - link and TX and RX 
....................  *                        xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                        x1xx: LEDA - TX 
....................  *                        x2xx: LEDA - RX 
....................  *                        x3xx: LEDA - collisions 
....................  *                        x4xx: LEDA - link (default) 
....................  *                        x5xx: LEDA - duplex 
....................  *                        x7xx: LEDA - TX and RX 
....................  *                        x8xx: LEDA - on 
....................  *                        x9xx: LEDA - off 
....................  *                        xAxx: LEDA - blink fast 
....................  *                        xBxx: LEDA - blink slow 
....................  *                        xCxx: LEDA - link and RX 
....................  *                        xDxx: LEDA - link and TX and RX 
....................  *                        xExx: LEDA - duplex and collisions 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Writes the value of NewConfig into the PHLCON PHY register. 
....................  *               The LED pins will beginning outputting the new 
....................  *               configuration immediately. 
....................  * 
....................  * Note: 
....................  *****************************************************************************/ 
.................... #define SetLEDConfig(NewConfig)      WritePHYReg(PHLCON, NewConfig) 
....................  
....................  
.................... /****************************************************************************** 
....................  * Macro:           WORD GetLEDConfig(void) 
....................  * 
....................  * PreCondition:    SPI bus must be initialized (done in MACInit()). 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          WORD -   xxx0: Pulse stretching disabled 
....................  *                     xxx2: Pulse stretch to 40ms (default) 
....................  *                     xxx6: Pulse stretch to 73ms 
....................  *                     xxxA: Pulse stretch to 139ms 
....................  * 
....................  *                     xx1x: LEDB - TX 
....................  *                     xx2x: LEDB - RX (default) 
....................  *                     xx3x: LEDB - collisions 
....................  *                     xx4x: LEDB - link 
....................  *                     xx5x: LEDB - duplex 
....................  *                     xx7x: LEDB - TX and RX 
....................  *                     xx8x: LEDB - on 
....................  *                     xx9x: LEDB - off 
....................  *                     xxAx: LEDB - blink fast 
....................  *                     xxBx: LEDB - blink slow 
....................  *                     xxCx: LEDB - link and RX 
....................  *                     xxDx: LEDB - link and TX and RX 
....................  *                     xxEx: LEDB - duplex and collisions 
....................  * 
....................  *                      x1xx: LEDA - TX 
....................  *                     x2xx: LEDA - RX 
....................  *                     x3xx: LEDA - collisions 
....................  *                     x4xx: LEDA - link (default) 
....................  *                     x5xx: LEDA - duplex 
....................  *                     x7xx: LEDA - TX and RX 
....................  *                     x8xx: LEDA - on 
....................  *                     x9xx: LEDA - off 
....................  *                     xAxx: LEDA - blink fast 
....................  *                     xBxx: LEDA - blink slow 
....................  *                     xCxx: LEDA - link and RX 
....................  *                     xDxx: LEDA - link and TX and RX 
....................  *                     xExx: LEDA - duplex and collisions 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        Returns the current value of the PHLCON register. 
....................  * 
....................  * Note:            None 
....................  *****************************************************************************/ 
.................... #define GetLEDConfig()      ReadPHYReg(PHLCON).Val 
....................  
.................... #endif 
....................  
....................  
.................... void    MACInit(void); 
.................... BOOL   MACIsLinked(void); 
....................  
.................... BOOL    MACGetHeader(MAC_ADDR *remote, BYTE* type); 
.................... void    MACSetRxBuffer(WORD offset); 
.................... BYTE    MACGet(void); 
.................... WORD    MACGetArray(BYTE *val, WORD len); 
.................... void    MACDiscardRx(void); 
.................... WORD    MACGetFreeRxSize(void); 
....................  
.................... void    MACPutHeader(MAC_ADDR *remote, 
....................                      BYTE type, 
....................                      WORD dataLen); 
.................... BOOL    MACIsTxReady(BOOL HighPriority); 
.................... void    MACSetTxBuffer(BUFFER buffer, WORD offset); 
.................... void    MACPut(BYTE val); 
.................... void    MACPutArray(BYTE *val, WORD len); 
.................... void    MACDiscardTx(BUFFER buffer); 
.................... void    MACFlush(void); 
.................... BUFFER   MACGetTxBuffer(BOOL HighPriority); 
....................  
....................  
.................... /* extern */ BUFFER CurrentTxBuffer; 
....................  
.................... #if STACK_USE_SLIP 
.................... #define NICCurrentTxBuffer      (0) 
.................... #endif 
....................  
.................... #endif 
....................  
....................  
.................... //#define debug_arp 
.................... //#define debug_arp debug_printf 
.................... #define debug_arp(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................  
.................... // ARP Operation codes. 
.................... #define ARP_OPERATION_REQ       0x01u 
.................... #define ARP_OPERATION_RESP      0x02u 
....................  
.................... // ETHERNET packet type as defined by IEEE 802.3 
.................... #define HW_ETHERNET             (0x0001u) 
.................... #define ARP_IP                  (0x0800u) 
....................  
....................  
....................  
.................... // ARP packet 
.................... typedef struct _ARP_PACKET 
.................... { 
....................     WORD        HardwareType; 
....................     WORD        Protocol; 
....................     BYTE        MACAddrLen; 
....................     BYTE        ProtocolLen; 
....................     WORD        Operation; 
....................     MAC_ADDR    SenderMACAddr; 
....................     IP_ADDR     SenderIPAddr; 
....................     MAC_ADDR    TargetMACAddr; 
....................     IP_ADDR     TargetIPAddr; 
.................... } ARP_PACKET; 
....................  
.................... // Helper function 
.................... static void SwapARPPacket(ARP_PACKET *p); 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        BOOL ARPGet(NODE_INFO* remote, BYTE* opCode) 
....................  * 
....................  * PreCondition:    ARP packet is ready in MAC buffer. 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - Buffer to hold ARP op code. 
....................  * 
....................  * Output:          TRUE if a valid ARP packet was received. 
....................  *                  FALSE otherwise. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... int1 ARPGet(NODE_INFO *remote, int8 *opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................     //MACGetArray((int8*)&packet, sizeof(packet)); 
....................     MACGetArray(&packet, sizeof(ARP_PACKET)); 
*
02F14:  MOVLW  09
02F16:  MOVLB  9
02F18:  MOVWF  x95
02F1A:  MOVLW  0E
02F1C:  MOVWF  x94
02F1E:  CLRF   x97
02F20:  MOVLW  1C
02F22:  MOVWF  x96
02F24:  MOVLB  0
02F26:  RCALL  2C7C
....................  
....................     MACDiscardRx(); 
02F28:  RCALL  2C06
....................  
....................     SwapARPPacket(&packet); 
02F2A:  MOVLW  09
02F2C:  MOVLB  9
02F2E:  MOVWF  x2B
02F30:  MOVLW  0E
02F32:  MOVWF  x2A
02F34:  MOVLB  0
02F36:  RCALL  2E40
....................  
....................    debug_arp(debug_putc, "\r\nARP: HW:%LX PR:%LX ML:%U PL:%U O:%LX TI:%U.%U.%U.%U FI:%U.%U.%U.%U", 
....................       packet.HardwareType, packet.Protocol, packet.MACAddrLen, packet.ProtocolLen, 
....................       packet.Operation, packet.TargetIPAddr.v[0],packet.TargetIPAddr.v[1], 
....................       packet.TargetIPAddr.v[2],packet.TargetIPAddr.v[3], 
....................       packet.SenderIPAddr.v[0],packet.SenderIPAddr.v[1],packet.SenderIPAddr.v[2],packet.SenderIPAddr.v[3]); 
....................  
....................     if ( packet.HardwareType != HW_ETHERNET     || 
....................          packet.MACAddrLen != sizeof(MAC_ADDR)  || 
....................          packet.ProtocolLen != sizeof(IP_ADDR) ) 
02F38:  MOVLB  9
02F3A:  DECFSZ x0E,W
02F3C:  BRA    2F4E
02F3E:  MOVF   x0F,F
02F40:  BNZ   2F4E
02F42:  MOVF   x12,W
02F44:  SUBLW  06
02F46:  BNZ   2F4E
02F48:  MOVF   x13,W
02F4A:  SUBLW  04
02F4C:  BZ    2F54
....................          return FALSE; 
02F4E:  MOVLW  00
02F50:  MOVWF  01
02F52:  BRA    3006
....................  
....................     if ( packet.Operation == ARP_OPERATION_RESP ) 
02F54:  MOVF   x14,W
02F56:  SUBLW  02
02F58:  BNZ   2F6E
02F5A:  MOVF   x15,F
02F5C:  BNZ   2F6E
....................         *opCode = ARP_REPLY; 
02F5E:  MOVFF  90D,03
02F62:  MOVFF  90C,FE9
02F66:  MOVFF  90D,FEA
02F6A:  CLRF   FEF
02F6C:  BRA    2F9A
....................     else if ( packet.Operation == ARP_OPERATION_REQ ) 
02F6E:  DECFSZ x14,W
02F70:  BRA    2F88
02F72:  MOVF   x15,F
02F74:  BNZ   2F88
....................         *opCode = ARP_REQUEST; 
02F76:  MOVFF  90D,03
02F7A:  MOVFF  90C,FE9
02F7E:  MOVFF  90D,FEA
02F82:  MOVLW  01
02F84:  MOVWF  FEF
02F86:  BRA    2F9A
....................     else 
....................     { 
....................         *opCode = ARP_UNKNOWN; 
02F88:  MOVFF  90C,FE9
02F8C:  MOVFF  90D,FEA
02F90:  MOVLW  02
02F92:  MOVWF  FEF
....................         return FALSE; 
02F94:  MOVLW  00
02F96:  MOVWF  01
02F98:  BRA    3006
....................     } 
....................  
....................     if(packet.TargetIPAddr.Val == AppConfig.MyIPAddr.Val) 
02F9A:  MOVLB  3
02F9C:  MOVF   x53,W
02F9E:  MOVLB  9
02FA0:  SUBWF  x26,W
02FA2:  BNZ   3002
02FA4:  MOVLB  3
02FA6:  MOVF   x54,W
02FA8:  MOVLB  9
02FAA:  SUBWF  x27,W
02FAC:  BNZ   3002
02FAE:  MOVLB  3
02FB0:  MOVF   x55,W
02FB2:  MOVLB  9
02FB4:  SUBWF  x28,W
02FB6:  BNZ   3002
02FB8:  MOVLB  3
02FBA:  MOVF   x56,W
02FBC:  MOVLB  9
02FBE:  SUBWF  x29,W
02FC0:  BNZ   3002
....................     { 
....................         remote->MACAddr     = packet.SenderMACAddr; 
02FC2:  MOVFF  90A,FE9
02FC6:  MOVFF  90B,FEA
02FCA:  MOVLW  09
02FCC:  MOVWF  FE2
02FCE:  MOVLW  16
02FD0:  MOVWF  FE1
02FD2:  MOVLW  06
02FD4:  MOVWF  01
02FD6:  MOVFF  FE6,FEE
02FDA:  DECFSZ 01,F
02FDC:  BRA    2FD6
....................         remote->IPAddr      = packet.SenderIPAddr; 
02FDE:  MOVLW  06
02FE0:  ADDWF  x0A,W
02FE2:  MOVWF  FE9
02FE4:  MOVLW  00
02FE6:  ADDWFC x0B,W
02FE8:  MOVWF  FEA
02FEA:  MOVFF  91C,FEF
02FEE:  MOVFF  91D,FEC
02FF2:  MOVFF  91E,FEC
02FF6:  MOVFF  91F,FEC
....................         return TRUE; 
02FFA:  MOVLW  01
02FFC:  MOVWF  01
02FFE:  BRA    3006
....................     } 
03000:  BRA    3006
....................     else 
....................         return FALSE; 
03002:  MOVLW  00
03004:  MOVWF  01
03006:  MOVLB  0
03008:  GOTO   360A (RETURN)
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void ARPPut(NODE_INFO* more, BYTE opCode) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           remote  - Remote node info 
....................  *                  opCode  - ARP op code to send 
....................  * 
....................  * Output:          TRUE - The ARP packet was generated properly 
....................  *               FALSE - Unable to allocate a TX buffer 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... BOOL ARPPut(NODE_INFO *remote, BYTE opCode) 
.................... { 
....................     ARP_PACKET packet; 
....................  
....................    BUFFER MyTxBuffer; 
....................    MyTxBuffer = MACGetTxBuffer(TRUE); 
*
03454:  MOVLW  01
03456:  MOVLB  9
03458:  MOVWF  x86
0345A:  MOVLB  0
0345C:  RCALL  300C
0345E:  MOVFF  01,929
....................     
....................    // Do not respond if there is no room to generate the ARP reply 
....................    if(MyTxBuffer == INVALID_BUFFER) 
03462:  MOVLB  9
03464:  INCFSZ x29,W
03466:  BRA    346E
....................       return FALSE; 
03468:  MOVLW  00
0346A:  MOVWF  01
0346C:  BRA    35E4
....................  
....................    MACSetTxBuffer(MyTxBuffer, 0); 
0346E:  MOVFF  929,99F
03472:  CLRF   xA1
03474:  CLRF   xA0
03476:  MOVLB  0
03478:  RCALL  3034
....................     
....................     
....................     packet.HardwareType             = HW_ETHERNET; 
0347A:  MOVLB  9
0347C:  CLRF   x0E
0347E:  MOVLW  01
03480:  MOVWF  x0D
....................     packet.Protocol                 = ARP_IP; 
03482:  MOVLW  08
03484:  MOVWF  x10
03486:  CLRF   x0F
....................     packet.MACAddrLen               = sizeof(MAC_ADDR); 
03488:  MOVLW  06
0348A:  MOVWF  x11
....................     packet.ProtocolLen              = sizeof(IP_ADDR); 
0348C:  MOVLW  04
0348E:  MOVWF  x12
....................  
....................     if ( opCode == ARP_REQUEST ) 
03490:  DECFSZ x0C,W
03492:  BRA    34A8
....................     { 
....................         packet.Operation            = ARP_OPERATION_REQ; 
03494:  CLRF   x14
03496:  MOVLW  01
03498:  MOVWF  x13
....................         packet.TargetMACAddr.v[0]   = 0xff; 
0349A:  SETF   x1F
....................         packet.TargetMACAddr.v[1]   = 0xff; 
0349C:  SETF   x20
....................         packet.TargetMACAddr.v[2]   = 0xff; 
0349E:  SETF   x21
....................         packet.TargetMACAddr.v[3]   = 0xff; 
034A0:  SETF   x22
....................         packet.TargetMACAddr.v[4]   = 0xff; 
034A2:  SETF   x23
....................         packet.TargetMACAddr.v[5]   = 0xff; 
034A4:  SETF   x24
....................     } 
034A6:  BRA    34CA
....................     else 
....................     { 
....................         packet.Operation            = ARP_OPERATION_RESP; 
034A8:  CLRF   x14
034AA:  MOVLW  02
034AC:  MOVWF  x13
....................         packet.TargetMACAddr        = remote->MACAddr; 
034AE:  MOVFF  90A,FE1
034B2:  MOVFF  90B,FE2
034B6:  MOVLW  09
034B8:  MOVWF  FEA
034BA:  MOVLW  1F
034BC:  MOVWF  FE9
034BE:  MOVLW  06
034C0:  MOVWF  01
034C2:  MOVFF  FE6,FEE
034C6:  DECFSZ 01,F
034C8:  BRA    34C2
....................     } 
....................  
....................     packet.SenderMACAddr = AppConfig.MyMACAddr; 
034CA:  MOVLW  09
034CC:  MOVWF  FEA
034CE:  MOVLW  15
034D0:  MOVWF  FE9
034D2:  MOVLW  03
034D4:  MOVWF  FE2
034D6:  MOVLW  57
034D8:  MOVWF  FE1
034DA:  MOVLW  06
034DC:  MOVWF  01
034DE:  MOVFF  FE6,FEE
034E2:  DECFSZ 01,F
034E4:  BRA    34DE
....................     packet.SenderIPAddr  = AppConfig.MyIPAddr; 
034E6:  MOVFF  356,91E
034EA:  MOVFF  355,91D
034EE:  MOVFF  354,91C
034F2:  MOVFF  353,91B
....................  
....................  
....................     // Check to see if target is on same subnet, if not, find Gateway MAC. 
....................     // Once we get Gateway MAC, all access to remote host will go through Gateway. 
....................     if((packet.SenderIPAddr.Val ^ remote->IPAddr.Val) & AppConfig.MyMask.Val) 
034F6:  MOVLW  06
034F8:  ADDWF  x0A,W
034FA:  MOVWF  FE9
034FC:  MOVLW  00
034FE:  ADDWFC x0B,W
03500:  MOVWF  FEA
03502:  MOVFF  FEF,00
03506:  MOVFF  FEC,01
0350A:  MOVFF  FEC,02
0350E:  MOVFF  FEC,03
03512:  MOVF   00,W
03514:  XORWF  x1B,W
03516:  MOVWF  x2A
03518:  MOVF   01,W
0351A:  XORWF  x1C,W
0351C:  MOVWF  x2B
0351E:  MOVF   02,W
03520:  XORWF  x1D,W
03522:  MOVWF  x2C
03524:  MOVF   03,W
03526:  XORWF  x1E,W
03528:  MOVWF  x2D
0352A:  MOVF   x2A,W
0352C:  MOVLB  3
0352E:  ANDWF  x5D,W
03530:  MOVWF  00
03532:  MOVLB  9
03534:  MOVF   x2B,W
03536:  MOVLB  3
03538:  ANDWF  x5E,W
0353A:  MOVWF  01
0353C:  MOVLB  9
0353E:  MOVF   x2C,W
03540:  MOVLB  3
03542:  ANDWF  x5F,W
03544:  MOVWF  02
03546:  MOVLB  9
03548:  MOVF   x2D,W
0354A:  MOVLB  3
0354C:  ANDWF  x60,W
0354E:  MOVWF  03
03550:  MOVF   00,F
03552:  BNZ   3560
03554:  MOVF   01,F
03556:  BNZ   3560
03558:  MOVF   02,F
0355A:  BNZ   3560
0355C:  MOVF   03,F
0355E:  BZ    3572
....................     { 
....................       packet.TargetIPAddr = AppConfig.MyGateway; 
03560:  MOVFF  364,928
03564:  MOVFF  363,927
03568:  MOVFF  362,926
0356C:  MOVFF  361,925
....................     } 
03570:  BRA    35A2
....................     else 
....................         packet.TargetIPAddr             = remote->IPAddr; 
03572:  MOVLW  06
03574:  MOVLB  9
03576:  ADDWF  x0A,W
03578:  MOVWF  FE9
0357A:  MOVLW  00
0357C:  ADDWFC x0B,W
0357E:  MOVWF  FEA
03580:  MOVFF  FEF,00
03584:  MOVFF  FEC,01
03588:  MOVFF  FEC,02
0358C:  MOVFF  FEC,03
03590:  MOVFF  00,925
03594:  MOVFF  01,926
03598:  MOVFF  02,927
0359C:  MOVFF  03,928
035A0:  MOVLB  3
....................  
....................     SwapARPPacket(&packet); 
035A2:  MOVLW  09
035A4:  MOVLB  9
035A6:  MOVWF  x2B
035A8:  MOVLW  0D
035AA:  MOVWF  x2A
035AC:  MOVLB  0
035AE:  RCALL  2E40
....................  
....................     MACPutHeader(&packet.TargetMACAddr, MAC_ARP, sizeof(packet)); 
035B0:  MOVLW  09
035B2:  MOVLB  9
035B4:  MOVWF  xA4
035B6:  MOVLW  1F
035B8:  MOVWF  xA3
035BA:  MOVLW  06
035BC:  MOVWF  xA5
035BE:  CLRF   xA7
035C0:  MOVLW  1C
035C2:  MOVWF  xA6
035C4:  MOVLB  0
035C6:  RCALL  314E
....................  
....................     //MACPutArray((int8*)&packet, sizeof(packet)); 
....................     MACPutArray(&packet, sizeof(ARP_PACKET)); 
035C8:  MOVLW  09
035CA:  MOVLB  9
035CC:  MOVWF  xAB
035CE:  MOVLW  0D
035D0:  MOVWF  xAA
035D2:  CLRF   xAD
035D4:  MOVLW  1C
035D6:  MOVWF  xAC
035D8:  MOVLB  0
035DA:  RCALL  3100
....................  
....................     MACFlush(); 
035DC:  RCALL  3224
....................     
....................    return TRUE; 
035DE:  MOVLW  01
035E0:  MOVWF  01
035E2:  MOVLB  9
035E4:  MOVLB  0
035E6:  RETURN 0
.................... } 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        static void SwapARPPacket(ARP_PACKET* p) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           p   - ARP packet to be swapped. 
....................  * 
....................  * Output:          None 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Overview:        None 
....................  * 
....................  * Note:            None 
....................  ********************************************************************/ 
.................... static void SwapARPPacket(ARP_PACKET *p) 
.................... { 
....................     p->HardwareType     = swaps(p->HardwareType); 
*
02E40:  MOVLB  9
02E42:  MOVFF  92A,01
02E46:  MOVFF  92B,03
02E4A:  MOVFF  92A,92C
02E4E:  MOVFF  92B,92D
02E52:  MOVFF  92A,FE9
02E56:  MOVFF  92B,FEA
02E5A:  MOVFF  FEC,92F
02E5E:  MOVF   FED,F
02E60:  MOVFF  FEF,92E
02E64:  MOVFF  92F,9A6
02E68:  MOVFF  92E,9A5
02E6C:  MOVLB  0
02E6E:  RCALL  2CE0
02E70:  MOVFF  92D,FEA
02E74:  MOVFF  92C,FE9
02E78:  MOVFF  02,FEC
02E7C:  MOVF   FED,F
02E7E:  MOVFF  01,FEF
....................     p->Protocol         = swaps(p->Protocol); 
02E82:  MOVLW  02
02E84:  MOVLB  9
02E86:  ADDWF  x2A,W
02E88:  MOVWF  01
02E8A:  MOVLW  00
02E8C:  ADDWFC x2B,W
02E8E:  MOVWF  03
02E90:  MOVFF  01,92C
02E94:  MOVWF  x2D
02E96:  MOVLW  02
02E98:  ADDWF  x2A,W
02E9A:  MOVWF  FE9
02E9C:  MOVLW  00
02E9E:  ADDWFC x2B,W
02EA0:  MOVWF  FEA
02EA2:  MOVFF  FEC,92F
02EA6:  MOVF   FED,F
02EA8:  MOVFF  FEF,92E
02EAC:  MOVFF  92F,9A6
02EB0:  MOVFF  92E,9A5
02EB4:  MOVLB  0
02EB6:  RCALL  2CE0
02EB8:  MOVFF  92D,FEA
02EBC:  MOVFF  92C,FE9
02EC0:  MOVFF  02,FEC
02EC4:  MOVF   FED,F
02EC6:  MOVFF  01,FEF
....................     p->Operation        = swaps(p->Operation); 
02ECA:  MOVLW  06
02ECC:  MOVLB  9
02ECE:  ADDWF  x2A,W
02ED0:  MOVWF  01
02ED2:  MOVLW  00
02ED4:  ADDWFC x2B,W
02ED6:  MOVWF  03
02ED8:  MOVFF  01,92C
02EDC:  MOVWF  x2D
02EDE:  MOVLW  06
02EE0:  ADDWF  x2A,W
02EE2:  MOVWF  FE9
02EE4:  MOVLW  00
02EE6:  ADDWFC x2B,W
02EE8:  MOVWF  FEA
02EEA:  MOVFF  FEC,92F
02EEE:  MOVF   FED,F
02EF0:  MOVFF  FEF,92E
02EF4:  MOVFF  92F,9A6
02EF8:  MOVFF  92E,9A5
02EFC:  MOVLB  0
02EFE:  RCALL  2CE0
02F00:  MOVFF  92D,FEA
02F04:  MOVFF  92C,FE9
02F08:  MOVFF  02,FEC
02F0C:  MOVF   FED,F
02F0E:  MOVFF  01,FEF
02F12:  RETURN 0
.................... } 
....................  
.................... #endif 
....................  
.................... #if STACK_USE_MPFS 
....................    #include "mpfs/mpfs.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    #include "tcpip/http.c" 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    #include "tcpip/http2.c" 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    #include "tcpip/ftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
....................    #include "tcpip/tftp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    #include "tcpip/smtp.c" 
.................... #endif 
....................  
.................... #if STACK_USE_BASE64 
....................    #include "tcpip/base64.c" 
.................... #endif 
....................  
.................... #if STACK_USE_DNS 
....................    #include "tcpip/dns.c" 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    #include "tcpip/announce.h" 
....................    #include "tcpip/announce.c" 
.................... #endif 
....................  
.................... #if STACK_USE_SNMP 
....................    #include "tcpip/snmp.c" 
.................... #endif 
....................  
.................... //#define MAX_ICMP_DATA_LEN   64 //moved to icmp.h 
....................  
.................... /* 
....................  * Stack FSM states. 
....................  */ 
.................... typedef enum _SM_STACK 
.................... { 
....................     SM_STACK_IDLE=0, 
....................     SM_STACK_MAC, 
....................     SM_STACK_IP, 
....................     SM_STACK_ICMP, 
....................     SM_STACK_ICMP_REPLY, 
....................     SM_STACK_ARP, 
....................     SM_STACK_TCP, 
....................     SM_STACK_UDP 
.................... } SM_STACK; 
....................  
.................... SM_STACK smStack; 
....................  
.................... NODE_INFO remoteNode; 
....................  
....................  
.................... /********************************************************************* 
....................  * Function:        void StackInit(void) 
....................  * 
....................  * PreCondition:    None 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack and its componets are initialized 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This function must be called before any of the 
....................  *                  stack or its component routines are used. 
....................  * 
....................  ********************************************************************/ 
.................... void StackInit(void) 
.................... { 
....................     smStack                     = SM_STACK_IDLE; 
*
01CF0:  MOVLB  8
01CF2:  CLRF   x92
....................  
.................... #if STACK_USE_IP_GLEANING || STACK_USE_DHCP 
....................     /* 
....................      * If DHCP or IP Gleaning is enabled, 
....................      * startup in Config Mode. 
....................      */ 
....................     AppConfig.Flags.bInConfigMode = TRUE; 
.................... #endif 
....................  
....................    TickInit(); 
01CF4:  MOVLB  0
01CF6:  BRA    1518
....................  
.................... #if STACK_USE_MAC 
....................     MACInit(); 
01CF8:  BRA    1846
.................... #endif 
....................  
.................... #if STACK_USE_ARP 
....................     ARPInit(); 
01CFA:  BRA    1A20
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
....................     UDPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     TCPInit(); 
01CFC:  BRA    1B9A
.................... #endif 
....................  
.................... #if STACK_USE_DHCP 
....................    DHCPReset(); 
.................... #endif 
....................  
.................... #if STACK_USE_PPP 
....................    ppp_init(); 
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP||STACK_USE_HTTP2 
....................    HTTP_Init(); 
.................... #endif 
....................  
.................... #if STACK_USE_FTP 
....................    FTPInit(); 
.................... #endif 
....................  
.................... #if STACK_USE_TFTP 
01CFE:  GOTO   7A9E (RETURN)
....................    TFTPInit(); 
.................... #endif 
.................... } 
....................  
.................... /* 
.................... #if STACK_USE_MCPENC 
.................... #if MAC_TX_BUFFER_COUNT > 1 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U TXB0.ADD=0x%LX TXB0.FR=%U NPL=0x%LX CPL=0x%LX",NICCurrentTxBuffer, TxBuffers[0].StartAddress, TxBuffers[0].bFree, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #else 
....................  #define DebugDisplayVals() debug_stack("\r\nTXB=%U NPL=0x%LX CPL=0x%LX", NICCurrentTxBuffer, NextPacketLocation.Val, CurrentPacketLocation.Val) 
.................... #endif 
.................... #else 
....................  #define DebugDisplayVals() 
.................... #endif 
.................... */ 
....................  
.................... #define DebugDisplayVals() 
....................  
.................... /********************************************************************* 
....................  * Function:        void StackTask(void) 
....................  * 
....................  * PreCondition:    StackInit() is already called. 
....................  * 
....................  * Input:           None 
....................  * 
....................  * Output:          Stack FSM is executed. 
....................  * 
....................  * Side Effects:    None 
....................  * 
....................  * Note:            This FSM checks for new incoming packets, 
....................  *                  and routes it to appropriate stack components. 
....................  *                  It also performs timed operations. 
....................  * 
....................  *                  This function must be called periodically to 
....................  *                  ensure timely responses. 
....................  * 
....................  ********************************************************************/ 
.................... void StackTask(void) 
*
05AA8:  MOVLB  8
05AAA:  BCF    xFE.0
.................... { 
....................     static WORD dataCount; 
....................  
.................... #if STACK_USE_ICMP 
....................     static BYTE data[MAX_ICMP_DATA_LEN]; 
....................     static WORD ICMPId; 
....................     static WORD ICMPSeq; 
.................... #endif 
....................     IP_ADDR tempLocalIP; 
....................  
....................  
....................     union 
....................     { 
....................         BYTE MACFrameType; 
....................         BYTE IPFrameType; 
.................... #if STACK_USE_ICMP 
....................         ICMP_CODE ICMPCode; 
.................... #endif 
....................     } type; 
....................  
....................  
....................     BOOL lbContinue=FALSE; 
....................  
....................     do 
....................     { 
....................         lbContinue = FALSE; 
05AAC:  BCF    xFE.0
....................         switch(smStack) 
05AAE:  MOVF   x92,W
05AB0:  ADDLW  F9
05AB2:  BTFSC  FD8.0
05AB4:  BRA    5C60
05AB6:  ADDLW  07
05AB8:  MOVLB  0
05ABA:  GOTO   5C6A
....................         { 
....................         case SM_STACK_IDLE: 
....................         case SM_STACK_MAC: 
....................             if ( !MACGetHeader(&remoteNode.MACAddr, &type.MACFrameType) ) 
05ABE:  MOVLW  08
05AC0:  MOVLB  9
05AC2:  MOVWF  x00
05AC4:  MOVLW  93
05AC6:  MOVLB  8
05AC8:  MOVWF  xFF
05ACA:  MOVLW  08
05ACC:  MOVLB  9
05ACE:  MOVWF  x02
05AD0:  MOVLW  FD
05AD2:  MOVWF  x01
05AD4:  MOVLB  0
05AD6:  GOTO   2CF6
05ADA:  MOVF   01,F
05ADC:  BNZ   5AE4
....................             { 
....................                 #if STACK_USE_DHCP 
....................                     // Normally, an application would not include  DHCP module 
....................                     // if it is not enabled. But in case some one wants to disable 
....................                     // DHCP module at run-time, remember to not clear our IP 
....................                     // address if link is removed. 
....................                     if ( !DHCPIsDisabled() ) 
....................                     { 
....................                         if ( !MACIsLinked() ) 
....................                         { 
....................                             AppConfig.MyIPAddr.Val = 0x00000000ul; 
....................                             AppConfig.Flags.bInConfigMode = TRUE; 
....................                             DHCPReset(); 
....................                         } 
....................                     } 
....................                 #endif 
....................                 break; 
05ADE:  MOVLB  8
05AE0:  BRA    5C60
05AE2:  MOVLB  0
....................             } 
....................  
....................             debug_stack(debug_putc, "\r\nMAC GET "); 
....................  
....................             lbContinue = TRUE; 
05AE4:  MOVLB  8
05AE6:  BSF    xFE.0
....................             if ( type.MACFrameType == MAC_IP ) { 
05AE8:  MOVF   xFD,F
05AEA:  BNZ   5AF2
....................                 smStack = SM_STACK_IP; 
05AEC:  MOVLW  02
05AEE:  MOVWF  x92
....................                 debug_stack(debug_putc, "IP "); 
....................             } 
05AF0:  BRA    5B06
....................             else if ( type.MACFrameType == MAC_ARP ) { 
05AF2:  MOVF   xFD,W
05AF4:  SUBLW  06
05AF6:  BNZ   5AFE
....................                 smStack = SM_STACK_ARP; 
05AF8:  MOVLW  05
05AFA:  MOVWF  x92
....................                 debug_stack(debug_putc, "ARP "); 
....................             } 
05AFC:  BRA    5B06
....................             else { 
....................                 MACDiscardRx(); 
05AFE:  MOVLB  0
05B00:  CALL   2C06
05B04:  MOVLB  8
....................                 debug_stack(debug_putc, "DISCARD"); 
....................             } 
....................             break; 
05B06:  BRA    5C60
....................  
....................         case SM_STACK_ARP: 
.................... #if STACK_USE_ARP 
....................             if ( ARPProcess() ) { 
05B08:  GOTO   35E8
05B0C:  MOVF   01,F
05B0E:  BZ    5B16
....................                 smStack = SM_STACK_IDLE; 
05B10:  MOVLB  8
05B12:  CLRF   x92
05B14:  MOVLB  0
....................             } 
.................... #else 
....................             smStack = SM_STACK_IDLE; 
.................... #endif 
....................             break; 
05B16:  MOVLB  8
05B18:  BRA    5C60
....................  
....................         case SM_STACK_IP: 
....................             if ( IPGetHeader(&tempLocalIP, 
....................                              &remoteNode, 
....................                              &type.IPFrameType, 
....................                              &dataCount) ) 
05B1A:  MOVLW  08
05B1C:  MOVLB  9
05B1E:  MOVWF  x00
05B20:  MOVLW  F9
05B22:  MOVLB  8
05B24:  MOVWF  xFF
05B26:  MOVLW  08
05B28:  MOVLB  9
05B2A:  MOVWF  x02
05B2C:  MOVLW  93
05B2E:  MOVWF  x01
05B30:  MOVLW  08
05B32:  MOVWF  x04
05B34:  MOVLW  FD
05B36:  MOVWF  x03
05B38:  MOVLW  08
05B3A:  MOVWF  x06
05B3C:  MOVLW  9D
05B3E:  MOVWF  x05
05B40:  MOVLB  0
05B42:  GOTO   38EE
05B46:  MOVF   01,F
05B48:  BZ    5B74
....................             { 
....................                 lbContinue = TRUE; 
05B4A:  MOVLB  8
05B4C:  BSF    xFE.0
....................                 if ( type.IPFrameType == IP_PROT_ICMP ) 
05B4E:  DECFSZ xFD,W
05B50:  BRA    5B58
....................                 { 
....................                     smStack = SM_STACK_ICMP; 
05B52:  MOVLW  03
05B54:  MOVWF  x92
....................                     debug_stack(debug_putc, "ICMP "); 
.................... #if STACK_USE_IP_GLEANING 
....................                     if(AppConfig.Flags.bInConfigMode && !DHCPIsDisabled()) 
....................                     { 
....................                         /* 
....................                          * Accoriding to "IP Gleaning" procedure, 
....................                          * when we receive an ICMP packet with a valid 
....................                          * IP address while we are still in configuration 
....................                          * mode, accept that address as ours and conclude 
....................                          * configuration mode. 
....................                          */ 
....................                         if( tempLocalIP.Val != 0xffffffff ) 
....................                         { 
....................                             AppConfig.Flags.bInConfigMode = FALSE; 
....................                             AppConfig.MyIPAddr = tempLocalIP; 
....................                             myDHCPBindCount--; 
....................                         } 
....................                     } 
.................... #endif 
....................                 } 
....................  
.................... #if STACK_USE_TCP 
05B56:  BRA    5B70
....................                 else if ( type.IPFrameType == IP_PROT_TCP ) { 
05B58:  MOVF   xFD,W
05B5A:  SUBLW  06
05B5C:  BNZ   5B64
....................                     smStack = SM_STACK_TCP; 
05B5E:  MOVLW  06
05B60:  MOVWF  x92
....................                     debug_stack(debug_putc, "TCP "); 
....................                 } 
.................... #endif 
....................  
.................... #if STACK_USE_UDP 
05B62:  BRA    5B70
....................                 else if ( type.IPFrameType == IP_PROT_UDP ) { 
....................                     smStack = SM_STACK_UDP; 
....................                     debug_stack(debug_putc, "UDP "); 
....................                 } 
.................... #endif 
....................  
....................                 else 
....................                 { 
....................                     lbContinue = FALSE; 
05B64:  BCF    xFE.0
....................                     MACDiscardRx(); 
05B66:  MOVLB  0
05B68:  CALL   2C06
....................  
....................                     smStack = SM_STACK_IDLE; 
05B6C:  MOVLB  8
05B6E:  CLRF   x92
....................                     debug_stack(debug_putc, "UNKOWN-IP1 "); 
....................                 } 
....................             } 
05B70:  BRA    5B7C
05B72:  MOVLB  0
....................             else 
....................             { 
....................                 MACDiscardRx(); 
05B74:  CALL   2C06
....................                 smStack = SM_STACK_IDLE; 
05B78:  MOVLB  8
05B7A:  CLRF   x92
....................                 debug_stack(debug_putc, "UNKOWN-IP2 "); 
....................             } 
....................             break; 
05B7C:  BRA    5C60
....................  
.................... #if STACK_USE_UDP 
....................         case SM_STACK_UDP: 
....................             if ( UDPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
....................             { 
....................                 debug_stack(debug_putc, "\r\nUDP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
....................             } 
....................             break; 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................         case SM_STACK_TCP: 
....................             if ( TCPProcess(&remoteNode, &tempLocalIP, dataCount) ) 
05B7E:  MOVLW  08
05B80:  MOVLB  9
05B82:  MOVWF  x00
05B84:  MOVLW  93
05B86:  MOVLB  8
05B88:  MOVWF  xFF
05B8A:  MOVLW  08
05B8C:  MOVLB  9
05B8E:  MOVWF  x02
05B90:  MOVLW  F9
05B92:  MOVWF  x01
05B94:  MOVFF  89E,904
05B98:  MOVFF  89D,903
05B9C:  MOVLB  0
05B9E:  GOTO   5176
05BA2:  MOVF   01,F
05BA4:  BZ    5BAC
....................             { 
....................                 debug_stack(debug_putc, "\r\nTCP PROCESSED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
05BA6:  MOVLB  8
05BA8:  CLRF   x92
05BAA:  MOVLB  0
....................             } 
....................             break; 
05BAC:  MOVLB  8
05BAE:  BRA    5C60
.................... #endif 
....................  
....................         case SM_STACK_ICMP: 
....................             smStack = SM_STACK_IDLE; 
05BB0:  MOVLB  8
05BB2:  CLRF   x92
....................  
.................... #if STACK_USE_ICMP 
....................             //if ( dataCount <= (MAX_ICMP_DATA_LEN+9) ) 
....................             if ( dataCount <= (MAX_ICMP_DATA_LEN+8) ) 
05BB4:  MOVF   x9E,F
05BB6:  BNZ   5C0A
05BB8:  MOVF   x9D,W
05BBA:  SUBLW  48
05BBC:  BNC   5C0A
....................             { 
....................                 if ( ICMPGet(&type.ICMPCode, 
....................                              data, 
....................                              (BYTE*)&dataCount, 
....................                              &ICMPId, 
....................                              &ICMPSeq) ) 
05BBE:  MOVLW  08
05BC0:  MOVLB  9
05BC2:  MOVWF  x00
05BC4:  MOVLW  9D
05BC6:  MOVLB  8
05BC8:  MOVWF  xFF
05BCA:  MOVLW  08
05BCC:  MOVLB  9
05BCE:  MOVWF  x02
05BD0:  MOVLW  FD
05BD2:  MOVWF  x01
05BD4:  MOVLW  08
05BD6:  MOVWF  x04
05BD8:  MOVLW  9F
05BDA:  MOVWF  x03
05BDC:  MOVFF  900,906
05BE0:  MOVFF  8FF,905
05BE4:  MOVLW  08
05BE6:  MOVWF  x08
05BE8:  MOVLW  DF
05BEA:  MOVWF  x07
05BEC:  MOVLW  08
05BEE:  MOVWF  x0A
05BF0:  MOVLW  E1
05BF2:  MOVWF  x09
05BF4:  MOVLB  0
05BF6:  BRA    5406
05BF8:  MOVF   01,F
05BFA:  BZ    5C0C
....................                 { 
....................                     if ( type.ICMPCode == ICMP_ECHO_REQUEST ) 
05BFC:  MOVLB  8
05BFE:  MOVF   xFD,W
05C00:  SUBLW  08
05C02:  BNZ   5C0A
....................                     { 
....................                         debug_stack(debug_putc, "\r\nICMP PROCESSED"); 
....................                         lbContinue = TRUE; 
05C04:  BSF    xFE.0
....................                         smStack = SM_STACK_ICMP_REPLY; 
05C06:  MOVLW  04
05C08:  MOVWF  x92
05C0A:  MOVLB  0
....................                     } 
....................                 } 
....................             } 
....................             DebugDisplayVals(); 
.................... #endif 
....................             MACDiscardRx(); 
05C0C:  CALL   2C06
....................             break; 
05C10:  MOVLB  8
05C12:  BRA    5C60
....................  
.................... #if STACK_USE_ICMP 
....................         case SM_STACK_ICMP_REPLY: 
....................             if ( ICMPIsTxReady() ) 
05C14:  MOVLW  01
05C16:  MOVLB  9
05C18:  MOVWF  x86
05C1A:  MOVLB  0
05C1C:  CALL   41D6
05C20:  MOVF   01,F
05C22:  BZ    5C5A
....................             { 
....................                 ICMPPut(&remoteNode, 
....................                         ICMP_ECHO_REPLY, 
....................                         data, 
....................                         (BYTE)dataCount, 
....................                         ICMPId, 
....................                         ICMPSeq); 
05C24:  MOVLW  08
05C26:  MOVLB  9
05C28:  MOVWF  x00
05C2A:  MOVLW  93
05C2C:  MOVLB  8
05C2E:  MOVWF  xFF
05C30:  MOVLB  9
05C32:  CLRF   x01
05C34:  MOVLW  08
05C36:  MOVWF  x03
05C38:  MOVLW  9F
05C3A:  MOVWF  x02
05C3C:  MOVFF  89D,904
05C40:  MOVFF  8E0,906
05C44:  MOVFF  8DF,905
05C48:  MOVFF  8E2,908
05C4C:  MOVFF  8E1,907
05C50:  MOVLB  0
05C52:  BRA    54E0
....................  
....................                 debug_stack(debug_putc, "\r\nICMP REPLIED"); 
....................                 DebugDisplayVals(); 
....................                 smStack = SM_STACK_IDLE; 
05C54:  MOVLB  8
05C56:  CLRF   x92
05C58:  MOVLB  0
....................             } 
....................             break; 
05C5A:  MOVLB  8
05C5C:  BRA    5C60
05C5E:  MOVLB  8
.................... #endif 
....................  
....................         } 
....................  
....................     } while( lbContinue ); 
05C60:  BTFSC  xFE.0
05C62:  BRA    5AAC
....................  
.................... #if STACK_USE_SMTP 
....................    SMTPTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_ANNOUNCE 
....................    AnnounceTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_TCP 
....................     // Perform timed TCP FSM. 
....................     TCPTick(); 
05C64:  MOVLB  0
05C66:  BRA    55F0
.................... #endif 
....................  
.................... #if STACK_USE_TELNET 
....................    TelnetTask(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #if STACK_USE_HTTP2 
....................    HTTP_Task(); 
.................... #endif 
....................  
.................... #IF STACK_USE_FTP 
....................    FTPTask();    
.................... #ENDIF    
....................  
.................... #if STACK_USE_TFTP 
....................    TFTPTask(); 
.................... #endif 
....................  
....................  
.................... #if STACK_USE_DHCP 
05C68:  RETURN 0
....................     /* 
....................      * DHCP must be called all the time even after IP configuration is 
....................      * discovered. 
....................      * DHCP has to account lease expiration time and renew the configuration 
....................      * time. 
....................      */ 
....................     DHCPTask(); 
....................  
....................     if ( DHCPIsBound() ) 
....................         AppConfig.Flags.bInConfigMode = FALSE; 
....................  
.................... #endif 
.................... } 
....................  
....................  
.................... // Dirección IP de la PC (destino). 
.................... IP_ADDR server; 
.................... // Puerto TCP. 
.................... #define EXAMPLE_TCP_PORT   (int16)7654 
.................... //int reintento_envio; 
.................... // Microchip VendorID, MAC: 00-04-A3-XX-XX-XX. 
....................  
.................... void MACAddrInit(void) 
.................... { 
....................    MY_MAC_BYTE1=0x00; 
*
014B6:  MOVLB  3
014B8:  CLRF   x57
....................    MY_MAC_BYTE2=0x04; 
014BA:  MOVLW  04
014BC:  MOVWF  x58
....................    MY_MAC_BYTE3=0xA3; 
014BE:  MOVLW  A3
014C0:  MOVWF  x59
....................    MY_MAC_BYTE4=0x00; 
014C2:  CLRF   x5A
....................    MY_MAC_BYTE5=0x00; 
014C4:  CLRF   x5B
....................    MY_MAC_BYTE6=0x11; 
014C6:  MOVLW  11
014C8:  MOVWF  x5C
014CA:  MOVLB  0
014CC:  GOTO   7A92 (RETURN)
.................... } 
....................  
.................... void IPAddrInit(void) { 
....................    // IP del dispositivo. 
....................    MY_IP_BYTE1=192; 
014D0:  MOVLW  C0
014D2:  MOVLB  3
014D4:  MOVWF  x53
....................    MY_IP_BYTE2=168; 
014D6:  MOVLW  A8
014D8:  MOVWF  x54
....................    MY_IP_BYTE3=1; 
014DA:  MOVLW  01
014DC:  MOVWF  x55
....................    MY_IP_BYTE4=151; 
014DE:  MOVLW  97
014E0:  MOVWF  x56
....................  
....................    // Puerta de enlace. 
....................    MY_GATE_BYTE1=192; 
014E2:  MOVLW  C0
014E4:  MOVWF  x61
....................    MY_GATE_BYTE2=168; 
014E6:  MOVLW  A8
014E8:  MOVWF  x62
....................    MY_GATE_BYTE3=1; 
014EA:  MOVLW  01
014EC:  MOVWF  x63
....................    MY_GATE_BYTE4=254; 
014EE:  MOVLW  FE
014F0:  MOVWF  x64
....................  
....................    // Máscara de Subred. 
....................    MY_MASK_BYTE1=255; 
014F2:  SETF   x5D
....................    MY_MASK_BYTE2=255; 
014F4:  SETF   x5E
....................    MY_MASK_BYTE3=255; 
014F6:  SETF   x5F
....................    MY_MASK_BYTE4=0; 
014F8:  CLRF   x60
014FA:  MOVLB  0
014FC:  GOTO   7A96 (RETURN)
.................... } 
....................  
.................... void ServerAddrInit(void) { 
....................    // IP del servidor.. 
....................    server.v[0]=192; 
01500:  MOVLW  C0
01502:  MOVLB  8
01504:  MOVWF  xE3
....................    server.v[1]=168; 
01506:  MOVLW  A8
01508:  MOVWF  xE4
....................    server.v[2]=1; 
0150A:  MOVLW  01
0150C:  MOVWF  xE5
....................    server.v[3]=150; //server caja estacionamiento 
0150E:  MOVLW  96
01510:  MOVWF  xE6
01512:  MOVLB  0
01514:  GOTO   7A9A (RETURN)
....................    //server.v[3]=221;  //server pruebas 
.................... } 
.................... //this function is called by MyTCPTask() when the specified socket is connected 
.................... //to the PC running the TCPSERVER.EXE demo. 
.................... //returns TRUE if BUTTON2 was pressed, therefore we must disconnect the socket 
....................  
.................... int8 TCPConnectedTask(TCP_SOCKET socket) { 
....................    char c; 
....................    //static int8 counter; 
....................    //char str[20]; 
....................    static int8 button1_held; 
....................     
....................    if (TCPIsGetReady(socket)) {//ESCUCHA PUERTO TCP 
*
06880:  MOVFF  8FC,8FE
06884:  GOTO   5FC6
06888:  MOVF   01,F
0688A:  BZ    6912
....................       //fprintf(DEBUG,"\r\nLEE SOCKET"); 
.................... //   if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      lcd_putc("LEE SOCKET          ");         } 
....................       edo_str=1;//bandera de dato recibido en socket actual 
0688C:  MOVLW  01
0688E:  MOVWF  4E
....................       i=0; 
06890:  CLRF   41
06892:  CLRF   40
....................       while ( TCPGet(socket, &c) ) { 
06894:  MOVFF  8FC,8FE
06898:  MOVLW  08
0689A:  MOVLB  9
0689C:  MOVWF  x00
0689E:  MOVLW  FD
068A0:  MOVLB  8
068A2:  MOVWF  xFF
068A4:  MOVLB  0
068A6:  GOTO   600C
068AA:  MOVF   01,F
068AC:  BZ    6912
....................          rxtcp[i++]=c; 
068AE:  MOVFF  41,03
068B2:  MOVF   40,W
068B4:  INCF   40,F
068B6:  BTFSC  FD8.2
068B8:  INCF   41,F
068BA:  MOVLB  8
068BC:  MOVWF  xFE
068BE:  MOVLW  60
068C0:  ADDWF  xFE,W
068C2:  MOVWF  FE9
068C4:  MOVLW  01
068C6:  ADDWFC 03,W
068C8:  MOVWF  FEA
068CA:  MOVFF  8FD,FEF
....................          if (c=='@') { 
068CE:  MOVF   xFD,W
068D0:  SUBLW  40
068D2:  BNZ   68F0
....................             edo_str=0; 
068D4:  CLRF   4E
....................             lcd_gotoxy(20,4); 
068D6:  MOVLW  14
068D8:  MOVLB  9
068DA:  MOVWF  x00
068DC:  MOVLW  04
068DE:  MOVWF  x01
068E0:  MOVLB  0
068E2:  CALL   1056
....................             printf(lcd_putc,"%c",c); 
068E6:  MOVFF  8FD,8FF
068EA:  CALL   10A8
068EE:  MOVLB  8
....................          } 
....................          if (i>port_size) {i=port_size;} 
068F0:  MOVF   41,F
068F2:  BNZ   68FA
068F4:  MOVF   40,W
068F6:  SUBLW  5A
068F8:  BC    6900
068FA:  CLRF   41
068FC:  MOVLW  5A
068FE:  MOVWF  40
....................          rxtcp[i]=0; 
06900:  MOVLW  60
06902:  ADDWF  40,W
06904:  MOVWF  FE9
06906:  MOVLW  01
06908:  ADDWFC 41,W
0690A:  MOVWF  FEA
0690C:  CLRF   FEF
0690E:  MOVLB  0
06910:  BRA    6894
....................       } 
....................    } 
....................  
.................... //send message over TCP 
....................    //if(envia_pc) fprintf(DEBUG,"envia_pc:%u !button1_held:%u TCPIsPutReady(socket):%u\r\n",envia_pc,button1_held, TCPIsPutReady(socket) ); 
....................    if (envia_pc && !button1_held && TCPIsPutReady(socket)) {//ENVIA MENSAJE POR TCP 
06912:  MOVF   1A,F
06914:  BZ    695C
06916:  MOVLB  8
06918:  MOVF   xE7,F
0691A:  BTFSC  FD8.2
0691C:  BRA    6922
0691E:  MOVLB  0
06920:  BRA    695C
06922:  MOVFF  8FC,90E
06926:  MOVLB  0
06928:  CALL   60F4
0692C:  MOVF   01,F
0692E:  BZ    695C
....................       button1_held=TRUE; 
06930:  MOVLW  01
06932:  MOVLB  8
06934:  MOVWF  xE7
....................       TCPPutArray(socket,txtcp,size_tx_tcp);//SOCKET,DATO,NO.BYTES 
06936:  MOVFF  8FC,8FE
0693A:  MOVLB  9
0693C:  MOVWF  x00
0693E:  MOVLW  06
06940:  MOVLB  8
06942:  MOVWF  xFF
06944:  MOVLB  9
06946:  CLRF   x02
06948:  MOVFF  48,901
0694C:  MOVLB  0
0694E:  BRA    64DC
....................       TCPFlush(socket); 
06950:  MOVFF  8FC,909
06954:  RCALL  6300
....................       reintento_envio=0; 
06956:  CLRF   4F
....................       envia_pc=0; 
06958:  CLRF   1A
....................       //fprintf(DEBUG,"Envio:%s\r\n",txtcp); 
.................... //      if(!espera)   { 
.................... //      lcd_gotoxy(1,4); 
.................... //      printf(lcd_putc,"Envio:%s       ",txtcp);} 
....................    }////////////////// 
0695A:  BRA    6988
....................    else if (envia_pc && !button1_held && !TCPIsPutReady(socket)) {//SI NO PUEDE VACIAR DATOS ROMPE CONEXION 
0695C:  MOVF   1A,F
0695E:  BZ    6988
06960:  MOVLB  8
06962:  MOVF   xE7,F
06964:  BTFSC  FD8.2
06966:  BRA    696C
06968:  MOVLB  0
0696A:  BRA    6988
0696C:  MOVFF  8FC,90E
06970:  MOVLB  0
06972:  CALL   60F4
06976:  MOVF   01,F
06978:  BNZ   6988
....................       reintento_envio++; 
0697A:  INCF   4F,F
....................       if(reintento_envio>=10) TCPDisconnect(socket); 
0697C:  MOVF   4F,W
0697E:  SUBLW  09
06980:  BC    6988
06982:  MOVFF  8FC,8FE
06986:  RCALL  671A
....................    }/////////////////// 
....................     
....................    if (!envia_pc) { 
06988:  MOVF   1A,F
0698A:  BNZ   6992
....................       button1_held=FALSE; 
0698C:  MOVLB  8
0698E:  CLRF   xE7
06990:  MOVLB  0
....................    } 
....................     
....................    //#if defined(ESTADO_entrada04)//CIERRA LAS CONEXIONES 
....................    //if (ESTADO_entrada04) { 
....................      // return(TRUE); 
....................    //} 
....................   //#endif 
....................  
....................    return(TRUE); 
06992:  MOVLW  01
06994:  MOVWF  01
06996:  GOTO   6BF0 (RETURN)
.................... } 
....................  
.................... void MyTCPTask() { 
....................    static TICKTYPE lastTick; 
....................    static TCP_SOCKET socket=INVALID_SOCKET; 
....................    static enum { 
....................       MYTCP_STATE_NEW=0, MYTCP_STATE_ARP_REQ=1, MYTCP_STATE_ARP_WAIT=2, 
....................       MYTCP_STATE_CONNECT=3, MYTCP_STATE_CONNECT_WAIT=4, 
....................       MYTCP_STATE_CONNECTED=5, MYTCP_STATE_DISCONNECT=6, 
....................       MYTCP_STATE_FORCE_DISCONNECT=7 
....................    } state=0; 
....................    static NODE_INFO remote; 
....................    TICKTYPE currTick; 
....................    int8 dis; 
....................  
....................    currTick=TickGet(); 
0699A:  CALL   40BA
0699E:  MOVFF  02,8FA
069A2:  MOVFF  01,8F9
....................  
....................    switch (state) { 
069A6:  MOVLB  8
069A8:  MOVF   xEB,W
069AA:  ADDLW  F8
069AC:  BTFSC  FD8.0
069AE:  BRA    6CE4
069B0:  ADDLW  08
069B2:  MOVLB  0
069B4:  GOTO   6CE8
....................       case MYTCP_STATE_NEW: 
....................          memcpy(&remote.IPAddr, &server, sizeof(IP_ADDR)); 
069B8:  MOVLW  08
069BA:  MOVWF  FEA
069BC:  MOVLW  F2
069BE:  MOVWF  FE9
069C0:  MOVLW  08
069C2:  MOVWF  FE2
069C4:  MOVLW  E3
069C6:  MOVWF  FE1
069C8:  MOVLW  04
069CA:  MOVWF  01
069CC:  MOVFF  FE6,FEE
069D0:  DECFSZ 01,F
069D2:  BRA    69CC
....................          //fprintf(DEBUG,"\n Solicitud ARP."); 
....................          if(!espera)   { 
069D4:  MOVLB  2
069D6:  MOVF   x7D,F
069D8:  BNZ   69F8
....................          lcd_gotoxy(1,4); 
069DA:  MOVLW  01
069DC:  MOVLB  9
069DE:  MOVWF  x00
069E0:  MOVLW  04
069E2:  MOVWF  x01
069E4:  MOVLB  0
069E6:  CALL   1056
....................          lcd_putc("Solicitud ARP.      ");} 
069EA:  MOVLW  2A
069EC:  MOVWF  FF6
069EE:  MOVLW  01
069F0:  MOVWF  FF7
069F2:  CALL   110C
069F6:  MOVLB  2
....................          state=MYTCP_STATE_ARP_REQ; 
069F8:  MOVLW  01
069FA:  MOVLB  8
069FC:  MOVWF  xEB
069FE:  MOVLB  0
....................  
....................       case MYTCP_STATE_ARP_REQ: 
....................          if (ARPIsTxReady()) { 
06A00:  MOVLW  01
06A02:  MOVLB  9
06A04:  MOVWF  x86
06A06:  MOVLB  0
06A08:  CALL   41D6
06A0C:  MOVF   01,F
06A0E:  BZ    6A30
....................             ARPResolve(&remote.IPAddr); 
06A10:  MOVLW  08
06A12:  MOVLB  8
06A14:  MOVWF  xFD
06A16:  MOVLW  F2
06A18:  MOVWF  xFC
06A1A:  MOVLB  0
06A1C:  GOTO   5C92
....................             lastTick=currTick; 
06A20:  MOVFF  8FA,8E9
06A24:  MOVFF  8F9,8E8
....................             state=MYTCP_STATE_ARP_WAIT; 
06A28:  MOVLW  02
06A2A:  MOVLB  8
06A2C:  MOVWF  xEB
06A2E:  MOVLB  0
....................          } 
....................          break; 
06A30:  MOVLB  8
06A32:  BRA    6CE4
....................  
....................       case MYTCP_STATE_ARP_WAIT: 
....................          if (ARPIsResolved(&remote.IPAddr, &remote.MACAddr)) { 
06A34:  MOVLW  08
06A36:  MOVLB  8
06A38:  MOVWF  xFD
06A3A:  MOVLW  F2
06A3C:  MOVWF  xFC
06A3E:  MOVLW  08
06A40:  MOVWF  xFF
06A42:  MOVLW  EC
06A44:  MOVWF  xFE
06A46:  MOVLB  0
06A48:  GOTO   5CD4
06A4C:  MOVF   01,F
06A4E:  BZ    6A7C
....................             state=MYTCP_STATE_CONNECT; 
06A50:  MOVLW  03
06A52:  MOVLB  8
06A54:  MOVWF  xEB
....................             //fprintf(DEBUG,"\nCONECTANDO...      "); 
....................             if(!espera)   { 
06A56:  MOVLB  2
06A58:  MOVF   x7D,F
06A5A:  BNZ   6A7A
....................             lcd_gotoxy(1,4); 
06A5C:  MOVLW  01
06A5E:  MOVLB  9
06A60:  MOVWF  x00
06A62:  MOVLW  04
06A64:  MOVWF  x01
06A66:  MOVLB  0
06A68:  CALL   1056
....................             lcd_putc("CONECTANDO...       ");} 
06A6C:  MOVLW  40
06A6E:  MOVWF  FF6
06A70:  MOVLW  01
06A72:  MOVWF  FF7
06A74:  CALL   110C
06A78:  MOVLB  2
....................          } 
06A7A:  BRA    6AD6
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 2)) { 
06A7C:  MOVLB  8
06A7E:  MOVF   xFA,W
06A80:  SUBWF  xE9,W
06A82:  BNC   6A8C
06A84:  BNZ   6A90
06A86:  MOVF   xE8,W
06A88:  SUBWF  xF9,W
06A8A:  BNC   6A90
06A8C:  MOVLW  00
06A8E:  BRA    6A92
06A90:  MOVLW  01
06A92:  CLRF   03
06A94:  IORWF  03,W
06A96:  BZ    6ABE
06A98:  MOVLW  FF
06A9A:  BSF    FD8.0
06A9C:  SUBFWB xE8,W
06A9E:  MOVWF  xFC
06AA0:  MOVLW  FF
06AA2:  SUBFWB xE9,W
06AA4:  MOVWF  xFD
06AA6:  MOVF   xF9,W
06AA8:  ADDWF  xFC,F
06AAA:  MOVF   xFA,W
06AAC:  ADDWFC xFD,F
06AAE:  MOVLW  01
06AB0:  ADDWF  xFC,W
06AB2:  MOVWF  01
06AB4:  MOVLW  00
06AB6:  ADDWFC xFD,W
06AB8:  MOVWF  03
06ABA:  MOVF   01,W
06ABC:  BRA    6ACC
06ABE:  MOVF   xE8,W
06AC0:  SUBWF  xF9,W
06AC2:  MOVWF  00
06AC4:  MOVF   xE9,W
06AC6:  SUBWFB xFA,W
06AC8:  MOVWF  03
06ACA:  MOVF   00,W
06ACC:  SUBLW  18
06ACE:  BC    6AD4
....................             state=MYTCP_STATE_ARP_REQ; 
06AD0:  MOVLW  01
06AD2:  MOVWF  xEB
06AD4:  MOVLB  2
....................          } 
....................          break; 
06AD6:  MOVLB  8
06AD8:  BRA    6CE4
....................  
....................       case MYTCP_STATE_CONNECT: 
....................          socket2=socket=TCPConnect(&remote, EXAMPLE_TCP_PORT); 
06ADA:  MOVLW  08
06ADC:  MOVLB  8
06ADE:  MOVWF  xFD
06AE0:  MOVLW  EC
06AE2:  MOVWF  xFC
06AE4:  MOVLW  1D
06AE6:  MOVWF  xFF
06AE8:  MOVLW  E6
06AEA:  MOVWF  xFE
06AEC:  MOVLB  0
06AEE:  GOTO   5D5E
06AF2:  MOVFF  01,8EA
06AF6:  MOVFF  8EA,51
....................          if (socket!=INVALID_SOCKET) { 
06AFA:  MOVLB  8
06AFC:  MOVF   xEA,W
06AFE:  SUBLW  FE
06B00:  BZ    6B18
....................             lastTick=TickGet(); 
06B02:  MOVLB  0
06B04:  CALL   40BA
06B08:  MOVFF  02,8E9
06B0C:  MOVFF  01,8E8
....................             state=MYTCP_STATE_CONNECT_WAIT; 
06B10:  MOVLW  04
06B12:  MOVLB  8
06B14:  MOVWF  xEB
....................          } 
06B16:  BRA    6B3E
....................          else { 
....................             //fprintf(DEBUG,"\nError en el socket."); 
....................             if(!espera)   { 
06B18:  MOVLB  2
06B1A:  MOVF   x7D,F
06B1C:  BNZ   6B3C
....................                lcd_gotoxy(1,4);  
06B1E:  MOVLW  01
06B20:  MOVLB  9
06B22:  MOVWF  x00
06B24:  MOVLW  04
06B26:  MOVWF  x01
06B28:  MOVLB  0
06B2A:  CALL   1056
....................                lcd_putc("Error en el socket. ");} 
06B2E:  MOVLW  56
06B30:  MOVWF  FF6
06B32:  MOVLW  01
06B34:  MOVWF  FF7
06B36:  CALL   110C
06B3A:  MOVLB  2
06B3C:  MOVLB  8
....................          } 
....................          break; 
06B3E:  BRA    6CE4
....................  
....................       case MYTCP_STATE_CONNECT_WAIT: 
....................          if (TCPIsConnected(socket)) { 
06B40:  MOVFF  8EA,8FC
06B44:  CALL   5F8A
06B48:  MOVF   01,F
06B4A:  BZ    6B80
....................             state=MYTCP_STATE_CONNECTED; 
06B4C:  MOVLW  05
06B4E:  MOVLB  8
06B50:  MOVWF  xEB
....................             //fprintf(DEBUG,"\nCONECTADO! "); 
....................             if(!espera)   { 
06B52:  MOVLB  2
06B54:  MOVF   x7D,F
06B56:  BNZ   6B76
....................                lcd_gotoxy(1,4); 
06B58:  MOVLW  01
06B5A:  MOVLB  9
06B5C:  MOVWF  x00
06B5E:  MOVLW  04
06B60:  MOVWF  x01
06B62:  MOVLB  0
06B64:  CALL   1056
....................                lcd_putc("CONECTADO           ");} 
06B68:  MOVLW  6C
06B6A:  MOVWF  FF6
06B6C:  MOVLW  01
06B6E:  MOVWF  FF7
06B70:  CALL   110C
06B74:  MOVLB  2
....................             output_high(salida06); 
06B76:  BCF    F94.2
06B78:  BSF    F8B.2
....................             inicializado=1; 
06B7A:  MOVLW  01
06B7C:  MOVWF  50
....................          } 
06B7E:  BRA    6BDA
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
06B80:  MOVLB  8
06B82:  MOVF   xFA,W
06B84:  SUBWF  xE9,W
06B86:  BNC   6B90
06B88:  BNZ   6B94
06B8A:  MOVF   xE8,W
06B8C:  SUBWF  xF9,W
06B8E:  BNC   6B94
06B90:  MOVLW  00
06B92:  BRA    6B96
06B94:  MOVLW  01
06B96:  CLRF   03
06B98:  IORWF  03,W
06B9A:  BZ    6BC2
06B9C:  MOVLW  FF
06B9E:  BSF    FD8.0
06BA0:  SUBFWB xE8,W
06BA2:  MOVWF  xFC
06BA4:  MOVLW  FF
06BA6:  SUBFWB xE9,W
06BA8:  MOVWF  xFD
06BAA:  MOVF   xF9,W
06BAC:  ADDWF  xFC,F
06BAE:  MOVF   xFA,W
06BB0:  ADDWFC xFD,F
06BB2:  MOVLW  01
06BB4:  ADDWF  xFC,W
06BB6:  MOVWF  01
06BB8:  MOVLW  00
06BBA:  ADDWFC xFD,W
06BBC:  MOVWF  03
06BBE:  MOVF   01,W
06BC0:  BRA    6BD0
06BC2:  MOVF   xE8,W
06BC4:  SUBWF  xF9,W
06BC6:  MOVWF  00
06BC8:  MOVF   xE9,W
06BCA:  SUBWFB xFA,W
06BCC:  MOVWF  03
06BCE:  MOVF   00,W
06BD0:  SUBLW  78
06BD2:  BC    6BD8
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
06BD4:  MOVLW  07
06BD6:  MOVWF  xEB
06BD8:  MOVLB  2
....................          } 
....................          break; 
06BDA:  MOVLB  8
06BDC:  BRA    6CE4
....................  
....................       case MYTCP_STATE_CONNECTED: 
....................          if (TCPIsConnected(socket)) { 
06BDE:  MOVFF  8EA,8FC
06BE2:  CALL   5F8A
06BE6:  MOVF   01,F
06BE8:  BZ    6C06
....................             dis=TCPConnectedTask(socket); 
06BEA:  MOVFF  8EA,8FC
06BEE:  BRA    6880
06BF0:  MOVFF  01,8FB
....................             //fprintf(DEBUG,"\ndis:%u ",dis); 
....................             if (dis) { 
06BF4:  MOVLB  8
06BF6:  MOVF   xFB,F
06BF8:  BZ    6C02
....................                //state=MYTCP_STATE_DISCONNECT; 
....................                lastTick=currTick; 
06BFA:  MOVFF  8FA,8E9
06BFE:  MOVFF  8F9,8E8
....................             } 
....................          } 
06C02:  BRA    6C0C
06C04:  MOVLB  0
....................          else { 
....................             //fprintf(DEBUG,"\nDESCONECTADO.   "); 
....................             //state=MYTCP_STATE_CONNECT; 
....................             state=MYTCP_STATE_DISCONNECT; 
06C06:  MOVLW  06
06C08:  MOVLB  8
06C0A:  MOVWF  xEB
....................             //output_low(salida06); 
....................          } 
....................          break; 
06C0C:  BRA    6CE4
....................  
....................       case MYTCP_STATE_DISCONNECT: 
....................          //fprintf(DEBUG,"\nDESCONECTANDO.   "); 
....................          if(!espera)   { 
06C0E:  MOVLB  2
06C10:  MOVF   x7D,F
06C12:  BNZ   6C32
....................             lcd_gotoxy(1,4); 
06C14:  MOVLW  01
06C16:  MOVLB  9
06C18:  MOVWF  x00
06C1A:  MOVLW  04
06C1C:  MOVWF  x01
06C1E:  MOVLB  0
06C20:  CALL   1056
....................             lcd_putc("DESCONECTADO       ");} 
06C24:  MOVLW  82
06C26:  MOVWF  FF6
06C28:  MOVLW  01
06C2A:  MOVWF  FF7
06C2C:  CALL   110C
06C30:  MOVLB  2
....................          output_low(salida06); 
06C32:  BCF    F94.2
06C34:  BCF    F8B.2
....................          inicializado=0; 
06C36:  CLRF   50
....................          if (TCPIsPutReady(socket)) { 
06C38:  MOVFF  8EA,90E
06C3C:  MOVLB  0
06C3E:  CALL   60F4
06C42:  MOVF   01,F
06C44:  BZ    6C4E
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
06C46:  MOVLW  07
06C48:  MOVLB  8
06C4A:  MOVWF  xEB
....................          } 
06C4C:  BRA    6CA6
....................          else if (TickGetDiff(currTick, lastTick) > (TICKS_PER_SECOND * 10)) { 
06C4E:  MOVLB  8
06C50:  MOVF   xFA,W
06C52:  SUBWF  xE9,W
06C54:  BNC   6C5E
06C56:  BNZ   6C62
06C58:  MOVF   xE8,W
06C5A:  SUBWF  xF9,W
06C5C:  BNC   6C62
06C5E:  MOVLW  00
06C60:  BRA    6C64
06C62:  MOVLW  01
06C64:  CLRF   03
06C66:  IORWF  03,W
06C68:  BZ    6C90
06C6A:  MOVLW  FF
06C6C:  BSF    FD8.0
06C6E:  SUBFWB xE8,W
06C70:  MOVWF  xFC
06C72:  MOVLW  FF
06C74:  SUBFWB xE9,W
06C76:  MOVWF  xFD
06C78:  MOVF   xF9,W
06C7A:  ADDWF  xFC,F
06C7C:  MOVF   xFA,W
06C7E:  ADDWFC xFD,F
06C80:  MOVLW  01
06C82:  ADDWF  xFC,W
06C84:  MOVWF  01
06C86:  MOVLW  00
06C88:  ADDWFC xFD,W
06C8A:  MOVWF  03
06C8C:  MOVF   01,W
06C8E:  BRA    6C9E
06C90:  MOVF   xE8,W
06C92:  SUBWF  xF9,W
06C94:  MOVWF  00
06C96:  MOVF   xE9,W
06C98:  SUBWFB xFA,W
06C9A:  MOVWF  03
06C9C:  MOVF   00,W
06C9E:  SUBLW  78
06CA0:  BC    6CA6
....................             state=MYTCP_STATE_FORCE_DISCONNECT; 
06CA2:  MOVLW  07
06CA4:  MOVWF  xEB
....................          } 
....................          break; 
06CA6:  BRA    6CE4
....................  
....................       case MYTCP_STATE_FORCE_DISCONNECT: 
....................          TCPDisconnect(socket); 
06CA8:  MOVFF  8EA,8FE
06CAC:  RCALL  671A
....................          state=MYTCP_STATE_CONNECT; 
06CAE:  MOVLW  03
06CB0:  MOVLB  8
06CB2:  MOVWF  xEB
....................          if(!espera)   { 
06CB4:  MOVLB  2
06CB6:  MOVF   x7D,F
06CB8:  BNZ   6CD8
....................             lcd_gotoxy(1,4); 
06CBA:  MOVLW  01
06CBC:  MOVLB  9
06CBE:  MOVWF  x00
06CC0:  MOVLW  04
06CC2:  MOVWF  x01
06CC4:  MOVLB  0
06CC6:  CALL   1056
....................             lcd_putc("DESCONECTADO       ");} 
06CCA:  MOVLW  96
06CCC:  MOVWF  FF6
06CCE:  MOVLW  01
06CD0:  MOVWF  FF7
06CD2:  CALL   110C
06CD6:  MOVLB  2
....................          output_low(salida06); 
06CD8:  BCF    F94.2
06CDA:  BCF    F8B.2
....................          inicializado=0; 
06CDC:  CLRF   50
....................          break; 
06CDE:  MOVLB  8
06CE0:  BRA    6CE4
06CE2:  MOVLB  8
....................    } 
06CE4:  MOVLB  0
06CE6:  RETURN 0
.................... } 
....................  
.................... ////wiegand/// 
.................... #int_TIMER1 //se utiliza timer 1 porque el 0 esta asignado al wdt 
.................... void TIMER1_isr(void){ 
.................... wiegand_cuenta++; 
*
001AA:  MOVLB  2
001AC:  INCF   x11,F
.................... time_relay1++; 
001AE:  INCF   1F,F
.................... time_boleto++; 
001B0:  INCF   x89,F
.................... cuenta++; 
001B2:  INCF   x7C,F
.................... cta_lcd++; 
001B4:  INCF   x8B,F
.................... set_timer1(3036); //50 ms 
001B6:  MOVLW  0B
001B8:  MOVWF  FCF
001BA:  MOVLW  DC
001BC:  MOVWF  FCE
.................... } 
....................  
001BE:  BCF    F9E.0
001C0:  MOVLB  0
001C2:  GOTO   0084
.................... #int_ext 
.................... void EXT_isr(void){//data1 
....................    while (!input(PIN_B0) ) {} 
001C6:  BSF    F93.0
001C8:  BTFSS  F81.0
001CA:  BRA    01C6
....................    wiegand_cuenta=0; 
001CC:  MOVLB  2
001CE:  CLRF   x11
....................    wieg=1; 
001D0:  MOVLW  01
001D2:  MOVWF  x0C
....................    data[sub_indice]=1; 
001D4:  CLRF   03
001D6:  MOVF   x0F,W
001D8:  ADDLW  16
001DA:  MOVWF  FE9
001DC:  MOVLW  02
001DE:  ADDWFC 03,W
001E0:  MOVWF  FEA
001E2:  MOVLW  01
001E4:  MOVWF  FEF
....................    sub_indice++; 
001E6:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
001E8:  MOVF   x0F,W
001EA:  SUBLW  1A
001EC:  BNZ   01F2
....................       wieg_full=1; 
001EE:  MOVLW  01
001F0:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
.................... } 
....................  
001F2:  BCF    FF2.1
001F4:  MOVLB  0
001F6:  GOTO   0084
.................... #int_ext1 
.................... void EXT1_isr(void){//data0 
....................    while (!input(PIN_B1) ) {} 
001FA:  BSF    F93.1
001FC:  BTFSS  F81.1
001FE:  BRA    01FA
....................    wiegand_cuenta=0; 
00200:  MOVLB  2
00202:  CLRF   x11
....................    wieg=1; 
00204:  MOVLW  01
00206:  MOVWF  x0C
....................    data[sub_indice]=0; 
00208:  CLRF   03
0020A:  MOVF   x0F,W
0020C:  ADDLW  16
0020E:  MOVWF  FE9
00210:  MOVLW  02
00212:  ADDWFC 03,W
00214:  MOVWF  FEA
00216:  CLRF   FEF
....................    sub_indice++; 
00218:  INCF   x0F,F
....................    if(sub_indice==wieg_size)  { 
0021A:  MOVF   x0F,W
0021C:  SUBLW  1A
0021E:  BNZ   0224
....................       wieg_full=1; 
00220:  MOVLW  01
00222:  MOVWF  x10
....................       //wiegand_read_card(); 
....................    } 
00224:  BCF    FF0.0
00226:  MOVLB  0
00228:  GOTO   0084
.................... } 
.................... /////////////////////// 
.................... //funciones extra 
.................... void wiegand_read_card(); 
.................... void enviar_tcp(); 
.................... /////////boleto//////////////////// 
.................... void reset(); 
.................... void encri(); 
.................... void barra1(); 
.................... void barra2(); 
.................... void CR(); 
.................... void LF(); 
.................... void ticket(); 
.................... void sensores(); 
.................... void llaves(); 
.................... void rd_eeprom(); 
.................... void zeller(); 
.................... void horario(); 
.................... void fecha(); 
....................  
.................... void main(void) { 
*
078E8:  CLRF   FF8
078EA:  BCF    FD0.7
078EC:  BSF    07.7
078EE:  CLRF   19
078F0:  BCF    FB8.3
078F2:  MOVLW  40
078F4:  MOVWF  FAF
078F6:  MOVLW  A6
078F8:  MOVWF  FAC
078FA:  MOVLW  90
078FC:  MOVWF  FAB
078FE:  MOVLB  2
07900:  CLRF   x0F
07902:  CLRF   x10
07904:  MOVLB  3
07906:  CLRF   x8C
07908:  CLRF   x8B
0790A:  CLRF   x8D
0790C:  CLRF   x8E
0790E:  CLRF   x96
07910:  CLRF   x95
07912:  MOVLW  04
07914:  MOVWF  x99
07916:  CLRF   x98
07918:  MOVLW  FE
0791A:  MOVLB  8
0791C:  MOVWF  xEA
0791E:  CLRF   xEB
07920:  CLRF   xF7
07922:  CLRF   xF6
07924:  MOVF   FC1,W
07926:  ANDLW  C0
07928:  IORLW  0F
0792A:  MOVWF  FC1
0792C:  MOVLW  07
0792E:  MOVWF  FB4
07930:  MOVLB  3
07932:  BCF    x93.1
07934:  BRA    7A2C
07936:  DATA 0B,02
07938:  DATA 8D,42
0793A:  DATA 4F,4C
0793C:  DATA 45,54
0793E:  DATA 4F,5F
07940:  DATA 46,4F
07942:  DATA 4C,00
07944:  DATA 0B,02
07946:  DATA 99,42
07948:  DATA 4F,52
0794A:  DATA 52,41
0794C:  DATA 52,54
0794E:  DATA 4F,44
07950:  DATA 4F,00
07952:  DATA 0B,02
07954:  DATA A5,42
07956:  DATA 4F,52
07958:  DATA 52,41
0795A:  DATA 52,5F
0795C:  DATA 54,41
0795E:  DATA 47,00
07960:  DATA 0B,02
07962:  DATA B1,41
07964:  DATA 42,52
07966:  DATA 49,52
07968:  DATA 5F,45
0796A:  DATA 4E,54
0796C:  DATA 52,00
0796E:  DATA 0B,02
07970:  DATA BD,43
07972:  DATA 55,50
07974:  DATA 4F,5F
07976:  DATA 4C,4C
07978:  DATA 45,4E
0797A:  DATA 4F,00
0797C:  DATA 0B,02
0797E:  DATA C9,43
07980:  DATA 55,50
07982:  DATA 4F,5F
07984:  DATA 44,49
07986:  DATA 53,50
07988:  DATA 4F,00
0798A:  DATA 0B,02
0798C:  DATA D5,4D
0798E:  DATA 45,4E
07990:  DATA 53,41
07992:  DATA 4A,45
07994:  DATA 45,4E
07996:  DATA 31,00
07998:  DATA 0A,42
0799A:  DATA E1,20
0799C:  DATA 01,80
0799E:  DATA 00,0B
079A0:  DATA 02,ED
079A2:  DATA 43,4F
079A4:  DATA 4E,53
079A6:  DATA 55,4C
079A8:  DATA 54,41
079AA:  DATA 30,31
079AC:  DATA 00,0B
079AE:  DATA 02,F9
079B0:  DATA 43,4F
079B2:  DATA 4E,46
079B4:  DATA 49,47
079B6:  DATA 44,41
079B8:  DATA 54,45
079BA:  DATA 00,0B
079BC:  DATA 03,05
079BE:  DATA 43,4F
079C0:  DATA 4E,46
079C2:  DATA 49,47
079C4:  DATA 55,52
079C6:  DATA 41,42
079C8:  DATA 00,0B
079CA:  DATA 03,11
079CC:  DATA 42,4F
079CE:  DATA 52,52
079D0:  DATA 41,5F
079D2:  DATA 43,4F
079D4:  DATA 4E,31
079D6:  DATA 00,0B
079D8:  DATA 03,1D
079DA:  DATA 46,4F
079DC:  DATA 4C,49
079DE:  DATA 4F,52
079E0:  DATA 45,53
079E2:  DATA 45,54
079E4:  DATA 00,06
079E6:  DATA 03,29
079E8:  DATA 50,41
079EA:  DATA 47,41
079EC:  DATA 44,4F
079EE:  DATA 04,C0
079F0:  DATA 30,01
079F2:  DATA 80,00
079F4:  DATA 18,03
079F6:  DATA 35,42
079F8:  DATA 4F,4C
079FA:  DATA 45,54
079FC:  DATA 4F,00
079FE:  DATA 42,41
07A00:  DATA 52,52
07A02:  DATA 45,52
07A04:  DATA 41,41
07A06:  DATA 42,49
07A08:  DATA 45,52
07A0A:  DATA 54,41
07A0C:  DATA 45,31
07A0E:  DATA 00,02
07A10:  DATA 03,84
07A12:  DATA 00,00
07A14:  DATA 01,03
07A16:  DATA 97,00
07A18:  DATA 0A,48
07A1A:  DATA 88,00
07A1C:  DATA 46,48
07A1E:  DATA 9D,00
07A20:  DATA 03,08
07A22:  DATA E7,00
07A24:  DATA 00,00
07A26:  DATA 0A,48
07A28:  DATA EC,00
07A2A:  DATA 00,00
07A2C:  MOVLW  00
07A2E:  MOVWF  FF8
07A30:  MOVLW  79
07A32:  MOVWF  FF7
07A34:  MOVLW  36
07A36:  MOVWF  FF6
07A38:  TBLRD*+
07A3A:  MOVF   FF5,W
07A3C:  MOVWF  00
07A3E:  XORLW  00
07A40:  BZ    7A68
07A42:  TBLRD*+
07A44:  MOVF   FF5,W
07A46:  MOVWF  01
07A48:  BTFSC  FE8.7
07A4A:  BRA    7A56
07A4C:  ANDLW  0F
07A4E:  MOVWF  FEA
07A50:  TBLRD*+
07A52:  MOVFF  FF5,FE9
07A56:  BTFSC  01.6
07A58:  TBLRD*+
07A5A:  BTFSS  01.6
07A5C:  TBLRD*+
07A5E:  MOVFF  FF5,FEE
07A62:  DCFSNZ 00,F
07A64:  BRA    7A38
07A66:  BRA    7A5A
07A68:  CLRF   FF8
....................    //fprintf(DEBUG,"\r\n\nCLIENTE TCP/IP\r\n"); 
....................    lcd_putc("\fINICIANDO"); 
07A6A:  MOVLW  2C
07A6C:  MOVWF  FF6
07A6E:  MOVLW  02
07A70:  MOVWF  FF7
07A72:  MOVLB  0
07A74:  CALL   110C
....................    setup_adc_ports(NO_ANALOGS); 
07A78:  MOVF   FC1,W
07A7A:  ANDLW  C0
07A7C:  IORLW  0F
07A7E:  MOVWF  FC1
....................    setup_adc(ADC_OFF); 
07A80:  BCF    FC2.0
....................     
....................    init_ext_eeprom();//iniciar memoria 
07A82:  GOTO   112C
....................    lcd_init();//iniciar LCD 
07A86:  GOTO   1134
....................    llaves(); 
07A8A:  GOTO   11B2
....................     
....................    MACAddrInit(); 
07A8E:  GOTO   14B6
....................    IPAddrInit(); 
07A92:  GOTO   14D0
....................    ServerAddrInit(); 
07A96:  GOTO   1500
....................    StackInit(); 
07A9A:  GOTO   1CF0
....................  
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_8);//Setup timer: Reloj interno, preescaler= 8 
07A9E:  MOVLW  B5
07AA0:  MOVWF  FCD
....................    enable_interrupts(INT_TIMER1);//Habilito interrupción particular del TIMER1 
07AA2:  BSF    F9D.0
....................    set_timer1(3036);//Carga del TMR1 
07AA4:  MOVLW  0B
07AA6:  MOVWF  FCF
07AA8:  MOVLW  DC
07AAA:  MOVWF  FCE
....................    ext_int_edge(0,L_TO_H);       //Asigno flancos de subida 
07AAC:  BSF    FF1.6
....................    ext_int_edge(1,L_TO_H);       //Asigno flancos de subida 
07AAE:  BSF    FF1.5
....................    enable_interrupts(INT_EXT1); 
07AB0:  BSF    FF0.3
....................    enable_interrupts(INT_EXT); 
07AB2:  BSF    FF2.4
....................    enable_interrupts(GLOBAL);//Habilito interrupciones globales 
07AB4:  MOVLW  C0
07AB6:  IORWF  FF2,F
....................     
....................     ticket(); 
07AB8:  CALL   207E
....................     
....................    envia_pc=0; 
07ABC:  CLRF   1A
....................    //int linked_out=0; 
....................    edo_str=envia_pc=0; 
07ABE:  CLRF   1A
07AC0:  MOVFF  1A,4E
....................    re_bol=0; 
07AC4:  MOVLB  2
07AC6:  CLRF   x8A
....................    //leyendo validacion de pago 
....................    int vigencia; 
....................    vigencia=read_ext_eeprom(10); 
07AC8:  MOVLB  9
07ACA:  CLRF   x0A
07ACC:  MOVLW  0A
07ACE:  MOVWF  x09
07AD0:  MOVLB  0
07AD2:  CALL   28AC
07AD6:  MOVFF  01,8F8
....................    if(vigencia!=1) { 
07ADA:  MOVLB  8
07ADC:  DECFSZ xF8,W
07ADE:  BRA    7AE2
07AE0:  BRA    7B26
....................       write_ext_eeprom(10,1); 
07AE2:  MOVLB  9
07AE4:  CLRF   x0A
07AE6:  MOVLW  0A
07AE8:  MOVWF  x09
07AEA:  MOVLW  01
07AEC:  MOVWF  x0B
07AEE:  MOVLB  0
07AF0:  CALL   2954
....................       write_ext_eeprom(11,0); 
07AF4:  MOVLB  9
07AF6:  CLRF   x0A
07AF8:  MOVLW  0B
07AFA:  MOVWF  x09
07AFC:  CLRF   x0B
07AFE:  MOVLB  0
07B00:  CALL   2954
....................       write_ext_eeprom(12,0); 
07B04:  MOVLB  9
07B06:  CLRF   x0A
07B08:  MOVLW  0C
07B0A:  MOVWF  x09
07B0C:  CLRF   x0B
07B0E:  MOVLB  0
07B10:  CALL   2954
....................       write_ext_eeprom(13,0); 
07B14:  MOVLB  9
07B16:  CLRF   x0A
07B18:  MOVLW  0D
07B1A:  MOVWF  x09
07B1C:  CLRF   x0B
07B1E:  MOVLB  0
07B20:  CALL   2954
07B24:  MOVLB  8
....................    } 
....................    pago=read_ext_eeprom(11);// 
07B26:  MOVLB  9
07B28:  CLRF   x0A
07B2A:  MOVLW  0B
07B2C:  MOVWF  x09
07B2E:  MOVLB  0
07B30:  CALL   28AC
07B34:  MOVFF  01,27B
....................    dias_prueba=read_ext_eeprom(12);//dias de prueba 
07B38:  MOVLB  9
07B3A:  CLRF   x0A
07B3C:  MOVLW  0C
07B3E:  MOVWF  x09
07B40:  MOVLB  0
07B42:  CALL   28AC
07B46:  MOVFF  01,279
....................    dia_temp=read_ext_eeprom(13);// 
07B4A:  MOVLB  9
07B4C:  CLRF   x0A
07B4E:  MOVLW  0D
07B50:  MOVWF  x09
07B52:  MOVLB  0
07B54:  CALL   28AC
07B58:  MOVFF  01,27A
....................    lcd_gotoxy(1,1); 
07B5C:  MOVLW  01
07B5E:  MOVLB  9
07B60:  MOVWF  x00
07B62:  MOVWF  x01
07B64:  MOVLB  0
07B66:  CALL   1056
....................    printf(lcd_putc,"Dias:%u PAGO:%d",dias_prueba,pago); 
07B6A:  MOVLW  38
07B6C:  MOVWF  FF6
07B6E:  MOVLW  02
07B70:  MOVWF  FF7
07B72:  MOVLW  05
07B74:  MOVLB  8
07B76:  MOVWF  xFA
07B78:  MOVLB  0
07B7A:  CALL   2A5A
07B7E:  MOVFF  279,8FA
07B82:  MOVLW  1B
07B84:  MOVLB  8
07B86:  MOVWF  xFB
07B88:  MOVLB  0
07B8A:  CALL   2A84
07B8E:  MOVLW  3F
07B90:  MOVWF  FF6
07B92:  MOVLW  02
07B94:  MOVWF  FF7
07B96:  MOVLW  06
07B98:  MOVLB  8
07B9A:  MOVWF  xFA
07B9C:  MOVLB  0
07B9E:  CALL   2A5A
07BA2:  MOVFF  27B,8F9
07BA6:  MOVLW  18
07BA8:  MOVLB  8
07BAA:  MOVWF  xFA
07BAC:  MOVLB  0
07BAE:  GOTO   2B0A
....................    lcd_gotoxy(1,2); 
07BB2:  MOVLW  01
07BB4:  MOVLB  9
07BB6:  MOVWF  x00
07BB8:  MOVLW  02
07BBA:  MOVWF  x01
07BBC:  MOVLB  0
07BBE:  CALL   1056
....................    printf(lcd_putc,"Restan:%u ",(dia_limite-dias_prueba) ); 
07BC2:  MOVLW  5A
07BC4:  BSF    FD8.0
07BC6:  MOVLB  2
07BC8:  SUBFWB x79,W
07BCA:  MOVLB  8
07BCC:  MOVWF  xF9
07BCE:  MOVLW  48
07BD0:  MOVWF  FF6
07BD2:  MOVLW  02
07BD4:  MOVWF  FF7
07BD6:  MOVLW  07
07BD8:  MOVWF  xFA
07BDA:  MOVLB  0
07BDC:  CALL   2A5A
07BE0:  MOVFF  8F9,8FA
07BE4:  MOVLW  1B
07BE6:  MOVLB  8
07BE8:  MOVWF  xFB
07BEA:  MOVLB  0
07BEC:  CALL   2A84
07BF0:  MOVLW  20
07BF2:  MOVLB  8
07BF4:  MOVWF  xFF
07BF6:  MOVLB  0
07BF8:  CALL   10A8
....................    delay_ms(1000); 
07BFC:  MOVLW  04
07BFE:  MOVLB  8
07C00:  MOVWF  xF9
07C02:  MOVLW  FA
07C04:  MOVLB  9
07C06:  MOVWF  x00
07C08:  MOVLB  0
07C0A:  CALL   102E
07C0E:  MOVLB  8
07C10:  DECFSZ xF9,F
07C12:  BRA    7C02
....................    setup_wdt(WDT_ON); 
07C14:  BSF    FD1.0
....................    ////////////////// 
....................    hrs2=espera=fmensaje=0; 
07C16:  MOVLB  3
07C18:  CLRF   x4D
07C1A:  MOVFF  34D,27D
07C1E:  MOVFF  27D,27E
....................    reset(); 
07C22:  MOVLB  0
07C24:  GOTO   2BD8
....................    while(TRUE) { 
....................       restart_wdt(); 
07C28:  CLRWDT
....................       StackTask(); 
07C2A:  CALL   5AA8
....................       MyTCPTask(); 
07C2E:  CALL   699A
....................       if( (dias_prueba>dia_limite)&&(pago!=1) ){//pruebas 
07C32:  MOVLB  2
07C34:  MOVF   x79,W
07C36:  SUBLW  5A
07C38:  BC    7D06
07C3A:  DECFSZ x7B,W
07C3C:  BRA    7C40
07C3E:  BRA    7D06
....................          lcd_gotoxy(1,1); 
07C40:  MOVLW  01
07C42:  MOVLB  9
07C44:  MOVWF  x00
07C46:  MOVWF  x01
07C48:  MOVLB  0
07C4A:  CALL   1056
....................          lcd_putc("TIEMPO DE PRUEBA"); 
07C4E:  MOVLW  54
07C50:  MOVWF  FF6
07C52:  MOVLW  02
07C54:  MOVWF  FF7
07C56:  CALL   110C
....................          lcd_gotoxy(1,2); 
07C5A:  MOVLW  01
07C5C:  MOVLB  9
07C5E:  MOVWF  x00
07C60:  MOVLW  02
07C62:  MOVWF  x01
07C64:  MOVLB  0
07C66:  CALL   1056
....................          lcd_putc("  HA EXPIRADO   "); 
07C6A:  MOVLW  66
07C6C:  MOVWF  FF6
07C6E:  MOVLW  02
07C70:  MOVWF  FF7
07C72:  CALL   110C
....................          if(edo_str){ 
07C76:  MOVF   4E,F
07C78:  BZ    7D00
....................             edo_str=0; 
07C7A:  CLRF   4E
....................             strcpy(XX,rxtcp); 
07C7C:  CLRF   FEA
07C7E:  MOVLW  52
07C80:  MOVWF  FE9
07C82:  MOVLW  01
07C84:  MOVWF  FE2
07C86:  MOVLW  60
07C88:  MOVWF  FE1
07C8A:  MOVF   FE7,F
07C8C:  MOVFF  FE6,FEE
07C90:  BNZ   7C8A
....................             if( (XX[0]=='P')&&(XX[1]=='A')&&(XX[2]=='G')&&(XX[3]=='A')&&(XX[4]=='D')&&(XX[5]=='O') ){ 
07C92:  MOVF   52,W
07C94:  SUBLW  50
07C96:  BNZ   7D00
07C98:  MOVF   53,W
07C9A:  SUBLW  41
07C9C:  BNZ   7D00
07C9E:  MOVF   54,W
07CA0:  SUBLW  47
07CA2:  BNZ   7D00
07CA4:  MOVF   55,W
07CA6:  SUBLW  41
07CA8:  BNZ   7D00
07CAA:  MOVF   56,W
07CAC:  SUBLW  44
07CAE:  BNZ   7D00
07CB0:  MOVF   57,W
07CB2:  SUBLW  4F
07CB4:  BNZ   7D00
....................                pago=1; 
07CB6:  MOVLW  01
07CB8:  MOVLB  2
07CBA:  MOVWF  x7B
....................                write_ext_eeprom(11,pago);// 
07CBC:  MOVLB  9
07CBE:  CLRF   x0A
07CC0:  MOVLW  0B
07CC2:  MOVWF  x09
07CC4:  MOVFF  27B,90B
07CC8:  MOVLB  0
07CCA:  CALL   2954
....................                strcpy (txtcp, "BOLETERA_PAGADO"); 
07CCE:  MOVLW  01
07CD0:  MOVWF  FEA
07CD2:  MOVLW  06
07CD4:  MOVWF  FE9
07CD6:  MOVLW  00
07CD8:  CALL   00E6
07CDC:  TBLRD*-
07CDE:  TBLRD*+
07CE0:  MOVF   FF5,W
07CE2:  MOVWF  FEE
07CE4:  IORLW  00
07CE6:  BNZ   7CDE
....................                size_tx_tcp=strlen(txtcp); 
07CE8:  MOVLW  01
07CEA:  MOVLB  9
07CEC:  MOVWF  x0F
07CEE:  MOVLW  06
07CF0:  MOVWF  x0E
07CF2:  MOVLB  0
07CF4:  CALL   1E36
07CF8:  MOVFF  01,48
....................                enviar_tcp(); 
07CFC:  CALL   6D12
....................             } 
....................          } 
....................       } 
07D00:  GOTO   841C
07D04:  MOVLB  2
....................       else{ 
....................          wiegand_read_card(); 
07D06:  MOVLB  0
07D08:  GOTO   6DAE
....................          sensores(); 
07D0C:  GOTO   6F58
....................          if(edo_str){//bandera de dato recibido en socket actual 
07D10:  MOVF   4E,F
07D12:  BTFSC  FD8.2
07D14:  BRA    7FA0
....................             edo_str=0; 
07D16:  CLRF   4E
....................             //fprintf(DEBUG,"\r\nrxtcp:%s",rxtcp); 
....................             //printf(lcd_putc,"\frxtcp:%s",rxtcp); 
....................             strcpy(XX,rxtcp); 
07D18:  CLRF   FEA
07D1A:  MOVLW  52
07D1C:  MOVWF  FE9
07D1E:  MOVLW  01
07D20:  MOVWF  FE2
07D22:  MOVLW  60
07D24:  MOVWF  FE1
07D26:  MOVF   FE7,F
07D28:  MOVFF  FE6,FEE
07D2C:  BNZ   7D26
....................             //fprintf(U1PRINTER,"\frxtcp:%s",XX); 
....................             rd_eeprom(); 
07D2E:  GOTO   7026
....................             //lcd_gotoxy(1,3); 
....................             //printf(lcd_putc,"rxtcp:%s",rxtcp); 
....................             //lcd_gotoxy(1,4); 
....................             //printf(lcd_putc,"b:%Ld                ",b); 
....................             switch (b) { 
07D32:  MOVFF  44,00
07D36:  MOVF   45,W
07D38:  MOVWF  03
07D3A:  BNZ   7D42
07D3C:  MOVLW  01
07D3E:  SUBWF  00,W
07D40:  BZ    7DCA
07D42:  MOVF   03,W
07D44:  BNZ   7D4E
07D46:  MOVLW  02
07D48:  SUBWF  00,W
07D4A:  BTFSC  FD8.2
07D4C:  BRA    7DFC
07D4E:  MOVF   03,W
07D50:  BNZ   7D58
07D52:  MOVLW  03
07D54:  SUBWF  00,W
07D56:  BZ    7DFE
07D58:  MOVF   03,W
07D5A:  BNZ   7D62
07D5C:  MOVLW  04
07D5E:  SUBWF  00,W
07D60:  BZ    7E00
07D62:  MOVF   03,W
07D64:  BNZ   7D6C
07D66:  MOVLW  05
07D68:  SUBWF  00,W
07D6A:  BZ    7E1A
07D6C:  MOVF   03,W
07D6E:  BNZ   7D76
07D70:  MOVLW  06
07D72:  SUBWF  00,W
07D74:  BZ    7E1C
07D76:  MOVF   03,W
07D78:  BNZ   7D80
07D7A:  MOVLW  07
07D7C:  SUBWF  00,W
07D7E:  BZ    7E1E
07D80:  MOVF   03,W
07D82:  BNZ   7D8C
07D84:  MOVLW  08
07D86:  SUBWF  00,W
07D88:  BTFSC  FD8.2
07D8A:  BRA    7F48
07D8C:  MOVF   03,W
07D8E:  BNZ   7D98
07D90:  MOVLW  09
07D92:  SUBWF  00,W
07D94:  BTFSC  FD8.2
07D96:  BRA    7F4A
07D98:  MOVF   03,W
07D9A:  BNZ   7DA4
07D9C:  MOVLW  0A
07D9E:  SUBWF  00,W
07DA0:  BTFSC  FD8.2
07DA2:  BRA    7F4C
07DA4:  MOVF   03,W
07DA6:  BNZ   7DB0
07DA8:  MOVLW  0B
07DAA:  SUBWF  00,W
07DAC:  BTFSC  FD8.2
07DAE:  BRA    7F52
07DB0:  MOVF   03,W
07DB2:  BNZ   7DBC
07DB4:  MOVLW  0D
07DB6:  SUBWF  00,W
07DB8:  BTFSC  FD8.2
07DBA:  BRA    7F54
07DBC:  MOVF   03,W
07DBE:  BNZ   7DC8
07DC0:  MOVLW  0E
07DC2:  SUBWF  00,W
07DC4:  BTFSC  FD8.2
07DC6:  BRA    7F56
07DC8:  BRA    7FA0
....................               case 1: {//IMPRIMIR BOLETO 
....................                   espera=1; 
07DCA:  MOVLW  01
07DCC:  MOVLB  2
07DCE:  MOVWF  x7D
....................                   printf(lcd_putc,"\f\n   TOME SU BOLETO\n Y AVANCE POR FAVOR"); 
07DD0:  MOVLW  78
07DD2:  MOVWF  FF6
07DD4:  MOVLW  02
07DD6:  MOVWF  FF7
07DD8:  MOVLB  0
07DDA:  CALL   110C
....................                   ticket(); 
07DDE:  CALL   207E
....................                   output_high(salida01);//abre entrada 
07DE2:  BCF    F92.5
07DE4:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07DE6:  BCF    F96.0
07DE8:  BSF    F8D.0
....................                   relay1=1; 
07DEA:  MOVLW  01
07DEC:  MOVWF  1D
....................                   time_relay1=0; 
07DEE:  CLRF   1F
....................                   flag_pluma=1; 
07DF0:  MOVLB  2
07DF2:  MOVWF  x88
....................                   //sprintf(txtcp,barra_codi);//CONFIRMACION DE BOLETO IMPRESO 
....................                   //size_tx_tcp=strlen(txtcp); 
....................                   //enviar_tcp(); 
....................                   cta_lcd=0; 
07DF4:  CLRF   x8B
....................                   re_bol=1; 
07DF6:  MOVWF  x8A
....................                   break;} 
07DF8:  MOVLB  0
07DFA:  BRA    7FA0
....................               case 2: {//VIGENCIA POR VENCER O VENCIDA 
....................                   break;} 
07DFC:  BRA    7FA0
....................               case 3: {//no activa en entrada 
....................                   break;} 
07DFE:  BRA    7FA0
....................               case 4: {//ABRIR ENTRADA 
....................                   //lcd_putc("\f\n     BIENVENIDO"); 
....................                   output_high(salida01);//abre entrada 
07E00:  BCF    F92.5
07E02:  BSF    F89.5
....................                   output_high(salida02);//abre entrada 
07E04:  BCF    F96.0
07E06:  BSF    F8D.0
....................                   flag_pluma=1; 
07E08:  MOVLW  01
07E0A:  MOVLB  2
07E0C:  MOVWF  x88
....................                   relay1=1; 
07E0E:  MOVWF  1D
....................                   time_relay1=0; 
07E10:  CLRF   1F
....................                   b=0; 
07E12:  CLRF   45
07E14:  CLRF   44
....................                   break;} 
07E16:  MOVLB  0
07E18:  BRA    7FA0
....................               case 5: {//CUPO LLENO 
....................                   break;} 
07E1A:  BRA    7FA0
....................               case 6: {//ACTIVA BOLETOS 
....................                   break;} 
07E1C:  BRA    7FA0
....................               case 7: {//MENSAJES DE LCD 
....................                      memset(lcd_men, 0, sizeof(lcd_men) ); 
07E1E:  MOVLW  01
07E20:  MOVWF  FEA
07E22:  MOVLW  BA
07E24:  MOVWF  FE9
07E26:  CLRF   00
07E28:  CLRF   02
07E2A:  MOVLW  50
07E2C:  MOVWF  01
07E2E:  CALL   1E1C
....................                      for(i=0;i<strlen(XX);i++) lcd_men[i]=XX[instruccion_size+i]; 
07E32:  CLRF   41
07E34:  CLRF   40
07E36:  MOVLB  9
07E38:  CLRF   x0F
07E3A:  MOVLW  52
07E3C:  MOVWF  x0E
07E3E:  MOVLB  0
07E40:  CALL   1E36
07E44:  MOVF   41,F
07E46:  BNZ   7E88
07E48:  MOVF   01,W
07E4A:  SUBWF  40,W
07E4C:  BC    7E88
07E4E:  MOVLW  BA
07E50:  ADDWF  40,W
07E52:  MOVWF  01
07E54:  MOVLW  01
07E56:  ADDWFC 41,W
07E58:  MOVWF  03
07E5A:  MOVFF  01,8F9
07E5E:  MOVLB  8
07E60:  MOVWF  xFA
07E62:  MOVLW  5C
07E64:  ADDWF  40,W
07E66:  MOVWF  FE9
07E68:  MOVLW  00
07E6A:  ADDWFC 41,W
07E6C:  MOVWF  FEA
07E6E:  MOVFF  FEF,8FD
07E72:  MOVFF  03,FEA
07E76:  MOVFF  01,FE9
07E7A:  MOVFF  8FD,FEF
07E7E:  INCF   40,F
07E80:  BTFSC  FD8.2
07E82:  INCF   41,F
07E84:  MOVLB  0
07E86:  BRA    7E36
....................                      lcd_putc("\f"); 
07E88:  MOVLW  A0
07E8A:  MOVWF  FF6
07E8C:  MOVLW  02
07E8E:  MOVWF  FF7
07E90:  CALL   110C
....................                      for(i=0;i<strlen(lcd_men);i++){ 
07E94:  CLRF   41
07E96:  CLRF   40
07E98:  MOVLW  01
07E9A:  MOVLB  9
07E9C:  MOVWF  x0F
07E9E:  MOVLW  BA
07EA0:  MOVWF  x0E
07EA2:  MOVLB  0
07EA4:  CALL   1E36
07EA8:  MOVF   41,F
07EAA:  BNZ   7F3C
07EAC:  MOVF   01,W
07EAE:  SUBWF  40,W
07EB0:  BC    7F3C
....................                         if(i==0)lcd_gotoxy(1,1); 
07EB2:  MOVF   40,F
07EB4:  BNZ   7ECA
07EB6:  MOVF   41,F
07EB8:  BNZ   7ECA
07EBA:  MOVLW  01
07EBC:  MOVLB  9
07EBE:  MOVWF  x00
07EC0:  MOVWF  x01
07EC2:  MOVLB  0
07EC4:  CALL   1056
07EC8:  BRA    7F1C
....................                         else if(i==20) lcd_gotoxy(1,2); 
07ECA:  MOVF   40,W
07ECC:  SUBLW  14
07ECE:  BNZ   7EE6
07ED0:  MOVF   41,F
07ED2:  BNZ   7EE6
07ED4:  MOVLW  01
07ED6:  MOVLB  9
07ED8:  MOVWF  x00
07EDA:  MOVLW  02
07EDC:  MOVWF  x01
07EDE:  MOVLB  0
07EE0:  CALL   1056
07EE4:  BRA    7F1C
....................                         else if(i==40) lcd_gotoxy(1,3); 
07EE6:  MOVF   40,W
07EE8:  SUBLW  28
07EEA:  BNZ   7F02
07EEC:  MOVF   41,F
07EEE:  BNZ   7F02
07EF0:  MOVLW  01
07EF2:  MOVLB  9
07EF4:  MOVWF  x00
07EF6:  MOVLW  03
07EF8:  MOVWF  x01
07EFA:  MOVLB  0
07EFC:  CALL   1056
07F00:  BRA    7F1C
....................                         else if(i==60) lcd_gotoxy(1,4); 
07F02:  MOVF   40,W
07F04:  SUBLW  3C
07F06:  BNZ   7F1C
07F08:  MOVF   41,F
07F0A:  BNZ   7F1C
07F0C:  MOVLW  01
07F0E:  MOVLB  9
07F10:  MOVWF  x00
07F12:  MOVLW  04
07F14:  MOVWF  x01
07F16:  MOVLB  0
07F18:  CALL   1056
....................                         printf(lcd_putc,"%c",lcd_men[i]); 
07F1C:  MOVLW  BA
07F1E:  ADDWF  40,W
07F20:  MOVWF  FE9
07F22:  MOVLW  01
07F24:  ADDWFC 41,W
07F26:  MOVWF  FEA
07F28:  MOVFF  FEF,8F9
07F2C:  MOVFF  8F9,8FF
07F30:  CALL   10A8
07F34:  INCF   40,F
07F36:  BTFSC  FD8.2
07F38:  INCF   41,F
07F3A:  BRA    7E98
....................                      } 
....................                      espera=1; 
07F3C:  MOVLW  01
07F3E:  MOVLB  2
07F40:  MOVWF  x7D
....................                      cta_lcd=0; 
07F42:  CLRF   x8B
....................                      break;}// 
07F44:  MOVLB  0
07F46:  BRA    7FA0
....................               case 8: {//MOITOREO DESACTIVADO 
....................                      break;}// 
07F48:  BRA    7FA0
....................               case 9: {//CONSULTA ENTRADAS SIN CONEXION 
....................                   break;} 
07F4A:  BRA    7FA0
....................               case 10:{//CONFIGURA FECHA Y HORA 
....................                   fecha(); 
07F4C:  GOTO   72AE
....................                   break;} 
07F50:  BRA    7FA0
....................               case 11:{//ultima conexion 
....................                   break;} 
07F52:  BRA    7FA0
....................               case 13:{//RESET DE FOLIOS 
....................                   break;} 
07F54:  BRA    7FA0
....................               case 14:{//PAGO EFECTUADO 
....................                   pago=1; 
07F56:  MOVLW  01
07F58:  MOVLB  2
07F5A:  MOVWF  x7B
....................                   write_ext_eeprom(11,pago);// 
07F5C:  MOVLB  9
07F5E:  CLRF   x0A
07F60:  MOVLW  0B
07F62:  MOVWF  x09
07F64:  MOVFF  27B,90B
07F68:  MOVLB  0
07F6A:  CALL   2954
....................                   strcpy (txtcp, "BOLETERA_PAGADO"); 
07F6E:  MOVLW  01
07F70:  MOVWF  FEA
07F72:  MOVLW  06
07F74:  MOVWF  FE9
07F76:  MOVLW  00
07F78:  CALL   00E6
07F7C:  TBLRD*-
07F7E:  TBLRD*+
07F80:  MOVF   FF5,W
07F82:  MOVWF  FEE
07F84:  IORLW  00
07F86:  BNZ   7F7E
....................                   size_tx_tcp=strlen(txtcp); 
07F88:  MOVLW  01
07F8A:  MOVLB  9
07F8C:  MOVWF  x0F
07F8E:  MOVLW  06
07F90:  MOVWF  x0E
07F92:  MOVLB  0
07F94:  CALL   1E36
07F98:  MOVFF  01,48
....................                   enviar_tcp(); 
07F9C:  CALL   6D12
....................                   break;} 
....................             }//end switch 
....................          }//end dato recibido tcp 
....................          ////////////////////////////////////// 
....................          if( (relay1)&&(time_relay1>=21) ){ 
07FA0:  MOVF   1D,F
07FA2:  BZ    7FB4
07FA4:  MOVF   1F,W
07FA6:  SUBLW  14
07FA8:  BC    7FB4
....................             relay1=0; 
07FAA:  CLRF   1D
....................             output_low(salida01); 
07FAC:  BCF    F92.5
07FAE:  BCF    F89.5
....................             output_low(salida02); 
07FB0:  BCF    F96.0
07FB2:  BCF    F8D.0
....................          } 
....................          //if( (time_boleto>60)&&(re_bol) )  re_bol=0; 
....................           
....................          if( (espera)&&(cta_lcd>=100) ) espera=0; 
07FB4:  MOVLB  2
07FB6:  MOVF   x7D,F
07FB8:  BZ    7FC2
07FBA:  MOVF   x8B,W
07FBC:  SUBLW  63
07FBE:  BC    7FC2
07FC0:  CLRF   x7D
....................           
....................          if( (cuenta>=20)&&(espera==0) ){//CADA 2 SEGUNDOS VERIFICA FECHA Y HORA 
07FC2:  MOVF   x7C,W
07FC4:  SUBLW  13
07FC6:  BTFSC  FD8.0
07FC8:  BRA    841A
07FCA:  MOVF   x7D,F
07FCC:  BTFSS  FD8.2
07FCE:  BRA    841A
....................              ds1307_get_time(hrs,min,sec); 
....................              ds1307_get_date(day,month,yr,dow); 
....................              if(hrs2!=hrs){ 
*
081C2:  MOVLB  2
081C4:  MOVF   x73,W
081C6:  SUBWF  x7E,W
081C8:  BZ    821A
....................                dia=31;//ultimo dia del mes 
081CA:  CLRF   x82
081CC:  MOVLW  1F
081CE:  MOVWF  x81
....................                mes2=10;//octubre, mes en el que cambia horario invierno 
081D0:  CLRF   x80
081D2:  MOVLW  0A
081D4:  MOVWF  x7F
....................                zeller(); 
081D6:  MOVLB  0
081D8:  GOTO   741C
....................                hrs2=hrs; 
081DC:  MOVFF  273,27E
....................                if( (dia_temp!=day)&&(pago!=1) ){ 
081E0:  MOVLB  2
081E2:  MOVF   x70,W
081E4:  SUBWF  x7A,W
081E6:  BZ    821A
081E8:  DECFSZ x7B,W
081EA:  BRA    81EE
081EC:  BRA    821A
....................                   dia_temp=day; 
081EE:  MOVFF  270,27A
....................                   dias_prueba++; 
081F2:  INCF   x79,F
....................                   write_ext_eeprom(12,dias_prueba);//dias de prueba 
081F4:  MOVLB  9
081F6:  CLRF   x0A
081F8:  MOVLW  0C
081FA:  MOVWF  x09
081FC:  MOVFF  279,90B
08200:  MOVLB  0
08202:  CALL   2954
....................                   write_ext_eeprom(13,dia_temp);// 
08206:  MOVLB  9
08208:  CLRF   x0A
0820A:  MOVLW  0D
0820C:  MOVWF  x09
0820E:  MOVFF  27A,90B
08212:  MOVLB  0
08214:  CALL   2954
08218:  MOVLB  2
....................                } 
....................              }//FIN CONFIGURA AUTMATICO FECHA Y HORA 
....................              //cuenta_lcd=0; 
....................              puntos=!puntos; 
0821A:  MOVF   x77,F
0821C:  BZ    8222
0821E:  MOVLW  00
08220:  BRA    8224
08222:  MOVLW  01
08224:  MOVWF  x77
....................              if( (!espera)&&(!en1) ){ 
08226:  MOVF   x7D,F
08228:  BTFSS  FD8.2
0822A:  BRA    8418
0822C:  MOVF   x83,F
0822E:  BTFSS  FD8.2
08230:  BRA    8418
....................                lcd_gotoxy(1,1); 
08232:  MOVLW  01
08234:  MOVLB  9
08236:  MOVWF  x00
08238:  MOVWF  x01
0823A:  MOVLB  0
0823C:  CALL   1056
....................                lcd_putc("                    "); 
08240:  MOVLW  A2
08242:  MOVWF  FF6
08244:  MOVLW  02
08246:  MOVWF  FF7
08248:  CALL   110C
....................                lcd_gotoxy(1,2);//printf(lcd_putc,"  %02d %02d %02d %02d/%02d/%02d   ",hrs_e,min_e,sec_e,day_e,month,yr); 
0824C:  MOVLW  01
0824E:  MOVLB  9
08250:  MOVWF  x00
08252:  MOVLW  02
08254:  MOVWF  x01
08256:  MOVLB  0
08258:  CALL   1056
....................                if(puntos==0)   printf(lcd_putc,"   %02d %02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
0825C:  MOVLB  2
0825E:  MOVF   x77,F
08260:  BNZ   830E
08262:  MOVLW  B8
08264:  MOVWF  FF6
08266:  MOVLW  02
08268:  MOVWF  FF7
0826A:  MOVLW  03
0826C:  MOVLB  8
0826E:  MOVWF  xFA
08270:  MOVLB  0
08272:  CALL   2A5A
08276:  MOVFF  273,8F9
0827A:  MOVLW  01
0827C:  MOVLB  8
0827E:  MOVWF  xFA
08280:  MOVLB  0
08282:  CALL   77FC
08286:  MOVLW  20
08288:  MOVLB  8
0828A:  MOVWF  xFF
0828C:  MOVLB  0
0828E:  CALL   10A8
08292:  MOVFF  274,8F9
08296:  MOVLW  01
08298:  MOVLB  8
0829A:  MOVWF  xFA
0829C:  MOVLB  0
0829E:  CALL   77FC
082A2:  MOVLW  20
082A4:  MOVLB  8
082A6:  MOVWF  xFF
082A8:  MOVLB  0
082AA:  CALL   10A8
082AE:  MOVFF  270,8F9
082B2:  MOVLW  01
082B4:  MOVLB  8
082B6:  MOVWF  xFA
082B8:  MOVLB  0
082BA:  CALL   77FC
082BE:  MOVLW  2F
082C0:  MOVLB  8
082C2:  MOVWF  xFF
082C4:  MOVLB  0
082C6:  CALL   10A8
082CA:  MOVFF  271,8F9
082CE:  MOVLW  01
082D0:  MOVLB  8
082D2:  MOVWF  xFA
082D4:  MOVLB  0
082D6:  CALL   77FC
082DA:  MOVLW  2F
082DC:  MOVLB  8
082DE:  MOVWF  xFF
082E0:  MOVLB  0
082E2:  CALL   10A8
082E6:  MOVFF  272,8F9
082EA:  MOVLW  01
082EC:  MOVLB  8
082EE:  MOVWF  xFA
082F0:  MOVLB  0
082F2:  CALL   77FC
082F6:  MOVLW  D3
082F8:  MOVWF  FF6
082FA:  MOVLW  02
082FC:  MOVWF  FF7
082FE:  MOVLW  04
08300:  MOVLB  8
08302:  MOVWF  xFA
08304:  MOVLB  0
08306:  CALL   2A5A
0830A:  BRA    83B6
0830C:  MOVLB  2
....................                else   printf(lcd_putc,"   %02d:%02d %02d/%02d/%02d    ",hrs,min,day,month,yr); 
0830E:  MOVLW  D8
08310:  MOVWF  FF6
08312:  MOVLW  02
08314:  MOVWF  FF7
08316:  MOVLW  03
08318:  MOVLB  8
0831A:  MOVWF  xFA
0831C:  MOVLB  0
0831E:  CALL   2A5A
08322:  MOVFF  273,8F9
08326:  MOVLW  01
08328:  MOVLB  8
0832A:  MOVWF  xFA
0832C:  MOVLB  0
0832E:  CALL   77FC
08332:  MOVLW  3A
08334:  MOVLB  8
08336:  MOVWF  xFF
08338:  MOVLB  0
0833A:  CALL   10A8
0833E:  MOVFF  274,8F9
08342:  MOVLW  01
08344:  MOVLB  8
08346:  MOVWF  xFA
08348:  MOVLB  0
0834A:  CALL   77FC
0834E:  MOVLW  20
08350:  MOVLB  8
08352:  MOVWF  xFF
08354:  MOVLB  0
08356:  CALL   10A8
0835A:  MOVFF  270,8F9
0835E:  MOVLW  01
08360:  MOVLB  8
08362:  MOVWF  xFA
08364:  MOVLB  0
08366:  CALL   77FC
0836A:  MOVLW  2F
0836C:  MOVLB  8
0836E:  MOVWF  xFF
08370:  MOVLB  0
08372:  CALL   10A8
08376:  MOVFF  271,8F9
0837A:  MOVLW  01
0837C:  MOVLB  8
0837E:  MOVWF  xFA
08380:  MOVLB  0
08382:  CALL   77FC
08386:  MOVLW  2F
08388:  MOVLB  8
0838A:  MOVWF  xFF
0838C:  MOVLB  0
0838E:  CALL   10A8
08392:  MOVFF  272,8F9
08396:  MOVLW  01
08398:  MOVLB  8
0839A:  MOVWF  xFA
0839C:  MOVLB  0
0839E:  CALL   77FC
083A2:  MOVLW  F3
083A4:  MOVWF  FF6
083A6:  MOVLW  02
083A8:  MOVWF  FF7
083AA:  MOVLW  04
083AC:  MOVLB  8
083AE:  MOVWF  xFA
083B0:  MOVLB  0
083B2:  CALL   2A5A
....................                cambio_msj++; 
083B6:  MOVLB  2
083B8:  INCF   x78,F
....................                lcd_gotoxy(1,3); 
083BA:  MOVLW  01
083BC:  MOVLB  9
083BE:  MOVWF  x00
083C0:  MOVLW  03
083C2:  MOVWF  x01
083C4:  MOVLB  0
083C6:  CALL   1056
....................                if(cambio_msj>=10) lcd_putc("   WWW.ACCESA.ME    ");//COMPLEJO CITY ANGELÓPOLIS   
083CA:  MOVLB  2
083CC:  MOVF   x78,W
083CE:  SUBLW  09
083D0:  BC    83E4
083D2:  MOVLW  F8
083D4:  MOVWF  FF6
083D6:  MOVLW  02
083D8:  MOVWF  FF7
083DA:  MOVLB  0
083DC:  CALL   110C
083E0:  BRA    83F2
083E2:  MOVLB  2
....................                else lcd_putc("       ACCESA       "); 
083E4:  MOVLW  0E
083E6:  MOVWF  FF6
083E8:  MOVLW  03
083EA:  MOVWF  FF7
083EC:  MOVLB  0
083EE:  CALL   110C
....................                lcd_gotoxy(1,4); 
083F2:  MOVLW  01
083F4:  MOVLB  9
083F6:  MOVWF  x00
083F8:  MOVLW  04
083FA:  MOVWF  x01
083FC:  MOVLB  0
083FE:  CALL   1056
....................                lcd_putc("                    "); 
08402:  MOVLW  24
08404:  MOVWF  FF6
08406:  MOVLW  03
08408:  MOVWF  FF7
0840A:  CALL   110C
....................                if(cambio_msj>=20) cambio_msj=0; 
0840E:  MOVLB  2
08410:  MOVF   x78,W
08412:  SUBLW  13
08414:  BC    8418
08416:  CLRF   x78
....................              } 
....................              cuenta=0; 
08418:  CLRF   x7C
0841A:  MOVLB  0
....................          }//END SEGUNDO 
....................       } 
....................       //if( (MACIsLinked()==0)&&(inicializado)&&(linked_out==0) ){//cable off 
....................       if( (MACIsLinked()==0)&&(inicializado) ){//cable off 
0841C:  GOTO   78C8
08420:  MOVF   01,F
08422:  BNZ   8430
08424:  MOVF   50,F
08426:  BZ    8430
....................          //linked_out=1; 
....................          TCPDisconnect(socket2); 
08428:  MOVFF  51,8FE
0842C:  CALL   671A
....................       } 
....................       ////////////////////////////////////// 
....................       if( (time_bot>=80)&&(flag_time) ) flag_time=0; 
08430:  MOVLB  3
08432:  MOVF   x52,F
08434:  BNZ   843C
08436:  MOVF   x51,W
08438:  SUBLW  4F
0843A:  BC    8442
0843C:  MOVF   x50,F
0843E:  BZ    8442
08440:  CLRF   x50
08442:  MOVLB  0
08444:  GOTO   7C28
....................    }//end true 
.................... }//end main 
....................  
08448:  SLEEP 
.................... int convertir_to_entero(char *cadena){ 
*
070E6:  MOVLB  8
070E8:  CLRF   xFC
....................    int valor = 0; 
....................         if(cadena=='0') valor=0; 
070EA:  MOVF   xFA,W
070EC:  SUBLW  30
070EE:  BNZ   70F8
070F0:  MOVF   xFB,F
070F2:  BNZ   70F8
070F4:  CLRF   xFC
070F6:  BRA    7186
....................    else if(cadena=='1') valor=1; 
070F8:  MOVF   xFA,W
070FA:  SUBLW  31
070FC:  BNZ   7108
070FE:  MOVF   xFB,F
07100:  BNZ   7108
07102:  MOVLW  01
07104:  MOVWF  xFC
07106:  BRA    7186
....................    else if(cadena=='2') valor=2; 
07108:  MOVF   xFA,W
0710A:  SUBLW  32
0710C:  BNZ   7118
0710E:  MOVF   xFB,F
07110:  BNZ   7118
07112:  MOVLW  02
07114:  MOVWF  xFC
07116:  BRA    7186
....................    else if(cadena=='3') valor=3; 
07118:  MOVF   xFA,W
0711A:  SUBLW  33
0711C:  BNZ   7128
0711E:  MOVF   xFB,F
07120:  BNZ   7128
07122:  MOVLW  03
07124:  MOVWF  xFC
07126:  BRA    7186
....................    else if(cadena=='4') valor=4; 
07128:  MOVF   xFA,W
0712A:  SUBLW  34
0712C:  BNZ   7138
0712E:  MOVF   xFB,F
07130:  BNZ   7138
07132:  MOVLW  04
07134:  MOVWF  xFC
07136:  BRA    7186
....................    else if(cadena=='5') valor=5; 
07138:  MOVF   xFA,W
0713A:  SUBLW  35
0713C:  BNZ   7148
0713E:  MOVF   xFB,F
07140:  BNZ   7148
07142:  MOVLW  05
07144:  MOVWF  xFC
07146:  BRA    7186
....................    else if(cadena=='6') valor=6; 
07148:  MOVF   xFA,W
0714A:  SUBLW  36
0714C:  BNZ   7158
0714E:  MOVF   xFB,F
07150:  BNZ   7158
07152:  MOVLW  06
07154:  MOVWF  xFC
07156:  BRA    7186
....................    else if(cadena=='7') valor=7; 
07158:  MOVF   xFA,W
0715A:  SUBLW  37
0715C:  BNZ   7168
0715E:  MOVF   xFB,F
07160:  BNZ   7168
07162:  MOVLW  07
07164:  MOVWF  xFC
07166:  BRA    7186
....................    else if(cadena=='8') valor=8; 
07168:  MOVF   xFA,W
0716A:  SUBLW  38
0716C:  BNZ   7178
0716E:  MOVF   xFB,F
07170:  BNZ   7178
07172:  MOVLW  08
07174:  MOVWF  xFC
07176:  BRA    7186
....................    else if(cadena=='9') valor=9; 
07178:  MOVF   xFA,W
0717A:  SUBLW  39
0717C:  BNZ   7186
0717E:  MOVF   xFB,F
07180:  BNZ   7186
07182:  MOVLW  09
07184:  MOVWF  xFC
....................    return valor; 
07186:  MOVFF  8FC,01
0718A:  MOVLB  0
0718C:  RETURN 0
.................... } 
....................  
.................... void fecha(){//falta revisar si se deshabilitan las int globales 
....................    disable_interrupts(INT_RDA); 
*
072AE:  BCF    F9D.5
....................    //delay_ms(1000); 
.................... //   lcd_gotoxy(1,2); 
.................... //   lcd_putc("\f     CONFIGURA      ");// 
.................... //   lcd_gotoxy(1,3); 
.................... //   lcd_putc("     FECHA/HORA     "); 
....................     
....................    setup_wdt(WDT_ON); 
072B0:  BSF    FD1.0
....................    restart_wdt(); 
072B2:  CLRWDT
....................     
....................    day=(convertir_to_entero(XX[instruccion_size])*10)+convertir_to_entero(XX[instruccion_size+1]); 
072B4:  MOVLB  8
072B6:  CLRF   xFB
072B8:  MOVFF  5C,8FA
072BC:  MOVLB  0
072BE:  RCALL  70E6
072C0:  MOVF   01,W
072C2:  MULLW  0A
072C4:  MOVFF  FF3,8F9
072C8:  MOVLB  8
072CA:  CLRF   xFB
072CC:  MOVFF  5D,8FA
072D0:  MOVLB  0
072D2:  RCALL  70E6
072D4:  MOVF   01,W
072D6:  MOVLB  8
072D8:  ADDWF  xF9,W
072DA:  MOVLB  2
072DC:  MOVWF  x70
....................    hrs=(convertir_to_entero(XX[instruccion_size+7])*10)+convertir_to_entero(XX[instruccion_size+8]); 
072DE:  MOVLB  8
072E0:  CLRF   xFB
072E2:  MOVFF  63,8FA
072E6:  MOVLB  0
072E8:  RCALL  70E6
072EA:  MOVF   01,W
072EC:  MULLW  0A
072EE:  MOVFF  FF3,8F9
072F2:  MOVLB  8
072F4:  CLRF   xFB
072F6:  MOVFF  64,8FA
072FA:  MOVLB  0
072FC:  RCALL  70E6
072FE:  MOVF   01,W
07300:  MOVLB  8
07302:  ADDWF  xF9,W
07304:  MOVLB  2
07306:  MOVWF  x73
....................    min=(convertir_to_entero(XX[instruccion_size+9])*10)+convertir_to_entero(XX[instruccion_size+10]); 
07308:  MOVLB  8
0730A:  CLRF   xFB
0730C:  MOVFF  65,8FA
07310:  MOVLB  0
07312:  RCALL  70E6
07314:  MOVF   01,W
07316:  MULLW  0A
07318:  MOVFF  FF3,8F9
0731C:  MOVLB  8
0731E:  CLRF   xFB
07320:  MOVFF  66,8FA
07324:  MOVLB  0
07326:  RCALL  70E6
07328:  MOVF   01,W
0732A:  MOVLB  8
0732C:  ADDWF  xF9,W
0732E:  MOVLB  2
07330:  MOVWF  x74
....................    sec=(convertir_to_entero(XX[instruccion_size+11])*10)+convertir_to_entero(XX[instruccion_size+12]); 
07332:  MOVLB  8
07334:  CLRF   xFB
07336:  MOVFF  67,8FA
0733A:  MOVLB  0
0733C:  RCALL  70E6
0733E:  MOVF   01,W
07340:  MULLW  0A
07342:  MOVFF  FF3,8F9
07346:  MOVLB  8
07348:  CLRF   xFB
0734A:  MOVFF  68,8FA
0734E:  MOVLB  0
07350:  RCALL  70E6
07352:  MOVF   01,W
07354:  MOVLB  8
07356:  ADDWF  xF9,W
07358:  MOVLB  2
0735A:  MOVWF  x75
....................     
....................    month=(convertir_to_entero(XX[instruccion_size+2])*10)+convertir_to_entero(XX[instruccion_size+3]); 
0735C:  MOVLB  8
0735E:  CLRF   xFB
07360:  MOVFF  5E,8FA
07364:  MOVLB  0
07366:  RCALL  70E6
07368:  MOVF   01,W
0736A:  MULLW  0A
0736C:  MOVFF  FF3,8F9
07370:  MOVLB  8
07372:  CLRF   xFB
07374:  MOVFF  5F,8FA
07378:  MOVLB  0
0737A:  RCALL  70E6
0737C:  MOVF   01,W
0737E:  MOVLB  8
07380:  ADDWF  xF9,W
07382:  MOVLB  2
07384:  MOVWF  x71
....................    yr= (convertir_to_entero(XX[instruccion_size+4])*10)+convertir_to_entero(XX[instruccion_size+5]); 
07386:  MOVLB  8
07388:  CLRF   xFB
0738A:  MOVFF  60,8FA
0738E:  MOVLB  0
07390:  RCALL  70E6
07392:  MOVF   01,W
07394:  MULLW  0A
07396:  MOVFF  FF3,8F9
0739A:  MOVLB  8
0739C:  CLRF   xFB
0739E:  MOVFF  61,8FA
073A2:  MOVLB  0
073A4:  RCALL  70E6
073A6:  MOVF   01,W
073A8:  MOVLB  8
073AA:  ADDWF  xF9,W
073AC:  MOVLB  2
073AE:  MOVWF  x72
....................    dow= convertir_to_entero(XX[instruccion_size+6]); 
073B0:  MOVLB  8
073B2:  CLRF   xFB
073B4:  MOVFF  62,8FA
073B8:  MOVLB  0
073BA:  RCALL  70E6
073BC:  MOVFF  01,276
....................    ///////////////////// 
....................    ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos), ,hora,min,seg 
073C0:  MOVFF  270,909
073C4:  MOVFF  271,90A
073C8:  MOVFF  272,90B
073CC:  MOVFF  276,90C
073D0:  MOVFF  273,90D
073D4:  MOVFF  274,90E
073D8:  MOVFF  275,90F
073DC:  RCALL  71B6
....................    //lcd_gotoxy(1,1); 
....................    //printf(lcd_putc,"      %02d:%02d:%02d      ",hrs,min,sec); 
....................    //lcd_gotoxy(1,2); 
....................    //printf (lcd_putc,"     %02d/%02d/2%03d     ",day,month,yr); 
....................    //lcd_gotoxy(1,3); 
....................    //lcd_putc("  DATOS GUARDADOS   "); 
....................    lcd_gotoxy(1,4); 
073DE:  MOVLW  01
073E0:  MOVLB  9
073E2:  MOVWF  x00
073E4:  MOVLW  04
073E6:  MOVWF  x01
073E8:  MOVLB  0
073EA:  CALL   1056
....................    lcd_putc("  Hora Actualizada  "); 
073EE:  MOVLW  3A
073F0:  MOVWF  FF6
073F2:  MOVLW  03
073F4:  MOVWF  FF7
073F6:  CALL   110C
....................    delay_ms(2500); 
073FA:  MOVLW  0A
073FC:  MOVLB  8
073FE:  MOVWF  xF9
07400:  MOVLW  FA
07402:  MOVLB  9
07404:  MOVWF  x00
07406:  MOVLB  0
07408:  CALL   102E
0740C:  MOVLB  8
0740E:  DECFSZ xF9,F
07410:  BRA    7400
....................    restart_wdt(); 
07412:  CLRWDT
....................    //if(demo==1) printf("\r\nXX:%s",XX); 
....................    enable_interrupts(INT_RDA); 
07414:  BSF    F9D.5
07416:  MOVLB  0
07418:  GOTO   7FA0 (RETURN)
.................... } 
....................  
.................... void wiegand_read_card(){ 
....................  if(wieg_full){ 
*
06DAE:  MOVLB  2
06DB0:  MOVF   x10,F
06DB2:  BTFSC  FD8.2
06DB4:  BRA    6EE4
....................    //disable_interrupts(GLOBAL);//Deshabilito las interrupciones globales 
....................    deci=0; 
06DB6:  CLRF   x15
06DB8:  CLRF   x14
06DBA:  CLRF   x13
06DBC:  CLRF   x12
....................    for(i=1;i<sub_indice-1;i++) deci = (deci<<1)|data[i]; 
06DBE:  CLRF   41
06DC0:  MOVLW  01
06DC2:  MOVWF  40
06DC4:  MOVLW  01
06DC6:  SUBWF  x0F,W
06DC8:  MOVF   41,F
06DCA:  BNZ   6E1A
06DCC:  SUBWF  40,W
06DCE:  BC    6E1A
06DD0:  BCF    FD8.0
06DD2:  RLCF   x12,W
06DD4:  MOVLB  8
06DD6:  MOVWF  xFA
06DD8:  MOVLB  2
06DDA:  RLCF   x13,W
06DDC:  MOVLB  8
06DDE:  MOVWF  xFB
06DE0:  MOVLB  2
06DE2:  RLCF   x14,W
06DE4:  MOVLB  8
06DE6:  MOVWF  xFC
06DE8:  MOVLB  2
06DEA:  RLCF   x15,W
06DEC:  MOVLB  8
06DEE:  MOVWF  xFD
06DF0:  MOVLW  16
06DF2:  ADDWF  40,W
06DF4:  MOVWF  FE9
06DF6:  MOVLW  02
06DF8:  ADDWFC 41,W
06DFA:  MOVWF  FEA
06DFC:  MOVF   FEF,W
06DFE:  IORWF  xFA,W
06E00:  MOVLB  2
06E02:  MOVWF  x12
06E04:  MOVFF  8FB,213
06E08:  MOVFF  8FC,214
06E0C:  MOVFF  8FD,215
06E10:  MOVLB  2
06E12:  INCF   40,F
06E14:  BTFSC  FD8.2
06E16:  INCF   41,F
06E18:  BRA    6DC4
....................    sprintf(YY,"%08LX",deci);// imprime en un arreglo (printf en ram) 
06E1A:  MOVLB  8
06E1C:  CLRF   xF7
06E1E:  MOVLW  AC
06E20:  MOVWF  xF6
06E22:  MOVFF  215,8F9
06E26:  MOVLW  37
06E28:  MOVWF  xFA
06E2A:  MOVLB  0
06E2C:  RCALL  6D3E
06E2E:  MOVFF  214,8F9
06E32:  MOVLW  37
06E34:  MOVLB  8
06E36:  MOVWF  xFA
06E38:  MOVLB  0
06E3A:  RCALL  6D3E
06E3C:  MOVFF  213,8F9
06E40:  MOVLW  37
06E42:  MOVLB  8
06E44:  MOVWF  xFA
06E46:  MOVLB  0
06E48:  RCALL  6D3E
06E4A:  MOVFF  212,8F9
06E4E:  MOVLW  37
06E50:  MOVLB  8
06E52:  MOVWF  xFA
06E54:  MOVLB  0
06E56:  RCALL  6D3E
....................    sprintf(txtcp,"EN1-%08LX",deci);// imprime en un arreglo (printf en ram) 
06E58:  MOVLW  01
06E5A:  MOVLB  8
06E5C:  MOVWF  xF7
06E5E:  MOVLW  06
06E60:  MOVWF  xF6
06E62:  MOVLW  50
06E64:  MOVWF  FF6
06E66:  MOVLW  03
06E68:  MOVWF  FF7
06E6A:  MOVLW  04
06E6C:  MOVWF  xF9
06E6E:  MOVLB  0
06E70:  BRA    6D84
06E72:  MOVFF  215,8F9
06E76:  MOVLW  37
06E78:  MOVLB  8
06E7A:  MOVWF  xFA
06E7C:  MOVLB  0
06E7E:  RCALL  6D3E
06E80:  MOVFF  214,8F9
06E84:  MOVLW  37
06E86:  MOVLB  8
06E88:  MOVWF  xFA
06E8A:  MOVLB  0
06E8C:  RCALL  6D3E
06E8E:  MOVFF  213,8F9
06E92:  MOVLW  37
06E94:  MOVLB  8
06E96:  MOVWF  xFA
06E98:  MOVLB  0
06E9A:  RCALL  6D3E
06E9C:  MOVFF  212,8F9
06EA0:  MOVLW  37
06EA2:  MOVLB  8
06EA4:  MOVWF  xFA
06EA6:  MOVLB  0
06EA8:  RCALL  6D3E
....................    //fprintf(DEBUG,"TA:%s\r\n",txtcp); 
....................    //lcd_gotoxy(1,3); 
....................    //printf(lcd_putc,"TA:%s",txtcp); 
....................    size_tx_tcp=strlen(txtcp); 
06EAA:  MOVLW  01
06EAC:  MOVLB  9
06EAE:  MOVWF  x0F
06EB0:  MOVLW  06
06EB2:  MOVWF  x0E
06EB4:  MOVLB  0
06EB6:  CALL   1E36
06EBA:  MOVFF  01,48
....................    enviar_tcp(); 
06EBE:  RCALL  6D12
....................    //validar_tag_salida();//FUNCION PARA ABRIR AUTOMATICAMENTE Y GUARDAR ESTADO DE ANTIPASS 
....................    wieg_full=0; 
06EC0:  MOVLB  2
06EC2:  CLRF   x10
....................    wieg=sub_indice=0; 
06EC4:  CLRF   x0F
06EC6:  MOVFF  20F,20C
....................    wiegand_cuenta=0; 
06ECA:  CLRF   x11
....................    memset(data, 0, sizeof(data) ); 
06ECC:  MOVLW  02
06ECE:  MOVWF  FEA
06ED0:  MOVLW  16
06ED2:  MOVWF  FE9
06ED4:  CLRF   00
06ED6:  CLRF   02
06ED8:  MOVLW  1A
06EDA:  MOVWF  01
06EDC:  MOVLB  0
06EDE:  CALL   1E1C
06EE2:  MOVLB  2
....................  }//END TARJETA LEIDA 
....................  if( (wieg==1)&&(wiegand_cuenta>=3) ) { 
06EE4:  DECFSZ x0C,W
06EE6:  BRA    6F30
06EE8:  MOVF   x11,W
06EEA:  SUBLW  02
06EEC:  BC    6F30
....................       wigmal++; 
06EEE:  INCF   x0D,F
....................       //fprintf(DEBUG,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_gotoxy(1,4); 
....................       //printf(lcd_putc,"CAPTURA INC. %u",wigmal ); 
....................       //lcd_putc("CAPTURA INCOMPLETA  "); 
....................       wieg_full=0; 
06EF0:  CLRF   x10
....................       deci=0; 
06EF2:  CLRF   x15
06EF4:  CLRF   x14
06EF6:  CLRF   x13
06EF8:  CLRF   x12
....................       ///////////UNIFICANDO EL TAMAÑO DEL DATO LEIDO///////////////// 
....................       deteccion_nulo=0; 
06EFA:  CLRF   x0A
....................       pre_cuenta=0; 
06EFC:  CLRF   x0B
....................       ////////////////////// 
....................       wieg=sub_indice=i=0; 
06EFE:  CLRF   41
06F00:  CLRF   40
06F02:  MOVFF  40,20F
06F06:  MOVFF  20F,20C
....................       wiegand_cuenta=0; 
06F0A:  CLRF   x11
....................       for(i=0;i<wieg_size;i++) data[i]=0; 
06F0C:  CLRF   41
06F0E:  CLRF   40
06F10:  MOVF   41,F
06F12:  BNZ   6F30
06F14:  MOVF   40,W
06F16:  SUBLW  19
06F18:  BNC   6F30
06F1A:  MOVLW  16
06F1C:  ADDWF  40,W
06F1E:  MOVWF  FE9
06F20:  MOVLW  02
06F22:  ADDWFC 41,W
06F24:  MOVWF  FEA
06F26:  CLRF   FEF
06F28:  INCF   40,F
06F2A:  BTFSC  FD8.2
06F2C:  INCF   41,F
06F2E:  BRA    6F10
....................  } 
06F30:  MOVLB  0
06F32:  GOTO   7D0C (RETURN)
.................... } 
....................  
.................... void enviar_tcp(){ 
....................    envia_pc=1; 
*
06D12:  MOVLW  01
06D14:  MOVWF  1A
....................    StackTask(); 
06D16:  CALL   5AA8
....................    MyTCPTask(); 
06D1A:  RCALL  699A
06D1C:  RETURN 0
.................... } 
.................... //////////////////// 
.................... void zeller(){ 
.................... int16 dia_s1,dia_s2,dia_s3,diac,mesc,dia_fecha;//(day,month,yr,dow,hrs,min,sec 
....................    int siglo,asiglo,resultado,di2; 
....................    diac=31; 
*
0741C:  MOVLB  9
0741E:  CLRF   x00
07420:  MOVLW  1F
07422:  MOVLB  8
07424:  MOVWF  xFF
....................    mesc=10; 
07426:  MOVLB  9
07428:  CLRF   x02
0742A:  MOVLW  0A
0742C:  MOVWF  x01
....................    siglo=20; 
0742E:  MOVLW  14
07430:  MOVWF  x05
....................    asiglo=yr; 
07432:  MOVFF  272,906
....................    //fprintf(U1PRINTER,"Dia:%Ld mes:%Ld año:%d siglo:%d asiglo:%d\r\n",diac,mesc,asiglo,siglo,asiglo); 
....................    if(mesc<3){ 
07436:  MOVF   x02,F
07438:  BNZ   744A
0743A:  MOVF   x01,W
0743C:  SUBLW  02
0743E:  BNC   744A
....................       mesc+=12; 
07440:  MOVLW  0C
07442:  ADDWF  x01,F
07444:  MOVLW  00
07446:  ADDWFC x02,F
....................       asiglo--; 
07448:  DECF   x06,F
....................    } 
....................    dia_s1=(siglo/4)+5*siglo; 
0744A:  RRCF   x05,W
0744C:  MOVWF  x09
0744E:  RRCF   x09,F
07450:  MOVLW  3F
07452:  ANDWF  x09,F
07454:  MOVF   x05,W
07456:  MULLW  05
07458:  MOVF   FF3,W
0745A:  ADDWF  x09,W
0745C:  MOVLB  8
0745E:  MOVWF  xF9
07460:  CLRF   xFA
....................    dia_s2=dia_s1+asiglo+(asiglo/4); 
07462:  MOVLB  9
07464:  MOVF   x06,W
07466:  MOVLB  8
07468:  ADDWF  xF9,W
0746A:  MOVLB  9
0746C:  MOVWF  x09
0746E:  MOVLW  00
07470:  MOVLB  8
07472:  ADDWFC xFA,W
07474:  MOVLB  9
07476:  MOVWF  x0A
07478:  RRCF   x06,W
0747A:  MOVWF  00
0747C:  RRCF   00,F
0747E:  MOVLW  3F
07480:  ANDWF  00,F
07482:  MOVF   00,W
07484:  ADDWF  x09,W
07486:  MOVLB  8
07488:  MOVWF  xFB
0748A:  MOVLW  00
0748C:  MOVLB  9
0748E:  ADDWFC x0A,W
07490:  MOVLB  8
07492:  MOVWF  xFC
....................    dia_s3=dia_s2+((mesc+1)*26)/10; 
07494:  MOVLW  01
07496:  MOVLB  9
07498:  ADDWF  x01,W
0749A:  MOVWF  x09
0749C:  MOVLW  00
0749E:  ADDWFC x02,W
074A0:  MOVWF  x0A
074A2:  MOVWF  x4B
074A4:  MOVFF  909,94A
074A8:  CLRF   x4D
074AA:  MOVLW  1A
074AC:  MOVWF  x4C
074AE:  MOVLB  0
074B0:  CALL   1A40
074B4:  MOVFF  02,90A
074B8:  MOVFF  01,909
074BC:  MOVFF  02,90C
074C0:  MOVFF  01,90B
074C4:  MOVLB  9
074C6:  CLRF   x0E
074C8:  MOVLW  0A
074CA:  MOVWF  x0D
074CC:  MOVLB  0
074CE:  CALL   1AD2
074D2:  MOVF   01,W
074D4:  MOVLB  8
074D6:  ADDWF  xFB,W
074D8:  MOVWF  xFD
074DA:  MOVF   02,W
074DC:  ADDWFC xFC,W
074DE:  MOVWF  xFE
....................    dia_fecha=(dia_s3+diac)%7;//dia de fin de mes 
074E0:  MOVF   xFF,W
074E2:  ADDWF  xFD,W
074E4:  MOVLB  9
074E6:  MOVWF  x09
074E8:  MOVF   x00,W
074EA:  MOVLB  8
074EC:  ADDWFC xFE,W
074EE:  MOVLB  9
074F0:  MOVWF  x0A
074F2:  MOVWF  x0C
074F4:  MOVFF  909,90B
074F8:  CLRF   x0E
074FA:  MOVLW  07
074FC:  MOVWF  x0D
074FE:  MOVLB  0
07500:  CALL   1AD2
07504:  MOVFF  00,903
07508:  MOVLB  9
0750A:  MOVFF  03,904
....................    if(dia_fecha==0) dia_fecha=7; 
0750E:  MOVF   x03,F
07510:  BNZ   751C
07512:  MOVF   x04,F
07514:  BNZ   751C
07516:  CLRF   x04
07518:  MOVLW  07
0751A:  MOVWF  x03
....................    //fprintf(U1PRINTER,"Dia:%Ld ",dia_fecha); 
....................    resultado=31-(dia_fecha-1); 
0751C:  MOVLW  01
0751E:  SUBWF  x03,W
07520:  MOVWF  00
07522:  MOVLW  00
07524:  SUBWFB x04,W
07526:  MOVF   00,W
07528:  XORLW  FF
0752A:  ADDLW  20
0752C:  MOVWF  x07
....................    //fprintf(U1PRINTER,"Dia:%d ",resultado); 
.................... ///////////revisar cambio de horario//////////// 
.................... ds1307_get_date(day,month,yr,dow); 
.................... ds1307_get_time(hrs,min,sec); 
.................... di2=read_ext_eeprom(14); 
*
0771E:  MOVLB  9
07720:  CLRF   x0A
07722:  MOVLW  0E
07724:  MOVWF  x09
07726:  MOVLB  0
07728:  CALL   28AC
0772C:  MOVFF  01,908
.................... if((month==4)&&(dow==1)&&(hrs>=2)&&(di2!=1)){//cambia a horario de verano 
07730:  MOVLB  2
07732:  MOVF   x71,W
07734:  SUBLW  04
07736:  BNZ   778E
07738:  DECFSZ x76,W
0773A:  BRA    778E
0773C:  MOVF   x73,W
0773E:  SUBLW  01
07740:  BC    778E
07742:  MOVLB  9
07744:  DECFSZ x08,W
07746:  BRA    774E
07748:  MOVLB  2
0774A:  BRA    778E
0774C:  MOVLB  9
....................  hrs=hrs+1; 
0774E:  MOVLW  01
07750:  MOVLB  2
07752:  ADDWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
07754:  MOVFF  270,909
07758:  MOVFF  271,90A
0775C:  MOVFF  272,90B
07760:  MOVFF  276,90C
07764:  MOVFF  273,90D
07768:  MOVFF  274,90E
0776C:  MOVFF  275,90F
07770:  MOVLB  0
07772:  RCALL  71B6
....................  di2=1; 
07774:  MOVLW  01
07776:  MOVLB  9
07778:  MOVWF  x08
....................  write_ext_eeprom(14,di2);//(1,0)horario de invierno 
0777A:  CLRF   x0A
0777C:  MOVLW  0E
0777E:  MOVWF  x09
07780:  MOVFF  908,90B
07784:  MOVLB  0
07786:  CALL   2954
.................... } 
0778A:  BRA    77F4
0778C:  MOVLB  2
.................... //if((month==10)&&(dow==1)&&(day==resultado)&&(hrs==3)&&(di2!=day)){//cambia a horario de invierno 
.................... else if((month==10)&&(day==resultado)&&(hrs>=3)&&(hrs<=5)&&(di2!=day)){//cambia a horario de invierno 
0778E:  MOVF   x71,W
07790:  SUBLW  0A
07792:  BNZ   77F6
07794:  MOVLB  9
07796:  MOVF   x07,W
07798:  MOVLB  2
0779A:  SUBWF  x70,W
0779C:  BNZ   77F6
0779E:  MOVF   x73,W
077A0:  SUBLW  02
077A2:  BC    77F6
077A4:  MOVF   x73,W
077A6:  SUBLW  05
077A8:  BNC   77F6
077AA:  MOVF   x70,W
077AC:  MOVLB  9
077AE:  SUBWF  x08,W
077B0:  BTFSS  FD8.2
077B2:  BRA    77B8
077B4:  MOVLB  2
077B6:  BRA    77F6
....................  hrs=hrs-1; 
077B8:  MOVLW  01
077BA:  MOVLB  2
077BC:  SUBWF  x73,F
....................  ds1307_set_date_time(day,month,yr,dow,hrs,min,sec); //dia,mes,año(2 digitos),diasemana,hora,min,seg 
077BE:  MOVFF  270,909
077C2:  MOVFF  271,90A
077C6:  MOVFF  272,90B
077CA:  MOVFF  276,90C
077CE:  MOVFF  273,90D
077D2:  MOVFF  274,90E
077D6:  MOVFF  275,90F
077DA:  MOVLB  0
077DC:  RCALL  71B6
....................  di2=day; 
077DE:  MOVFF  270,908
....................  write_ext_eeprom(14,di2); 
077E2:  MOVLB  9
077E4:  CLRF   x0A
077E6:  MOVLW  0E
077E8:  MOVWF  x09
077EA:  MOVFF  908,90B
077EE:  MOVLB  0
077F0:  CALL   2954
077F4:  MOVLB  2
....................  } 
077F6:  MOVLB  0
077F8:  GOTO   81DC (RETURN)
.................... } 
.................... //////////////////// 
.................... void sensores(){ 
.................... if(en1!=input(entrada01) ){//SENSOR 1 bobina DE ENTRADA 
*
06F58:  BSF    F95.4
06F5A:  MOVLW  00
06F5C:  BTFSC  F83.4
06F5E:  MOVLW  01
06F60:  MOVLB  2
06F62:  SUBWF  x83,W
06F64:  BZ    6FB0
....................    delay_ms(20); 
06F66:  MOVLW  14
06F68:  MOVLB  9
06F6A:  MOVWF  x00
06F6C:  MOVLB  0
06F6E:  CALL   102E
....................    if(en1!=input(entrada01)){ 
06F72:  BSF    F95.4
06F74:  MOVLW  00
06F76:  BTFSC  F83.4
06F78:  MOVLW  01
06F7A:  MOVLB  2
06F7C:  SUBWF  x83,W
06F7E:  BZ    6FB0
....................       en1=input(entrada01); 
06F80:  BSF    F95.4
06F82:  CLRF   x83
06F84:  BTFSC  F83.4
06F86:  INCF   x83,F
....................       //fen4=0; 
....................       if(en1==1){ 
06F88:  DECFSZ x83,W
06F8A:  BRA    6FAA
....................          lcd_putc("\f\n     BIENVENIDO"); 
06F8C:  MOVLW  5A
06F8E:  MOVWF  FF6
06F90:  MOVLW  03
06F92:  MOVWF  FF7
06F94:  MOVLB  0
06F96:  CALL   110C
....................          re_bol=0; 
06F9A:  MOVLB  2
06F9C:  CLRF   x8A
....................          time_bot=0; 
06F9E:  MOVLB  3
06FA0:  CLRF   x52
06FA2:  CLRF   x51
....................          flag_time=0; 
06FA4:  CLRF   x50
....................          //strcpy(txtcp,"EN1-ENTRADA"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
06FA6:  BRA    6FB2
06FA8:  MOVLB  2
....................       else { 
....................          output_low(salida04); 
06FAA:  BCF    F95.3
06FAC:  BCF    F8C.3
....................          re_bol=0; 
06FAE:  CLRF   x8A
06FB0:  MOVLB  3
....................          //lcd_putc("\fEN1-SINDETECCION"); 
....................          //strcpy(txtcp,"EN1-SINDETECCION"); 
....................          //size_tx_tcp=strlen(txtcp); 
....................          //enviar_tcp(); 
....................       } 
....................    } 
.................... }//end S1 
....................  
.................... if(en4!=input(entrada04) ){//BOTON DE TICKET 
06FB2:  BSF    F95.0
06FB4:  MOVLW  00
06FB6:  BTFSC  F83.0
06FB8:  MOVLW  01
06FBA:  MOVLB  2
06FBC:  SUBWF  x86,W
06FBE:  BZ    7020
....................    //delay_ms(10); 
....................    if(en4!=input(entrada04)){ 
06FC0:  BSF    F95.0
06FC2:  MOVLW  00
06FC4:  BTFSC  F83.0
06FC6:  MOVLW  01
06FC8:  SUBWF  x86,W
06FCA:  BZ    7020
....................       en4=input(entrada04); 
06FCC:  BSF    F95.0
06FCE:  CLRF   x86
06FD0:  BTFSC  F83.0
06FD2:  INCF   x86,F
....................       //if( (en4)&&(en1)&&(!re_bol) ){ 
....................       if( (en4)&&(en1)&&(!re_bol)&&(!flag_time) ){ 
06FD4:  MOVF   x86,F
06FD6:  BZ    7020
06FD8:  MOVF   x83,F
06FDA:  BZ    7020
06FDC:  MOVF   x8A,F
06FDE:  BNZ   7020
06FE0:  MOVLB  3
06FE2:  MOVF   x50,F
06FE4:  BTFSC  FD8.2
06FE6:  BRA    6FEC
06FE8:  MOVLB  2
06FEA:  BRA    7020
....................          flag_time=1; 
06FEC:  MOVLW  01
06FEE:  MOVWF  x50
....................          time_boleto=0; 
06FF0:  MOVLB  2
06FF2:  CLRF   x89
....................          //re_bol=1; 
....................          sprintf(txtcp,"BOTON_BOLETO");//01-id de camion  
06FF4:  MOVLB  8
06FF6:  MOVWF  xF7
06FF8:  MOVLW  06
06FFA:  MOVWF  xF6
06FFC:  MOVLW  6C
06FFE:  MOVWF  FF6
07000:  MOVLW  03
07002:  MOVWF  FF7
07004:  MOVLB  0
07006:  BRA    6F36
....................          size_tx_tcp=strlen(txtcp); 
07008:  MOVLW  01
0700A:  MOVLB  9
0700C:  MOVWF  x0F
0700E:  MOVLW  06
07010:  MOVWF  x0E
07012:  MOVLB  0
07014:  CALL   1E36
07018:  MOVFF  01,48
....................          enviar_tcp(); 
0701C:  RCALL  6D12
0701E:  MOVLB  2
....................       }//end boton activado 
....................       /*else if( (en4==1)&&(cupo) ){ 
....................             lcd_gotoxy(1,2); 
....................             lcd_putc("     CUPO LLENO     "); 
....................       }*/ 
....................    }//verificacion boton 
.................... }//en boton ticket 
07020:  MOVLB  0
07022:  GOTO   7D10 (RETURN)
.................... ///////////////////// 
.................... /*if(en5!=input(entrada05) ){//SENSOR DE BARRERA ENTRADA 
....................    delay_ms(200); 
....................    if(en5!=input(entrada05) ){ 
....................       en5=input(entrada05); 
....................       if( (en5==0)&&(flag_pluma==0) ){ 
....................          espera_tcp(); 
....................          for(i=0;i<16;i++) tcp_XX[i]=barrera[i];//BARRERAABIERTAS2 
....................          size_tx_tcp=i; 
....................          enviar_tcp();//enviar a pc//avisar por tcp 
....................       } 
....................       else if(en5==1) flag_pluma=0; 
....................    } 
.................... }*/ 
.................... ///////////////////// 
.................... } 
.................... //EPSON 
.................... void ticket(){//U1PRINTER //HHMMSSFFFFFFFFZ 
....................    // 1-Direccion1 para Folio 
....................    // 2-Direccion2 para Folio 
....................    // 3-Direccion3 para Folio 
....................    //int cta_l,cta_m,cta_h; 
....................    char fol_bol[20]; 
....................    /*//leer 
....................    cta_l=read_ext_eeprom(3); 
....................    cta_m=read_ext_eeprom(2); 
....................    cta_h=read_ext_eeprom(1); 
....................    folio=0;//24bits 16,777,215 
....................    folio=cta_h;// 
....................    folio=(folio<<8)|cta_m; 
....................    folio=(folio<<8)|cta_l; 
....................    //fin de leer 
....................    folio++; 
....................    //printf("Total:%Ld\r\n",folio); 
....................    write_ext_eeprom(3,folio);//graba 
....................    write_ext_eeprom(2,folio>>8);//graba 
....................    write_ext_eeprom(1,folio>>16);//graba 
....................    */ 
....................    //////////////////////////////// 
....................    ds1307_get_date(day,month,yr,dow); 
....................    ds1307_get_time(hrs,min,sec); 
....................    ////////texto////// 
....................    //inicializa el envio de codigos esc/pos 
....................    fputc(27, U1PRINTER); 
*
02248:  MOVLW  1B
0224A:  MOVLB  9
0224C:  MOVWF  x13
0224E:  MOVLB  0
02250:  RCALL  1E0C
....................    fputc('@', U1PRINTER); 
02252:  MOVLW  40
02254:  MOVLB  9
02256:  MOVWF  x13
02258:  MOVLB  0
0225A:  RCALL  1E0C
....................    //linea de justificacion 1B "a" 0izquierda 1centrado 2derecha 
....................    fputc(27, U1PRINTER); 
0225C:  MOVLW  1B
0225E:  MOVLB  9
02260:  MOVWF  x13
02262:  MOVLB  0
02264:  RCALL  1E0C
....................    fputc(97, U1PRINTER); 
02266:  MOVLW  61
02268:  MOVLB  9
0226A:  MOVWF  x13
0226C:  MOVLB  0
0226E:  RCALL  1E0C
....................    fputc(1, U1PRINTER); 
02270:  MOVLW  01
02272:  MOVLB  9
02274:  MOVWF  x13
02276:  MOVLB  0
02278:  RCALL  1E0C
....................    //////interlineado//////// 
....................    //fprintf(U1PRINTER,"\x1B"); 
....................    //fprintf(U1PRINTER,"3"); 
....................    fputc(27, U1PRINTER); 
0227A:  MOVLW  1B
0227C:  MOVLB  9
0227E:  MOVWF  x13
02280:  MOVLB  0
02282:  RCALL  1E0C
....................    fputc(51, U1PRINTER); 
02284:  MOVLW  33
02286:  MOVLB  9
02288:  MOVWF  x13
0228A:  MOVLB  0
0228C:  RCALL  1E0C
....................    fputc(40, U1PRINTER); 
0228E:  MOVLW  28
02290:  MOVLB  9
02292:  MOVWF  x13
02294:  MOVLB  0
02296:  RCALL  1E0C
....................    //////////// 
....................    /////negritas activas 
....................    fprintf(U1PRINTER,"\x1B"); 
02298:  MOVLW  1B
0229A:  MOVLB  9
0229C:  MOVWF  x13
0229E:  MOVLB  0
022A0:  RCALL  1E0C
....................    fprintf(U1PRINTER,"G"); 
022A2:  MOVLW  47
022A4:  MOVLB  9
022A6:  MOVWF  x13
022A8:  MOVLB  0
022AA:  RCALL  1E0C
....................    fprintf(U1PRINTER,"\x01"); 
022AC:  MOVLW  01
022AE:  MOVLB  9
022B0:  MOVWF  x13
022B2:  MOVLB  0
022B4:  RCALL  1E0C
....................    /////Tipo de fuente 
....................    fprintf(U1PRINTER,"\x1B"); 
022B6:  MOVLW  1B
022B8:  MOVLB  9
022BA:  MOVWF  x13
022BC:  MOVLB  0
022BE:  RCALL  1E0C
....................    fprintf(U1PRINTER,"!"); 
022C0:  MOVLW  21
022C2:  MOVLB  9
022C4:  MOVWF  x13
022C6:  MOVLB  0
022C8:  RCALL  1E0C
....................    fputc(1, U1PRINTER); 
022CA:  MOVLW  01
022CC:  MOVLB  9
022CE:  MOVWF  x13
022D0:  MOVLB  0
022D2:  RCALL  1E0C
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
022D4:  MOVLW  1D
022D6:  MOVLB  9
022D8:  MOVWF  x13
022DA:  MOVLB  0
022DC:  RCALL  1E0C
....................    fprintf(U1PRINTER,"!"); 
022DE:  MOVLW  21
022E0:  MOVLB  9
022E2:  MOVWF  x13
022E4:  MOVLB  0
022E6:  RCALL  1E0C
....................    fputc(17, U1PRINTER); 
022E8:  MOVLW  11
022EA:  MOVLB  9
022EC:  MOVWF  x13
022EE:  MOVLB  0
022F0:  RCALL  1E0C
....................    //printf("\x0A");//limpia la justificación 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    memset(fol_bol, 0, sizeof(fol_bol)); 
022F2:  MOVLW  08
022F4:  MOVWF  FEA
022F6:  MOVLW  F9
022F8:  MOVWF  FE9
022FA:  CLRF   00
022FC:  CLRF   02
022FE:  MOVLW  14
02300:  MOVWF  01
02302:  RCALL  1E1C
....................    for(i=0;i<strlen(XX);i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
02304:  CLRF   41
02306:  CLRF   40
02308:  MOVLB  9
0230A:  CLRF   x0F
0230C:  MOVLW  52
0230E:  MOVWF  x0E
02310:  MOVLB  0
02312:  RCALL  1E36
02314:  MOVF   41,F
02316:  BNZ   2358
02318:  MOVF   01,W
0231A:  SUBWF  40,W
0231C:  BC    2358
0231E:  MOVLW  F9
02320:  ADDWF  40,W
02322:  MOVWF  01
02324:  MOVLW  08
02326:  ADDWFC 41,W
02328:  MOVWF  03
0232A:  MOVFF  01,90D
0232E:  MOVLB  9
02330:  MOVWF  x0E
02332:  MOVLW  5C
02334:  ADDWF  40,W
02336:  MOVWF  FE9
02338:  MOVLW  00
0233A:  ADDWFC 41,W
0233C:  MOVWF  FEA
0233E:  MOVFF  FEF,911
02342:  MOVFF  03,FEA
02346:  MOVFF  01,FE9
0234A:  MOVFF  911,FEF
0234E:  INCF   40,F
02350:  BTFSC  FD8.2
02352:  INCF   41,F
02354:  BRA    230A
02356:  MOVLB  0
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //for(i=0;i<8;i++) fol_bol[i]=XX[instruccion_size+i];//vaciando folio del tcp 
....................    //folio = atoi32(fol_bol); 
....................    //fprintf(U1PRINTER,"Folio:%08Ld",folio); 
....................    fprintf(U1PRINTER,"Folio:%s",fol_bol);/////////----------------------------------------------+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
02358:  MOVLW  7A
0235A:  MOVWF  FF6
0235C:  MOVLW  03
0235E:  MOVWF  FF7
02360:  MOVLW  06
02362:  MOVLB  9
02364:  MOVWF  x0D
02366:  MOVLB  0
02368:  RCALL  1E70
0236A:  MOVLW  08
0236C:  MOVWF  FEA
0236E:  MOVLW  F9
02370:  MOVWF  FE9
02372:  RCALL  1E98
....................    //fprintf(U1PRINTER,"Folio:%s","A188264"); 
....................    strcpy(barra_codi,fol_bol);      /********************************************regresar modificacion*/ 
02374:  MOVLW  02
02376:  MOVWF  FEA
02378:  MOVLW  4E
0237A:  MOVWF  FE9
0237C:  MOVLW  08
0237E:  MOVWF  FE2
02380:  MOVLW  F9
02382:  MOVWF  FE1
02384:  MOVF   FE7,F
02386:  MOVFF  FE6,FEE
0238A:  BNZ   2384
....................    //strcpy(barra_codi,"A188264"); 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0238C:  MOVLW  0A
0238E:  MOVLB  9
02390:  MOVWF  x13
02392:  MOVLB  0
02394:  RCALL  1E0C
....................    LF(); 
02396:  RCALL  1EBC
....................    /////////////////////////////////////////////////////////// 
....................    fprintf(U1PRINTER,"MARIA TERESA BAEZ MONROY"); 
02398:  MOVLW  84
0239A:  MOVWF  FF6
0239C:  MOVLW  03
0239E:  MOVWF  FF7
023A0:  RCALL  1EC8
....................    //fprintf(U1PRINTER,"PLAZA COMERCIAL 4 y 13"); 
....................    //printf("\x0A");//limpia la justificación  
....................    ////desactiva negritas 
....................    fprintf(U1PRINTER,"\x1B"); 
023A2:  MOVLW  1B
023A4:  MOVLB  9
023A6:  MOVWF  x13
023A8:  MOVLB  0
023AA:  RCALL  1E0C
....................    fprintf(U1PRINTER,"G"); 
023AC:  MOVLW  47
023AE:  MOVLB  9
023B0:  MOVWF  x13
023B2:  MOVLB  0
023B4:  RCALL  1E0C
....................    fprintf(U1PRINTER,"\x00"); 
....................    /////////////////////////////////////////////////////////// 
....................    LF(); 
023B6:  RCALL  1EBC
....................    LF(); 
023B8:  RCALL  1EBC
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); 
023BA:  MOVLW  1D
023BC:  MOVLB  9
023BE:  MOVWF  x13
023C0:  MOVLB  0
023C2:  RCALL  1E0C
....................    fprintf(U1PRINTER,"!"); 
023C4:  MOVLW  21
023C6:  MOVLB  9
023C8:  MOVWF  x13
023CA:  MOVLB  0
023CC:  RCALL  1E0C
....................    fputc(0, U1PRINTER); 
023CE:  MOVLB  9
023D0:  CLRF   x13
023D2:  MOVLB  0
023D4:  RCALL  1E0C
....................    ///// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
023D6:  MOVLW  0A
023D8:  MOVLB  9
023DA:  MOVWF  x13
023DC:  MOVLB  0
023DE:  RCALL  1E0C
....................    fprintf(U1PRINTER,"RFC:BAMT97052884A\x0A"); 
023E0:  MOVLW  9E
023E2:  MOVWF  FF6
023E4:  MOVLW  03
023E6:  MOVWF  FF7
023E8:  RCALL  1EC8
....................    fprintf(U1PRINTER,"4 poniente 1302, colonia Centro  CP 72000\x0APuebla, Puebla\x0A"); 
023EA:  MOVLW  B2
023EC:  MOVWF  FF6
023EE:  MOVLW  03
023F0:  MOVWF  FF7
023F2:  RCALL  1EC8
....................     
....................    fprintf(U1PRINTER,"   Estacionamiento por Autoservicio\x0A"); 
023F4:  MOVLW  EC
023F6:  MOVWF  FF6
023F8:  MOVLW  03
023FA:  MOVWF  FF7
023FC:  RCALL  1EC8
....................    ///size 
....................    fprintf(U1PRINTER,"\x1D"); 
023FE:  MOVLW  1D
02400:  MOVLB  9
02402:  MOVWF  x13
02404:  MOVLB  0
02406:  RCALL  1E0C
....................    fprintf(U1PRINTER,"!"); 
02408:  MOVLW  21
0240A:  MOVLB  9
0240C:  MOVWF  x13
0240E:  MOVLB  0
02410:  RCALL  1E0C
....................    fputc(17, U1PRINTER); 
02412:  MOVLW  11
02414:  MOVLB  9
02416:  MOVWF  x13
02418:  MOVLB  0
0241A:  RCALL  1E0C
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0241C:  MOVLW  0A
0241E:  MOVLB  9
02420:  MOVWF  x13
02422:  MOVLB  0
02424:  RCALL  1E0C
....................    fprintf(U1PRINTER,"%02d/%02d/20%02d %02d:%02d:%02d",day,month,yr,hrs,min,sec); 
02426:  MOVFF  270,90D
0242A:  MOVLW  01
0242C:  MOVLB  9
0242E:  MOVWF  x0E
02430:  MOVLB  0
02432:  RCALL  1F14
02434:  MOVLW  2F
02436:  MOVLB  9
02438:  MOVWF  x13
0243A:  MOVLB  0
0243C:  RCALL  1E0C
0243E:  MOVFF  271,90D
02442:  MOVLW  01
02444:  MOVLB  9
02446:  MOVWF  x0E
02448:  MOVLB  0
0244A:  RCALL  1F14
0244C:  MOVLW  1B
0244E:  MOVWF  FF6
02450:  MOVLW  04
02452:  MOVWF  FF7
02454:  MOVLW  03
02456:  MOVLB  9
02458:  MOVWF  x0D
0245A:  MOVLB  0
0245C:  RCALL  1E70
0245E:  MOVFF  272,90D
02462:  MOVLW  01
02464:  MOVLB  9
02466:  MOVWF  x0E
02468:  MOVLB  0
0246A:  RCALL  1F14
0246C:  MOVLW  20
0246E:  MOVLB  9
02470:  MOVWF  x13
02472:  MOVLB  0
02474:  RCALL  1E0C
02476:  MOVFF  273,90D
0247A:  MOVLW  01
0247C:  MOVLB  9
0247E:  MOVWF  x0E
02480:  MOVLB  0
02482:  RCALL  1F14
02484:  MOVLW  3A
02486:  MOVLB  9
02488:  MOVWF  x13
0248A:  MOVLB  0
0248C:  RCALL  1E0C
0248E:  MOVFF  274,90D
02492:  MOVLW  01
02494:  MOVLB  9
02496:  MOVWF  x0E
02498:  MOVLB  0
0249A:  RCALL  1F14
0249C:  MOVLW  3A
0249E:  MOVLB  9
024A0:  MOVWF  x13
024A2:  MOVLB  0
024A4:  RCALL  1E0C
024A6:  MOVFF  275,90D
024AA:  MOVLW  01
024AC:  MOVLB  9
024AE:  MOVWF  x0E
024B0:  MOVLB  0
024B2:  RCALL  1F14
....................    LF(); 
024B4:  RCALL  1EBC
....................    /////size//////////// 
....................    fprintf(U1PRINTER,"\x1D"); //1D 
024B6:  MOVLW  1D
024B8:  MOVLB  9
024BA:  MOVWF  x13
024BC:  MOVLB  0
024BE:  RCALL  1E0C
....................    fprintf(U1PRINTER,"!"); 
024C0:  MOVLW  21
024C2:  MOVLB  9
024C4:  MOVWF  x13
024C6:  MOVLB  0
024C8:  RCALL  1E0C
....................    fputc(0, U1PRINTER); 
024CA:  MOVLB  9
024CC:  CLRF   x13
024CE:  MOVLB  0
024D0:  RCALL  1E0C
....................    ///// 
....................    //barra1(); 
....................    barra1(); 
024D2:  BRA    1FD0
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
024D4:  MOVLW  0A
024D6:  MOVLB  9
024D8:  MOVWF  x13
024DA:  MOVLB  0
024DC:  RCALL  1E0C
....................    fprintf(U1PRINTER,"TARIFA:$19.00/100 Hora o Fraccion              \x0A"); 
024DE:  MOVLW  32
024E0:  MOVWF  FF6
024E2:  MOVLW  04
024E4:  MOVWF  FF7
024E6:  RCALL  1EC8
....................    fprintf(U1PRINTER,"TOLERANCIA:5 min. la primera hora              \x0A"); 
024E8:  MOVLW  64
024EA:  MOVWF  FF6
024EC:  MOVLW  04
024EE:  MOVWF  FF7
024F0:  RCALL  1EC8
....................    fprintf(U1PRINTER,"Horarios:de 7:00 a 21:00hrs. de lunes a viernes\x0A"); 
024F2:  MOVLW  96
024F4:  MOVWF  FF6
024F6:  MOVLW  04
024F8:  MOVWF  FF7
024FA:  RCALL  1EC8
....................    fprintf(U1PRINTER,"Sabado y domingo de 8:00 a 20:00hrs.           \x0A"); 
024FC:  MOVLW  C8
024FE:  MOVWF  FF6
02500:  MOVLW  04
02502:  MOVWF  FF7
02504:  RCALL  1EC8
....................   // fprintf(U1PRINTER,"Domingo  de 8:00 a 19:00hrs.                   \x0A"); 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
02506:  MOVLW  0A
02508:  MOVLB  9
0250A:  MOVWF  x13
0250C:  MOVLB  0
0250E:  RCALL  1E0C
....................    //////////////////// 
....................   //barra2(); 
....................    //////////////////// 
....................   //fprintf(U1PRINTER,"Hora de salida:________________________________\x0A"); 
....................    ///****//////// 
....................    fprintf(U1PRINTER,"    CONTRATO DE PRESTACION DE SERVICIOS DE     \x0A"); 
02510:  MOVLW  FA
02512:  MOVWF  FF6
02514:  MOVLW  04
02516:  MOVWF  FF7
02518:  RCALL  1EC8
....................    fprintf(U1PRINTER,"       ESTACIONAMIENTO POR AUTOSERVICIO        \x0A"); 
0251A:  MOVLW  2C
0251C:  MOVWF  FF6
0251E:  MOVLW  05
02520:  MOVWF  FF7
02522:  RCALL  1EC8
....................    fprintf(U1PRINTER,"                  CLAUSULAS                    \x0A"); 
02524:  MOVLW  5E
02526:  MOVWF  FF6
02528:  MOVLW  05
0252A:  MOVWF  FF7
0252C:  RCALL  1EC8
....................    fprintf(U1PRINTER,"PRIMERA.- El vehículo será resguardado en el   \x0A"); 
0252E:  MOVLW  90
02530:  MOVWF  FF6
02532:  MOVLW  05
02534:  MOVWF  FF7
02536:  RCALL  1EC8
....................    fprintf(U1PRINTER,"estacionamiento. Solo al portador de este docu-\x0A"); 
02538:  MOVLW  C2
0253A:  MOVWF  FF6
0253C:  MOVLW  05
0253E:  MOVWF  FF7
02540:  RCALL  1EC8
....................    fprintf(U1PRINTER,"mento se le hará entrega de la unidad, en caso \x0A"); 
02542:  MOVLW  F4
02544:  MOVWF  FF6
02546:  MOVLW  05
02548:  MOVWF  FF7
0254A:  RCALL  1EC8
....................    fprintf(U1PRINTER,"de extravió del mismo se hará entrega a quien  \x0A"); 
0254C:  MOVLW  26
0254E:  MOVWF  FF6
02550:  MOVLW  06
02552:  MOVWF  FF7
02554:  RCALL  1EC8
....................    fprintf(U1PRINTER,"acredite su propiedad. En este supuesto,el mon-\x0A"); 
02556:  MOVLW  58
02558:  MOVWF  FF6
0255A:  MOVLW  06
0255C:  MOVWF  FF7
0255E:  RCALL  1EC8
....................    fprintf(U1PRINTER,"to a pagar se calculara desde las 7:00 horas   \x0A"); 
02560:  MOVLW  8A
02562:  MOVWF  FF6
02564:  MOVLW  06
02566:  MOVWF  FF7
02568:  RCALL  1EC8
....................    fprintf(U1PRINTER,"del día en que ingreso el vehículo hasta su ho-\x0A"); 
0256A:  MOVLW  BC
0256C:  MOVWF  FF6
0256E:  MOVLW  06
02570:  MOVWF  FF7
02572:  RCALL  1EC8
....................    fprintf(U1PRINTER,"ra de salida, sin cargo económico adicional.   \x0A"); 
02574:  MOVLW  EE
02576:  MOVWF  FF6
02578:  MOVLW  06
0257A:  MOVWF  FF7
0257C:  RCALL  1EC8
....................    fprintf(U1PRINTER,"El proveedor no podrá cobrar ningún pago sin el\x0A"); 
0257E:  MOVLW  20
02580:  MOVWF  FF6
02582:  MOVLW  07
02584:  MOVWF  FF7
02586:  RCALL  1EC8
....................    fprintf(U1PRINTER,"consentimiento del consumidor o que éste no de-\x0A"); 
02588:  MOVLW  52
0258A:  MOVWF  FF6
0258C:  MOVLW  07
0258E:  MOVWF  FF7
02590:  RCALL  1EC8
....................    fprintf(U1PRINTER,"venga de este contrato.                        \x0A"); 
02592:  MOVLW  84
02594:  MOVWF  FF6
02596:  MOVLW  07
02598:  MOVWF  FF7
0259A:  RCALL  1EC8
....................    fprintf(U1PRINTER,"SEGUNDA.- Se otorgarán cinco minutos de tole-  \x0A"); 
0259C:  MOVLW  B6
0259E:  MOVWF  FF6
025A0:  MOVLW  07
025A2:  MOVWF  FF7
025A4:  RCALL  1EC8
....................    fprintf(U1PRINTER,"rancia sólo en la primera hora, en las horas   \x0A"); 
025A6:  MOVLW  E8
025A8:  MOVWF  FF6
025AA:  MOVLW  07
025AC:  MOVWF  FF7
025AE:  RCALL  1EC8
....................    fprintf(U1PRINTER,"subsecuentes no habrá tolerancia. El proveedor \x0A"); 
025B0:  MOVLW  1A
025B2:  MOVWF  FF6
025B4:  MOVLW  08
025B6:  MOVWF  FF7
025B8:  RCALL  1EC8
....................    fprintf(U1PRINTER,"hizo del conocimiento al consumidor las res-   \x0A"); 
025BA:  MOVLW  4C
025BC:  MOVWF  FF6
025BE:  MOVLW  08
025C0:  MOVWF  FF7
025C2:  RCALL  1EC8
....................    fprintf(U1PRINTER,"tricciones que, en su caso, operen sobre el    \x0A"); 
025C4:  MOVLW  7E
025C6:  MOVWF  FF6
025C8:  MOVLW  08
025CA:  MOVWF  FF7
025CC:  RCALL  1EC8
....................    fprintf(U1PRINTER,"servicio objeto de este contrato.              \x0A");   
025CE:  MOVLW  B0
025D0:  MOVWF  FF6
025D2:  MOVLW  08
025D4:  MOVWF  FF7
025D6:  RCALL  1EC8
....................    fprintf(U1PRINTER,"TERCERA.-Para el caso de robo total,el proveedo\x0A"); 
025D8:  MOVLW  E2
025DA:  MOVWF  FF6
025DC:  MOVLW  08
025DE:  MOVWF  FF7
025E0:  RCALL  1EC8
....................    fprintf(U1PRINTER,"or cuenta con un seguro que cubre dicho evento.\x0A"); 
025E2:  MOVLW  14
025E4:  MOVWF  FF6
025E6:  MOVLW  09
025E8:  MOVWF  FF7
025EA:  RCALL  1EC8
....................    fprintf(U1PRINTER,"CUARTA.- El proveedor no será responsable por: \x0A"); 
025EC:  MOVLW  46
025EE:  MOVWF  FF6
025F0:  MOVLW  09
025F2:  MOVWF  FF7
025F4:  RCALL  1EC8
....................    fprintf(U1PRINTER,"vehículo(s) abandonado(s) más de 30 días,en cu-\x0A"); 
025F6:  MOVLW  78
025F8:  MOVWF  FF6
025FA:  MOVLW  09
025FC:  MOVWF  FF7
025FE:  RCALL  1EC8
....................    fprintf(U1PRINTER,"yo caso se procederá en términos del Reglamento\x0A"); 
02600:  MOVLW  AA
02602:  MOVWF  FF6
02604:  MOVLW  09
02606:  MOVWF  FF7
02608:  RCALL  1EC8
....................    fprintf(U1PRINTER,"de Estacionamientos Públicos de la Ciudad de   \x0A"); 
0260A:  MOVLW  DC
0260C:  MOVWF  FF6
0260E:  MOVLW  09
02610:  MOVWF  FF7
02612:  RCALL  1EC8
....................    fprintf(U1PRINTER,"México.                                        \x0A");    
02614:  MOVLW  0E
02616:  MOVWF  FF6
02618:  MOVLW  0A
0261A:  MOVWF  FF7
0261C:  RCALL  1EC8
....................    fprintf(U1PRINTER,"QUINTA.- La entrega y recibo del presente con- \x0A"); 
0261E:  MOVLW  40
02620:  MOVWF  FF6
02622:  MOVLW  0A
02624:  MOVWF  FF7
02626:  RCALL  1EC8
....................    fprintf(U1PRINTER,"trato implica la aceptación de los derechos y  \x0A"); 
02628:  MOVLW  72
0262A:  MOVWF  FF6
0262C:  MOVLW  0A
0262E:  MOVWF  FF7
02630:  RCALL  1EC8
....................    fprintf(U1PRINTER,"obligaciones estipulados en él.                \x0A"); 
02632:  MOVLW  A4
02634:  MOVWF  FF6
02636:  MOVLW  0A
02638:  MOVWF  FF7
0263A:  RCALL  1EC8
....................    fprintf(U1PRINTER,"SEXTA.- La Procuraduría Federal del Consumidor \x0A"); 
0263C:  MOVLW  D6
0263E:  MOVWF  FF6
02640:  MOVLW  0A
02642:  MOVWF  FF7
02644:  RCALL  1EC8
....................    fprintf(U1PRINTER,"es competente en la vía administrativa para re-\x0A"); 
02646:  MOVLW  08
02648:  MOVWF  FF6
0264A:  MOVLW  0B
0264C:  MOVWF  FF7
0264E:  RCALL  1EC8
....................    fprintf(U1PRINTER,"solver cualquier controversia que se suscite   \x0A"); 
02650:  MOVLW  3A
02652:  MOVWF  FF6
02654:  MOVLW  0B
02656:  MOVWF  FF7
02658:  RCALL  1EC8
....................    fprintf(U1PRINTER,"sobre la interpretación o cumplimiento del pre-\x0A"); 
0265A:  MOVLW  6C
0265C:  MOVWF  FF6
0265E:  MOVLW  0B
02660:  MOVWF  FF7
02662:  RCALL  1EC8
....................    fprintf(U1PRINTER,"sente contrato. Sin perjuicio de lo anterior,  \x0A"); 
02664:  MOVLW  9E
02666:  MOVWF  FF6
02668:  MOVLW  0B
0266A:  MOVWF  FF7
0266C:  RCALL  1EC8
....................    fprintf(U1PRINTER,"las partes se someten a la jurisdicción de los \x0A"); 
0266E:  MOVLW  D0
02670:  MOVWF  FF6
02672:  MOVLW  0B
02674:  MOVWF  FF7
02676:  RCALL  1EC8
....................    fprintf(U1PRINTER,"Tribunales competentes en Puebla, renunciando  \x0A"); 
02678:  MOVLW  02
0267A:  MOVWF  FF6
0267C:  MOVLW  0C
0267E:  MOVWF  FF7
02680:  RCALL  1EC8
....................    fprintf(U1PRINTER,"expresamente a cualquier otra jurisdicción que \x0A"); 
02682:  MOVLW  34
02684:  MOVWF  FF6
02686:  MOVLW  0C
02688:  MOVWF  FF7
0268A:  RCALL  1EC8
....................    fprintf(U1PRINTER,"pudiera corresponderles, por razón de sus domi-\x0A"); 
0268C:  MOVLW  66
0268E:  MOVWF  FF6
02690:  MOVLW  0C
02692:  MOVWF  FF7
02694:  RCALL  1EC8
....................    fprintf(U1PRINTER,"cilios presentes o futuros o por cualquier otra\x0A"); 
02696:  MOVLW  98
02698:  MOVWF  FF6
0269A:  MOVLW  0C
0269C:  MOVWF  FF7
0269E:  RCALL  1EC8
....................    fprintf(U1PRINTER,"razón.                                         \x0A");  
026A0:  MOVLW  CA
026A2:  MOVWF  FF6
026A4:  MOVLW  0C
026A6:  MOVWF  FF7
026A8:  RCALL  1EC8
....................    fprintf(U1PRINTER,"De no estar de acuerdo con las clausulas ante -\x0A");  
026AA:  MOVLW  FC
026AC:  MOVWF  FF6
026AE:  MOVLW  0C
026B0:  MOVWF  FF7
026B2:  RCALL  1EC8
....................    fprintf(U1PRINTER,"riores favor de retirar su automóvil.          \x0A"); 
026B4:  MOVLW  2E
026B6:  MOVWF  FF6
026B8:  MOVLW  0D
026BA:  MOVWF  FF7
026BC:  RCALL  1EC8
....................    fprintf(U1PRINTER,"Este contrato fue aprobado y registrado por la \x0A"); 
026BE:  MOVLW  60
026C0:  MOVWF  FF6
026C2:  MOVLW  0D
026C4:  MOVWF  FF7
026C6:  RCALL  1EC8
....................    fprintf(U1PRINTER,"Procuraduría Federal del Consumidor bajo el nú-\x0A"); 
026C8:  MOVLW  92
026CA:  MOVWF  FF6
026CC:  MOVLW  0D
026CE:  MOVWF  FF7
026D0:  CALL   1EC8
....................    fprintf(U1PRINTER,"mero <<NÚMERO DE REGISTRO>> de fecha <<FECHA DE\x0A"); 
026D4:  MOVLW  C4
026D6:  MOVWF  FF6
026D8:  MOVLW  0D
026DA:  MOVWF  FF7
026DC:  CALL   1EC8
....................    fprintf(U1PRINTER,"REGISTRO>>. Cualquier variación del presente   \x0A"); 
026E0:  MOVLW  F6
026E2:  MOVWF  FF6
026E4:  MOVLW  0D
026E6:  MOVWF  FF7
026E8:  CALL   1EC8
....................    fprintf(U1PRINTER,"contrato en perjuicio de EL CONSUMIDOR, frente \x0A"); 
026EC:  MOVLW  28
026EE:  MOVWF  FF6
026F0:  MOVLW  0E
026F2:  MOVWF  FF7
026F4:  CALL   1EC8
....................    fprintf(U1PRINTER,"al contrato de adhesión registrado, se tendrá  \x0A"); 
026F8:  MOVLW  5A
026FA:  MOVWF  FF6
026FC:  MOVLW  0E
026FE:  MOVWF  FF7
02700:  CALL   1EC8
....................    fprintf(U1PRINTER,"por no puesta.                                 \x0A"); 
02704:  MOVLW  8C
02706:  MOVWF  FF6
02708:  MOVLW  0E
0270A:  MOVWF  FF7
0270C:  CALL   1EC8
....................     
....................  
....................     
....................    ///****//////// 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
02710:  MOVLW  0A
02712:  MOVLB  9
02714:  MOVWF  x13
02716:  MOVLB  0
02718:  CALL   1E0C
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
0271C:  MOVLW  0A
0271E:  MOVLB  9
02720:  MOVWF  x13
02722:  MOVLB  0
02724:  CALL   1E0C
....................    fprintf(U1PRINTER,"\"QUEJAS AL TELEFONO:"); 
02728:  MOVLW  BE
0272A:  MOVWF  FF6
0272C:  MOVLW  0E
0272E:  MOVWF  FF7
02730:  CALL   1EC8
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
02734:  MOVLW  0A
02736:  MOVLB  9
02738:  MOVWF  x13
0273A:  MOVLB  0
0273C:  CALL   1E0C
....................    fprintf(U1PRINTER,"    (222)2-46-15-22 EN LA CIUDAD DE PUEBLA    \x0A"); 
02740:  MOVLW  D4
02742:  MOVWF  FF6
02744:  MOVLW  0E
02746:  MOVWF  FF7
02748:  CALL   1EC8
....................    fprintf(U1PRINTER,"Y AL  01-800-468-8722  DEL  INTERIOR (PROFECO)\x0A"); 
0274C:  MOVLW  04
0274E:  MOVWF  FF6
02750:  MOVLW  0F
02752:  MOVWF  FF7
02754:  CALL   1EC8
....................    //fprintf(U1PRINTER,"                  REPUBLICA                   \x0A"); 
....................    //fprintf(U1PRINTER,"                   PROFECO                    \x0A"); 
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación 
02758:  MOVLW  0A
0275A:  MOVLB  9
0275C:  MOVWF  x13
0275E:  MOVLB  0
02760:  CALL   1E0C
....................     
....................    fprintf(U1PRINTER," ""ACCESA" "automatizacion de estacionamientos\x0A"); 
02764:  MOVLW  34
02766:  MOVWF  FF6
02768:  MOVLW  0F
0276A:  MOVWF  FF7
0276C:  CALL   1EC8
....................    fprintf(U1PRINTER,"   www.accesa.me automatizacion@accesa.me     \x0A"); 
02770:  MOVLW  60
02772:  MOVWF  FF6
02774:  MOVLW  0F
02776:  MOVWF  FF7
02778:  CALL   1EC8
....................    /////////feed para corte de papel////////////// 
....................    fprintf(U1PRINTER,"\x1B"); 
0277C:  MOVLW  1B
0277E:  MOVLB  9
02780:  MOVWF  x13
02782:  MOVLB  0
02784:  CALL   1E0C
....................    fprintf(U1PRINTER,"J"); 
02788:  MOVLW  4A
0278A:  MOVLB  9
0278C:  MOVWF  x13
0278E:  MOVLB  0
02790:  CALL   1E0C
....................    //fputc(190, U1PRINTER); 
....................    fputc(250, U1PRINTER); 
02794:  MOVLW  FA
02796:  MOVLB  9
02798:  MOVWF  x13
0279A:  MOVLB  0
0279C:  CALL   1E0C
....................    fprintf(U1PRINTER,"\x0A");//limpia la justificación  
027A0:  MOVLW  0A
027A2:  MOVLB  9
027A4:  MOVWF  x13
027A6:  MOVLB  0
027A8:  CALL   1E0C
....................    LF(); 
027AC:  CALL   1EBC
....................    ///////// 
....................    //ESC i 69 Corte total de papel 
....................    //ESC m 6D Corte parcial de papel 
....................    fprintf(U1PRINTER,"\x1B"); 
027B0:  MOVLW  1B
027B2:  MOVLB  9
027B4:  MOVWF  x13
027B6:  MOVLB  0
027B8:  CALL   1E0C
....................    fprintf(U1PRINTER,"m"); 
027BC:  MOVLW  6D
027BE:  MOVLB  9
027C0:  MOVWF  x13
027C2:  MOVLB  0
027C4:  CALL   1E0C
027C8:  RETURN 0
....................    //////////////////////////////////////// 
.................... } 
....................  
.................... void LF(){ 
.................... fprintf(U1PRINTER,"\x0A"); 
*
01EBC:  MOVLW  0A
01EBE:  MOVLB  9
01EC0:  MOVWF  x13
01EC2:  MOVLB  0
01EC4:  RCALL  1E0C
01EC6:  RETURN 0
.................... } 
....................  
.................... void CR(){ 
.................... fprintf(U1PRINTER,"\x0D");//enter 
.................... } 
....................  
.................... void barra1(){ 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d",folio,yr,month,day,hrs,min,sec);// 
....................    //sprintf(con_barra,"%08Ld%d",folio,idbar);//01-id de camion 
....................     
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //fprintf(U1PRINTER,"%08Ld/%02d/%02d/%02d/%02d/%02d/%02d/%d/",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi)+2; 
*
01FD0:  MOVLW  02
01FD2:  MOVLB  9
01FD4:  MOVWF  x0F
01FD6:  MOVLW  4E
01FD8:  MOVWF  x0E
01FDA:  MOVLB  0
01FDC:  RCALL  1E36
01FDE:  MOVLW  02
01FE0:  ADDWF  01,W
01FE2:  MOVLB  9
01FE4:  MOVWF  x0D
....................    //size_bar=strlen(barra_codi); 
....................    //printf (lcd_putc,"\fsize_bar:%u",size_bar); 
....................    //delay_ms(2000); 
.................... //////bar code/////// 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
01FE6:  MOVLW  90
01FE8:  MOVWF  FF6
01FEA:  MOVLW  0F
01FEC:  MOVWF  FF7
01FEE:  MOVLB  0
01FF0:  RCALL  1EC8
....................    //fprintf(U1PRINTER,"\x1D\x77\x01");// 
....................    fprintf(U1PRINTER,"\x1D\x78\x01");// 
01FF2:  MOVLW  94
01FF4:  MOVWF  FF6
01FF6:  MOVLW  0F
01FF8:  MOVWF  FF7
01FFA:  RCALL  1EC8
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
01FFC:  MOVLW  1D
01FFE:  MOVLB  9
02000:  MOVWF  x13
02002:  MOVLB  0
02004:  RCALL  1E0C
....................    fputc(72,U1PRINTER);// 
02006:  MOVLW  48
02008:  MOVLB  9
0200A:  MOVWF  x13
0200C:  MOVLB  0
0200E:  RCALL  1E0C
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
02010:  MOVLW  02
02012:  MOVLB  9
02014:  MOVWF  x13
02016:  MOVLB  0
02018:  RCALL  1E0C
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
0201A:  MOVLW  1D
0201C:  MOVLB  9
0201E:  MOVWF  x13
02020:  MOVLB  0
02022:  RCALL  1E0C
....................    fputc(102,U1PRINTER);// 
02024:  MOVLW  66
02026:  MOVLB  9
02028:  MOVWF  x13
0202A:  MOVLB  0
0202C:  RCALL  1E0C
....................    fputc(1,U1PRINTER);//0,1 Y 2 
0202E:  MOVLW  01
02030:  MOVLB  9
02032:  MOVWF  x13
02034:  MOVLB  0
02036:  RCALL  1E0C
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
02038:  MOVLW  1D
0203A:  MOVLB  9
0203C:  MOVWF  x13
0203E:  MOVLB  0
02040:  RCALL  1E0C
....................    fputc('k',U1PRINTER); 
02042:  MOVLW  6B
02044:  MOVLB  9
02046:  MOVWF  x13
02048:  MOVLB  0
0204A:  RCALL  1E0C
....................    //fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
....................    fputc(73,U1PRINTER); //69=code39//72=code93//73=code128//70=ITF (solo cantidades pares)// 
0204C:  MOVLW  49
0204E:  MOVLB  9
02050:  MOVWF  x13
02052:  MOVLB  0
02054:  RCALL  1E0C
....................    //fputc(23,U1PRINTER); //numero de caracteres+2 (solo code128) 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
02056:  MOVFF  90D,913
0205A:  RCALL  1E0C
....................    fputc(123,U1PRINTER);// d1 (solo code128) 
0205C:  MOVLW  7B
0205E:  MOVLB  9
02060:  MOVWF  x13
02062:  MOVLB  0
02064:  RCALL  1E0C
....................    fputc(65,U1PRINTER); // d2 (solo code128) 
02066:  MOVLW  41
02068:  MOVLB  9
0206A:  MOVWF  x13
0206C:  MOVLB  0
0206E:  RCALL  1E0C
....................     
....................    fprintf(U1PRINTER,"%s",barra_codi); 
02070:  MOVLW  02
02072:  MOVWF  FEA
02074:  MOVLW  4E
02076:  MOVWF  FE9
02078:  RCALL  1E98
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
0207A:  GOTO   24D4 (RETURN)
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void barra2(){ 
....................    int size_bar; 
....................    size_bar=strlen(barra_codi); 
....................    //sprintf(con_barra,"%08Ld%02d%02d%02d%02d%02d%02d%d",folio,yr,month,day,hrs,min,sec,idbar);//01-id de camion 
....................    //encri();//barra_codi 
....................    //CODIGO DE BARRAS 
....................    fprintf(U1PRINTER,"\x1D\x68\x8C");//h Setea el alto 
....................    fprintf(U1PRINTER,"\x1D\x77\x01");//setea ancho 
....................    //imprimir numero 29 72 n 
....................    fputc(29,U1PRINTER);// 
....................    fputc(72,U1PRINTER);// 
....................    fputc(2,U1PRINTER);//n=0 sin numero, 1 arriba, 2 abajo, 3 arriba y abajo 
....................    //Fuente 29 102 n 
....................    fputc(29,U1PRINTER);// 
....................    fputc(102,U1PRINTER);// 
....................    fputc(1,U1PRINTER);//0,1 Y 2 
....................    /////////////// 
....................    fputc(29,U1PRINTER); 
....................    fputc('k',U1PRINTER); 
....................    fputc(69,U1PRINTER);//69=code39//72=code93//73=code128//70=ITF(solo cantidades pares)// 
....................    //fputc(21,U1PRINTER);//numero de caracteres 
....................    fputc(size_bar,U1PRINTER);//numero de caracteres+2 (solo code128) 
....................    fprintf(U1PRINTER,"%s",barra_codi); 
....................    fprintf(U1PRINTER,"\x00");//envia impresion de codigo 
....................    ///////END BAR CODE////////// 
.................... } 
....................  
.................... void encri(){ 
....................  int tem; 
....................  //fprintf(U1PRINTER,"con_barra:%Lu\r\n",strlen(con_barra)); 
....................   
....................  for(tem=0;tem<=strlen(con_barra);tem++){ 
....................          if(con_barra[tem]=='0') barra_codi[tem]='5'; 
....................     else if(con_barra[tem]=='1') barra_codi[tem]='7'; 
....................     else if(con_barra[tem]=='2') barra_codi[tem]='8'; 
....................     else if(con_barra[tem]=='3') barra_codi[tem]='2'; 
....................     else if(con_barra[tem]=='4') barra_codi[tem]='9'; 
....................     else if(con_barra[tem]=='5') barra_codi[tem]='0'; 
....................     else if(con_barra[tem]=='6') barra_codi[tem]='6'; 
....................     else if(con_barra[tem]=='7') barra_codi[tem]='4'; 
....................     else if(con_barra[tem]=='8') barra_codi[tem]='1'; 
....................     else if(con_barra[tem]=='9') barra_codi[tem]='3'; 
....................  }//end for 
.................... } 
....................  
.................... ///////////////////// 
.................... void llaves(){ 
....................    int tem; 
....................    char texto[12]; 
....................    ////////////////llaves//////////// 
....................    ///TEXTO8 DIRECCIONES 0-8 YA NO SE USAN son para almacenar registros de cuentas 
....................    for(tem=1;tem<=data_set;tem++){ 
*
011B2:  MOVLW  01
011B4:  MOVLB  8
011B6:  MOVWF  xF9
011B8:  MOVF   xF9,W
011BA:  SUBLW  0E
011BC:  BTFSS  FD8.0
011BE:  BRA    147A
....................       switch (tem) { 
011C0:  MOVLW  01
011C2:  SUBWF  xF9,W
011C4:  ADDLW  F2
011C6:  BTFSC  FD8.0
011C8:  BRA    1378
011CA:  ADDLW  0E
011CC:  MOVLB  0
011CE:  GOTO   1480
....................            case 1: {// 
....................                strcpy(texto,texto1); 
011D2:  MOVLW  08
011D4:  MOVWF  FEA
011D6:  MOVLW  FA
011D8:  MOVWF  FE9
011DA:  MOVLW  02
011DC:  MOVWF  FE2
011DE:  MOVLW  8D
011E0:  MOVWF  FE1
011E2:  MOVF   FE7,F
011E4:  MOVFF  FE6,FEE
011E8:  BNZ   11E2
....................                break;} 
011EA:  MOVLB  8
011EC:  BRA    1378
011EE:  MOVLB  0
....................            case 2: {// 
....................                strcpy(texto,texto2); 
011F0:  MOVLW  08
011F2:  MOVWF  FEA
011F4:  MOVLW  FA
011F6:  MOVWF  FE9
011F8:  MOVLW  02
011FA:  MOVWF  FE2
011FC:  MOVLW  99
011FE:  MOVWF  FE1
01200:  MOVF   FE7,F
01202:  MOVFF  FE6,FEE
01206:  BNZ   1200
....................                break;} 
01208:  MOVLB  8
0120A:  BRA    1378
0120C:  MOVLB  0
....................            case 3: {// 
....................                strcpy(texto,texto3); 
0120E:  MOVLW  08
01210:  MOVWF  FEA
01212:  MOVLW  FA
01214:  MOVWF  FE9
01216:  MOVLW  02
01218:  MOVWF  FE2
0121A:  MOVLW  A5
0121C:  MOVWF  FE1
0121E:  MOVF   FE7,F
01220:  MOVFF  FE6,FEE
01224:  BNZ   121E
....................                break;} 
01226:  MOVLB  8
01228:  BRA    1378
0122A:  MOVLB  0
....................            case 4: {// 
....................                strcpy(texto,texto4); 
0122C:  MOVLW  08
0122E:  MOVWF  FEA
01230:  MOVLW  FA
01232:  MOVWF  FE9
01234:  MOVLW  02
01236:  MOVWF  FE2
01238:  MOVLW  B1
0123A:  MOVWF  FE1
0123C:  MOVF   FE7,F
0123E:  MOVFF  FE6,FEE
01242:  BNZ   123C
....................                break;} 
01244:  MOVLB  8
01246:  BRA    1378
01248:  MOVLB  0
....................            case 5: {// 
....................                strcpy(texto,texto5); 
0124A:  MOVLW  08
0124C:  MOVWF  FEA
0124E:  MOVLW  FA
01250:  MOVWF  FE9
01252:  MOVLW  02
01254:  MOVWF  FE2
01256:  MOVLW  BD
01258:  MOVWF  FE1
0125A:  MOVF   FE7,F
0125C:  MOVFF  FE6,FEE
01260:  BNZ   125A
....................                break;} 
01262:  MOVLB  8
01264:  BRA    1378
01266:  MOVLB  0
....................            case 6: {// 
....................                strcpy(texto,texto6); 
01268:  MOVLW  08
0126A:  MOVWF  FEA
0126C:  MOVLW  FA
0126E:  MOVWF  FE9
01270:  MOVLW  02
01272:  MOVWF  FE2
01274:  MOVLW  C9
01276:  MOVWF  FE1
01278:  MOVF   FE7,F
0127A:  MOVFF  FE6,FEE
0127E:  BNZ   1278
....................                break;} 
01280:  MOVLB  8
01282:  BRA    1378
01284:  MOVLB  0
....................            case 7: {// 
....................                strcpy(texto,texto7); 
01286:  MOVLW  08
01288:  MOVWF  FEA
0128A:  MOVLW  FA
0128C:  MOVWF  FE9
0128E:  MOVLW  02
01290:  MOVWF  FE2
01292:  MOVLW  D5
01294:  MOVWF  FE1
01296:  MOVF   FE7,F
01298:  MOVFF  FE6,FEE
0129C:  BNZ   1296
....................                break;} 
0129E:  MOVLB  8
012A0:  BRA    1378
012A2:  MOVLB  0
....................            case 8: {// 
....................                strcpy(texto,texto8); 
012A4:  MOVLW  08
012A6:  MOVWF  FEA
012A8:  MOVLW  FA
012AA:  MOVWF  FE9
012AC:  MOVLW  02
012AE:  MOVWF  FE2
012B0:  MOVLW  E1
012B2:  MOVWF  FE1
012B4:  MOVF   FE7,F
012B6:  MOVFF  FE6,FEE
012BA:  BNZ   12B4
....................                break;} 
012BC:  MOVLB  8
012BE:  BRA    1378
012C0:  MOVLB  0
....................            case 9: {// 
....................                strcpy(texto,texto9); 
012C2:  MOVLW  08
012C4:  MOVWF  FEA
012C6:  MOVLW  FA
012C8:  MOVWF  FE9
012CA:  MOVLW  02
012CC:  MOVWF  FE2
012CE:  MOVLW  ED
012D0:  MOVWF  FE1
012D2:  MOVF   FE7,F
012D4:  MOVFF  FE6,FEE
012D8:  BNZ   12D2
....................                break;} 
012DA:  MOVLB  8
012DC:  BRA    1378
012DE:  MOVLB  0
....................            case 10: {// 
....................                strcpy(texto,texto10); 
012E0:  MOVLW  08
012E2:  MOVWF  FEA
012E4:  MOVLW  FA
012E6:  MOVWF  FE9
012E8:  MOVLW  02
012EA:  MOVWF  FE2
012EC:  MOVLW  F9
012EE:  MOVWF  FE1
012F0:  MOVF   FE7,F
012F2:  MOVFF  FE6,FEE
012F6:  BNZ   12F0
....................                break;} 
012F8:  MOVLB  8
012FA:  BRA    1378
012FC:  MOVLB  0
....................            case 11: {// 
....................                strcpy(texto,texto11); 
012FE:  MOVLW  08
01300:  MOVWF  FEA
01302:  MOVLW  FA
01304:  MOVWF  FE9
01306:  MOVLW  03
01308:  MOVWF  FE2
0130A:  MOVLW  05
0130C:  MOVWF  FE1
0130E:  MOVF   FE7,F
01310:  MOVFF  FE6,FEE
01314:  BNZ   130E
....................                break;} 
01316:  MOVLB  8
01318:  BRA    1378
0131A:  MOVLB  0
....................            case 12: {// 
....................                strcpy(texto,texto12); 
0131C:  MOVLW  08
0131E:  MOVWF  FEA
01320:  MOVLW  FA
01322:  MOVWF  FE9
01324:  MOVLW  03
01326:  MOVWF  FE2
01328:  MOVLW  11
0132A:  MOVWF  FE1
0132C:  MOVF   FE7,F
0132E:  MOVFF  FE6,FEE
01332:  BNZ   132C
....................                break;} 
01334:  MOVLB  8
01336:  BRA    1378
01338:  MOVLB  0
....................            case 13: {// 
....................                strcpy(texto,texto13); 
0133A:  MOVLW  08
0133C:  MOVWF  FEA
0133E:  MOVLW  FA
01340:  MOVWF  FE9
01342:  MOVLW  03
01344:  MOVWF  FE2
01346:  MOVLW  1D
01348:  MOVWF  FE1
0134A:  MOVF   FE7,F
0134C:  MOVFF  FE6,FEE
01350:  BNZ   134A
....................                break;} 
01352:  MOVLB  8
01354:  BRA    1378
01356:  MOVLB  0
....................            case 14: {// 
....................                strcpy(texto,texto14); 
01358:  MOVLW  08
0135A:  MOVWF  FEA
0135C:  MOVLW  FA
0135E:  MOVWF  FE9
01360:  MOVLW  03
01362:  MOVWF  FE2
01364:  MOVLW  29
01366:  MOVWF  FE1
01368:  MOVF   FE7,F
0136A:  MOVFF  FE6,FEE
0136E:  BNZ   1368
....................                break;} 
01370:  MOVLB  8
01372:  BRA    1378
01374:  MOVLB  0
01376:  MOVLB  8
....................       } 
....................       a=i=0; 
01378:  CLRF   41
0137A:  CLRF   40
0137C:  MOVFF  40,1B
....................       while (i < instruccion_size) {  //word_size=8 
01380:  MOVF   41,F
01382:  BNZ   1404
01384:  MOVF   40,W
01386:  SUBLW  09
01388:  BNC   1404
....................            memory[i] = read_eeprom( (tem*instruccion_size)+i); 
0138A:  MOVLW  22
0138C:  ADDWF  40,W
0138E:  MOVWF  FE9
01390:  MOVLW  00
01392:  ADDWFC 41,W
01394:  MOVWF  FEA
01396:  MOVF   xF9,W
01398:  MULLW  0A
0139A:  MOVF   FF3,W
0139C:  ADDWF  40,W
0139E:  MOVLB  9
013A0:  MOVWF  x08
013A2:  MOVLW  00
013A4:  ADDWFC 41,W
013A6:  MOVWF  x09
013A8:  MOVFF  FF2,90A
013AC:  BCF    FF2.7
013AE:  MOVFF  909,FAA
013B2:  MOVFF  908,FA9
013B6:  BCF    FA6.6
013B8:  BCF    FA6.7
013BA:  BSF    FA6.0
013BC:  MOVF   FA8,W
013BE:  BTFSC  x0A.7
013C0:  BSF    FF2.7
013C2:  MOVWF  FEF
....................            if (memory[i] != texto[i])  break; 
013C4:  MOVLW  22
013C6:  ADDWF  40,W
013C8:  MOVWF  FE9
013CA:  MOVLW  00
013CC:  ADDWFC 41,W
013CE:  MOVWF  FEA
013D0:  MOVFF  FEF,906
013D4:  MOVLW  FA
013D6:  ADDWF  40,W
013D8:  MOVWF  FE9
013DA:  MOVLW  08
013DC:  ADDWFC 41,W
013DE:  MOVWF  FEA
013E0:  MOVF   FEF,W
013E2:  SUBWF  x06,W
013E4:  BZ    13EC
013E6:  MOVLB  8
013E8:  BRA    1404
013EA:  MOVLB  9
....................            i++; 
013EC:  INCF   40,F
013EE:  BTFSC  FD8.2
013F0:  INCF   41,F
....................            if (i==instruccion_size) a=1; 
013F2:  MOVF   40,W
013F4:  SUBLW  0A
013F6:  BNZ   1400
013F8:  MOVF   41,F
013FA:  BNZ   1400
013FC:  MOVLW  01
013FE:  MOVWF  1B
01400:  MOVLB  8
01402:  BRA    1380
....................       } 
....................       //fprintf(U1PRINTER,"\r\n"); 
....................       if (a==0){ 
01404:  MOVF   1B,F
01406:  BNZ   1476
....................          i=0; 
01408:  CLRF   41
0140A:  CLRF   40
....................          while (texto[i] != 0x00){ 
0140C:  MOVLW  FA
0140E:  ADDWF  40,W
01410:  MOVWF  FE9
01412:  MOVLW  08
01414:  ADDWFC 41,W
01416:  MOVWF  FEA
01418:  MOVF   FEF,F
0141A:  BZ    1476
....................             write_eeprom(i+(tem*instruccion_size),texto[i]); 
0141C:  MOVF   xF9,W
0141E:  MULLW  0A
01420:  MOVF   FF3,W
01422:  ADDWF  40,W
01424:  MOVLB  9
01426:  MOVWF  x06
01428:  MOVLW  00
0142A:  ADDWFC 41,W
0142C:  MOVWF  x07
0142E:  MOVLW  FA
01430:  ADDWF  40,W
01432:  MOVWF  FE9
01434:  MOVLW  08
01436:  ADDWFC 41,W
01438:  MOVWF  FEA
0143A:  MOVFF  FEF,908
0143E:  MOVF   FF2,W
01440:  MOVWF  00
01442:  BCF    FF2.7
01444:  MOVFF  907,FAA
01448:  MOVFF  906,FA9
0144C:  MOVFF  908,FA8
01450:  BCF    FA6.6
01452:  BCF    FA6.7
01454:  BSF    FA6.2
01456:  MOVLB  F
01458:  MOVLW  55
0145A:  MOVWF  FA7
0145C:  MOVLW  AA
0145E:  MOVWF  FA7
01460:  BSF    FA6.1
01462:  BTFSC  FA6.1
01464:  BRA    1462
01466:  BCF    FA6.2
01468:  MOVF   00,W
0146A:  IORWF  FF2,F
....................             //fprintf(U1PRINTER,"%c",texto[i]); 
....................             i++; 
0146C:  INCF   40,F
0146E:  BTFSC  FD8.2
01470:  INCF   41,F
01472:  MOVLB  8
01474:  BRA    140C
....................          }//end grabar 
....................       }//END a 
01476:  INCF   xF9,F
01478:  BRA    11B8
....................    }//end for 
0147A:  MOVLB  0
0147C:  GOTO   7A8E (RETURN)
.................... } 
....................  
.................... void rd_eeprom(){ 
.................... n=a=b=0; 
*
07026:  CLRF   45
07028:  CLRF   44
0702A:  MOVFF  44,1B
0702E:  CLRF   43
07030:  MOVFF  1B,42
.................... n=instruccion_size;// 
07034:  CLRF   43
07036:  MOVLW  0A
07038:  MOVWF  42
.................... i=0; 
0703A:  CLRF   41
0703C:  CLRF   40
.................... while ((b <=data_numbers)&&(a==0)){//NUMERO TOTAL DE TARJETAS 
0703E:  MOVF   45,F
07040:  BNZ   70E2
07042:  MOVF   44,W
07044:  SUBLW  0E
07046:  BNC   70E2
07048:  MOVF   1B,F
0704A:  BNZ   70E2
....................     i=0; 
0704C:  CLRF   41
0704E:  CLRF   40
....................     b++; 
07050:  INCF   44,F
07052:  BTFSC  FD8.2
07054:  INCF   45,F
....................     while (i < instruccion_size) {//WORD_SIZE_2=10 
07056:  MOVF   41,F
07058:  BNZ   70D6
0705A:  MOVF   40,W
0705C:  SUBLW  09
0705E:  BNC   70D6
....................         memory[i] = read_eeprom(n+i); 
07060:  MOVLW  22
07062:  ADDWF  40,W
07064:  MOVWF  FE9
07066:  MOVLW  00
07068:  ADDWFC 41,W
0706A:  MOVWF  FEA
0706C:  MOVF   40,W
0706E:  ADDWF  42,W
07070:  MOVLB  8
07072:  MOVWF  xFB
07074:  MOVF   41,W
07076:  ADDWFC 43,W
07078:  MOVWF  xFC
0707A:  MOVFF  FF2,8FD
0707E:  BCF    FF2.7
07080:  MOVFF  8FC,FAA
07084:  MOVFF  8FB,FA9
07088:  BCF    FA6.6
0708A:  BCF    FA6.7
0708C:  BSF    FA6.0
0708E:  MOVF   FA8,W
07090:  BTFSC  xFD.7
07092:  BSF    FF2.7
07094:  MOVWF  FEF
....................         //fprintf(U1PRINTER,"m[%Ld]=%c",i,memory[i]); 
....................         //fprintf(U1PRINTER,"X[%Ld]=%c",i,XX[i]); 
....................         if (memory[i] != XX[i]) 
07096:  MOVLW  22
07098:  ADDWF  40,W
0709A:  MOVWF  FE9
0709C:  MOVLW  00
0709E:  ADDWFC 41,W
070A0:  MOVWF  FEA
070A2:  MOVFF  FEF,8F9
070A6:  MOVLW  52
070A8:  ADDWF  40,W
070AA:  MOVWF  FE9
070AC:  MOVLW  00
070AE:  ADDWFC 41,W
070B0:  MOVWF  FEA
070B2:  MOVF   FEF,W
070B4:  SUBWF  xF9,W
070B6:  BZ    70BE
....................             break; 
070B8:  MOVLB  0
070BA:  BRA    70D6
070BC:  MOVLB  8
....................         i++; 
070BE:  INCF   40,F
070C0:  BTFSC  FD8.2
070C2:  INCF   41,F
....................         if (i==instruccion_size) a=1; 
070C4:  MOVF   40,W
070C6:  SUBLW  0A
070C8:  BNZ   70D2
070CA:  MOVF   41,F
070CC:  BNZ   70D2
070CE:  MOVLW  01
070D0:  MOVWF  1B
070D2:  MOVLB  0
070D4:  BRA    7056
....................     } 
....................     //fprintf(PRINTER," \r\n"); 
....................     //fprintf(PRINTER," n=%Ld ",n); 
....................     n=n+instruccion_size;//WORD_SIZE=30 
070D6:  MOVLW  0A
070D8:  ADDWF  42,F
070DA:  MOVLW  00
070DC:  ADDWFC 43,F
....................     restart_wdt(); 
070DE:  CLRWDT
070E0:  BRA    703E
....................     //fprintf(U1PRINTER," \r\n"); 
....................     //fprintf(U1PRINTER,"b=%Ld",b); 
....................     } 
070E2:  GOTO   7D32 (RETURN)
.................... } 
....................  
.................... void reset(){ 
....................  switch ( restart_cause() ) 
*
02BD8:  MOVF   FD0,W
02BDA:  ANDLW  0F
02BDC:  BTFSS  FD0.4
02BDE:  MOVLW  00
02BE0:  BSF    FD0.0
02BE2:  BSF    FD0.1
02BE4:  BSF    FD0.4
02BE6:  BSF    FD8.3
02BE8:  BSF    FD8.4
02BEA:  XORLW  07
02BEC:  BZ    2BFC
02BEE:  XORLW  08
02BF0:  BZ    2BFE
02BF2:  XORLW  01
02BF4:  BZ    2C00
02BF6:  XORLW  02
02BF8:  BZ    2C02
02BFA:  BRA    2C02
....................    { 
....................       case WDT_TIMEOUT: 
....................       {  //lcd_putc("REINICIO-WD");// 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-WD"); 
....................          break;} 
02BFC:  BRA    2C02
....................       case MCLR_FROM_RUN://avisa que reinicio por master clear 
....................       {   
....................          //fprintf(U1PRINTER,"\r\nREINICIO-MCLR"); 
....................          break;} 
02BFE:  BRA    2C02
....................       case BROWNOUT_RESTART://avisa que el pic reinicio por un voltaje menor a 4v 
....................       { 
....................          //fprintf(U1PRINTER,"\r\nREINICIO-VOLTAJE_BAJO"); 
....................          break; 
02C00:  BRA    2C02
....................       } 
....................       case NORMAL_POWER_UP:{ 
....................          //fprintf(U1PRINTER,"\r\nPOWER_UP"); 
....................          /* 
....................          #define WDT_TIMEOUT       7      
....................          #define MCLR_FROM_SLEEP  11      
....................          #define MCLR_FROM_RUN    15      
....................          #define NORMAL_POWER_UP  12      
....................          #define BROWNOUT_RESTART 14      
....................          #define WDT_FROM_SLEEP    3      
....................          #define RESET_INSTRUCTION 0     */ 
....................          break; 
....................       } 
....................    } 
02C02:  GOTO   7C28 (RETURN)
.................... } 

Configuration Fuses:
   Word  1: C600   H4 FCMEN IESO
   Word  2: 1918   PUT NOBROWNOUT BORV21 WDT WDT4096
   Word  3: 8000   NOPBADEN NOLPT1OSC MCLR
   Word  4: 00B1   STVREN NOLVP NOXINST NODEBUG
   Word  5: C000   PROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
